{
  "14254": {
    "UID": "14254",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Sink();\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "3718": {
    "UID": "3718",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53aSink(data);\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "18145": {
    "UID": "18145",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Sink();\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "8424": {
    "UID": "8424",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "2249": {
    "UID": "2249",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)\n{\n    int data = myStruct.structFirst;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "6936": {
    "UID": "6936",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73aSink(dataList);\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "3768": {
    "UID": "3768",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74a()\n{\n    int * data;\n    map<int, int *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74aSink(dataMap);\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "8540": {
    "UID": "8540",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_01()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "5344": {
    "UID": "5344",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74aSink(dataMap);\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "9854": {
    "UID": "9854",
    "code": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();\n}\n",
    "predicted": "121,Stack-based Buffer Overflow",
    "CWE": "CWE121"
  },
  "27598": {
    "UID": "27598",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
    "predicted": "122,Heap-based Buffer Overflow\n415,Double Free",
    "CWE": "CWE122"
  },
  "20798": {
    "UID": "20798",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_c(data);\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "26916": {
    "UID": "26916",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_c(data);\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "28994": {
    "UID": "28994",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)malloc(10);\n    if (data == NULL) {exit(-1);}\n    CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45Sink();\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "34186": {
    "UID": "34186",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_06()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = (int *)malloc(50*sizeof(int));\n        if (data == NULL) {exit(-1);}\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            free(data);\n        }\n    }\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "27882": {
    "UID": "27882",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_c(data);\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "27572": {
    "UID": "27572",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_e(data);\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "34246": {
    "UID": "34246",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_42()\n{\n    int * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_42Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            free(data);\n        }\n    }\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "28423": {
    "UID": "28423",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
    "predicted": "122,Heap-based Buffer Overflow\n415,Double Free",
    "CWE": "CWE122"
  },
  "25960": {
    "UID": "25960",
    "code": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_d(data);\n}\n",
    "predicted": "122,Heap-based Buffer Overflow",
    "CWE": "CWE122"
  },
  "40429": {
    "UID": "40429",
    "code": "void CWE123_Write_What_Where_Condition__fgets_67a()\n{\n    CWE123_Write_What_Where_Condition__fgets_67aStruct data;\n    CWE123_Write_What_Where_Condition__fgets_67_structType myStruct;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    /* FLAW: overwrite linked list pointers with user data */\n    if (fgets((char*)&data, sizeof(data), stdin) == NULL)\n    {\n        printLine(\"fgets failed!\");\n        exit(1);\n    }\n    myStruct.structFirst = data;\n    CWE123_Write_What_Where_Condition__fgets_67aSink(myStruct);\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40286": {
    "UID": "40286",
    "code": "void CWE123_Write_What_Where_Condition__connect_socket_74bSink(map<int, CWE123_Write_What_Where_Condition__connect_socket_74bStruct> dataMap)\n{\n    /* copy data out of dataMap */\n    CWE123_Write_What_Where_Condition__connect_socket_74bStruct data = dataMap[2];\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40200": {
    "UID": "40200",
    "code": "static CWE123_Write_What_Where_Condition__connect_socket_42Struct CWE123_Write_What_Where_Condition__connect_socket_42Source(CWE123_Write_What_Where_Condition__connect_socket_42Struct data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* FLAW: overwrite linked list pointers with data */\n            recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40441": {
    "UID": "40441",
    "code": "void CWE123_Write_What_Where_Condition__fgets_73a()\n{\n    CWE123_Write_What_Where_Condition__fgets_73aStruct data;\n    list<CWE123_Write_What_Where_Condition__fgets_73aStruct> dataList;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    /* FLAW: overwrite linked list pointers with user data */\n    if (fgets((char*)&data, sizeof(data), stdin) == NULL)\n    {\n        printLine(\"fgets failed!\");\n        exit(1);\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE123_Write_What_Where_Condition__fgets_73aSink(dataList);\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40596": {
    "UID": "40596",
    "code": "void CWE123_Write_What_Where_Condition__listen_socket_68bSink()\n{\n    CWE123_Write_What_Where_Condition__listen_socket_68bStruct data = CWE123_Write_What_Where_Condition__listen_socket_68bData;\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40201": {
    "UID": "40201",
    "code": "void CWE123_Write_What_Where_Condition__connect_socket_42()\n{\n    CWE123_Write_What_Where_Condition__connect_socket_42Struct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    data = CWE123_Write_What_Where_Condition__connect_socket_42Source(data);\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40566": {
    "UID": "40566",
    "code": "void CWE123_Write_What_Where_Condition__listen_socket_61a()\n{\n    CWE123_Write_What_Where_Condition__listen_socket_61aStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    data = CWE123_Write_What_Where_Condition__listen_socket_61aSource(data);\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40222": {
    "UID": "40222",
    "code": "void CWE123_Write_What_Where_Condition__connect_socket_52bSink(CWE123_Write_What_Where_Condition__connect_socket_52bStruct data)\n{\n    CWE123_Write_What_Where_Condition__connect_socket_52bSink(data);\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40328": {
    "UID": "40328",
    "code": "void CWE123_Write_What_Where_Condition__fgets_15()\n{\n    CWE123_Write_What_Where_Condition__fgets_15Struct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: overwrite linked list pointers with user data */\n        if (fgets((char*)&data, sizeof(data), stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "40362": {
    "UID": "40362",
    "code": "void CWE123_Write_What_Where_Condition__fgets_42()\n{\n    CWE123_Write_What_Where_Condition__fgets_42Struct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    data = CWE123_Write_What_Where_Condition__fgets_42Source(data);\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n",
    "predicted": "123,Write-what-where Condition",
    "CWE": "CWE123"
  },
  "45100": {
    "UID": "45100",
    "code": "void CWE124_Buffer_Underwrite__new_wchar_t_ncpy_53bSink_b(wchar_t * data)\n{\n    CWE124_Buffer_Underwrite__new_wchar_t_ncpy_53bSink_c(data);\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "46337": {
    "UID": "46337",
    "code": "void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67a()\n{\n    wchar_t * data;\n    CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67_structType myStruct;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    myStruct.structFirst = data;\n    CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67aSink(myStruct);\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "44297": {
    "UID": "44297",
    "code": "void CWE124_Buffer_Underwrite__new_char_ncpy_53cSink_c(char * data)\n{\n    CWE124_Buffer_Underwrite__new_char_ncpy_53cSink_d(data);\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "43687": {
    "UID": "43687",
    "code": "void CWE124_Buffer_Underwrite__new_char_cpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    {\n        char * dataBuffer = new char[100];\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE124_Buffer_Underwrite__new_char_cpy_66aSink(dataArray);\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "40624": {
    "UID": "40624",
    "code": "void CWE124_Buffer_Underwrite__char_alloca_cpy_06()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "42794": {
    "UID": "42794",
    "code": "static wchar_t * CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_21Source(wchar_t * data)\n{\n    if(CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_21Static)\n    {\n        {\n            wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\n            if (dataBuffer == NULL) {exit(-1);}\n            wmemset(dataBuffer, L'A', 100-1);\n            dataBuffer[100-1] = L'\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    return data;\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "41850": {
    "UID": "41850",
    "code": "void CWE124_Buffer_Underwrite__char_declare_ncpy_16()\n{\n    char * data;\n    char dataBuffer[100];\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    while(1)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n    }\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "43774": {
    "UID": "43774",
    "code": "void CWE124_Buffer_Underwrite__new_char_loop_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            /* Ensure the destination buffer is null terminated */\n            data[100-1] = '\\0';\n            printLine(data);\n            /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n             * returned by new [] so can't safely call delete [] on it */\n        }\n    }\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')\n401,Missing Release of Memory after Effective Lifetime",
    "CWE": "CWE124"
  },
  "43663": {
    "UID": "43663",
    "code": "void CWE124_Buffer_Underwrite__new_char_cpy_54dSink_d(char * data)\n{\n    CWE124_Buffer_Underwrite__new_char_cpy_54dSink_e(data);\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')",
    "CWE": "CWE124"
  },
  "42473": {
    "UID": "42473",
    "code": "void CWE124_Buffer_Underwrite__malloc_char_memmove_21()\n{\n    char * data;\n    data = NULL;\n    CWE124_Buffer_Underwrite__malloc_char_memmove_21Static = 1; /* true */\n    data = CWE124_Buffer_Underwrite__malloc_char_memmove_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memmove(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by malloc() so can't safely call free() on it */\n    }\n}\n",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')\n401,Missing Release of Memory after Effective Lifetime",
    "CWE": "CWE124"
  },
  "48617": {
    "UID": "48617",
    "code": "void CWE126_Buffer_Overread__CWE129_rand_32()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound\n             * This check does not check the upper bounds of the array index */\n            if (data >= 0)\n            {\n                printIntLine(buffer[data]);\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative\");\n            }\n        }\n    }\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "48599": {
    "UID": "48599",
    "code": "void CWE126_Buffer_Overread__CWE129_rand_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE126_Buffer_Overread__CWE129_rand_21Static = 1; /* true */\n    CWE126_Buffer_Overread__CWE129_rand_21Sink(data);\n}\n",
    "predicted": "190,Integer Overflow or Wraparound\n126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "50602": {
    "UID": "50602",
    "code": "void CWE126_Buffer_Overread__new_wchar_t_loop_52bSink_b(wchar_t * data)\n{\n    CWE126_Buffer_Overread__new_wchar_t_loop_52bSink_c(data);\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "51119": {
    "UID": "51119",
    "code": "void CWE126_Buffer_Overread__wchar_t_alloca_loop_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    wmemset(dataBadBuffer, L'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = L'\\0'; /* null terminate */\n    wmemset(dataGoodBuffer, L'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = L'\\0'; /* null terminate */\n    /* FLAW: Set data pointer to a small buffer */\n    data = dataBadBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE126_Buffer_Overread__wchar_t_alloca_loop_74aSink(dataMap);\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "49090": {
    "UID": "49090",
    "code": "void CWE126_Buffer_Overread__malloc_char_loop_12()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Use a small buffer */\n        data = (char *)malloc(50*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Use a large buffer */\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i, destLen;\n        char dest[100];\n        memset(dest, 'C', 100-1);\n        dest[100-1] = '\\0'; /* null terminate */\n        destLen = strlen(dest);\n        /* POTENTIAL FLAW: using length of the dest where data\n         * could be smaller than dest causing buffer overread */\n        for (i = 0; i < destLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[100-1] = '\\0';\n        printLine(dest);\n        free(data);\n    }\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "46728": {
    "UID": "46728",
    "code": "void CWE126_Buffer_Overread__char_alloca_memcpy_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE126_Buffer_Overread__char_alloca_memcpy_65aSink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBadBuffer, 'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = '\\0'; /* null terminate */\n    memset(dataGoodBuffer, 'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = '\\0'; /* null terminate */\n    /* FLAW: Set data pointer to a small buffer */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "48656": {
    "UID": "48656",
    "code": "void CWE126_Buffer_Overread__CWE129_rand_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE126_Buffer_Overread__CWE129_rand_51aSink(data);\n}\n",
    "predicted": "190,Integer Overflow or Wraparound\n126,Buffer Over-read",
    "CWE": "CWE126"
  },
  "50616": {
    "UID": "50616",
    "code": "void CWE126_Buffer_Overread__new_wchar_t_loop_54bSink_b(wchar_t * data)\n{\n    CWE126_Buffer_Overread__new_wchar_t_loop_54bSink_c(data);\n}\n",
    "predicted": "126,Buffer Over-read",
    "CWE": "CWE126"
  }
}