ID,UID,Function,Vulnerable,CWE
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45.c,14254,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Sink();
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a.c,3718,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53aSink(data);
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45.c,18145,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Sink();
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07.c,8424,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b.c,2249,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)
{
    int data = myStruct.structFirst;
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73a.cpp,6936,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73aSink(dataList);
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74a.cpp,3768,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74a()
{
    int * data;
    map<int, int *> dataMap;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74aSink(dataMap);
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_01.c,8540,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_01()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74a.cpp,5344,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74aSink(dataMap);
}
",1,CWE121
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a.c,9854,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();
}
",1,CWE121
CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_66b.cpp,27598,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53b.cpp,20798,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_c(data);
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53b.cpp,26916,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_c(data);
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45.c,28994,"void CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)malloc(10);
    if (data == NULL) {exit(-1);}
    CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45Sink();
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_06.c,34186,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_06()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53b.cpp,27882,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_c(data);
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54d.cpp,27572,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_e(data);
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_42.c,34246,"void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_42()
{
    int * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_42Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_74b.cpp,28423,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
}
",1,CWE122
CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54c.cpp,25960,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_d(data);
}
",1,CWE122
CWE123_Write_What_Where_Condition__fgets_67a.c,40429,"void CWE123_Write_What_Where_Condition__fgets_67a()
{
    CWE123_Write_What_Where_Condition__fgets_67aStruct data;
    CWE123_Write_What_Where_Condition__fgets_67_structType myStruct;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    /* FLAW: overwrite linked list pointers with user data */
    if (fgets((char*)&data, sizeof(data), stdin) == NULL)
    {
        printLine(""fgets failed!"");
        exit(1);
    }
    myStruct.structFirst = data;
    CWE123_Write_What_Where_Condition__fgets_67aSink(myStruct);
}
",1,CWE123
CWE123_Write_What_Where_Condition__connect_socket_74b.cpp,40286,"void CWE123_Write_What_Where_Condition__connect_socket_74bSink(map<int, CWE123_Write_What_Where_Condition__connect_socket_74bStruct> dataMap)
{
    /* copy data out of dataMap */
    CWE123_Write_What_Where_Condition__connect_socket_74bStruct data = dataMap[2];
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE123_Write_What_Where_Condition__connect_socket_42.c,40200,"static CWE123_Write_What_Where_Condition__connect_socket_42Struct CWE123_Write_What_Where_Condition__connect_socket_42Source(CWE123_Write_What_Where_Condition__connect_socket_42Struct data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            /* FLAW: overwrite linked list pointers with data */
            recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
",1,CWE123
CWE123_Write_What_Where_Condition__fgets_73a.cpp,40441,"void CWE123_Write_What_Where_Condition__fgets_73a()
{
    CWE123_Write_What_Where_Condition__fgets_73aStruct data;
    list<CWE123_Write_What_Where_Condition__fgets_73aStruct> dataList;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    /* FLAW: overwrite linked list pointers with user data */
    if (fgets((char*)&data, sizeof(data), stdin) == NULL)
    {
        printLine(""fgets failed!"");
        exit(1);
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE123_Write_What_Where_Condition__fgets_73aSink(dataList);
}
",1,CWE123
CWE123_Write_What_Where_Condition__listen_socket_68b.c,40596,"void CWE123_Write_What_Where_Condition__listen_socket_68bSink()
{
    CWE123_Write_What_Where_Condition__listen_socket_68bStruct data = CWE123_Write_What_Where_Condition__listen_socket_68bData;
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE123_Write_What_Where_Condition__connect_socket_42.c,40201,"void CWE123_Write_What_Where_Condition__connect_socket_42()
{
    CWE123_Write_What_Where_Condition__connect_socket_42Struct data;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    data = CWE123_Write_What_Where_Condition__connect_socket_42Source(data);
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE123_Write_What_Where_Condition__listen_socket_61a.c,40566,"void CWE123_Write_What_Where_Condition__listen_socket_61a()
{
    CWE123_Write_What_Where_Condition__listen_socket_61aStruct data;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    data = CWE123_Write_What_Where_Condition__listen_socket_61aSource(data);
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE123_Write_What_Where_Condition__connect_socket_52b.c,40222,"void CWE123_Write_What_Where_Condition__connect_socket_52bSink(CWE123_Write_What_Where_Condition__connect_socket_52bStruct data)
{
    CWE123_Write_What_Where_Condition__connect_socket_52bSink(data);
}
",1,CWE123
CWE123_Write_What_Where_Condition__fgets_15.c,40328,"void CWE123_Write_What_Where_Condition__fgets_15()
{
    CWE123_Write_What_Where_Condition__fgets_15Struct data;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    switch(6)
    {
    case 6:
        /* FLAW: overwrite linked list pointers with user data */
        if (fgets((char*)&data, sizeof(data), stdin) == NULL)
        {
            printLine(""fgets failed!"");
            exit(1);
        }
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE123_Write_What_Where_Condition__fgets_42.c,40362,"void CWE123_Write_What_Where_Condition__fgets_42()
{
    CWE123_Write_What_Where_Condition__fgets_42Struct data;
    linkedList head = { &head, &head };
    /* This simulates a Microsoft-style linked list insertion */
    data.list.next = head.next;
    data.list.prev = head.prev;
    head.next = &data.list;
    head.prev = &data.list;
    data = CWE123_Write_What_Where_Condition__fgets_42Source(data);
    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this
     * causes a ""write-what-where"" aka ""write4"".  It does another write as
     * well.  But this is the prototypical ""write-what-where"" at least from
     * the Windows perspective.
     *
     * linkedListPrev = a->list->prev  WHAT
     * linkedListNext = a->list->next  WHERE
     * linkedListPrev->next = linkedListNext  ""at the address that prev/WHERE points, write
     *                    next/WHAT""
     *                    aka ""write-what-where""
     * linkedListNext->prev = linkedListPrev  ""at the address that next/WHAT points plus 4
     *                    (because prev is the second field in 'list' hence
     *                    4 bytes away on 32b machines), write prev/WHERE""
     */
    linkedListPrev = data.list.prev;
    linkedListNext = data.list.next;
    linkedListPrev->next = linkedListNext;
    linkedListNext->prev = linkedListPrev;
}
",1,CWE123
CWE124_Buffer_Underwrite__new_wchar_t_ncpy_53b.cpp,45100,"void CWE124_Buffer_Underwrite__new_wchar_t_ncpy_53bSink_b(wchar_t * data)
{
    CWE124_Buffer_Underwrite__new_wchar_t_ncpy_53bSink_c(data);
}
",1,CWE124
CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67a.c,46337,"void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67a()
{
    wchar_t * data;
    CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67_structType myStruct;
    wchar_t dataBuffer[100];
    wmemset(dataBuffer, L'A', 100-1);
    dataBuffer[100-1] = L'\0';
    /* FLAW: Set data pointer to before the allocated memory buffer */
    data = dataBuffer - 8;
    myStruct.structFirst = data;
    CWE124_Buffer_Underwrite__wchar_t_declare_memmove_67aSink(myStruct);
}
",1,CWE124
CWE124_Buffer_Underwrite__new_char_ncpy_53c.cpp,44297,"void CWE124_Buffer_Underwrite__new_char_ncpy_53cSink_c(char * data)
{
    CWE124_Buffer_Underwrite__new_char_ncpy_53cSink_d(data);
}
",1,CWE124
CWE124_Buffer_Underwrite__new_char_cpy_66a.cpp,43687,"void CWE124_Buffer_Underwrite__new_char_cpy_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    {
        char * dataBuffer = new char[100];
        memset(dataBuffer, 'A', 100-1);
        dataBuffer[100-1] = '\0';
        /* FLAW: Set data pointer to before the allocated memory buffer */
        data = dataBuffer - 8;
    }
    /* put data in array */
    dataArray[2] = data;
    CWE124_Buffer_Underwrite__new_char_cpy_66aSink(dataArray);
}
",1,CWE124
CWE124_Buffer_Underwrite__char_alloca_cpy_06.c,40624,"void CWE124_Buffer_Underwrite__char_alloca_cpy_06()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    memset(dataBuffer, 'A', 100-1);
    dataBuffer[100-1] = '\0';
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set data pointer to before the allocated memory buffer */
        data = dataBuffer - 8;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */
        strcpy(data, source);
        printLine(data);
    }
}
",1,CWE124
CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_21.c,42794,"static wchar_t * CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_21Source(wchar_t * data)
{
    if(CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_21Static)
    {
        {
            wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
            if (dataBuffer == NULL) {exit(-1);}
            wmemset(dataBuffer, L'A', 100-1);
            dataBuffer[100-1] = L'\0';
            /* FLAW: Set data pointer to before the allocated memory buffer */
            data = dataBuffer - 8;
        }
    }
    return data;
}
",1,CWE124
CWE124_Buffer_Underwrite__char_declare_ncpy_16.c,41850,"void CWE124_Buffer_Underwrite__char_declare_ncpy_16()
{
    char * data;
    char dataBuffer[100];
    memset(dataBuffer, 'A', 100-1);
    dataBuffer[100-1] = '\0';
    while(1)
    {
        /* FLAW: Set data pointer to before the allocated memory buffer */
        data = dataBuffer - 8;
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */
        strncpy(data, source, 100-1);
        /* Ensure the destination buffer is null terminated */
        data[100-1] = '\0';
        printLine(data);
    }
}
",1,CWE124
CWE124_Buffer_Underwrite__new_char_loop_32.cpp,43774,"void CWE124_Buffer_Underwrite__new_char_loop_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        {
            char * dataBuffer = new char[100];
            memset(dataBuffer, 'A', 100-1);
            dataBuffer[100-1] = '\0';
            /* FLAW: Set data pointer to before the allocated memory buffer */
            data = dataBuffer - 8;
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            size_t i;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            /* Ensure the destination buffer is null terminated */
            data[100-1] = '\0';
            printLine(data);
            /* INCIDENTAL CWE-401: Memory Leak - data may not point to location
             * returned by new [] so can't safely call delete [] on it */
        }
    }
}
",1,CWE124
CWE124_Buffer_Underwrite__new_char_cpy_54d.cpp,43663,"void CWE124_Buffer_Underwrite__new_char_cpy_54dSink_d(char * data)
{
    CWE124_Buffer_Underwrite__new_char_cpy_54dSink_e(data);
}
",1,CWE124
CWE124_Buffer_Underwrite__malloc_char_memmove_21.c,42473,"void CWE124_Buffer_Underwrite__malloc_char_memmove_21()
{
    char * data;
    data = NULL;
    CWE124_Buffer_Underwrite__malloc_char_memmove_21Static = 1; /* true */
    data = CWE124_Buffer_Underwrite__malloc_char_memmove_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */
        memmove(data, source, 100*sizeof(char));
        /* Ensure the destination buffer is null terminated */
        data[100-1] = '\0';
        printLine(data);
        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location
         * returned by malloc() so can't safely call free() on it */
    }
}
",1,CWE124
CWE126_Buffer_Overread__CWE129_rand_32.c,48617,"void CWE126_Buffer_Overread__CWE129_rand_32()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    /* Initialize data */
    data = -1;
    {
        int data = *dataPtr1;
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound
             * This check does not check the upper bounds of the array index */
            if (data >= 0)
            {
                printIntLine(buffer[data]);
            }
            else
            {
                printLine(""ERROR: Array index is negative"");
            }
        }
    }
}
",1,CWE126
CWE126_Buffer_Overread__CWE129_rand_21.c,48599,"void CWE126_Buffer_Overread__CWE129_rand_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE126_Buffer_Overread__CWE129_rand_21Static = 1; /* true */
    CWE126_Buffer_Overread__CWE129_rand_21Sink(data);
}
",1,CWE126
CWE126_Buffer_Overread__new_wchar_t_loop_52b.cpp,50602,"void CWE126_Buffer_Overread__new_wchar_t_loop_52bSink_b(wchar_t * data)
{
    CWE126_Buffer_Overread__new_wchar_t_loop_52bSink_c(data);
}
",1,CWE126
CWE126_Buffer_Overread__wchar_t_alloca_loop_74a.cpp,51119,"void CWE126_Buffer_Overread__wchar_t_alloca_loop_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    wmemset(dataBadBuffer, L'A', 50-1); /* fill with 'A's */
    dataBadBuffer[50-1] = L'\0'; /* null terminate */
    wmemset(dataGoodBuffer, L'A', 100-1); /* fill with 'A's */
    dataGoodBuffer[100-1] = L'\0'; /* null terminate */
    /* FLAW: Set data pointer to a small buffer */
    data = dataBadBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE126_Buffer_Overread__wchar_t_alloca_loop_74aSink(dataMap);
}
",1,CWE126
CWE126_Buffer_Overread__malloc_char_loop_12.c,49090,"void CWE126_Buffer_Overread__malloc_char_loop_12()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Use a small buffer */
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Use a large buffer */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        size_t i, destLen;
        char dest[100];
        memset(dest, 'C', 100-1);
        dest[100-1] = '\0'; /* null terminate */
        destLen = strlen(dest);
        /* POTENTIAL FLAW: using length of the dest where data
         * could be smaller than dest causing buffer overread */
        for (i = 0; i < destLen; i++)
        {
            dest[i] = data[i];
        }
        dest[100-1] = '\0';
        printLine(dest);
        free(data);
    }
}
",1,CWE126
CWE126_Buffer_Overread__char_alloca_memcpy_65a.c,46728,"void CWE126_Buffer_Overread__char_alloca_memcpy_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE126_Buffer_Overread__char_alloca_memcpy_65aSink;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    memset(dataBadBuffer, 'A', 50-1); /* fill with 'A's */
    dataBadBuffer[50-1] = '\0'; /* null terminate */
    memset(dataGoodBuffer, 'A', 100-1); /* fill with 'A's */
    dataGoodBuffer[100-1] = '\0'; /* null terminate */
    /* FLAW: Set data pointer to a small buffer */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE126
CWE126_Buffer_Overread__CWE129_rand_51a.c,48656,"void CWE126_Buffer_Overread__CWE129_rand_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE126_Buffer_Overread__CWE129_rand_51aSink(data);
}
",1,CWE126
CWE126_Buffer_Overread__new_wchar_t_loop_54b.cpp,50616,"void CWE126_Buffer_Overread__new_wchar_t_loop_54bSink_b(wchar_t * data)
{
    CWE126_Buffer_Overread__new_wchar_t_loop_54bSink_c(data);
}
",1,CWE126
CWE126_Buffer_Overread__new_wchar_t_memcpy_53c.cpp,50771,"void CWE126_Buffer_Overread__new_wchar_t_memcpy_53cSink_c(wchar_t * data)
{
    CWE126_Buffer_Overread__new_wchar_t_memcpy_53cSink_d(data);
}
",1,CWE126
CWE126_Buffer_Overread__new_wchar_t_memcpy_72b.cpp,50819,"void CWE126_Buffer_Overread__new_wchar_t_memcpy_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t dest[100];
        wmemset(dest, L'C', 100-1);
        dest[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: using memcpy with the length of the dest where data
         * could be smaller than dest causing buffer overread */
        memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
        dest[100-1] = L'\0';
        printWLine(dest);
        delete [] data;
    }
}
",1,CWE126
CWE127_Buffer_Underread__new_char_ncpy_53b.cpp,55473,"void CWE127_Buffer_Underread__new_char_ncpy_53bSink_b(char * data)
{
    CWE127_Buffer_Underread__new_char_ncpy_53bSink_c(data);
}
",1,CWE127
CWE127_Buffer_Underread__malloc_wchar_t_ncpy_64b.c,54698,"void CWE127_Buffer_Underread__malloc_wchar_t_ncpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[100];
        wmemset(dest, L'C', 100-1); /* fill with 'C's */
        dest[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */
        wcsncpy(dest, data, wcslen(dest));
        /* Ensure null termination */
        dest[100-1] = L'\0';
        printWLine(dest);
        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location
         * returned by malloc() so can't safely call free() on it */
    }
}
",1,CWE127
CWE127_Buffer_Underread__new_wchar_t_memcpy_54b.cpp,55964,"void CWE127_Buffer_Underread__new_wchar_t_memcpy_54bSink_b(wchar_t * data)
{
    CWE127_Buffer_Underread__new_wchar_t_memcpy_54bSink_c(data);
}
",1,CWE127
CWE127_Buffer_Underread__wchar_t_declare_ncpy_34.c,57590,"void CWE127_Buffer_Underread__wchar_t_declare_ncpy_34()
{
    wchar_t * data;
    CWE127_Buffer_Underread__wchar_t_declare_ncpy_34_unionType myUnion;
    wchar_t dataBuffer[100];
    wmemset(dataBuffer, L'A', 100-1);
    dataBuffer[100-1] = L'\0';
    /* FLAW: Set data pointer to before the allocated memory buffer */
    data = dataBuffer - 8;
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[100];
            wmemset(dest, L'C', 100-1); /* fill with 'C's */
            dest[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */
            wcsncpy(dest, data, wcslen(dest));
            /* Ensure null termination */
            dest[100-1] = L'\0';
            printWLine(dest);
        }
    }
}
",1,CWE127
CWE127_Buffer_Underread__new_char_memmove_12.cpp,55243,"void CWE127_Buffer_Underread__new_char_memmove_12()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        {
            char * dataBuffer = new char[100];
            memset(dataBuffer, 'A', 100-1);
            dataBuffer[100-1] = '\0';
            /* FLAW: Set data pointer to before the allocated memory buffer */
            data = dataBuffer - 8;
        }
    }
    else
    {
        {
            char * dataBuffer = new char[100];
            memset(dataBuffer, 'A', 100-1);
            dataBuffer[100-1] = '\0';
            /* FIX: Set data pointer to the allocated memory buffer */
            data = dataBuffer;
        }
    }
    {
        char dest[100];
        memset(dest, 'C', 100-1); /* fill with 'C's */
        dest[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */
        memmove(dest, data, 100*sizeof(char));
        /* Ensure null termination */
        dest[100-1] = '\0';
        printLine(dest);
        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location
         * returned by new [] so can't safely call delete [] on it */
    }
}
",1,CWE127
CWE127_Buffer_Underread__new_wchar_t_cpy_54c.cpp,55644,"void CWE127_Buffer_Underread__new_wchar_t_cpy_54cSink_c(wchar_t * data)
{
    CWE127_Buffer_Underread__new_wchar_t_cpy_54cSink_d(data);
}
",1,CWE127
CWE127_Buffer_Underread__new_char_memcpy_53c.cpp,55153,"void CWE127_Buffer_Underread__new_char_memcpy_53cSink_c(char * data)
{
    CWE127_Buffer_Underread__new_char_memcpy_53cSink_d(data);
}
",1,CWE127
CWE127_Buffer_Underread__new_char_loop_54c.cpp,55000,"void CWE127_Buffer_Underread__new_char_loop_54cSink_c(char * data)
{
    CWE127_Buffer_Underread__new_char_loop_54cSink_d(data);
}
",1,CWE127
CWE127_Buffer_Underread__new_char_ncpy_53c.cpp,55475,"void CWE127_Buffer_Underread__new_char_ncpy_53cSink_c(char * data)
{
    CWE127_Buffer_Underread__new_char_ncpy_53cSink_d(data);
}
",1,CWE127
CWE127_Buffer_Underread__char_declare_ncpy_34.c,53040,"void CWE127_Buffer_Underread__char_declare_ncpy_34()
{
    char * data;
    CWE127_Buffer_Underread__char_declare_ncpy_34_unionType myUnion;
    char dataBuffer[100];
    memset(dataBuffer, 'A', 100-1);
    dataBuffer[100-1] = '\0';
    /* FLAW: Set data pointer to before the allocated memory buffer */
    data = dataBuffer - 8;
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[100];
            memset(dest, 'C', 100-1); /* fill with 'C's */
            dest[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */
            strncpy(dest, data, strlen(dest));
            /* Ensure null termination */
            dest[100-1] = '\0';
            printLine(dest);
        }
    }
}
",1,CWE127
CWE134_Uncontrolled_Format_String__char_environment_fprintf_34.c,61595,"void CWE134_Uncontrolled_Format_String__char_environment_fprintf_34()
{
    char * data;
    CWE134_Uncontrolled_Format_String__char_environment_fprintf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */
        fprintf(stdout, data);
    }
}
",1,CWE134
CWE134_Uncontrolled_Format_String__char_environment_vprintf_53d.c,62891,"void CWE134_Uncontrolled_Format_String__char_environment_vprintf_53dSink(char * data)
{
    CWE134_Uncontrolled_Format_String__char_environment_vprintf_53dVaSink(data, data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__char_file_fprintf_32.c,63500,"void CWE134_Uncontrolled_Format_String__char_file_fprintf_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            /* Read input from a file */
            size_t dataLen = strlen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        /* Restore NUL terminator if fgets fails */
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */
        fprintf(stdout, data);
    }
}
",1,CWE134
CWE134_Uncontrolled_Format_String__wchar_t_file_printf_21.c,73282,"static void CWE134_Uncontrolled_Format_String__wchar_t_file_printf_21Sink(wchar_t * data)
{
    if(CWE134_Uncontrolled_Format_String__wchar_t_file_printf_21Static)
    {
        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */
        wprintf(data);
    }
}
",1,CWE134
CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_45.c,65154,"static void CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_45Sink()
{
    char * data = CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_45Data;
    CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_45VaSink(data, data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__wchar_t_file_vprintf_62a.cpp,74390,"void CWE134_Uncontrolled_Format_String__wchar_t_file_vprintf_62a()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__wchar_t_file_vprintf_62aSource(data);
    CWE134_Uncontrolled_Format_String__wchar_t_file_vprintf_62aVaSink(data, data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__char_console_vfprintf_45.c,60550,"static void CWE134_Uncontrolled_Format_String__char_console_vfprintf_45Sink()
{
    char * data = CWE134_Uncontrolled_Format_String__char_console_vfprintf_45Data;
    CWE134_Uncontrolled_Format_String__char_console_vfprintf_45VaSink(data, data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_52c.c,72822,"void CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_52cSink(wchar_t * data)
{
    CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_52cVaSink(data, data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__wchar_t_console_printf_68b.c,69605,"void CWE134_Uncontrolled_Format_String__wchar_t_console_printf_68bSink()
{
    wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_console_printf_68bData;
    /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */
    wprintf(data);
}
",1,CWE134
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_63b.c,67418,"void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_63bSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */
    fwprintf(stdout, data);
}
",1,CWE134
CWE15_External_Control_of_System_or_Configuration_Setting__w32_41.c,76847,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_41Sink(char * data)
{
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_74b.cpp,76937,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_66b.c,76917,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_45.c,76863,"static void CWE15_External_Control_of_System_or_Configuration_Setting__w32_45Sink()
{
    char * data = CWE15_External_Control_of_System_or_Configuration_Setting__w32_45Data;
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_09.c,76801,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_09()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            WSADATA wsaData;
            BOOL wsaDataInit = FALSE;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            struct sockaddr_in service;
            int recvResult;
            do
            {
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
                listenSocket = socket(PF_INET, SOCK_STREAM, 0);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(LISTEN_PORT);
                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))
                {
                    break;
                }
                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == INVALID_SOCKET)
                {
                    break;
                }
                /* INCIDENTAL CWE 188 - reliance on data memory layout
                 * recv and friends return ""number of bytes"" received
                 * char's on our system, however, may not be ""octets"" (8-bit
                 * bytes) but could be just about anything.  Also,
                 * even if the external environment is ASCII or UTF8,
                 * the ANSI/ISO C standard does not dictate that the
                 * character set used by the actual language or character
                 * constants matches.
                 *
                 * In practice none of these are usually issues...
                 */
                /* FLAW: read the new hostname from a network socket */
                recvResult = recv(acceptSocket, data, 100 - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[recvResult] = '\0';
            }
            while (0);
            if (acceptSocket != INVALID_SOCKET)
            {
                closesocket(acceptSocket);
            }
            if (listenSocket != INVALID_SOCKET)
            {
                closesocket(listenSocket);
            }
            if (wsaDataInit)
            {
                WSACleanup();
            }
        }
    }
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_64b.c,76909,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_67b.c,76921,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_67bSink(CWE15_External_Control_of_System_or_Configuration_Setting__w32_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_73b.cpp,76933,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_72b.cpp,76929,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE15_External_Control_of_System_or_Configuration_Setting__w32_21.c,76828,"void CWE15_External_Control_of_System_or_Configuration_Setting__w32_21()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE15_External_Control_of_System_or_Configuration_Setting__w32_21Static = 1; /* true */
    data = CWE15_External_Control_of_System_or_Configuration_Setting__w32_21Source(data);
    /* POTENTIAL FLAW: set the hostname to data obtained from a potentially external source */
    if (!SetComputerNameA(data))
    {
        printLine(""Failure setting computer name"");
        exit(1);
    }
}
",1,CWE15
CWE176_Improper_Handling_of_Unicode_Encoding__w32_44.c,77066,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE176_Improper_Handling_of_Unicode_Encoding__w32_44Sink;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_44 sink */
    wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_22a.c,77027,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_22a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_22a sink */
    wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_22aGlobal = 1; /* true */
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_22aSink(data);
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_63b.c,77134,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_63bSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        char convertedText[10] = """";
        int requiredSize;
        requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
        /* POTENTIAL FLAW: Do not check that the size of the destination buffer for the conversion is large enough. */
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
    }
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_15.c,77005,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_15()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_15 sink */
        wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char convertedText[10] = """";
        int requiredSize;
        requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
        /* POTENTIAL FLAW: Do not check that the size of the destination buffer for the conversion is large enough. */
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_63a.c,77131,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_63a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_63a sink */
    wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_63aSink(&data);
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_66a.c,77149,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_66a sink */
    wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    /* put data in array */
    dataArray[2] = data;
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_66aSink(dataArray);
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_73b.cpp,77176,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        char convertedText[10] = """";
        int requiredSize;
        requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
        /* POTENTIAL FLAW: Do not check that the size of the destination buffer for the conversion is large enough. */
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
    }
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_12.c,76992,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_12()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_12 sink */
        wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    }
    else
    {
        /* FIX: Initialize data as a small unicode string that will NOT cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_12 sink */
        wcscpy(data, L""\\u9580"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char convertedText[10] = """";
            int requiredSize;
            requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
            /* POTENTIAL FLAW: Do not check that the size of the destination buffer for the conversion is large enough. */
            WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
        }
    }
    else
    {
        {
            char convertedText[10] = """";
            int requiredSize;
            requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
            /* FIX: Check that the size of the destination buffer for the conversion is large enough. */
            if (requiredSize < 10)
            {
                WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
            }
            else
            {
                printLine(""Destination buffer not large enough to perform conversion."");
            }
        }
    }
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_68a.c,77161,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_68a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_68a sink */
    wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_68aData = data;
    CWE176_Improper_Handling_of_Unicode_Encoding__w32_68aSink();
}
",1,CWE176
CWE176_Improper_Handling_of_Unicode_Encoding__w32_32.c,77038,"void CWE176_Improper_Handling_of_Unicode_Encoding__w32_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the CWE176_Improper_Handling_of_Unicode_Encoding__w32_32 sink */
        wcscpy(data, L""\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644\\u9580\\u961c\\u9640\\u963f\\u963b\\u9644"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            char convertedText[10] = """";
            int requiredSize;
            requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);
            /* POTENTIAL FLAW: Do not check that the size of the destination buffer for the conversion is large enough. */
            WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);
        }
    }
}
",1,CWE176
CWE190_Integer_Overflow__unsigned_int_rand_preinc_67a.c,98223,"void CWE190_Integer_Overflow__unsigned_int_rand_preinc_67a()
{
    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;
    data = 0;
    /* POTENTIAL FLAW: Use a random value */
    data = (unsigned int)RAND32();
    myStruct.structFirst = data;
    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67aSink(myStruct);
}
",1,CWE190
CWE190_Integer_Overflow__int64_t_rand_preinc_22a.c,95554,"void CWE190_Integer_Overflow__int64_t_rand_preinc_22a()
{
    int64_t data;
    data = 0LL;
    /* POTENTIAL FLAW: Use a random value */
    data = (int64_t)RAND64();
    CWE190_Integer_Overflow__int64_t_rand_preinc_22aGlobal = 1; /* true */
    CWE190_Integer_Overflow__int64_t_rand_preinc_22aSink(data);
}
",1,CWE190
CWE190_Integer_Overflow__unsigned_int_rand_postinc_05.c,94206,"void CWE190_Integer_Overflow__unsigned_int_rand_postinc_05()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Use a random value */
        data = (unsigned int)RAND32();
    }
    if(staticTrue)
    {
        {
            /* POTENTIAL FLAW: Incrementing data could cause an overflow */
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
",1,CWE190
CWE190_Integer_Overflow__char_rand_add_32.c,78858,"void CWE190_Integer_Overflow__char_rand_add_32()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        /* POTENTIAL FLAW: Use a random value */
        data = (char)RAND32();
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
",1,CWE190
CWE190_Integer_Overflow__unsigned_int_max_preinc_52a.c,97944,"void CWE190_Integer_Overflow__unsigned_int_max_preinc_52a()
{
    unsigned int data;
    data = 0;
    /* POTENTIAL FLAW: Use the maximum size of the data type */
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_preinc_52aSink(data);
}
",1,CWE190
CWE190_Integer_Overflow__char_max_preinc_45.c,94738,"void CWE190_Integer_Overflow__char_max_preinc_45()
{
    char data;
    data = ' ';
    /* POTENTIAL FLAW: Use the maximum size of the data type */
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_preinc_45Data = data;
    CWE190_Integer_Overflow__char_max_preinc_45Sink();
}
",1,CWE190
CWE190_Integer_Overflow__char_rand_square_42.c,79366,"void CWE190_Integer_Overflow__char_rand_square_42()
{
    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_rand_square_42Source(data);
    {
        /* POTENTIAL FLAW: if (data*data) > CHAR_MAX, this will overflow */
        char result = data * data;
        printHexCharLine(result);
    }
}
",1,CWE190
CWE190_Integer_Overflow__char_fscanf_preinc_67a.c,94602,"void CWE190_Integer_Overflow__char_fscanf_preinc_67a()
{
    char data;
    CWE190_Integer_Overflow__char_fscanf_preinc_67_structType myStruct;
    data = ' ';
    /* POTENTIAL FLAW: Use a value input from the console */
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
    CWE190_Integer_Overflow__char_fscanf_preinc_67aSink(myStruct);
}
",1,CWE190
CWE190_Integer_Overflow__int_fgets_square_63b.c,83136,"void CWE190_Integer_Overflow__int_fgets_square_63bSink(int * dataPtr)
{
    int data = *dataPtr;
    {
        /* POTENTIAL FLAW: if (data*data) > INT_MAX, this will overflow */
        int result = data * data;
        printIntLine(result);
    }
}
",1,CWE190
CWE190_Integer_Overflow__short_fscanf_preinc_68a.c,97164,"void CWE190_Integer_Overflow__short_fscanf_preinc_68a()
{
    short data;
    data = 0;
    /* POTENTIAL FLAW: Use a value input from the console */
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_preinc_68aData = data;
    CWE190_Integer_Overflow__short_fscanf_preinc_68aSink();
}
",1,CWE190
CWE191_Integer_Underflow__short_rand_postdec_07.c,109363,"void CWE191_Integer_Underflow__short_rand_postdec_07()
{
    short data;
    data = 0;
    if(staticFive==5)
    {
        /* POTENTIAL FLAW: Use a random value */
        data = (short)RAND32();
    }
    if(staticFive==5)
    {
        {
            /* POTENTIAL FLAW: Decrementing data could cause an underflow */
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
",1,CWE191
CWE191_Integer_Underflow__int_rand_predec_45.c,112653,"static void CWE191_Integer_Underflow__int_rand_predec_45Sink()
{
    int data = CWE191_Integer_Underflow__int_rand_predec_45Data;
    {
        /* POTENTIAL FLAW: Decrementing data could cause an underflow */
        --data;
        int result = data;
        printIntLine(result);
    }
}
",1,CWE191
CWE191_Integer_Underflow__int64_t_rand_predec_52a.c,111387,"void CWE191_Integer_Underflow__int64_t_rand_predec_52a()
{
    int64_t data;
    data = 0LL;
    /* POTENTIAL FLAW: Use a random value */
    data = (int64_t)RAND64();
    CWE191_Integer_Underflow__int64_t_rand_predec_52aSink(data);
}
",1,CWE191
CWE191_Integer_Underflow__short_rand_sub_64a.c,105567,"void CWE191_Integer_Underflow__short_rand_sub_64a()
{
    short data;
    data = 0;
    /* POTENTIAL FLAW: Use a random value */
    data = (short)RAND32();
    CWE191_Integer_Underflow__short_rand_sub_64aSink(&data);
}
",1,CWE191
CWE191_Integer_Underflow__char_rand_postdec_67a.c,106980,"void CWE191_Integer_Underflow__char_rand_postdec_67a()
{
    char data;
    CWE191_Integer_Underflow__char_rand_postdec_67_structType myStruct;
    data = ' ';
    /* POTENTIAL FLAW: Use a random value */
    data = (char)RAND32();
    myStruct.structFirst = data;
    CWE191_Integer_Underflow__char_rand_postdec_67aSink(myStruct);
}
",1,CWE191
CWE191_Integer_Underflow__int64_t_rand_sub_04.c,100954,"void CWE191_Integer_Underflow__int64_t_rand_sub_04()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Use a random value */
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            /* POTENTIAL FLAW: Subtracting 1 from data could cause an underflow */
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
",1,CWE191
CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c,107072,"static void CWE191_Integer_Underflow__int64_t_fscanf_postdec_21Sink(int64_t data)
{
    if(CWE191_Integer_Underflow__int64_t_fscanf_postdec_21Static)
    {
        {
            /* POTENTIAL FLAW: Decrementing data could cause an underflow */
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
",1,CWE191
CWE191_Integer_Underflow__char_min_sub_54a.c,99138,"void CWE191_Integer_Underflow__char_min_sub_54a()
{
    char data;
    data = ' ';
    /* POTENTIAL FLAW: Use the minimum size of the data type */
    data = CHAR_MIN;
    CWE191_Integer_Underflow__char_min_sub_54aSink(data);
}
",1,CWE191
CWE191_Integer_Underflow__int_listen_socket_predec_42.c,112216,"void CWE191_Integer_Underflow__int_listen_socket_predec_42()
{
    int data;
    /* Initialize data */
    data = 0;
    data = CWE191_Integer_Underflow__int_listen_socket_predec_42Source(data);
    {
        /* POTENTIAL FLAW: Decrementing data could cause an underflow */
        --data;
        int result = data;
        printIntLine(result);
    }
}
",1,CWE191
CWE191_Integer_Underflow__int64_t_min_sub_73a.cpp,100683,"void CWE191_Integer_Underflow__int64_t_min_sub_73a()
{
    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    /* POTENTIAL FLAW: Use the minimum size of the data type */
    data = LLONG_MIN;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE191_Integer_Underflow__int64_t_min_sub_73aSink(dataList);
}
",1,CWE191
CWE194_Unexpected_Sign_Extension__rand_memmove_45.c,117649,"void CWE194_Unexpected_Sign_Extension__rand_memmove_45()
{
    short data;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a random value that could be less than 0 */
    data = (short)RAND32();
    CWE194_Unexpected_Sign_Extension__rand_memmove_45Data = data;
    CWE194_Unexpected_Sign_Extension__rand_memmove_45Sink();
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__negative_memmove_63a.c,117044,"void CWE194_Unexpected_Sign_Extension__negative_memmove_63a()
{
    short data;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a negative number */
    data = -1;
    CWE194_Unexpected_Sign_Extension__negative_memmove_63aSink(&data);
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__rand_malloc_21.c,117290,"static short CWE194_Unexpected_Sign_Extension__rand_malloc_21Source(short data)
{
    if(CWE194_Unexpected_Sign_Extension__rand_malloc_21Static)
    {
        /* FLAW: Use a random value that could be less than 0 */
        data = (short)RAND32();
    }
    return data;
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__negative_strncpy_63a.c,117205,"void CWE194_Unexpected_Sign_Extension__negative_strncpy_63a()
{
    short data;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a negative number */
    data = -1;
    CWE194_Unexpected_Sign_Extension__negative_strncpy_63aSink(&data);
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__rand_strncpy_22b.c,117782,"short CWE194_Unexpected_Sign_Extension__rand_strncpy_22bSource(short data)
{
    if(CWE194_Unexpected_Sign_Extension__rand_strncpy_22bGlobal)
    {
        /* FLAW: Use a random value that could be less than 0 */
        data = (short)RAND32();
    }
    return data;
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__negative_malloc_68a.c,116742,"void CWE194_Unexpected_Sign_Extension__negative_malloc_68a()
{
    short data;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a negative number */
    data = -1;
    CWE194_Unexpected_Sign_Extension__negative_malloc_68aData = data;
    CWE194_Unexpected_Sign_Extension__negative_malloc_68aSink();
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__rand_memcpy_65a.c,117535,"void CWE194_Unexpected_Sign_Extension__rand_memcpy_65a()
{
    short data;
    /* define a function pointer */
    void (*funcPtr) (short) = CWE194_Unexpected_Sign_Extension__rand_memcpy_65aSink;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a random value that could be less than 0 */
    data = (short)RAND32();
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__fgets_strncpy_15.c,115188,"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_15()
{
    short data;
    /* Initialize data */
    data = 0;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* FLAW: Use a value input from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to short */
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[100];
        char dest[100] = """";
        memset(source, 'A', 100-1);
        source[100-1] = '\0';
        if (data < 100)
        {
            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,
             * the sign extension could result in a very large number */
            strncpy(dest, source, data);
            dest[data] = '\0'; /* strncpy() does not always NULL terminate */
        }
        printLine(dest);
    }
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__rand_memmove_67a.c,117704,"void CWE194_Unexpected_Sign_Extension__rand_memmove_67a()
{
    short data;
    CWE194_Unexpected_Sign_Extension__rand_memmove_67_structType myStruct;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a random value that could be less than 0 */
    data = (short)RAND32();
    myStruct.structFirst = data;
    CWE194_Unexpected_Sign_Extension__rand_memmove_67aSink(myStruct);
}
",1,CWE194
CWE194_Unexpected_Sign_Extension__rand_memmove_64a.c,117692,"void CWE194_Unexpected_Sign_Extension__rand_memmove_64a()
{
    short data;
    /* Initialize data */
    data = 0;
    /* FLAW: Use a random value that could be less than 0 */
    data = (short)RAND32();
    CWE194_Unexpected_Sign_Extension__rand_memmove_64aSink(&data);
}
",1,CWE194
CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15.c,118569,"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    /* Assume we want to allocate a relatively small buffer */
    if (data < 100)
    {
        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,
         * the conversion will cause malloc() to allocate a very large amount of data or fail */
        char * dataBuffer = (char *)malloc(data);
        if (dataBuffer == NULL) {exit(-1);}
        /* Do something with dataBuffer */
        memset(dataBuffer, 'A', data-1);
        dataBuffer[data-1] = '\0';
        printLine(dataBuffer);
        free(dataBuffer);
    }
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b.c,120580,"int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61bSource(int data)
{
    /* FLAW: Use a negative number */
    data = -1;
    return data;
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53a.c,120721,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a negative number */
    data = -1;
    CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53aSink(data);
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18.c,121474,"void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18()
{
    int data;
    /* Initialize data */
    data = -1;
    goto source;
source:
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    {
        char source[100];
        char dest[100] = """";
        memset(source, 'A', 100-1);
        source[100-1] = '\0';
        if (data < 100)
        {
            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,
             * the sign conversion could result in a very large number */
            memmove(dest, source, data);
            dest[data] = '\0'; /* NULL terminate */
        }
        printLine(dest);
    }
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68a.c,119318,"void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68aData = data;
    CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68aSink();
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42.c,120534,"static int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42Source(int data)
{
    /* FLAW: Use a negative number */
    data = -1;
    return data;
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53a.c,120560,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a negative number */
    data = -1;
    CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53aSink(data);
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68a.c,120767,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a negative number */
    data = -1;
    CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68aData = data;
    CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68aSink();
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54a.c,120729,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a negative number */
    data = -1;
    CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54aSink(data);
}
",1,CWE195
CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65a.c,120755,"void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65a()
{
    int data;
    /* define a function pointer */
    void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65aSink;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a negative number */
    data = -1;
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE195
CWE197_Numeric_Truncation_Error__int_fscanf_to_short_22a.c,122658,"void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    CWE197_Numeric_Truncation_Error__int_fscanf_to_short_22aGlobal = 1; /* true */
    data = CWE197_Numeric_Truncation_Error__int_fscanf_to_short_22aSource(data);
    {
        /* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_large_to_char_21.c,122813,"static int CWE197_Numeric_Truncation_Error__int_large_to_char_21Source(int data)
{
    if(CWE197_Numeric_Truncation_Error__int_large_to_char_21Static)
    {
        /* FLAW: Use a number larger than SHRT_MAX */
        data = SHRT_MAX + 5;
    }
    return data;
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_rand_to_short_34.c,123636,"void CWE197_Numeric_Truncation_Error__int_rand_to_short_34()
{
    int data;
    CWE197_Numeric_Truncation_Error__int_rand_to_short_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */
            short shortData = (short)data;
            printShortLine(shortData);
        }
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41.c,121867,"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41Sink(int data)
{
    {
        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_large_to_short_34.c,122992,"void CWE197_Numeric_Truncation_Error__int_large_to_short_34()
{
    int data;
    CWE197_Numeric_Truncation_Error__int_large_to_short_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a number larger than SHRT_MAX */
    data = SHRT_MAX + 5;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */
            short shortData = (short)data;
            printShortLine(shortData);
        }
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__short_rand_34.c,124602,"void CWE197_Numeric_Truncation_Error__short_rand_34()
{
    short data;
    CWE197_Numeric_Truncation_Error__short_rand_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a random number */
    data = (short)RAND32();
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */
            char charData = (char)data;
            printHexCharLine(charData);
        }
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_large_to_short_01.c,122925,"void CWE197_Numeric_Truncation_Error__int_large_to_short_01()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a number larger than SHRT_MAX */
    data = SHRT_MAX + 5;
    {
        /* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__short_large_03.c,124218,"void CWE197_Numeric_Truncation_Error__short_large_03()
{
    short data;
    /* Initialize data */
    data = -1;
    if(5==5)
    {
        /* FLAW: Use a number larger than CHAR_MAX */
        data = CHAR_MAX + 1;
    }
    {
        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__int_rand_to_char_22a.c,123463,"void CWE197_Numeric_Truncation_Error__int_rand_to_char_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    CWE197_Numeric_Truncation_Error__int_rand_to_char_22aGlobal = 1; /* true */
    data = CWE197_Numeric_Truncation_Error__int_rand_to_char_22aSource(data);
    {
        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
",1,CWE197
CWE197_Numeric_Truncation_Error__short_large_21.c,124262,"static short CWE197_Numeric_Truncation_Error__short_large_21Source(short data)
{
    if(CWE197_Numeric_Truncation_Error__short_large_21Static)
    {
        /* FLAW: Use a number larger than CHAR_MAX */
        data = CHAR_MAX + 1;
    }
    return data;
}
",1,CWE197
CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_54c.cpp,128643,"void CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_54cSink_c(char * data)
{
    CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_54cSink_d(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__char_connect_socket_open_54c.cpp,125584,"void CWE23_Relative_Path_Traversal__char_connect_socket_open_54cSink_c(char * data)
{
    CWE23_Relative_Path_Traversal__char_connect_socket_open_54cSink_d(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__wchar_t_console_open_54c.cpp,130414,"void CWE23_Relative_Path_Traversal__wchar_t_console_open_54cSink_c(wchar_t * data)
{
    CWE23_Relative_Path_Traversal__wchar_t_console_open_54cSink_d(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_53c.cpp,125737,"void CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_53cSink_c(char * data)
{
    CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_53cSink_d(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__wchar_t_file_w32CreateFile_53c.cpp,132177,"void CWE23_Relative_Path_Traversal__wchar_t_file_w32CreateFile_53cSink_c(wchar_t * data)
{
    CWE23_Relative_Path_Traversal__wchar_t_file_w32CreateFile_53cSink_d(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__char_environment_ofstream_31.cpp,126983,"void CWE23_Relative_Path_Traversal__char_environment_ofstream_31()
{
    char * data;
    char dataBuffer[FILENAME_MAX] = BASEPATH;
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            ofstream outputFile;
            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */
            outputFile.open((char *)data);
            outputFile.close();
        }
    }
}
",1,CWE23
CWE23_Relative_Path_Traversal__char_environment_fopen_01.cpp,126600,"void CWE23_Relative_Path_Traversal__char_environment_fopen_01()
{
    char * data;
    char dataBuffer[FILENAME_MAX] = BASEPATH;
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);
        }
    }
    {
        FILE *pFile = NULL;
        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */
        pFile = FOPEN(data, ""wb+"");
        if (pFile != NULL)
        {
            fclose(pFile);
        }
    }
}
",1,CWE23
CWE23_Relative_Path_Traversal__wchar_t_file_ofstream_54d.cpp,131865,"void CWE23_Relative_Path_Traversal__wchar_t_file_ofstream_54dSink_d(wchar_t * data)
{
    CWE23_Relative_Path_Traversal__wchar_t_file_ofstream_54dSink_e(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_53b.cpp,132497,"void CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_53bSink_b(wchar_t * data)
{
    CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_53bSink_c(data);
}
",1,CWE23
CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_22a.cpp,125206,"void CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_22a()
{
    char * data;
    char dataBuffer[FILENAME_MAX] = BASEPATH;
    data = dataBuffer;
    CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_22aGlobal = 1; /* true */
    data = CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_22aSource(data);
    {
        ifstream inputFile;
        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */
        inputFile.open((char *)data);
        inputFile.close();
    }
    ;
}
",1,CWE23
CWE252_Unchecked_Return_Value__wchar_t_putchar_05.c,134570,"void CWE252_Unchecked_Return_Value__wchar_t_putchar_05()
{
    if(staticTrue)
    {
        /* FLAW: Do not check the return value */
        putwchar((wchar_t)L'A');
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__wchar_t_sscanf_06.c,134916,"void CWE252_Unchecked_Return_Value__wchar_t_sscanf_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */
            wchar_t dataBuffer[100] = L"""";
            wchar_t * data = dataBuffer;
            /* FLAW: Do not check the return value */
            swscanf(SRC, L""%99s\0"", data);
        }
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__char_sscanf_06.c,134034,"void CWE252_Unchecked_Return_Value__char_sscanf_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            /* FLAW: Do not check the return value */
            sscanf(SRC, ""%99s\0"", data);
        }
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__char_fputc_10.c,133458,"void CWE252_Unchecked_Return_Value__char_fputc_10()
{
    if(globalTrue)
    {
        /* FLAW: Do not check the return value */
        fputc((int)'A', stdout);
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__w32ImpersonateSelf_16.c,134210,"void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_16()
{
    while(1)
    {
        /* FLAW: Do not check if ImpersonateSelf() fails */
        ImpersonateSelf(SecurityImpersonation);
        break;
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__wchar_t_puts_18.c,134704,"void CWE252_Unchecked_Return_Value__wchar_t_puts_18()
{
    goto sink;
sink:
    /* FLAW: Do not check the return value */
    PUTS(L""string"");
}
",1,CWE252
CWE252_Unchecked_Return_Value__char_fputs_10.c,133507,"void CWE252_Unchecked_Return_Value__char_fputs_10()
{
    if(globalTrue)
    {
        /* FLAW: Do not check the return value */
        fputs(""string"", stdout);
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__wchar_t_putchar_01.c,134559,"void CWE252_Unchecked_Return_Value__wchar_t_putchar_01()
{
    /* FLAW: Do not check the return value */
    putwchar((wchar_t)L'A');
}
",1,CWE252
CWE252_Unchecked_Return_Value__wchar_t_fwrite_17.c,134555,"void CWE252_Unchecked_Return_Value__wchar_t_fwrite_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        /* FLAW: Do not check the return value */
        fwrite((wchar_t *)L""string"", sizeof(wchar_t), wcslen(L""string""), stdout);
    }
}
",1,CWE252
CWE252_Unchecked_Return_Value__char_putchar_11.c,133706,"void CWE252_Unchecked_Return_Value__char_putchar_11()
{
    if(globalReturnsTrue())
    {
        /* FLAW: Do not check the return value */
        putchar((int)'A');
    }
}
",1,CWE252
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_09.c,136542,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: remove() might fail, in which case the return value will be non-zero, but
         * we are checking to see if the return value is 0 */
        if (REMOVE(L""removemeCWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_09.txt"") == 0)
        {
            printLine(""remove failed!"");
        }
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_15.c,136510,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_15()
{
    switch(6)
    {
    case 6:
        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but
         * we are checking to see if the return value is 0 */
        if (PUTS(L""string"") == 0)
        {
            printLine(""puts failed!"");
        }
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_03.c,135250,"void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_03()
{
    if(5==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,
             * but we are checking to see if the return value is equal to 0 */
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)
            {
                printLine(""fread failed!"");
            }
        }
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_01.c,136666,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_01()
{
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */
        wchar_t dataBuffer[100] = L"""";
        wchar_t * data = dataBuffer;
        /* FLAW: swprintf() might fail, in which case the return value will be negative, but
         * we are checking to see if the return value is 0 */
        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L""%s\n"", SRC_STRING) == 0)
        {
            printLine(""snprintf failed!"");
        }
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_10.c,135957,"void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_10()
{
    if(globalTrue)
    {
        /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see
         * if the return value is greater than zero (true) */
        if (ImpersonateSelf(SecurityImpersonation) > 0)
        {
            exit(1);
        }
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_16.c,135239,"void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_16()
{
    while(1)
    {
        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but
         * we are checking to see if the return value is 0 */
        if (fputs(""string"", stdout) == 0)
        {
            printLine(""fputs failed!"");
        }
        break;
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_16.c,135827,"void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_16()
{
    while(1)
    {
        {
            HANDLE hMutex = NULL;
            hMutex = CreateMutexA(NULL, FALSE, NULL);
            /* FLAW: If CreateMutexA() failed, the return value will be NULL,
               but we are checking to see if the return value is INVALID_HANDLE_VALUE */
            if (hMutex == INVALID_HANDLE_VALUE)
            {
                exit(1);
            }
            /* We'll leave out most of the implementation since it has nothing to do with the CWE
             * and since the checkers are looking for certain function calls anyway */
            CloseHandle(hMutex);
        }
        break;
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_17.c,136221,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but
         * we are checking to see if the return value is 0 */
        if (fputws(L""string"", stdout) == 0)
        {
            printLine(""fputws failed!"");
        }
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_16.c,136219,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputs_16()
{
    while(1)
    {
        /* FLAW: fputws() might fail, in which case the return value will be WEOF (-1), but
         * we are checking to see if the return value is 0 */
        if (fputws(L""string"", stdout) == 0)
        {
            printLine(""fputws failed!"");
        }
        break;
    }
}
",1,CWE253
CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_13.c,136063,"void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */
            wchar_t dataBuffer[100] = L"""";
            wchar_t * data = dataBuffer;
            printLine(""Please enter a string: "");
            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,
             * but we are checking to see if the return value is less than 0. */
            if (fgetws(data, 100, stdin) < 0)
            {
                printLine(""fgetws failed!"");
                exit(1);
            }
            printWLine(data);
        }
    }
}
",1,CWE253
CWE256_Plaintext_Storage_of_Password__w32_wchar_t_67a.c,137373,"void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_67a()
{
    wchar_t * data;
    CWE256_Plaintext_Storage_of_Password__w32_wchar_t_67_structType myStruct;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgetws(data, 100, pFile) == NULL)
            {
                data[0] = L'\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = L'\0';
        }
    }
    myStruct.structFirst = data;
    CWE256_Plaintext_Storage_of_Password__w32_wchar_t_67aSink(myStruct);
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_char_74b.cpp,137154,"void CWE256_Plaintext_Storage_of_Password__w32_char_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        HANDLE pHandle;
        char * username = ""User"";
        char * domain = ""Domain"";
        /* POTENTIAL FLAW: Attempt to login user with password from the source */
        if (LogonUserA(
                    username,
                    domain,
                    data,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
    }
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_wchar_t_44.c,137284,"void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE256_Plaintext_Storage_of_Password__w32_wchar_t_44Sink;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgetws(data, 100, pFile) == NULL)
            {
                data[0] = L'\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = L'\0';
        }
    }
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_char_21.c,136992,"void CWE256_Plaintext_Storage_of_Password__w32_char_21()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgets(data, 100, pFile) == NULL)
            {
                data[0] = '\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = '\0';
        }
    }
    CWE256_Plaintext_Storage_of_Password__w32_char_21Static = 1; /* true */
    CWE256_Plaintext_Storage_of_Password__w32_char_21Sink(data);
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_char_61b.c,137094,"char * CWE256_Plaintext_Storage_of_Password__w32_char_61bSource(char * data)
{
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgets(data, 100, pFile) == NULL)
            {
                data[0] = '\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = '\0';
        }
    }
    return data;
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_wchar_t_72a.cpp,137385,"void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgetws(data, 100, pFile) == NULL)
            {
                data[0] = L'\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = L'\0';
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE256_Plaintext_Storage_of_Password__w32_wchar_t_72aSink(dataVector);
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_char_12.c,136964,"void CWE256_Plaintext_Storage_of_Password__w32_char_12()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            FILE *pFile;
            pFile = fopen(""passwords.txt"", ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read the password from a file */
                if (fgets(data, 100, pFile) == NULL)
                {
                    data[0] = '\0';
                }
                fclose(pFile);
            }
            else
            {
                data[0] = '\0';
            }
        }
    }
    else
    {
        {
            FILE *pFile;
            HCRYPTPROV hCryptProv = 0;
            HCRYPTHASH hHash = 0;
            HCRYPTKEY hKey = 0;
            char hashData[100] = HASH_INPUT;
            pFile = fopen(""passwords.txt"", ""r"");
            if (pFile != NULL)
            {
                if (fgets(data, 100, pFile) == NULL)
                {
                    data[0] = '\0';
                }
                fclose(pFile);
            }
            else
            {
                data[0] = '\0';
            }
            do
            {
                BYTE payload[(100 - 1) * sizeof(char)]; /* same size as data except for NUL terminator */
                DWORD payloadBytes;
                /* Hex-decode the input string into raw bytes */
                payloadBytes = decodeHexChars(payload, sizeof(payload), data);
                /* Wipe the hex string, to prevent it from being given to LogonUserA if
                 * any of the crypto calls fail. */
                SecureZeroMemory(data, 100 * sizeof(char));
                /* Aquire a Context */
                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))
                {
                    break;
                }
                /* Create hash handle */
                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))
                {
                    break;
                }
                /* Hash the input string */
                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))
                {
                    break;
                }
                /* Derive an AES key from the hash */
                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))
                {
                    break;
                }
                /* FIX: Decrypt the password before passing it to the sink */
                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))
                {
                    break;
                }
                /* Copy back into data and NUL-terminate */
                memcpy(data, payload, payloadBytes);
                data[payloadBytes / sizeof(char)] = '\0';
            }
            while (0);
            if (hKey)
            {
                CryptDestroyKey(hKey);
            }
            if (hHash)
            {
                CryptDestroyHash(hHash);
            }
            if (hCryptProv)
            {
                CryptReleaseContext(hCryptProv, 0);
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            HANDLE pHandle;
            char * username = ""User"";
            char * domain = ""Domain"";
            /* POTENTIAL FLAW: Attempt to login user with password from the source */
            if (LogonUserA(
                        username,
                        domain,
                        data,
                        LOGON32_LOGON_NETWORK,
                        LOGON32_PROVIDER_DEFAULT,
                        &pHandle) != 0)
            {
                printLine(""User logged in successfully."");
                CloseHandle(pHandle);
            }
            else
            {
                printLine(""Unable to login."");
            }
        }
    }
    else
    {
        {
            HANDLE pHandle;
            char * username = ""User"";
            char * domain = ""Domain"";
            char hashData[100] = HASH_INPUT;
            HCRYPTPROV hCryptProv = 0;
            HCRYPTHASH hHash = 0;
            HCRYPTKEY hKey = 0;
            do
            {
                BYTE payload[(100 - 1) * sizeof(char)]; /* same size as data except for NUL terminator */
                DWORD payloadBytes;
                /* Hex-decode the input string into raw bytes */
                payloadBytes = decodeHexChars(payload, sizeof(payload), data);
                /* Wipe the hex string, to prevent it from being given to LogonUserA if
                 * any of the crypto calls fail. */
                SecureZeroMemory(data, 100 * sizeof(char));
                /* Aquire a Context */
                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))
                {
                    break;
                }
                /* Create hash handle */
                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))
                {
                    break;
                }
                /* Hash the input string */
                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))
                {
                    break;
                }
                /* Derive an AES key from the hash */
                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))
                {
                    break;
                }
                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))
                {
                    break;
                }
                /* Copy back into data and NUL-terminate */
                memcpy(data, payload, payloadBytes);
                data[payloadBytes / sizeof(char)] = '\0';
            }
            while (0);
            if (hKey)
            {
                CryptDestroyKey(hKey);
            }
            if (hHash)
            {
                CryptDestroyHash(hHash);
            }
            if (hCryptProv)
            {
                CryptReleaseContext(hCryptProv, 0);
            }
            /* FIX: Decrypt the password before using it for authentication  */
            if (LogonUserA(
                        username,
                        domain,
                        data,
                        LOGON32_LOGON_NETWORK,
                        LOGON32_PROVIDER_DEFAULT,
                        &pHandle) != 0)
            {
                printLine(""User logged in successfully."");
                CloseHandle(pHandle);
            }
            else
            {
                printLine(""Unable to login."");
            }
        }
    }
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_wchar_t_73b.cpp,137394,"void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        HANDLE pHandle;
        wchar_t * username = L""User"";
        wchar_t * domain = L""Domain"";
        /* POTENTIAL FLAW: Attempt to login user with password from the source */
        if (LogonUserW(
                    username,
                    domain,
                    data,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
    }
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_char_67a.c,137127,"void CWE256_Plaintext_Storage_of_Password__w32_char_67a()
{
    char * data;
    CWE256_Plaintext_Storage_of_Password__w32_char_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        FILE *pFile;
        pFile = fopen(""passwords.txt"", ""r"");
        if (pFile != NULL)
        {
            /* POTENTIAL FLAW: Read the password from a file */
            if (fgets(data, 100, pFile) == NULL)
            {
                data[0] = '\0';
            }
            fclose(pFile);
        }
        else
        {
            data[0] = '\0';
        }
    }
    myStruct.structFirst = data;
    CWE256_Plaintext_Storage_of_Password__w32_char_67aSink(myStruct);
}
",1,CWE256
CWE256_Plaintext_Storage_of_Password__w32_wchar_t_14.c,137218,"void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_14()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            FILE *pFile;
            pFile = fopen(""passwords.txt"", ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read the password from a file */
                if (fgetws(data, 100, pFile) == NULL)
                {
                    data[0] = L'\0';
                }
                fclose(pFile);
            }
            else
            {
                data[0] = L'\0';
            }
        }
    }
    if(globalFive==5)
    {
        {
            HANDLE pHandle;
            wchar_t * username = L""User"";
            wchar_t * domain = L""Domain"";
            /* POTENTIAL FLAW: Attempt to login user with password from the source */
            if (LogonUserW(
                        username,
                        domain,
                        data,
                        LOGON32_LOGON_NETWORK,
                        LOGON32_PROVIDER_DEFAULT,
                        &pHandle) != 0)
            {
                printLine(""User logged in successfully."");
                CloseHandle(pHandle);
            }
            else
            {
                printLine(""Unable to login."");
            }
        }
    }
}
",1,CWE256
CWE259_Hard_Coded_Password__w32_wchar_t_43.cpp,137641,"static void CWE259_Hard_Coded_Password__w32_wchar_t_43Source(wchar_t * &password)
{
    /* FLAW: Use a hardcoded password */
    wcscpy(password, PASSWORD);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_char_12.c,137435,"void CWE259_Hard_Coded_Password__w32_char_12()
{
    char * password;
    char passwordBuffer[100] = """";
    password = passwordBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Use a hardcoded password */
        strcpy(password, PASSWORD);
    }
    else
    {
        {
            size_t passwordLen = 0;
            /* FIX: Read the password from the console */
            if (fgets(password, 100, stdin) == NULL)
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                password[0] = '\0';
            }
            /* Remove the carriage return from the string that is inserted by fgets() */
            passwordLen = strlen(password);
            if (passwordLen > 0)
            {
                password[passwordLen-1] = '\0';
            }
        }
    }
    {
        HANDLE pHandle;
        char * username = ""User"";
        char * domain = ""Domain"";
        /* POTENTIAL FLAW: Attempt to login user with password from the source (which may be hardcoded) */
        if (LogonUserA(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
    }
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_wchar_t_12.c,137596,"void CWE259_Hard_Coded_Password__w32_wchar_t_12()
{
    wchar_t * password;
    wchar_t passwordBuffer[100] = L"""";
    password = passwordBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Use a hardcoded password */
        wcscpy(password, PASSWORD);
    }
    else
    {
        {
            size_t passwordLen = 0;
            /* FIX: Read the password from the console */
            if (fgetws(password, 100, stdin) == NULL)
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                password[0] = L'\0';
            }
            /* Remove the carriage return from the string that is inserted by fgetws() */
            passwordLen = wcslen(password);
            if (passwordLen > 0)
            {
                password[passwordLen-1] = L'\0';
            }
        }
    }
    {
        HANDLE pHandle;
        wchar_t * username = L""User"";
        wchar_t * domain = L""Domain"";
        /* POTENTIAL FLAW: Attempt to login user with password from the source (which may be hardcoded) */
        if (LogonUserW(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
    }
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_char_73a.cpp,137556,"void CWE259_Hard_Coded_Password__w32_char_73a()
{
    char * password;
    list<char *> passwordList;
    char passwordBuffer[100] = """";
    password = passwordBuffer;
    /* FLAW: Use a hardcoded password */
    strcpy(password, PASSWORD);
    /* Put password in a list */
    passwordList.push_back(password);
    passwordList.push_back(password);
    passwordList.push_back(password);
    CWE259_Hard_Coded_Password__w32_char_73aSink(passwordList);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_wchar_t_66a.c,137701,"void CWE259_Hard_Coded_Password__w32_wchar_t_66a()
{
    wchar_t * password;
    wchar_t * passwordArray[5];
    wchar_t passwordBuffer[100] = L"""";
    password = passwordBuffer;
    /* FLAW: Use a hardcoded password */
    wcscpy(password, PASSWORD);
    /* put password in array */
    passwordArray[2] = password;
    CWE259_Hard_Coded_Password__w32_wchar_t_66aSink(passwordArray);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_wchar_t_15.c,137604,"void CWE259_Hard_Coded_Password__w32_wchar_t_15()
{
    wchar_t * password;
    wchar_t passwordBuffer[100] = L"""";
    password = passwordBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Use a hardcoded password */
        wcscpy(password, PASSWORD);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        HANDLE pHandle;
        wchar_t * username = L""User"";
        wchar_t * domain = L""Domain"";
        /* POTENTIAL FLAW: Attempt to login user with password from the source (which may be hardcoded) */
        if (LogonUserW(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
    }
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_char_41.c,137473,"void CWE259_Hard_Coded_Password__w32_char_41()
{
    char * password;
    char passwordBuffer[100] = """";
    password = passwordBuffer;
    /* FLAW: Use a hardcoded password */
    strcpy(password, PASSWORD);
    CWE259_Hard_Coded_Password__w32_char_41Sink(password);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_char_67a.c,137544,"void CWE259_Hard_Coded_Password__w32_char_67a()
{
    char * password;
    CWE259_Hard_Coded_Password__w32_char_67_structType myStruct;
    char passwordBuffer[100] = """";
    password = passwordBuffer;
    /* FLAW: Use a hardcoded password */
    strcpy(password, PASSWORD);
    myStruct.structFirst = password;
    CWE259_Hard_Coded_Password__w32_char_67aSink(myStruct);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_wchar_t_67a.c,137705,"void CWE259_Hard_Coded_Password__w32_wchar_t_67a()
{
    wchar_t * password;
    CWE259_Hard_Coded_Password__w32_wchar_t_67_structType myStruct;
    wchar_t passwordBuffer[100] = L"""";
    password = passwordBuffer;
    /* FLAW: Use a hardcoded password */
    wcscpy(password, PASSWORD);
    myStruct.structFirst = password;
    CWE259_Hard_Coded_Password__w32_wchar_t_67aSink(myStruct);
}
",1,CWE259
CWE259_Hard_Coded_Password__w32_char_22b.c,137461,"char * CWE259_Hard_Coded_Password__w32_char_22bSource(char * password)
{
    if(CWE259_Hard_Coded_Password__w32_char_22bGlobal)
    {
        /* FLAW: Use a hardcoded password */
        strcpy(password, PASSWORD);
    }
    return password;
}
",1,CWE259
CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_15.c,138255,"void CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_15()
{
    switch(6)
    {
    case 6:
    {
        wchar_t * keyName = L""TEST\\TestKey"";
        HKEY hKey;
        /* FLAW: Call RegCreateKeyW() with HKEY_LOCAL_MACHINE violating the least privilege principal */
        if (RegCreateKeyW(
                    HKEY_LOCAL_MACHINE,
                    keyName,
                    &hKey) != ERROR_SUCCESS)
        {
            printLine(""Registry key could not be created"");
        }
        else
        {
            printLine(""Registry key created successfully"");
            RegCloseKey(hKey);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_char_RegCreateKeyEx_17.c,137868,"void CWE272_Least_Privilege_Violation__w32_char_RegCreateKeyEx_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * keyName = ""TEST\\TestKey"";
            HKEY hKey;
            /* FLAW: Call RegCreateKeyExA() with HKEY_LOCAL_MACHINE violating the least privilege principal */
            if (RegCreateKeyExA(
                        HKEY_LOCAL_MACHINE,
                        keyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        NULL) != ERROR_SUCCESS)
            {
                printLine(""Registry key could not be created"");
            }
            else
            {
                printLine(""Registry key created successfully"");
                RegCloseKey(hKey);
            }
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_char_CreateProcess_01.c,137774,"void CWE272_Least_Privilege_Violation__w32_char_CreateProcess_01()
{
    {
        STARTUPINFOA si;
        PROCESS_INFORMATION pi;
        /* FLAW: The commandLine parameter to CreateProcess() contains a space in it and does not
           surround the executable path with quotes.  A malicious executable could be run because
           of the way the function parses spaces. The process will attempt to run ""Program.exe,""
           if it exists, instead of the intended ""GoodApp.exe"" */
        if( !CreateProcessA(NULL,
                            ""C:\\Program Files\\GoodApp arg1 arg2"",
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi))
        {
            printLine(""CreateProcess failed"");
            return;
        }
        else
        {
            printLine(""CreateProcess successful"");
        }
        /* Wait until child process exits. */
        WaitForSingleObject(pi.hProcess, INFINITE);
        /* Close process and thread handles.*/
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_wchar_t_RegOpenKeyEx_16.c,138307,"void CWE272_Least_Privilege_Violation__w32_wchar_t_RegOpenKeyEx_16()
{
    while(1)
    {
        {
            wchar_t * keyName = L""TEST\\TestKey"";
            HKEY hKey;
            /* FLAW: Call RegOpenKeyExW() with HKEY_LOCAL_MACHINE violating the least privilege principal */
            if (RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        keyName,
                        0,
                        KEY_WRITE,
                        &hKey) != ERROR_SUCCESS)
            {
                printLine(""Registry key could not be opened"");
            }
            else
            {
                printLine(""Registry key opened successfully"");
                RegCloseKey(hKey);
            }
        }
        break;
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_18.c,138262,"void CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_18()
{
    goto sink;
sink:
    {
        wchar_t * keyName = L""TEST\\TestKey"";
        HKEY hKey;
        /* FLAW: Call RegCreateKeyW() with HKEY_LOCAL_MACHINE violating the least privilege principal */
        if (RegCreateKeyW(
                    HKEY_LOCAL_MACHINE,
                    keyName,
                    &hKey) != ERROR_SUCCESS)
        {
            printLine(""Registry key could not be created"");
        }
        else
        {
            printLine(""Registry key created successfully"");
            RegCloseKey(hKey);
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_char_SHRegCreateUSKey_17.c,138015,"void CWE272_Least_Privilege_Violation__w32_char_SHRegCreateUSKey_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * keyName = ""TEST\\TestKey"";
            HUSKEY hKey;
            /* FLAW: Call SHRegCreateUSKeyA() with SHREGSET_HKLM violating the least privilege principal */
            if (SHRegCreateUSKeyA(
                        keyName,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        SHREGSET_HKLM) != ERROR_SUCCESS)
            {
                printLine(""Registry key could not be created"");
            }
            else
            {
                printLine(""Registry key created successfully"");
                SHRegCloseUSKey(hKey);
            }
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_wchar_t_SHRegOpenUSKey_17.c,138407,"void CWE272_Least_Privilege_Violation__w32_wchar_t_SHRegOpenUSKey_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            wchar_t * keyName = L""TEST\\TestKey"";
            HUSKEY hKey;
            /* FLAW: Call SHRegOpenUSKeyW() with HKEY_LOCAL_MACHINE (fIgnoreHKCU == TRUE) violating the least privilege principal */
            if (SHRegOpenUSKeyW(
                        keyName,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        TRUE) != ERROR_SUCCESS)
            {
                printLine(""Registry key could not be opened"");
            }
            else
            {
                printLine(""Registry key opened successfully"");
                SHRegCloseUSKey(hKey);
            }
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_01.c,138215,"void CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_01()
{
    {
        wchar_t * keyName = L""TEST\\TestKey"";
        HKEY hKey;
        /* FLAW: Call RegCreateKeyW() with HKEY_LOCAL_MACHINE violating the least privilege principal */
        if (RegCreateKeyW(
                    HKEY_LOCAL_MACHINE,
                    keyName,
                    &hKey) != ERROR_SUCCESS)
        {
            printLine(""Registry key could not be created"");
        }
        else
        {
            printLine(""Registry key created successfully"");
            RegCloseKey(hKey);
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_wchar_t_CreateProcess_02.c,138119,"void CWE272_Least_Privilege_Violation__w32_wchar_t_CreateProcess_02()
{
    if(1)
    {
        {
            STARTUPINFOW si;
            PROCESS_INFORMATION pi;
            /* FLAW: The commandLine parameter to CreateProcess() contains a space in it and does not
               surround the executable path with quotes.  A malicious executable could be run because
               of the way the function parses spaces. The process will attempt to run ""Program.exe,""
               if it exists, instead of the intended ""GoodApp.exe"" */
            if( !CreateProcessW(NULL,
                                L""C:\\Program Files\\GoodApp arg1 arg2"",
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                NULL,
                                &si,
                                &pi))
            {
                printLine(""CreateProcess failed"");
                return;
            }
            else
            {
                printLine(""CreateProcess successful"");
            }
            /* Wait until child process exits. */
            WaitForSingleObject(pi.hProcess, INFINITE);
            /* Close process and thread handles.*/
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
}
",1,CWE272
CWE272_Least_Privilege_Violation__w32_char_RegOpenKeyEx_17.c,137966,"void CWE272_Least_Privilege_Violation__w32_char_RegOpenKeyEx_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * keyName = ""TEST\\TestKey"";
            HKEY hKey;
            /* FLAW: Call RegOpenKeyExA() with HKEY_LOCAL_MACHINE violating the least privilege principal */
            if (RegOpenKeyExA(
                        HKEY_LOCAL_MACHINE,
                        keyName,
                        0,
                        KEY_WRITE,
                        &hKey) != ERROR_SUCCESS)
            {
                printLine(""Registry key could not be opened"");
            }
            else
            {
                printLine(""Registry key opened successfully"");
                RegCloseKey(hKey);
            }
        }
    }
}
",1,CWE272
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_17.c,138505,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_10.c,138486,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_10()
{
    if(globalTrue)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_16.c,138503,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_16()
{
    while(1)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
        break;
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_08.c,138480,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_08()
{
    if(staticReturnsTrue())
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_12.c,138443,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            HANDLE hPipe = INVALID_HANDLE_VALUE;
            hPipe = CreateNamedPipeA(
                        ""\\\\.\\pipe\\test_pipe"",
                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,
                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                        PIPE_UNLIMITED_INSTANCES,
                        BUFSIZE,
                        BUFSIZE,
                        NMPWAIT_USE_DEFAULT_WAIT,
                        NULL);
            if (hPipe == INVALID_HANDLE_VALUE)
            {
                exit(1);
            }
            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,
             * which isn't actually an error in terms of waiting for a client. */
            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)
            {
                CloseHandle(hPipe);
                exit(1);
            }
            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient
             * -- However, since we're not even DOING anything with the pipe
             * it's debatable whether this is really a bug
             */
            ImpersonateNamedPipeClient(hPipe);
            printLine(""Impersonated"");
            if (!RevertToSelf())
            {
                exit(1);
            }
            CloseHandle(hPipe);
        }
    }
    else
    {
        {
            HANDLE hPipe = INVALID_HANDLE_VALUE;
            hPipe = CreateNamedPipeA(
                        ""\\\\.\\pipe\\test_pipe"",
                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,
                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                        PIPE_UNLIMITED_INSTANCES,
                        BUFSIZE,
                        BUFSIZE,
                        NMPWAIT_USE_DEFAULT_WAIT,
                        NULL);
            if (hPipe == INVALID_HANDLE_VALUE)
            {
                exit(1);
            }
            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,
             * which isn't actually an error in terms of waiting for a client. */
            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)
            {
                CloseHandle(hPipe);
                exit(1);
            }
            /* FIX: Check if ""ImpersonateNamedPipeClient"" succeeded or not */
            if (!ImpersonateNamedPipeClient(hPipe))
            {
                printLine(""Failed to impersonate"");
            }
            else
            {
                printLine(""Impersonated"");
                if (!RevertToSelf())
                {
                    exit(1);
                }
            }
            CloseHandle(hPipe);
        }
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_14.c,138497,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_14()
{
    if(globalFive==5)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_02.c,138462,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_02()
{
    if(1)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_01.c,138460,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_01()
{
    RpcImpersonateClient(0);
    /* FLAW: Do not check if RpcImpersonateClient() fails */
    /* We'll leave out most of the implementation since it has nothing to do with the CWE
     * and since the checkers are looking for certain function calls anyway */
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_13.c,138494,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_09.c,138483,"void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        RpcImpersonateClient(0);
        /* FLAW: Do not check if RpcImpersonateClient() fails */
        /* We'll leave out most of the implementation since it has nothing to do with the CWE
         * and since the checkers are looking for certain function calls anyway */
    }
}
",1,CWE273
CWE321_Hard_Coded_Cryptographic_Key__w32_char_42.c,139566,"static char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_42Source(char * cryptoKey)
{
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    strcpy(cryptoKey, CRYPTO_KEY);
    return cryptoKey;
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_char_74a.cpp,139650,"void CWE321_Hard_Coded_Cryptographic_Key__w32_char_74a()
{
    char * cryptoKey;
    map<int, char *> cryptoKeyMap;
    char cryptoKeyBuffer[100] = """";
    cryptoKey = cryptoKeyBuffer;
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    strcpy(cryptoKey, CRYPTO_KEY);
    /* Put cryptoKey in a map */
    cryptoKeyMap[0] = cryptoKey;
    cryptoKeyMap[1] = cryptoKey;
    cryptoKeyMap[2] = cryptoKey;
    CWE321_Hard_Coded_Cryptographic_Key__w32_char_74aSink(cryptoKeyMap);
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21.c,139703,"static wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21Source(wchar_t * cryptoKey)
{
    if(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21Static)
    {
        /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
        wcscpy(cryptoKey, CRYPTO_KEY);
    }
    return cryptoKey;
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_74a.cpp,139811,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_74a()
{
    wchar_t * cryptoKey;
    map<int, wchar_t *> cryptoKeyMap;
    wchar_t cryptoKeyBuffer[100] = L"""";
    cryptoKey = cryptoKeyBuffer;
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    wcscpy(cryptoKey, CRYPTO_KEY);
    /* Put cryptoKey in a map */
    cryptoKeyMap[0] = cryptoKey;
    cryptoKeyMap[1] = cryptoKey;
    cryptoKeyMap[2] = cryptoKey;
    CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_74aSink(cryptoKeyMap);
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_char_22b.c,139551,"char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_22bSource(char * cryptoKey)
{
    if(CWE321_Hard_Coded_Cryptographic_Key__w32_char_22bGlobal)
    {
        /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
        strcpy(cryptoKey, CRYPTO_KEY);
    }
    return cryptoKey;
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b.c,139588,"void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52bSink(char * cryptoKey)
{
    CWE321_Hard_Coded_Cryptographic_Key__w32_char_52bSink(cryptoKey);
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66a.c,139791,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66a()
{
    wchar_t * cryptoKey;
    wchar_t * cryptoKeyArray[5];
    wchar_t cryptoKeyBuffer[100] = L"""";
    cryptoKey = cryptoKeyBuffer;
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    wcscpy(cryptoKey, CRYPTO_KEY);
    /* put cryptoKey in array */
    cryptoKeyArray[2] = cryptoKey;
    CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66aSink(cryptoKeyArray);
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65a.c,139787,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65a()
{
    wchar_t * cryptoKey;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65aSink;
    wchar_t cryptoKeyBuffer[100] = L"""";
    cryptoKey = cryptoKeyBuffer;
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    wcscpy(cryptoKey, CRYPTO_KEY);
    /* use the function pointer */
    funcPtr(cryptoKey);
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15.c,139694,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15()
{
    wchar_t * cryptoKey;
    wchar_t cryptoKeyBuffer[100] = L"""";
    cryptoKey = cryptoKeyBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
        wcscpy(cryptoKey, CRYPTO_KEY);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        HCRYPTPROV hCryptProv;
        HCRYPTKEY hKey;
        HCRYPTHASH hHash;
        wchar_t toBeEncrypted[] = L""String to be encrypted"";
        DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);
        BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */
        /* Copy plaintext (without NUL terminator) into byte buffer */
        memcpy(encrypted, toBeEncrypted, encryptedLen);
        /* Try to get a context with and without a new key set */
        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))
        {
            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))
            {
                printLine(""Error in acquiring cryptographic context"");
                exit(1);
            }
        }
        /* Create Hash handle */
        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))
        {
            printLine(""Error in creating hash"");
            exit(1);
        }
        /* Hash the cryptoKey */
        if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))
        {
            printLine(""Error in hashing cryptoKey"");
            exit(1);
        }
        /* Derive an AES key from the Hashed cryptoKey */
        if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))
        {
            printLine(""Error in CryptDeriveKey"");
            exit(1);
        }
        /* POTENTIAL FLAW: Possibly using a hardcoded crypto key */
        /* Use the derived key to encrypt something */
        if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))
        {
            printLine(""Error in CryptEncrypt"");
            exit(1);
        }
        /* use encrypted block */
        printBytesLine(encrypted, encryptedLen);
        if (hKey)
        {
            CryptDestroyKey(hKey);
        }
        if (hHash)
        {
            CryptDestroyHash(hHash);
        }
        if (hCryptProv)
        {
            CryptReleaseContext(hCryptProv, 0);
        }
    }
}
",1,CWE321
CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_72a.cpp,139803,"void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_72a()
{
    wchar_t * cryptoKey;
    vector<wchar_t *> cryptoKeyVector;
    wchar_t cryptoKeyBuffer[100] = L"""";
    cryptoKey = cryptoKeyBuffer;
    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */
    wcscpy(cryptoKey, CRYPTO_KEY);
    /* Put cryptoKey in a vector */
    cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);
    cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);
    cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);
    CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_72aSink(cryptoKeyVector);
}
",1,CWE321
CWE338_Weak_PRNG__w32_04.c,140313,"void CWE338_Weak_PRNG__w32_04()
{
    if(STATIC_CONST_TRUE)
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_16.c,140348,"void CWE338_Weak_PRNG__w32_16()
{
    while(1)
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
        break;
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_05.c,140316,"void CWE338_Weak_PRNG__w32_05()
{
    if(staticTrue)
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_15.c,140345,"void CWE338_Weak_PRNG__w32_15()
{
    switch(6)
    {
    case 6:
    {
        /* FLAW: Use of rand() as a PRNG */
        int data = rand();
        printIntLine(data);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_18.c,140352,"void CWE338_Weak_PRNG__w32_18()
{
    goto sink;
sink:
    {
        /* FLAW: Use of rand() as a PRNG */
        int data = rand();
        printIntLine(data);
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_17.c,140350,"void CWE338_Weak_PRNG__w32_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_12.c,140337,"void CWE338_Weak_PRNG__w32_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
    else
    {
        {
            HCRYPTPROV hCryptProv;
            int data;
            if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))
            {
                exit(1);
            }
            /* FIX: Use of CryptGenRandom() as a more secure PRNG */
            if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))
            {
                CryptReleaseContext(hCryptProv, 0);
                exit(1);
            }
            if (hCryptProv)
            {
                CryptReleaseContext(hCryptProv, 0);
            }
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_08.c,140325,"void CWE338_Weak_PRNG__w32_08()
{
    if(staticReturnsTrue())
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_01.c,140305,"void CWE338_Weak_PRNG__w32_01()
{
    {
        /* FLAW: Use of rand() as a PRNG */
        int data = rand();
        printIntLine(data);
    }
}
",1,CWE338
CWE338_Weak_PRNG__w32_10.c,140331,"void CWE338_Weak_PRNG__w32_10()
{
    if(globalTrue)
    {
        {
            /* FLAW: Use of rand() as a PRNG */
            int data = rand();
            printIntLine(data);
        }
    }
}
",1,CWE338
CWE36_Absolute_Path_Traversal__wchar_t_file_fopen_52b.cpp,151562,"void CWE36_Absolute_Path_Traversal__wchar_t_file_fopen_52bSink_b(wchar_t * data)
{
    CWE36_Absolute_Path_Traversal__wchar_t_file_fopen_52bSink_c(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_console_fopen_54c.cpp,145943,"void CWE36_Absolute_Path_Traversal__char_console_fopen_54cSink_c(char * data)
{
    CWE36_Absolute_Path_Traversal__char_console_fopen_54cSink_d(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_file_fopen_54b.cpp,147551,"void CWE36_Absolute_Path_Traversal__char_file_fopen_54bSink_b(char * data)
{
    CWE36_Absolute_Path_Traversal__char_file_fopen_54bSink_c(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_53c.cpp,145291,"void CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_53cSink_c(char * data)
{
    CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_53cSink_d(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_54d.cpp,146589,"void CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_54dSink_d(char * data)
{
    CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_54dSink_e(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_53c.cpp,148511,"void CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_53cSink_c(char * data)
{
    CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_53cSink_d(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__wchar_t_console_ifstream_53b.cpp,150119,"void CWE36_Absolute_Path_Traversal__wchar_t_console_ifstream_53bSink_b(wchar_t * data)
{
    CWE36_Absolute_Path_Traversal__wchar_t_console_ifstream_53bSink_c(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__char_environment_fopen_54c.cpp,146748,"void CWE36_Absolute_Path_Traversal__char_environment_fopen_54cSink_c(char * data)
{
    CWE36_Absolute_Path_Traversal__char_environment_fopen_54cSink_d(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_54c.cpp,152705,"void CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_54cSink_c(wchar_t * data)
{
    CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_54cSink_d(data);
}
",1,CWE36
CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_53c.cpp,149799,"void CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_53cSink_c(wchar_t * data)
{
    CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_53cSink_d(data);
}
",1,CWE36
CWE364_Signal_Handler_Race_Condition__basic_15.c,140394,"void CWE364_Signal_Handler_Race_Condition__basic_15()
{
    switch(6)
    {
    case 6:
    {
        structSigAtomic *gStructSigAtomic = NULL;
        signal(SIGINT, SIG_DFL);
        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;
        }
        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
        if (gStructSigAtomic == NULL) {exit(-1);}
        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = gStructSigAtomic;
        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad->val = 1;
        /* Assign CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad BEFORE
         * calling 'signal', because pointer types are not (according to spec), atomic
         * with respect to signals.
         *
         * In practice they are on most (all?) POSIX-y computers, but thems the
         * rules
         */
        signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_15_helper);
        /* FLAW: This test, free, and set operation is not atomic, so if signal
         * delivery occurs (for example) between the free and setting to NULL,
         * the signal handler could corrupt the heap, cause an access violation,
         * etc
         *
         * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
         * systems that don't actually exist, but this should trigger on
         * theoretical as well as actual computer systems.
         */
        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_01.c,140354,"void CWE364_Signal_Handler_Race_Condition__basic_01()
{
    {
        structSigAtomic *gStructSigAtomic = NULL;
        signal(SIGINT, SIG_DFL);
        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = NULL;
        }
        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
        if (gStructSigAtomic == NULL) {exit(-1);}
        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = gStructSigAtomic;
        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad->val = 1;
        /* Assign CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad BEFORE
         * calling 'signal', because pointer types are not (according to spec), atomic
         * with respect to signals.
         *
         * In practice they are on most (all?) POSIX-y computers, but thems the
         * rules
         */
        signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_01_helper);
        /* FLAW: This test, free, and set operation is not atomic, so if signal
         * delivery occurs (for example) between the free and setting to NULL,
         * the signal handler could corrupt the heap, cause an access violation,
         * etc
         *
         * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
         * systems that don't actually exist, but this should trigger on
         * theoretical as well as actual computer systems.
         */
        if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicBad = NULL;
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_17.c,140399,"void CWE364_Signal_Handler_Race_Condition__basic_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_17_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_17StructSigAtomicBad = NULL;
            }
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_12.c,140386,"void CWE364_Signal_Handler_Race_Condition__basic_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_12_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad = NULL;
            }
        }
    }
    else
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);
                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = 0;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_12_helper);
            /* FIX: In this instance, the fix is to temporarily disable the signal
             * handler while performing non-atomic operations.  Another way would
             * be to use sigprocmask or sigvec, or to restructure the signal handler
             * to operate in a safe manner.
             */
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood);
                CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood = NULL;
            }
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_12_helper);
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_14.c,140391,"void CWE364_Signal_Handler_Race_Condition__basic_14()
{
    if(globalFive==5)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_14_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicBad = NULL;
            }
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_16.c,140397,"void CWE364_Signal_Handler_Race_Condition__basic_16()
{
    while(1)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_16_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_16StructSigAtomicBad = NULL;
            }
        }
        break;
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_06.c,140368,"void CWE364_Signal_Handler_Race_Condition__basic_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_06_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_06StructSigAtomicBad = NULL;
            }
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_07.c,140371,"void CWE364_Signal_Handler_Race_Condition__basic_07()
{
    if(staticFive==5)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_07_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad = NULL;
            }
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_18.c,140401,"void CWE364_Signal_Handler_Race_Condition__basic_18()
{
    goto sink;
sink:
    {
        structSigAtomic *gStructSigAtomic = NULL;
        signal(SIGINT, SIG_DFL);
        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = NULL;
        }
        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
        if (gStructSigAtomic == NULL) {exit(-1);}
        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = gStructSigAtomic;
        CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad->val = 1;
        /* Assign CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad BEFORE
         * calling 'signal', because pointer types are not (according to spec), atomic
         * with respect to signals.
         *
         * In practice they are on most (all?) POSIX-y computers, but thems the
         * rules
         */
        signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_18_helper);
        /* FLAW: This test, free, and set operation is not atomic, so if signal
         * delivery occurs (for example) between the free and setting to NULL,
         * the signal handler could corrupt the heap, cause an access violation,
         * etc
         *
         * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
         * systems that don't actually exist, but this should trigger on
         * theoretical as well as actual computer systems.
         */
        if (CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad != NULL)
        {
            free(CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad);
            CWE364_Signal_Handler_Race_Condition__basic_18StructSigAtomicBad = NULL;
        }
    }
}
",1,CWE364
CWE364_Signal_Handler_Race_Condition__basic_13.c,140388,"void CWE364_Signal_Handler_Race_Condition__basic_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            structSigAtomic *gStructSigAtomic = NULL;
            signal(SIGINT, SIG_DFL);
            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = NULL;
            }
            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));
            if (gStructSigAtomic == NULL) {exit(-1);}
            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = gStructSigAtomic;
            CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad->val = 1;
            /* Assign CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad BEFORE
             * calling 'signal', because pointer types are not (according to spec), atomic
             * with respect to signals.
             *
             * In practice they are on most (all?) POSIX-y computers, but thems the
             * rules
             */
            signal(SIGINT, CWE364_Signal_Handler_Race_Condition__basic_13_helper);
            /* FLAW: This test, free, and set operation is not atomic, so if signal
             * delivery occurs (for example) between the free and setting to NULL,
             * the signal handler could corrupt the heap, cause an access violation,
             * etc
             *
             * Technically, ""CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = 0"" is not atomic on certain theoretical computer
             * systems that don't actually exist, but this should trigger on
             * theoretical as well as actual computer systems.
             */
            if (CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad != NULL)
            {
                free(CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad);
                CWE364_Signal_Handler_Race_Condition__basic_13StructSigAtomicBad = NULL;
            }
        }
    }
}
",1,CWE364
CWE366_Race_Condition_Within_Thread__global_int_05.c,140414,"void CWE366_Race_Condition_Within_Thread__global_int_05()
{
    if(staticTrue)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_05_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_05_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__int_byref_12.c,140484,"void CWE366_Race_Condition_Within_Thread__int_byref_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            int valBadSink;
            valBadSink = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_12_helper, (void*)&valBadSink, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_12_helper, (void*)&valBadSink, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(valBadSink);
        }
    }
    else
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            int valGoodSink;
            valGoodSink = 0;
            if (!stdThreadLockCreate(&gGoodLock))
            {
                return;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_12_helper, (void*)&valGoodSink, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_12_helper, (void*)&valGoodSink, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            stdThreadLockDestroy(gGoodLock);
            printIntLine(valGoodSink);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_18.c,140450,"void CWE366_Race_Condition_Within_Thread__global_int_18()
{
    goto sink;
sink:
    {
        stdThread threadA = NULL;
        stdThread threadB = NULL;
        gBadInt = 0;
        if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_18_helper, NULL, &threadA))
        {
            threadA = NULL;
        }
        if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_18_helper, NULL, &threadB))
        {
            threadB = NULL;
        }
        if (threadA && stdThreadJoin(threadA))
        {
            stdThreadDestroy(threadA);
        }
        if (threadB && stdThreadJoin(threadB))
        {
            stdThreadDestroy(threadB);
        }
        printIntLine(gBadInt);
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_08.c,140423,"void CWE366_Race_Condition_Within_Thread__global_int_08()
{
    if(staticReturnsTrue())
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_08_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_08_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_16.c,140446,"void CWE366_Race_Condition_Within_Thread__global_int_16()
{
    while(1)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_16_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_16_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
        break;
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_04.c,140411,"void CWE366_Race_Condition_Within_Thread__global_int_04()
{
    if(STATIC_CONST_TRUE)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_04_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_04_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_09.c,140426,"void CWE366_Race_Condition_Within_Thread__global_int_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_09_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_09_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__global_int_02.c,140405,"void CWE366_Race_Condition_Within_Thread__global_int_02()
{
    if(1)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            gBadInt = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_02_helper, NULL, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__global_int_02_helper, NULL, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(gBadInt);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__int_byref_17.c,140497,"void CWE366_Race_Condition_Within_Thread__int_byref_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            stdThread threadA = NULL;
            stdThread threadB = NULL;
            int valBadSink;
            valBadSink = 0;
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_17_helper, (void*)&valBadSink, &threadA))
            {
                threadA = NULL;
            }
            if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_17_helper, (void*)&valBadSink, &threadB))
            {
                threadB = NULL;
            }
            if (threadA && stdThreadJoin(threadA))
            {
                stdThreadDestroy(threadA);
            }
            if (threadB && stdThreadJoin(threadB))
            {
                stdThreadDestroy(threadB);
            }
            printIntLine(valBadSink);
        }
    }
}
",1,CWE366
CWE366_Race_Condition_Within_Thread__int_byref_01.c,140452,"void CWE366_Race_Condition_Within_Thread__int_byref_01()
{
    {
        stdThread threadA = NULL;
        stdThread threadB = NULL;
        int valBadSink;
        valBadSink = 0;
        if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_01_helper, (void*)&valBadSink, &threadA))
        {
            threadA = NULL;
        }
        if (!stdThreadCreate(CWE366_Race_Condition_Within_Thread__int_byref_01_helper, (void*)&valBadSink, &threadB))
        {
            threadB = NULL;
        }
        if (threadA && stdThreadJoin(threadA))
        {
            stdThreadDestroy(threadA);
        }
        if (threadB && stdThreadJoin(threadB))
        {
            stdThreadDestroy(threadB);
        }
        printIntLine(valBadSink);
    }
}
",1,CWE366
CWE369_Divide_by_Zero__int_fscanf_modulo_13.c,143361,"void CWE369_Divide_by_Zero__int_fscanf_modulo_13()
{
    int data;
    /* Initialize data */
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Possibly divide by zero */
        printIntLine(100 % data);
    }
}
",1,CWE369
CWE369_Divide_by_Zero__float_zero_68a.c,142051,"void CWE369_Divide_by_Zero__float_zero_68a()
{
    float data;
    /* Initialize data */
    data = 0.0F;
    /* POTENTIAL FLAW: Set data to zero */
    data = 0.0F;
    CWE369_Divide_by_Zero__float_zero_68aData = data;
    CWE369_Divide_by_Zero__float_zero_68aSink();
}
",1,CWE369
CWE369_Divide_by_Zero__float_fscanf_68a.c,141313,"void CWE369_Divide_by_Zero__float_fscanf_68a()
{
    float data;
    /* Initialize data */
    data = 0.0F;
    /* POTENTIAL FLAW: Use a value input from the console using fscanf() */
    fscanf (stdin, ""%f"", &data);
    CWE369_Divide_by_Zero__float_fscanf_68aData = data;
    CWE369_Divide_by_Zero__float_fscanf_68aSink();
}
",1,CWE369
CWE369_Divide_by_Zero__float_fgets_42.c,140959,"static float CWE369_Divide_by_Zero__float_fgets_42Source(float data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        /* POTENTIAL FLAW: Use a value input from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to float */
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
",1,CWE369
CWE369_Divide_by_Zero__float_fgets_66a.c,141055,"void CWE369_Divide_by_Zero__float_fgets_66a()
{
    float data;
    float dataArray[5];
    /* Initialize data */
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        /* POTENTIAL FLAW: Use a value input from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to float */
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE369_Divide_by_Zero__float_fgets_66aSink(dataArray);
}
",1,CWE369
CWE369_Divide_by_Zero__int_zero_modulo_54a.c,144946,"void CWE369_Divide_by_Zero__int_zero_modulo_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to zero */
    data = 0;
    CWE369_Divide_by_Zero__int_zero_modulo_54aSink(data);
}
",1,CWE369
CWE369_Divide_by_Zero__float_fscanf_31.c,141187,"void CWE369_Divide_by_Zero__float_fscanf_31()
{
    float data;
    /* Initialize data */
    data = 0.0F;
    /* POTENTIAL FLAW: Use a value input from the console using fscanf() */
    fscanf (stdin, ""%f"", &data);
    {
        float dataCopy = data;
        float data = dataCopy;
        {
            /* POTENTIAL FLAW: Possibly divide by zero */
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
    }
}
",1,CWE369
CWE369_Divide_by_Zero__float_zero_54a.c,141994,"void CWE369_Divide_by_Zero__float_zero_54a()
{
    float data;
    /* Initialize data */
    data = 0.0F;
    /* POTENTIAL FLAW: Set data to zero */
    data = 0.0F;
    CWE369_Divide_by_Zero__float_zero_54aSink(data);
}
",1,CWE369
CWE369_Divide_by_Zero__int_rand_divide_01.c,144043,"void CWE369_Divide_by_Zero__int_rand_divide_01()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* POTENTIAL FLAW: Possibly divide by zero */
    printIntLine(100 / data);
}
",1,CWE369
CWE369_Divide_by_Zero__float_rand_33.cpp,141685,"void CWE369_Divide_by_Zero__float_rand_33()
{
    float data;
    float &dataRef = data;
    /* Initialize data */
    data = 0.0F;
    /* POTENTIAL FLAW: Use a random number that could possibly equal zero */
    data = (float)RAND32();
    {
        float data = dataRef;
        {
            /* POTENTIAL FLAW: Possibly divide by zero */
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
    }
}
",1,CWE369
CWE377_Insecure_Temporary_File__wchar_t_mktemp_17.c,153318,"void CWE377_Insecure_Temporary_File__wchar_t_mktemp_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            wchar_t * filename;
            wchar_t tmpl[] = L""fnXXXXXX"";
            int fileDesc;
            filename = MKTEMP(tmpl);
            if (filename == NULL)
            {
                exit(1);
            }
            printWLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__wchar_t_mktemp_18.c,153320,"void CWE377_Insecure_Temporary_File__wchar_t_mktemp_18()
{
    goto sink;
sink:
    {
        wchar_t * filename;
        wchar_t tmpl[] = L""fnXXXXXX"";
        int fileDesc;
        filename = MKTEMP(tmpl);
        if (filename == NULL)
        {
            exit(1);
        }
        printWLine(filename);
        /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
        fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        if (fileDesc != -1)
        {
            printLine(""Temporary file was opened...now closing file"");
            CLOSE(fileDesc);
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_mktemp_05.c,153088,"void CWE377_Insecure_Temporary_File__char_mktemp_05()
{
    if(staticTrue)
    {
        {
            char * filename;
            char tmpl[] = ""fnXXXXXX"";
            int fileDesc;
            filename = MKTEMP(tmpl);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__wchar_t_tempnam_15.c,153362,"void CWE377_Insecure_Temporary_File__wchar_t_tempnam_15()
{
    switch(6)
    {
    case 6:
    {
        wchar_t * filename;
        int fileDesc;
        filename = TEMPNAM(NULL, NULL);
        if (filename == NULL)
        {
            exit(1);
        }
        printWLine(filename);
        /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
        fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        if (fileDesc != -1)
        {
            printLine(""Temporary file was opened...now closing file"");
            CLOSE(fileDesc);
        }
        free(filename);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_tmpnam_17.c,153220,"void CWE377_Insecure_Temporary_File__char_tmpnam_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * filename;
            int fileDesc;
            filename = TMPNAM(NULL);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_w32GetTempFileName_01.c,153224,"void CWE377_Insecure_Temporary_File__char_w32GetTempFileName_01()
{
    {
        char filename[MAX_PATH] = """";
        int fileDesc;
        /* FLAW: Passing 0 in for uUnique tells GetTempFileName to create and then close the file,
        * leading to an inescapable race condition when we try to open it again. */
        if (GetTempFileNameA(""."", ""CWE377_Insecure_Temporary_File__char_w32GetTempFileName_01"", 0, filename) == 0)
        {
            exit(1);
        }
        printLine(filename);
        /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
        fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        if (fileDesc != -1)
        {
            printLine(""Temporary file was opened...now closing file"");
            CLOSE(fileDesc);
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_mktemp_12.c,153109,"void CWE377_Insecure_Temporary_File__char_mktemp_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            char * filename;
            char tmpl[] = ""fnXXXXXX"";
            int fileDesc;
            filename = MKTEMP(tmpl);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
    else
    {
        {
            char * filename;
            char tmpl[] = ""fnXXXXXX"";
            int fileDesc;
            filename = MKTEMP(tmpl);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FIX: Open a temporary file using open() and the O_CREAT and O_EXCL flags
            * NOTE: This is not a perfect solution, but it is the base case scenario */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_tempnam_07.c,153143,"void CWE377_Insecure_Temporary_File__char_tempnam_07()
{
    if(staticFive==5)
    {
        {
            char * filename;
            int fileDesc;
            filename = TEMPNAM(NULL, NULL);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
            free(filename);
        }
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_tmpnam_16.c,153218,"void CWE377_Insecure_Temporary_File__char_tmpnam_16()
{
    while(1)
    {
        {
            char * filename;
            int fileDesc;
            filename = TMPNAM(NULL);
            if (filename == NULL)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
        break;
    }
}
",1,CWE377
CWE377_Insecure_Temporary_File__char_w32GetTempFileName_12.c,153256,"void CWE377_Insecure_Temporary_File__char_w32GetTempFileName_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            char filename[MAX_PATH] = """";
            int fileDesc;
            /* FLAW: Passing 0 in for uUnique tells GetTempFileName to create and then close the file,
            * leading to an inescapable race condition when we try to open it again. */
            if (GetTempFileNameA(""."", ""CWE377_Insecure_Temporary_File__char_w32GetTempFileName_12"", 0, filename) == 0)
            {
                exit(1);
            }
            printLine(filename);
            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
    else
    {
        {
            char filename[MAX_PATH] = """";
            int fileDesc;
            /* FIX: Passing a non-zero value in for uUnique prevents GetTempFileName from creating
             * and then closing the file, at the cost of no longer guaranteeing the name is unique. */
            /* INCIDENTAL CWE338 Weak PRNG - use of rand() as a PRNG */
            if (GetTempFileNameA(""."", ""good"", rand() + 1, filename) == 0)
            {
                exit(1);
            }
            printLine(filename);
            /* FIX: Open a temporary file using open() and the O_CREAT and O_EXCL flags
            * NOTE: This is not a perfect solution, but it is the base case scenario */
            fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);
            if (fileDesc != -1)
            {
                printLine(""Temporary file was opened...now closing file"");
                CLOSE(fileDesc);
            }
        }
    }
}
",1,CWE377
CWE390_Error_Without_Action__empty_catch_17.cpp,153514,"void CWE390_Error_Without_Action__empty_catch_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            try
            {
                string stringHello = ""hello"";
                string stringSubstring = stringHello.substr(rand(), rand());
                printLine(stringSubstring.c_str());
            }
            catch (out_of_range &)
            {
                /* FLAW: Catch, but do not handle the out_of_range error */
            }
        }
    }
}
",1,CWE390
CWE390_Error_Without_Action__empty_catch_15.cpp,153509,"void CWE390_Error_Without_Action__empty_catch_15()
{
    switch(6)
    {
    case 6:
    {
        try
        {
            string stringHello = ""hello"";
            string stringSubstring = stringHello.substr(rand(), rand());
            printLine(stringSubstring.c_str());
        }
        catch (out_of_range &)
        {
            /* FLAW: Catch, but do not handle the out_of_range error */
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE390
CWE390_Error_Without_Action__empty_catch_16.cpp,153512,"void CWE390_Error_Without_Action__empty_catch_16()
{
    while(1)
    {
        {
            try
            {
                string stringHello = ""hello"";
                string stringSubstring = stringHello.substr(rand(), rand());
                printLine(stringSubstring.c_str());
            }
            catch (out_of_range &)
            {
                /* FLAW: Catch, but do not handle the out_of_range error */
            }
        }
        break;
    }
}
",1,CWE390
CWE390_Error_Without_Action__sqrt_15.c,153705,"void CWE390_Error_Without_Action__sqrt_15()
{
    switch(6)
    {
    case 6:
    {
        double doubleNumber;
        errno = 0; /* set errno to zero before calling sqrt(), which can change its value */
        doubleNumber = (double)sqrt((double)-1);
        /* FLAW: Check errno to see if sqrt() failed, but do not handle errors */
        if (errno == EDOM)
        {
            /* do nothing */
        }
        printDoubleLine(doubleNumber);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE390
CWE390_Error_Without_Action__empty_catch_12.cpp,153501,"void CWE390_Error_Without_Action__empty_catch_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            try
            {
                string stringHello = ""hello"";
                string stringSubstring = stringHello.substr(rand(), rand());
                printLine(stringSubstring.c_str());
            }
            catch (out_of_range &)
            {
                /* FLAW: Catch, but do not handle the out_of_range error */
            }
        }
    }
    else
    {
        {
            try
            {
                string stringHello = ""hello"";
                string stringSubstring = stringHello.substr(rand(), rand());
                printLine(stringSubstring.c_str());
            }
            catch (out_of_range &)
            {
                /* FIX: catch the out_of_range error */
                printLine(""Range specified was invalid"");
                exit(1);
            }
        }
    }
}
",1,CWE390
CWE390_Error_Without_Action__empty_catch_18.cpp,153516,"void CWE390_Error_Without_Action__empty_catch_18()
{
    goto sink;
sink:
    {
        try
        {
            string stringHello = ""hello"";
            string stringSubstring = stringHello.substr(rand(), rand());
            printLine(stringSubstring.c_str());
        }
        catch (out_of_range &)
        {
            /* FLAW: Catch, but do not handle the out_of_range error */
        }
    }
}
",1,CWE390
CWE390_Error_Without_Action__fgets_wchar_t_16.c,153610,"void CWE390_Error_Without_Action__fgets_wchar_t_16()
{
    while(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() */
            wchar_t dataBuffer[100] = L"""";
            wchar_t * data = dataBuffer;
            printWLine(L""Please enter a string: "");
            /* FLAW: check the return value, but do nothing if there is an error */
            if (fgetws(data, 100, stdin) == NULL)
            {
                /* do nothing */
            }
            printWLine(data);
        }
        break;
    }
}
",1,CWE390
CWE390_Error_Without_Action__fgets_wchar_t_18.c,153614,"void CWE390_Error_Without_Action__fgets_wchar_t_18()
{
    goto sink;
sink:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() */
        wchar_t dataBuffer[100] = L"""";
        wchar_t * data = dataBuffer;
        printWLine(L""Please enter a string: "");
        /* FLAW: check the return value, but do nothing if there is an error */
        if (fgetws(data, 100, stdin) == NULL)
        {
            /* do nothing */
        }
        printWLine(data);
    }
}
",1,CWE390
CWE390_Error_Without_Action__fopen_17.c,153661,"void CWE390_Error_Without_Action__fopen_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            FILE * fileDesc = NULL;
            fileDesc = fopen(""file.txt"", ""w+"");
            /* FLAW: Check to see if fopen failed, but do nothing about it */
            if (fileDesc == NULL)
            {
                /* do nothing */
            }
            fclose(fileDesc);
        }
    }
}
",1,CWE390
CWE390_Error_Without_Action__sqrt_17.c,153710,"void CWE390_Error_Without_Action__sqrt_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            double doubleNumber;
            errno = 0; /* set errno to zero before calling sqrt(), which can change its value */
            doubleNumber = (double)sqrt((double)-1);
            /* FLAW: Check errno to see if sqrt() failed, but do not handle errors */
            if (errno == EDOM)
            {
                /* do nothing */
            }
            printDoubleLine(doubleNumber);
        }
    }
}
",1,CWE390
CWE391_Unchecked_Error_Condition__strtol_03.c,153768,"void CWE391_Unchecked_Error_Condition__strtol_03()
{
    if(5==5)
    {
        {
            long longNumber;
            longNumber = strtol(""0xfffffffff"", NULL, 0);
            /* FLAW: Do not check to see if strtol() failed */
            printf(""%li\n"", longNumber);
        }
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__wcstombs_17.c,153857,"void CWE391_Unchecked_Error_Condition__wcstombs_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            size_t bytesTranslated = 0;
            char charString[100];
            charString[0] = '\0';
            bytesTranslated = wcstombs((char *)&charString, L""\xffff"", 100);
            /* FLAW: Do not check to see if wcstombs() failed */
            printUnsignedLine(bytesTranslated);
            printLine(charString);
        }
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__wcstombs_03.c,153817,"void CWE391_Unchecked_Error_Condition__wcstombs_03()
{
    if(5==5)
    {
        {
            size_t bytesTranslated = 0;
            char charString[100];
            charString[0] = '\0';
            bytesTranslated = wcstombs((char *)&charString, L""\xffff"", 100);
            /* FLAW: Do not check to see if wcstombs() failed */
            printUnsignedLine(bytesTranslated);
            printLine(charString);
        }
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__sqrt_16.c,153757,"void CWE391_Unchecked_Error_Condition__sqrt_16()
{
    while(1)
    {
        {
            double doubleNumber;
            doubleNumber = (double)sqrt((double)-1);
            /* FLAW: Do not check to see if sqrt() failed */
            printDoubleLine(doubleNumber);
        }
        break;
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__sqrt_15.c,153754,"void CWE391_Unchecked_Error_Condition__sqrt_15()
{
    switch(6)
    {
    case 6:
    {
        double doubleNumber;
        doubleNumber = (double)sqrt((double)-1);
        /* FLAW: Do not check to see if sqrt() failed */
        printDoubleLine(doubleNumber);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__strtol_17.c,153808,"void CWE391_Unchecked_Error_Condition__strtol_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            long longNumber;
            longNumber = strtol(""0xfffffffff"", NULL, 0);
            /* FLAW: Do not check to see if strtol() failed */
            printf(""%li\n"", longNumber);
        }
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__strtol_18.c,153810,"void CWE391_Unchecked_Error_Condition__strtol_18()
{
    goto sink;
sink:
    {
        long longNumber;
        longNumber = strtol(""0xfffffffff"", NULL, 0);
        /* FLAW: Do not check to see if strtol() failed */
        printf(""%li\n"", longNumber);
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__strtol_16.c,153806,"void CWE391_Unchecked_Error_Condition__strtol_16()
{
    while(1)
    {
        {
            long longNumber;
            longNumber = strtol(""0xfffffffff"", NULL, 0);
            /* FLAW: Do not check to see if strtol() failed */
            printf(""%li\n"", longNumber);
        }
        break;
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__wcstombs_12.c,153844,"void CWE391_Unchecked_Error_Condition__wcstombs_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            size_t bytesTranslated = 0;
            char charString[100];
            charString[0] = '\0';
            bytesTranslated = wcstombs((char *)&charString, L""\xffff"", 100);
            /* FLAW: Do not check to see if wcstombs() failed */
            printUnsignedLine(bytesTranslated);
            printLine(charString);
        }
    }
    else
    {
        {
            size_t bytesTranslated = 0;
            char charString[100];
            charString[0] = '\0';
            errno = 0; /* set errno to zero before calling wcstombs(), which can change its value */
            bytesTranslated = wcstombs((char *)&charString, L""\xffff"", 100);
            /* FIX: Check errno to see if wcstombs() failed */
            if (errno == EILSEQ)
            {
                printLine(""wcstombs() failed"");
                exit(1);
            }
            printUnsignedLine(bytesTranslated);
            printLine(charString);
        }
    }
}
",1,CWE391
CWE391_Unchecked_Error_Condition__wcstombs_18.c,153859,"void CWE391_Unchecked_Error_Condition__wcstombs_18()
{
    goto sink;
sink:
    {
        size_t bytesTranslated = 0;
        char charString[100];
        charString[0] = '\0';
        bytesTranslated = wcstombs((char *)&charString, L""\xffff"", 100);
        /* FLAW: Do not check to see if wcstombs() failed */
        printUnsignedLine(bytesTranslated);
        printLine(charString);
    }
}
",1,CWE391
CWE397_Throw_Generic_Exception__throw_exception_18.cpp,154055,"void CWE397_Throw_Generic_Exception__throw_exception_18()
{
    goto sink;
sink:
    /* FLAW: throw std::exception class, which is very generic */
    throw exception();
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_02.cpp,154010,"void CWE397_Throw_Generic_Exception__throw_exception_02()
{
    if(1)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_05.cpp,154019,"void CWE397_Throw_Generic_Exception__throw_exception_05()
{
    if(staticTrue)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_15.cpp,154048,"void CWE397_Throw_Generic_Exception__throw_exception_15()
{
    switch(6)
    {
    case 6:
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_03.cpp,154013,"void CWE397_Throw_Generic_Exception__throw_exception_03()
{
    if(5==5)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_09.cpp,154031,"void CWE397_Throw_Generic_Exception__throw_exception_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_12.cpp,154040,"void CWE397_Throw_Generic_Exception__throw_exception_12()
{
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
    else
    {
        /* FIX: Throw a specific exception */
        throw range_error(""Test"");
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_16.cpp,154051,"void CWE397_Throw_Generic_Exception__throw_exception_16()
{
    while(1)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
        break;
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_04.cpp,154016,"void CWE397_Throw_Generic_Exception__throw_exception_04()
{
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE397_Throw_Generic_Exception__throw_exception_08.cpp,154028,"void CWE397_Throw_Generic_Exception__throw_exception_08()
{
    if(staticReturnsTrue())
    {
        /* FLAW: throw std::exception class, which is very generic */
        throw exception();
    }
}
",1,CWE397
CWE400_Resource_Exhaustion__fscanf_fwrite_15.c,156335,"void CWE400_Resource_Exhaustion__fscanf_fwrite_15()
{
    int count;
    /* Initialize count */
    count = -1;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Read count from the console using fscanf() */
        fscanf(stdin, ""%d"", &count);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        size_t i = 0;
        FILE *pFile = NULL;
        const char *filename = ""output_CWE400_Resource_Exhaustion__fscanf_fwrite_15.txt"";
        pFile = fopen(filename, ""w+"");
        if (pFile == NULL)
        {
            exit(1);
        }
        /* POTENTIAL FLAW: For loop using count as the loop variant and no validation
         * This can cause a file to become very large */
        for (i = 0; i < (size_t)count; i++)
        {
            if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))
            {
                exit(1);
            }
        }
        if (pFile)
        {
            fclose(pFile);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE400
CWE400_Resource_Exhaustion__connect_socket_for_loop_67b.c,154766,"void CWE400_Resource_Exhaustion__connect_socket_for_loop_67bSink(CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct)
{
    int count = myStruct.structFirst;
    {
        size_t i = 0;
        /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */
        for (i = 0; i < (size_t)count; i++)
        {
            printLine(""Hello"");
        }
    }
}
",1,CWE400
CWE400_Resource_Exhaustion__rand_for_loop_66a.c,157709,"void CWE400_Resource_Exhaustion__rand_for_loop_66a()
{
    int count;
    int countArray[5];
    /* Initialize count */
    count = -1;
    /* POTENTIAL FLAW: Set count to a random value */
    count = RAND32();
    /* put count in array */
    countArray[2] = count;
    CWE400_Resource_Exhaustion__rand_for_loop_66aSink(countArray);
}
",1,CWE400
CWE400_Resource_Exhaustion__rand_for_loop_41.c,157608,"void CWE400_Resource_Exhaustion__rand_for_loop_41()
{
    int count;
    /* Initialize count */
    count = -1;
    /* POTENTIAL FLAW: Set count to a random value */
    count = RAND32();
    CWE400_Resource_Exhaustion__rand_for_loop_41Sink(count);
}
",1,CWE400
CWE400_Resource_Exhaustion__fgets_for_loop_03.c,155293,"void CWE400_Resource_Exhaustion__fgets_for_loop_03()
{
    int count;
    /* Initialize count */
    count = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            /* POTENTIAL FLAW: Read count from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to int */
                count = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            size_t i = 0;
            /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */
            for (i = 0; i < (size_t)count; i++)
            {
                printLine(""Hello"");
            }
        }
    }
}
",1,CWE400
CWE400_Resource_Exhaustion__fscanf_fwrite_45.c,156402,"void CWE400_Resource_Exhaustion__fscanf_fwrite_45()
{
    int count;
    /* Initialize count */
    count = -1;
    /* POTENTIAL FLAW: Read count from the console using fscanf() */
    fscanf(stdin, ""%d"", &count);
    CWE400_Resource_Exhaustion__fscanf_fwrite_45Data = count;
    CWE400_Resource_Exhaustion__fscanf_fwrite_45Sink();
}
",1,CWE400
CWE400_Resource_Exhaustion__connect_socket_fwrite_31.c,154889,"void CWE400_Resource_Exhaustion__connect_socket_fwrite_31()
{
    int count;
    /* Initialize count */
    count = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            /* POTENTIAL FLAW: Read count using a connect socket */
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            /* NUL-terminate the string */
            inputBuffer[recvResult] = '\0';
            /* Convert to int */
            count = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int countCopy = count;
        int count = countCopy;
        {
            size_t i = 0;
            FILE *pFile = NULL;
            const char *filename = ""output_CWE400_Resource_Exhaustion__connect_socket_fwrite_31.txt"";
            pFile = fopen(filename, ""w+"");
            if (pFile == NULL)
            {
                exit(1);
            }
            /* POTENTIAL FLAW: For loop using count as the loop variant and no validation
             * This can cause a file to become very large */
            for (i = 0; i < (size_t)count; i++)
            {
                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))
                {
                    exit(1);
                }
            }
            if (pFile)
            {
                fclose(pFile);
            }
        }
    }
}
",1,CWE400
CWE400_Resource_Exhaustion__rand_fwrite_21.c,157826,"void CWE400_Resource_Exhaustion__rand_fwrite_21()
{
    int count;
    /* Initialize count */
    count = -1;
    /* POTENTIAL FLAW: Set count to a random value */
    count = RAND32();
    CWE400_Resource_Exhaustion__rand_fwrite_21Static = 1; /* true */
    CWE400_Resource_Exhaustion__rand_fwrite_21Sink(count);
}
",1,CWE400
CWE400_Resource_Exhaustion__rand_sleep_31.c,158087,"void CWE400_Resource_Exhaustion__rand_sleep_31()
{
    int count;
    /* Initialize count */
    count = -1;
    /* POTENTIAL FLAW: Set count to a random value */
    count = RAND32();
    {
        int countCopy = count;
        int count = countCopy;
        /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */
        SLEEP(count);
        printLine(""Sleep time possibly too long"");
    }
}
",1,CWE400
CWE400_Resource_Exhaustion__connect_socket_sleep_12.c,155092,"void CWE400_Resource_Exhaustion__connect_socket_sleep_12()
{
    int count;
    /* Initialize count */
    count = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                /* POTENTIAL FLAW: Read count using a connect socket */
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                /* NUL-terminate the string */
                inputBuffer[recvResult] = '\0';
                /* Convert to int */
                count = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        /* FIX: Use a relatively small number */
        count = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */
        SLEEP(count);
        printLine(""Sleep time possibly too long"");
    }
    else
    {
        /* FIX: Validate count before using it as a parameter in the sleep function */
        if (count > 0 && count <= 2000)
        {
            SLEEP(count);
            printLine(""Sleep time OK"");
        }
        else
        {
            printLine(""Sleep time too long"");
        }
    }
}
",1,CWE400
CWE401_Memory_Leak__new_twoIntsStruct_45.cpp,163529,"static void CWE401_Memory_Leak__new_twoIntsStruct_45Sink()
{
    twoIntsStruct * data = CWE401_Memory_Leak__new_twoIntsStruct_45Data;
    /* POTENTIAL FLAW: No deallocation */
    ; /* empty statement needed for some flow variants */
}
",1,CWE401
CWE401_Memory_Leak__int_malloc_66a.c,160169,"void CWE401_Memory_Leak__int_malloc_66a()
{
    int * data;
    int * dataArray[5];
    data = NULL;
    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    data[0] = 5;
    printIntLine(data[0]);
    /* put data in array */
    dataArray[2] = data;
    CWE401_Memory_Leak__int_malloc_66aSink(dataArray);
}
",1,CWE401
CWE401_Memory_Leak__int_malloc_62a.cpp,160145,"void CWE401_Memory_Leak__int_malloc_62a()
{
    int * data;
    data = NULL;
    CWE401_Memory_Leak__int_malloc_62aSource(data);
    /* POTENTIAL FLAW: No deallocation */
    ; /* empty statement needed for some flow variants */
}
",1,CWE401
CWE401_Memory_Leak__strdup_wchar_t_73a.cpp,164333,"void CWE401_Memory_Leak__strdup_wchar_t_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    data = NULL;
    {
        wchar_t myString[] = L""myString"";
        /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */
        data = wcsdup(myString);
        /* Use data */
        printWLine(data);
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE401_Memory_Leak__strdup_wchar_t_73aSink(dataList);
}
",1,CWE401
CWE401_Memory_Leak__new_int_33.cpp,162845,"void CWE401_Memory_Leak__new_int_33()
{
    int * data;
    int * &dataRef = data;
    data = NULL;
    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = new int;
    /* Initialize and make use of data */
    *data = 5;
    printIntLine(*data);
    {
        int * data = dataRef;
        /* POTENTIAL FLAW: No deallocation */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE401
CWE401_Memory_Leak__new_array_wchar_t_33.cpp,162179,"void CWE401_Memory_Leak__new_array_wchar_t_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    data = NULL;
    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = new wchar_t[100];
    /* Initialize and make use of data */
    wcscpy(data, L""A String"");
    printWLine(data);
    {
        wchar_t * data = dataRef;
        /* POTENTIAL FLAW: No deallocation */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE401
CWE401_Memory_Leak__strdup_char_43.cpp,163974,"void CWE401_Memory_Leak__strdup_char_43()
{
    char * data;
    data = NULL;
    CWE401_Memory_Leak__strdup_char_43Source(data);
    /* POTENTIAL FLAW: No deallocation of memory */
    /* no deallocation */
    ; /* empty statement needed for some flow variants */
}
",1,CWE401
CWE401_Memory_Leak__strdup_wchar_t_67a.c,164315,"void CWE401_Memory_Leak__strdup_wchar_t_67a()
{
    wchar_t * data;
    CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct;
    data = NULL;
    {
        wchar_t myString[] = L""myString"";
        /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */
        data = wcsdup(myString);
        /* Use data */
        printWLine(data);
    }
    myStruct.structFirst = data;
    CWE401_Memory_Leak__strdup_wchar_t_67aSink(myStruct);
}
",1,CWE401
CWE401_Memory_Leak__new_int64_t_73a.cpp,162731,"void CWE401_Memory_Leak__new_int64_t_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    data = NULL;
    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = new int64_t;
    /* Initialize and make use of data */
    *data = 5LL;
    printLongLongLine(*data);
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE401_Memory_Leak__new_int64_t_73aSink(dataList);
}
",1,CWE401
CWE401_Memory_Leak__new_array_int64_t_45.cpp,161087,"static void CWE401_Memory_Leak__new_array_int64_t_45Sink()
{
    int64_t * data = CWE401_Memory_Leak__new_array_int64_t_45Data;
    /* POTENTIAL FLAW: No deallocation */
    ; /* empty statement needed for some flow variants */
}
",1,CWE401
CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_45.c,166645,"void CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_45()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_45Data = data;
    CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_45Sink();
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__freopen_w32_close_68a.c,167187,"void CWE404_Improper_Resource_Shutdown__freopen_w32_close_68a()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */
    data = freopen(""BadSource_freopen.txt"",""w+"",stdin);
    CWE404_Improper_Resource_Shutdown__freopen_w32_close_68aDataForBadSink = data;
    CWE404_Improper_Resource_Shutdown__freopen_w32_close_68aSink();
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__freopen_w32CloseHandle_45.c,166966,"static void CWE404_Improper_Resource_Shutdown__freopen_w32CloseHandle_45Sink()
{
    FILE * data = CWE404_Improper_Resource_Shutdown__freopen_w32CloseHandle_45Data;
    if (data != NULL)
    {
        /* FLAW: Attempt to close the file using CloseHandle() instead of fclose() */
        CloseHandle((HANDLE)data);
    }
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__w32CreateFile_close_67b.c,167668,"void CWE404_Improper_Resource_Shutdown__w32CreateFile_close_67bSink(CWE404_Improper_Resource_Shutdown__w32CreateFile_close_67_structType myStruct)
{
    HANDLE data = myStruct.structFirst;
    if (data != INVALID_HANDLE_VALUE)
    {
        /* FLAW: Attempt to close the file using close() instead of CloseHandle() */
        _close((int)data);
    }
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_22a.c,166614,"void CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_22a()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_22aGlobal = 1; /* true */
    CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_22aSink(data);
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__freopen_w32_close_22a.c,167097,"void CWE404_Improper_Resource_Shutdown__freopen_w32_close_22a()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */
    data = freopen(""BadSource_freopen.txt"",""w+"",stdin);
    CWE404_Improper_Resource_Shutdown__freopen_w32_close_22aGlobal = 1; /* true */
    CWE404_Improper_Resource_Shutdown__freopen_w32_close_22aSink(data);
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__open_fclose_74b.cpp,167362,"void CWE404_Improper_Resource_Shutdown__open_fclose_74bSink(map<int, int> dataMap)
{
    /* copy data out of dataMap */
    int data = dataMap[2];
    if (data != -1)
    {
        /* FLAW: Attempt to close the file using fclose() instead of close() */
        fclose((FILE *)data);
    }
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__open_fclose_67b.c,167346,"void CWE404_Improper_Resource_Shutdown__open_fclose_67bSink(CWE404_Improper_Resource_Shutdown__open_fclose_67_structType myStruct)
{
    int data = myStruct.structFirst;
    if (data != -1)
    {
        /* FLAW: Attempt to close the file using fclose() instead of close() */
        fclose((FILE *)data);
    }
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_66b.c,166698,"void CWE404_Improper_Resource_Shutdown__fopen_w32CloseHandle_66bSink(FILE * dataArray[])
{
    /* copy data out of dataArray */
    FILE * data = dataArray[2];
    if (data != NULL)
    {
        /* FLAW: Attempt to close the file using CloseHandle() instead of fclose() */
        CloseHandle((HANDLE)data);
    }
}
",1,CWE404
CWE404_Improper_Resource_Shutdown__open_w32CloseHandle_44.c,167446,"void CWE404_Improper_Resource_Shutdown__open_w32CloseHandle_44()
{
    int data;
    /* define a function pointer */
    void (*funcPtr) (int) = CWE404_Improper_Resource_Shutdown__open_w32CloseHandle_44Sink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */
    data = OPEN(""BadSource_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE404
CWE415_Double_Free__new_delete_array_int64_t_52b.cpp,169962,"void CWE415_Double_Free__new_delete_array_int64_t_52bSink_b(int64_t * data)
{
    CWE415_Double_Free__new_delete_array_int64_t_52bSink_c(data);
}
",1,CWE415
CWE415_Double_Free__malloc_free_int64_t_42.c,168207,"static int64_t * CWE415_Double_Free__malloc_free_int64_t_42Source(int64_t * data)
{
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    /* POTENTIAL FLAW: Free data in the source - the CWE415_Double_Free__malloc_free_int64_t_42 sink frees data as well */
    free(data);
    return data;
}
",1,CWE415
CWE415_Double_Free__malloc_free_int64_t_68a.c,168315,"void CWE415_Double_Free__malloc_free_int64_t_68a()
{
    int64_t * data;
    /* Initialize data */
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    /* POTENTIAL FLAW: Free data in the source - the CWE415_Double_Free__malloc_free_int64_t_68a sink frees data as well */
    free(data);
    CWE415_Double_Free__malloc_free_int64_t_68aData = data;
    CWE415_Double_Free__malloc_free_int64_t_68aSink();
}
",1,CWE415
CWE415_Double_Free__new_delete_char_68b.cpp,171270,"void CWE415_Double_Free__new_delete_char_68bSink()
{
    char * data = CWE415_Double_Free__new_delete_char_68bData;
    /* POTENTIAL FLAW: Possibly deleting memory twice */
    delete data;
}
",1,CWE415
CWE415_Double_Free__new_delete_array_wchar_t_21.cpp,170880,"void CWE415_Double_Free__new_delete_array_wchar_t_21()
{
    wchar_t * data;
    /* Initialize data */
    data = NULL;
    data = new wchar_t[100];
    /* POTENTIAL FLAW: delete the array data in the source - the CWE415_Double_Free__new_delete_array_wchar_t_21 sink deletes the array data as well */
    delete [] data;
    CWE415_Double_Free__new_delete_array_wchar_t_21Static = 1; /* true */
    CWE415_Double_Free__new_delete_array_wchar_t_21Sink(data);
}
",1,CWE415
CWE415_Double_Free__malloc_free_struct_21.c,168912,"void CWE415_Double_Free__malloc_free_struct_21()
{
    twoIntsStruct * data;
    /* Initialize data */
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    /* POTENTIAL FLAW: Free data in the source - the CWE415_Double_Free__malloc_free_struct_21 sink frees data as well */
    free(data);
    CWE415_Double_Free__malloc_free_struct_21Static = 1; /* true */
    CWE415_Double_Free__malloc_free_struct_21Sink(data);
}
",1,CWE415
CWE415_Double_Free__new_delete_array_char_06.cpp,169346,"void CWE415_Double_Free__new_delete_array_char_06()
{
    char * data;
    /* Initialize data */
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new char[100];
        /* POTENTIAL FLAW: delete the array data in the source - the CWE415_Double_Free__new_delete_array_char_06 sink deletes the array data as well */
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Possibly deleting memory twice */
        delete [] data;
    }
}
",1,CWE415
CWE415_Double_Free__new_delete_array_struct_67a.cpp,170769,"void CWE415_Double_Free__new_delete_array_struct_67a()
{
    twoIntsStruct * data;
    structType myStruct;
    /* Initialize data */
    data = NULL;
    data = new twoIntsStruct[100];
    /* POTENTIAL FLAW: delete the array data in the source - the CWE415_Double_Free__new_delete_array_struct_67a sink deletes the array data as well */
    delete [] data;
    myStruct.structFirst = data;
    CWE415_Double_Free__new_delete_array_struct_67aSink(myStruct);
}
",1,CWE415
CWE415_Double_Free__new_delete_struct_61b.cpp,172458,"twoIntsStruct * CWE415_Double_Free__new_delete_struct_61bSource(twoIntsStruct * data)
{
    data = new twoIntsStruct;
    /* POTENTIAL FLAW: delete data in the source - the CWE415_Double_Free__new_delete_struct_61b sink deletes data as well */
    delete data;
    return data;
}
",1,CWE415
CWE415_Double_Free__new_delete_wchar_t_65a.cpp,172725,"void CWE415_Double_Free__new_delete_wchar_t_65a()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE415_Double_Free__new_delete_wchar_t_65aSink;
    /* Initialize data */
    data = NULL;
    data = new wchar_t;
    /* POTENTIAL FLAW: delete data in the source - the CWE415_Double_Free__new_delete_wchar_t_65a sink deletes data as well */
    delete data;
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE415
CWE416_Use_After_Free__new_delete_wchar_t_63a.cpp,174835,"void CWE416_Use_After_Free__new_delete_wchar_t_63a()
{
    wchar_t * data;
    /* Initialize data */
    data = NULL;
    data = new wchar_t;
    *data = L'A';
    /* POTENTIAL FLAW: Delete data in the source - the CWE416_Use_After_Free__new_delete_wchar_t_63a sink attempts to use data */
    delete data;
    CWE416_Use_After_Free__new_delete_wchar_t_63aSink(&data);
}
",1,CWE416
CWE416_Use_After_Free__malloc_free_struct_63b.c,173278,"void CWE416_Use_After_Free__malloc_free_struct_63bSink(twoIntsStruct * * dataPtr)
{
    twoIntsStruct * data = *dataPtr;
    /* POTENTIAL FLAW: Use of data that may have been freed */
    printStructLine(&data[0]);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
}
",1,CWE416
CWE416_Use_After_Free__new_delete_struct_62a.cpp,174725,"void CWE416_Use_After_Free__new_delete_struct_62a()
{
    twoIntsStruct * data;
    /* Initialize data */
    data = NULL;
    CWE416_Use_After_Free__new_delete_struct_62aSource(data);
    /* POTENTIAL FLAW: Use of data that may have been deleted */
    printStructLine(data);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */
}
",1,CWE416
CWE416_Use_After_Free__malloc_free_char_43.cpp,172848,"void CWE416_Use_After_Free__malloc_free_char_43()
{
    char * data;
    /* Initialize data */
    data = NULL;
    CWE416_Use_After_Free__malloc_free_char_43Source(data);
    /* POTENTIAL FLAW: Use of data that may have been freed */
    printLine(data);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
}
",1,CWE416
CWE416_Use_After_Free__new_delete_array_class_18.cpp,173572,"void CWE416_Use_After_Free__new_delete_array_class_18()
{
    TwoIntsClass * data;
    /* Initialize data */
    data = NULL;
    goto source;
source:
    data = new TwoIntsClass[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    /* POTENTIAL FLAW: Delete data in the source - the CWE416_Use_After_Free__new_delete_array_class_18 sink attempts to use data */
    delete [] data;
    goto sink;
sink:
    /* POTENTIAL FLAW: Use of data that may have been deleted */
    printIntLine(data[0].intOne);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */
}
",1,CWE416
CWE416_Use_After_Free__malloc_free_long_63b.c,173174,"void CWE416_Use_After_Free__malloc_free_long_63bSink(long * * dataPtr)
{
    long * data = *dataPtr;
    /* POTENTIAL FLAW: Use of data that may have been freed */
    printLongLine(data[0]);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
}
",1,CWE416
CWE416_Use_After_Free__new_delete_int64_t_62a.cpp,174413,"void CWE416_Use_After_Free__new_delete_int64_t_62a()
{
    int64_t * data;
    /* Initialize data */
    data = NULL;
    CWE416_Use_After_Free__new_delete_int64_t_62aSource(data);
    /* POTENTIAL FLAW: Use of data that may have been deleted */
    printLongLongLine(*data);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */
}
",1,CWE416
CWE416_Use_After_Free__new_delete_int64_t_04.cpp,174340,"void CWE416_Use_After_Free__new_delete_int64_t_04()
{
    int64_t * data;
    /* Initialize data */
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new int64_t;
        *data = 5LL;
        /* POTENTIAL FLAW: Delete data in the source - the CWE416_Use_After_Free__new_delete_int64_t_04 sink attempts to use data */
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Use of data that may have been deleted */
        printLongLongLine(*data);
        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */
    }
}
",1,CWE416
CWE416_Use_After_Free__malloc_free_struct_43.cpp,173264,"void CWE416_Use_After_Free__malloc_free_struct_43()
{
    twoIntsStruct * data;
    /* Initialize data */
    data = NULL;
    CWE416_Use_After_Free__malloc_free_struct_43Source(data);
    /* POTENTIAL FLAW: Use of data that may have been freed */
    printStructLine(&data[0]);
    /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */
}
",1,CWE416
CWE416_Use_After_Free__new_delete_long_17.cpp,174609,"void CWE416_Use_After_Free__new_delete_long_17()
{
    int i,j;
    long * data;
    /* Initialize data */
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new long;
        *data = 5L;
        /* POTENTIAL FLAW: Delete data in the source - the CWE416_Use_After_Free__new_delete_long_17 sink attempts to use data */
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        /* POTENTIAL FLAW: Use of data that may have been deleted */
        printLongLine(*data);
        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */
    }
}
",1,CWE416
CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_45.c,176913,"static void CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_45Sink()
{
    wchar_t * data = CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_45Data;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45.c,175625,"static void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45Sink()
{
    char * data = CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45Data;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__char_environment_68b.c,176009,"void CWE427_Uncontrolled_Search_Path_Element__char_environment_68bSink()
{
    char * data = CWE427_Uncontrolled_Search_Path_Element__char_environment_68bData;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__char_console_68b.c,175848,"void CWE427_Uncontrolled_Search_Path_Element__char_console_68bSink()
{
    char * data = CWE427_Uncontrolled_Search_Path_Element__char_console_68bData;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_68b.c,176975,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_68bSink()
{
    wchar_t * data = CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_68bData;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__wchar_t_console_67b.c,176649,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_console_67bSink(CWE427_Uncontrolled_Search_Path_Element__wchar_t_console_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_63a.c,176792,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_63a()
{
    wchar_t * data;
    wchar_t dataBuffer[250] = L""PATH="";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 250-dataLen-1);
        }
    }
    CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_63aSink(&data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_22a.c,176883,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_22a()
{
    wchar_t * data;
    wchar_t dataBuffer[250] = L""PATH="";
    data = dataBuffer;
    CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_22aGlobal = 1; /* true */
    data = CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_22aSource(data);
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__wchar_t_console_12.c,176538,"void CWE427_Uncontrolled_Search_Path_Element__wchar_t_console_12()
{
    wchar_t * data;
    wchar_t dataBuffer[250] = L""PATH="";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            /* Read input from the console */
            size_t dataLen = wcslen(data);
            /* if there is room in data, read into it from the console */
            if (250-dataLen > 1)
            {
                /* POTENTIAL FLAW: Read data from the console */
                if (fgetws(data+dataLen, (int)(250-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgetws() */
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    else
    {
        /* FIX: Set the path as the ""system"" path */
        wcscat(data, NEW_PATH);
    }
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE427_Uncontrolled_Search_Path_Element__char_file_45.c,176108,"static void CWE427_Uncontrolled_Search_Path_Element__char_file_45Sink()
{
    char * data = CWE427_Uncontrolled_Search_Path_Element__char_file_45Data;
    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */
    PUTENV(data);
}
",1,CWE427
CWE457_Use_of_Uninitialized_Variable__wchar_t_pointer_11.c,181566,"void CWE457_Use_of_Uninitialized_Variable__wchar_t_pointer_11()
{
    wchar_t * data;
    if(globalReturnsTrue())
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    if(globalReturnsTrue())
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        printWLine(data);
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__double_pointer_43.cpp,178063,"void CWE457_Use_of_Uninitialized_Variable__double_pointer_43()
{
    double * data;
    CWE457_Use_of_Uninitialized_Variable__double_pointer_43Source(data);
    /* POTENTIAL FLAW: Use data without initializing it */
    printDoubleLine(*data);
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_17.c,180136,"void CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_17()
{
    int i,j;
    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    for(j = 0; j < 1; j++)
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__double_pointer_05.c,178000,"void CWE457_Use_of_Uninitialized_Variable__double_pointer_05()
{
    double * data;
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        printDoubleLine(*data);
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__int64_t_09.c,178124,"void CWE457_Use_of_Uninitialized_Variable__int64_t_09()
{
    int64_t data;
    if(GLOBAL_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    if(GLOBAL_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        printLongLongLine(data);
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__long_09.c,179060,"void CWE457_Use_of_Uninitialized_Variable__long_09()
{
    long data;
    if(GLOBAL_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    if(GLOBAL_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        printLongLine(data);
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__twointsclass_07.cpp,180610,"void CWE457_Use_of_Uninitialized_Variable__twointsclass_07()
{
    TwoIntsClass data;
    if(staticFive==5)
    {
        /* POTENTIAL FLAW: Don't initialize data */
        ; /* empty statement needed for some flow variants */
    }
    if(staticFive==5)
    {
        /* POTENTIAL FLAW: Use data without initializing it */
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
    }
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__double_64a.c,177352,"void CWE457_Use_of_Uninitialized_Variable__double_64a()
{
    double data;
    /* POTENTIAL FLAW: Don't initialize data */
    ; /* empty statement needed for some flow variants */
    CWE457_Use_of_Uninitialized_Variable__double_64aSink(&data);
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_63a.c,180362,"void CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_63a()
{
    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    /* POTENTIAL FLAW: Don't initialize data */
    ; /* empty statement needed for some flow variants */
    CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_63aSink(&data);
}
",1,CWE457
CWE457_Use_of_Uninitialized_Variable__char_pointer_62b.cpp,177239,"void CWE457_Use_of_Uninitialized_Variable__char_pointer_62bSource(char * &data)
{
    /* POTENTIAL FLAW: Don't initialize data */
    ; /* empty statement needed for some flow variants */
}
",1,CWE457
CWE459_Incomplete_Cleanup__wchar_t_01.c,181671,"void CWE459_Incomplete_Cleanup__wchar_t_01()
{
    {
        wchar_t * filename;
        wchar_t tmpl[] = L""CWE459_Incomplete_Cleanup__wchar_t_01XXXXXX"";
        FILE *pFile;
        /* Establish that this is a temporary file and that it should be deleted */
        filename = MKTEMP(tmpl);
        if (filename != NULL)
        {
            pFile = FOPEN(filename, L""w"");
            if (pFile != NULL)
            {
                fprintf(pFile, ""Temporary file"");
                fclose(pFile);
                /* FLAW: We don't unlink */
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_18.c,181669,"void CWE459_Incomplete_Cleanup__char_18()
{
    goto sink;
sink:
    {
        char filename[] = ""CWE459_Incomplete_Cleanup__char_18XXXXXX"";
        FILE *pFile;
        /* Establish that this is a temporary file and that it should be deleted */
        int fileDesc = MKSTEMP(filename);
        if (fileDesc != -1)
        {
            pFile = FDOPEN(fileDesc, ""w"");
            if (pFile != NULL)
            {
                fprintf(pFile, ""Temporary file"");
                fclose(pFile);
                /* FLAW: We don't unlink */
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__wchar_t_12.c,181703,"void CWE459_Incomplete_Cleanup__wchar_t_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            wchar_t * filename;
            wchar_t tmpl[] = L""CWE459_Incomplete_Cleanup__wchar_t_12XXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            filename = MKTEMP(tmpl);
            if (filename != NULL)
            {
                pFile = FOPEN(filename, L""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FLAW: We don't unlink */
                }
            }
        }
    }
    else
    {
        {
            wchar_t * filename;
            wchar_t tmpl[] = L""goodXXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            filename = MKTEMP(tmpl);
            if (filename != NULL)
            {
                pFile = FOPEN(filename, L""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FIX: Unlink the temporary file */
                    UNLINK(filename); /* EXPECTED INCIDENTAL: CWE367 TOCTOU - This POSIX API is essentially insecure by design */
                }
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_05.c,181633,"void CWE459_Incomplete_Cleanup__char_05()
{
    if(staticTrue)
    {
        {
            char filename[] = ""CWE459_Incomplete_Cleanup__char_05XXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            int fileDesc = MKSTEMP(filename);
            if (fileDesc != -1)
            {
                pFile = FDOPEN(fileDesc, ""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FLAW: We don't unlink */
                }
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__wchar_t_15.c,181711,"void CWE459_Incomplete_Cleanup__wchar_t_15()
{
    switch(6)
    {
    case 6:
    {
        wchar_t * filename;
        wchar_t tmpl[] = L""CWE459_Incomplete_Cleanup__wchar_t_15XXXXXX"";
        FILE *pFile;
        /* Establish that this is a temporary file and that it should be deleted */
        filename = MKTEMP(tmpl);
        if (filename != NULL)
        {
            pFile = FOPEN(filename, L""w"");
            if (pFile != NULL)
            {
                fprintf(pFile, ""Temporary file"");
                fclose(pFile);
                /* FLAW: We don't unlink */
            }
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_17.c,181667,"void CWE459_Incomplete_Cleanup__char_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char filename[] = ""CWE459_Incomplete_Cleanup__char_17XXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            int fileDesc = MKSTEMP(filename);
            if (fileDesc != -1)
            {
                pFile = FDOPEN(fileDesc, ""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FLAW: We don't unlink */
                }
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__wchar_t_17.c,181716,"void CWE459_Incomplete_Cleanup__wchar_t_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            wchar_t * filename;
            wchar_t tmpl[] = L""CWE459_Incomplete_Cleanup__wchar_t_17XXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            filename = MKTEMP(tmpl);
            if (filename != NULL)
            {
                pFile = FOPEN(filename, L""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FLAW: We don't unlink */
                }
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_06.c,181636,"void CWE459_Incomplete_Cleanup__char_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            char filename[] = ""CWE459_Incomplete_Cleanup__char_06XXXXXX"";
            FILE *pFile;
            /* Establish that this is a temporary file and that it should be deleted */
            int fileDesc = MKSTEMP(filename);
            if (fileDesc != -1)
            {
                pFile = FDOPEN(fileDesc, ""w"");
                if (pFile != NULL)
                {
                    fprintf(pFile, ""Temporary file"");
                    fclose(pFile);
                    /* FLAW: We don't unlink */
                }
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_01.c,181622,"void CWE459_Incomplete_Cleanup__char_01()
{
    {
        char filename[] = ""CWE459_Incomplete_Cleanup__char_01XXXXXX"";
        FILE *pFile;
        /* Establish that this is a temporary file and that it should be deleted */
        int fileDesc = MKSTEMP(filename);
        if (fileDesc != -1)
        {
            pFile = FDOPEN(fileDesc, ""w"");
            if (pFile != NULL)
            {
                fprintf(pFile, ""Temporary file"");
                fclose(pFile);
                /* FLAW: We don't unlink */
            }
        }
    }
}
",1,CWE459
CWE459_Incomplete_Cleanup__char_15.c,181662,"void CWE459_Incomplete_Cleanup__char_15()
{
    switch(6)
    {
    case 6:
    {
        char filename[] = ""CWE459_Incomplete_Cleanup__char_15XXXXXX"";
        FILE *pFile;
        /* Establish that this is a temporary file and that it should be deleted */
        int fileDesc = MKSTEMP(filename);
        if (fileDesc != -1)
        {
            pFile = FDOPEN(fileDesc, ""w"");
            if (pFile != NULL)
            {
                fprintf(pFile, ""Temporary file"");
                fclose(pFile);
                /* FLAW: We don't unlink */
            }
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE459
CWE464_Addition_of_Data_Structure_Sentinel__basic_67b.c,181863,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_67bSink(CWE464_Addition_of_Data_Structure_Sentinel__basic_67_structType myStruct)
{
    char data = myStruct.structFirst;
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_17.c,181765,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_17()
{
    int i;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        {
            char charArraySource[2];
            charArraySource[0] = (char)getc(stdin);
            charArraySource[1] = '\0';
            /* FLAW: If the character entered on the command line is not an int,
             * a null value will be returned */
            data = (char)atoi(charArraySource);
        }
    }
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_12.c,181752,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_12()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        {
            char charArraySource[2];
            charArraySource[0] = (char)getc(stdin);
            charArraySource[1] = '\0';
            /* FLAW: If the character entered on the command line is not an int,
             * a null value will be returned */
            data = (char)atoi(charArraySource);
        }
    }
    else
    {
        /* FIX: Set data to be a char */
        data = 'a';
    }
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_44.c,181801,"static void CWE464_Addition_of_Data_Structure_Sentinel__basic_44Sink(char data)
{
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_21.c,181769,"static char CWE464_Addition_of_Data_Structure_Sentinel__basic_21Source(char data)
{
    if(CWE464_Addition_of_Data_Structure_Sentinel__basic_21Static)
    {
        {
            char charArraySource[2];
            charArraySource[0] = (char)getc(stdin);
            charArraySource[1] = '\0';
            /* FLAW: If the character entered on the command line is not an int,
             * a null value will be returned */
            data = (char)atoi(charArraySource);
        }
    }
    return data;
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_73b.cpp,181875,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_73bSink(list<char> dataList)
{
    /* copy data out of dataList */
    char data = dataList.back();
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_64b.c,181851,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * dataPtr = (char *)dataVoidPtr;
    /* dereference dataPtr into data */
    char data = (*dataPtr);
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_74b.cpp,181879,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_74bSink(map<int, char> dataMap)
{
    /* copy data out of dataMap */
    char data = dataMap[2];
    {
        char charArraySink[4];
        charArraySink[0] = 'x';
        /* POTENTIAL FLAW: If data is null, the rest of the array will not be printed */
        charArraySink[1] = data;
        charArraySink[2] = 'z';
        charArraySink[3] = '\0';
        printLine(charArraySink);
    }
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_41.c,181790,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_41()
{
    char data;
    data = ' ';
    {
        char charArraySource[2];
        charArraySource[0] = (char)getc(stdin);
        charArraySource[1] = '\0';
        /* FLAW: If the character entered on the command line is not an int,
         * a null value will be returned */
        data = (char)atoi(charArraySource);
    }
    CWE464_Addition_of_Data_Structure_Sentinel__basic_41Sink(data);
}
",1,CWE464
CWE464_Addition_of_Data_Structure_Sentinel__basic_72a.cpp,181869,"void CWE464_Addition_of_Data_Structure_Sentinel__basic_72a()
{
    char data;
    vector<char> dataVector;
    data = ' ';
    {
        char charArraySource[2];
        charArraySource[0] = (char)getc(stdin);
        charArraySource[1] = '\0';
        /* FLAW: If the character entered on the command line is not an int,
         * a null value will be returned */
        data = (char)atoi(charArraySource);
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE464_Addition_of_Data_Structure_Sentinel__basic_72aSink(dataVector);
}
",1,CWE464
CWE467_Use_of_sizeof_on_Pointer_Type__short_14.c,182016,"void CWE467_Use_of_sizeof_on_Pointer_Type__short_14()
{
    if(globalFive==5)
    {
        {
            short * CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short = (short *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short = 5;
            printShortLine(*CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__short_14Short);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__char_05.c,181892,"void CWE467_Use_of_sizeof_on_Pointer_Type__char_05()
{
    if(staticTrue)
    {
        {
            char * CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char = (char *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char = 'B';
            printHexCharLine(*CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__char_05Char);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__char_16.c,181924,"void CWE467_Use_of_sizeof_on_Pointer_Type__char_16()
{
    while(1)
    {
        {
            char * CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char = (char *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char = 'B';
            printHexCharLine(*CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__char_16Char);
        }
        break;
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__int_12.c,181962,"void CWE467_Use_of_sizeof_on_Pointer_Type__int_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            int * CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int = (int *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int = 5;
            printIntLine(*CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__int_12Int);
        }
    }
    else
    {
        {
            int * goodInt = NULL;
            /* FIX: Using sizeof the data type in malloc() */
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__short_18.c,182026,"void CWE467_Use_of_sizeof_on_Pointer_Type__short_18()
{
    goto sink;
sink:
    {
        short * CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short = NULL;
        /* FLAW: Using sizeof the pointer and not the data type in malloc() */
        CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short = (short *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short));
        if (CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short == NULL) {exit(-1);}
        *CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short = 5;
        printShortLine(*CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short);
        free(CWE467_Use_of_sizeof_on_Pointer_Type__short_18Short);
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__char_17.c,181926,"void CWE467_Use_of_sizeof_on_Pointer_Type__char_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char = (char *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char = 'B';
            printHexCharLine(*CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__char_17Char);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__int_01.c,181930,"void CWE467_Use_of_sizeof_on_Pointer_Type__int_01()
{
    {
        int * CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int = NULL;
        /* FLAW: Using sizeof the pointer and not the data type in malloc() */
        CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int = (int *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int));
        if (CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int == NULL) {exit(-1);}
        *CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int = 5;
        printIntLine(*CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int);
        free(CWE467_Use_of_sizeof_on_Pointer_Type__int_01Int);
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__short_07.c,181996,"void CWE467_Use_of_sizeof_on_Pointer_Type__short_07()
{
    if(staticFive==5)
    {
        {
            short * CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short = (short *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short = 5;
            printShortLine(*CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__short_07Short);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__short_06.c,181993,"void CWE467_Use_of_sizeof_on_Pointer_Type__short_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            short * CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short = (short *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short = 5;
            printShortLine(*CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__short_06Short);
        }
    }
}
",1,CWE467
CWE467_Use_of_sizeof_on_Pointer_Type__short_08.c,181999,"void CWE467_Use_of_sizeof_on_Pointer_Type__short_08()
{
    if(staticReturnsTrue())
    {
        {
            short * CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short = NULL;
            /* FLAW: Using sizeof the pointer and not the data type in malloc() */
            CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short = (short *)malloc(sizeof(CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short));
            if (CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short == NULL) {exit(-1);}
            *CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short = 5;
            printShortLine(*CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short);
            free(CWE467_Use_of_sizeof_on_Pointer_Type__short_08Short);
        }
    }
}
",1,CWE467
CWE476_NULL_Pointer_Dereference__long_54a.c,183461,"void CWE476_NULL_Pointer_Dereference__long_54a()
{
    long * data;
    /* POTENTIAL FLAW: Set data to NULL */
    data = NULL;
    CWE476_NULL_Pointer_Dereference__long_54aSink(data);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__long_05.c,183326,"void CWE476_NULL_Pointer_Dereference__long_05()
{
    long * data;
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Set data to NULL */
        data = NULL;
    }
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Attempt to use data, which may be NULL */
        printLongLine(*data);
    }
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__class_53a.cpp,182734,"void CWE476_NULL_Pointer_Dereference__class_53a()
{
    TwoIntsClass * data;
    /* POTENTIAL FLAW: Set data to NULL */
    data = NULL;
    CWE476_NULL_Pointer_Dereference__class_53aSink_b(data);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__class_67b.cpp,182788,"void CWE476_NULL_Pointer_Dereference__class_67bSink(structType myStruct)
{
    TwoIntsClass * data = myStruct.structFirst;
    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */
    printIntLine(data->intOne);
    /* avoid memory leak - deleting a NULL pointer is a no-op in C++ so no need to check for NULL */
    delete data;
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__struct_53a.c,183720,"void CWE476_NULL_Pointer_Dereference__struct_53a()
{
    twoIntsStruct * data;
    /* POTENTIAL FLAW: Set data to NULL */
    data = NULL;
    CWE476_NULL_Pointer_Dereference__struct_53aSink(data);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__struct_03.c,183587,"void CWE476_NULL_Pointer_Dereference__struct_03()
{
    twoIntsStruct * data;
    if(5==5)
    {
        /* POTENTIAL FLAW: Set data to NULL */
        data = NULL;
    }
    if(5==5)
    {
        /* POTENTIAL FLAW: Attempt to use data, which may be NULL */
        printIntLine(data->intOne);
    }
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__wchar_t_63a.c,183969,"void CWE476_NULL_Pointer_Dereference__wchar_t_63a()
{
    wchar_t * data;
    /* POTENTIAL FLAW: Set data to NULL */
    data = NULL;
    CWE476_NULL_Pointer_Dereference__wchar_t_63aSink(&data);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__char_63b.c,182542,"void CWE476_NULL_Pointer_Dereference__char_63bSink(char * * dataPtr)
{
    char * data = *dataPtr;
    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */
    /* printLine() checks for NULL, so we cannot use it here */
    printHexCharLine(data[0]);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__int64_t_68b.c,183065,"void CWE476_NULL_Pointer_Dereference__int64_t_68bSink()
{
    int64_t * data = CWE476_NULL_Pointer_Dereference__int64_t_68bData;
    /* POTENTIAL FLAW: Attempt to use data, which may be NULL */
    printLongLongLine(*data);
}
",1,CWE476
CWE476_NULL_Pointer_Dereference__int_66a.c,183272,"void CWE476_NULL_Pointer_Dereference__int_66a()
{
    int * data;
    int * dataArray[5];
    /* POTENTIAL FLAW: Set data to NULL */
    data = NULL;
    /* put data in array */
    dataArray[2] = data;
    CWE476_NULL_Pointer_Dereference__int_66aSink(dataArray);
}
",1,CWE476
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_02.c,184074,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_02()
{
    if(1)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_02_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_06.c,184086,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_06_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_16.c,184115,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_16()
{
    while(1)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_16_helper);
        break;
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_11.c,184101,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_11()
{
    if(globalReturnsTrue())
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_11_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10.c,184098,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10()
{
    if(globalTrue)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12.c,184104,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12()
{
    if(globalReturnsTrueOrFalse())
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12_helper);
    }
    else
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_04.c,184080,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_04()
{
    if(STATIC_CONST_TRUE)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_04_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_09.c,184095,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_09_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08.c,184092,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08()
{
    if(staticReturnsTrue())
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08_helper);
    }
}
",1,CWE479
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_05.c,184083,"void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_05()
{
    if(staticTrue)
    {
        signal(SIGINT, CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_05_helper);
    }
}
",1,CWE479
CWE480_Use_of_Incorrect_Operator__basic_03.c,184126,"void CWE480_Use_of_Incorrect_Operator__basic_03()
{
    if(5==5)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_03_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_10.c,184147,"void CWE480_Use_of_Incorrect_Operator__basic_10()
{
    if(globalTrue)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_10_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_15.c,184161,"void CWE480_Use_of_Incorrect_Operator__basic_15()
{
    switch(6)
    {
    case 6:
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_15_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_18.c,184168,"void CWE480_Use_of_Incorrect_Operator__basic_18()
{
    goto sink;
sink:
    /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
    if(CWE480_Use_of_Incorrect_Operator__basic_18_helper == NULL)
    {
        printLine(""Got a NULL"");
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_11.c,184150,"void CWE480_Use_of_Incorrect_Operator__basic_11()
{
    if(globalReturnsTrue())
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_11_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_06.c,184135,"void CWE480_Use_of_Incorrect_Operator__basic_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_06_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_07.c,184138,"void CWE480_Use_of_Incorrect_Operator__basic_07()
{
    if(staticFive==5)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_07_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_04.c,184129,"void CWE480_Use_of_Incorrect_Operator__basic_04()
{
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_04_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_12.c,184153,"void CWE480_Use_of_Incorrect_Operator__basic_12()
{
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_12_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
    else
    {
        /* FIX: add () to function call */
        if(CWE480_Use_of_Incorrect_Operator__basic_12_helper() == NULL) /* this will sometimes be true (depending on the rand() in CWE480_Use_of_Incorrect_Operator__basic_12_helper) */
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE480_Use_of_Incorrect_Operator__basic_13.c,184155,"void CWE480_Use_of_Incorrect_Operator__basic_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: This will never be true becuase the () was omitted.  Also INCIDENTAL CWE 570 Expression Is Always False */
        if(CWE480_Use_of_Incorrect_Operator__basic_13_helper == NULL)
        {
            printLine(""Got a NULL"");
        }
    }
}
",1,CWE480
CWE511_Logic_Time_Bomb__counter_15.c,184655,"void CWE511_Logic_Time_Bomb__counter_15()
{
    switch(6)
    {
    case 6:
    {
        int count = 0;
        do
        {
            /* FLAW: If a counter reaches a certain value, delete a file */
            if (count == COUNT_CHECK)
            {
                UNLINK(""important_file.txt"");
            }
            count++;
        }
        while(1 == 1);   /* infinite loop */
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__rand_15.c,184704,"void CWE511_Logic_Time_Bomb__rand_15()
{
    switch(6)
    {
    case 6:
        srand((unsigned)time(NULL));
        /* FLAW: If a certain number, delete a file */
        if (rand() == NUM_CHECK)
        {
            UNLINK(""important_file.txt"");
        }
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__w32CompareFileTime_01.c,184762,"void CWE511_Logic_Time_Bomb__w32CompareFileTime_01()
{
    {
        SYSTEMTIME setTime, currentTime;
        FILETIME setTimeAsFileTime, currentTimeAsFileTime;
        /* Jan 1, 2008 12:00:00 PM */
        setTime.wYear         = 2008; /* Year */
        setTime.wMonth        = 1;    /* January */
        setTime.wDayOfWeek    = 0;    /* Ignored */
        setTime.wDay          = 1;    /* The first of the month */
        setTime.wHour         = 12;   /* 12 PM */
        setTime.wMinute       = 0;    /* 0 minutes into the hour */
        setTime.wSecond       = 0;    /* 0 seconds into the minute */
        setTime.wMilliseconds = 0;    /* 0 milliseconds into the second */
        GetSystemTime(&currentTime);
        /* Must convert to FILETIME for comparison */
        SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);
        SystemTimeToFileTime(&setTime, &setTimeAsFileTime);
        /* FLAW: After a certain date, delete a file */
        if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)
        {
            UNLINK(""important_file.txt"");
        }
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__rand_18.c,184711,"void CWE511_Logic_Time_Bomb__rand_18()
{
    goto sink;
sink:
    srand((unsigned)time(NULL));
    /* FLAW: If a certain number, delete a file */
    if (rand() == NUM_CHECK)
    {
        UNLINK(""important_file.txt"");
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__rand_17.c,184709,"void CWE511_Logic_Time_Bomb__rand_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        srand((unsigned)time(NULL));
        /* FLAW: If a certain number, delete a file */
        if (rand() == NUM_CHECK)
        {
            UNLINK(""important_file.txt"");
        }
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__time_18.c,184760,"void CWE511_Logic_Time_Bomb__time_18()
{
    goto sink;
sink:
    {
        time_t currentTime;
        /* FLAW: After a certain date, delete a file */
        time(&currentTime);
        if (currentTime > TIME_CHECK)
        {
            UNLINK(""important_file.txt"");
        }
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__time_16.c,184756,"void CWE511_Logic_Time_Bomb__time_16()
{
    while(1)
    {
        {
            time_t currentTime;
            /* FLAW: After a certain date, delete a file */
            time(&currentTime);
            if (currentTime > TIME_CHECK)
            {
                UNLINK(""important_file.txt"");
            }
        }
        break;
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__w32CompareFileTime_12.c,184794,"void CWE511_Logic_Time_Bomb__w32CompareFileTime_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            SYSTEMTIME setTime, currentTime;
            FILETIME setTimeAsFileTime, currentTimeAsFileTime;
            /* Jan 1, 2008 12:00:00 PM */
            setTime.wYear         = 2008; /* Year */
            setTime.wMonth        = 1;    /* January */
            setTime.wDayOfWeek    = 0;    /* Ignored */
            setTime.wDay          = 1;    /* The first of the month */
            setTime.wHour         = 12;   /* 12 PM */
            setTime.wMinute       = 0;    /* 0 minutes into the hour */
            setTime.wSecond       = 0;    /* 0 seconds into the minute */
            setTime.wMilliseconds = 0;    /* 0 milliseconds into the second */
            GetSystemTime(&currentTime);
            /* Must convert to FILETIME for comparison */
            SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);
            SystemTimeToFileTime(&setTime, &setTimeAsFileTime);
            /* FLAW: After a certain date, delete a file */
            if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)
            {
                UNLINK(""important_file.txt"");
            }
        }
    }
    else
    {
        {
            SYSTEMTIME setTime, currentTime;
            FILETIME setTimeAsFileTime, currentTimeAsFileTime;
            /* Jan 1, 2008 12:00:00 PM */
            setTime.wYear         = 2008; /* Year */
            setTime.wMonth        = 1;    /* January */
            setTime.wDayOfWeek    = 0;    /* Ignored */
            setTime.wDay          = 1;    /* The first of the month */
            setTime.wHour         = 12;   /* 12 PM */
            setTime.wMinute       = 0;    /* 0 minutes into the hour */
            setTime.wSecond       = 0;    /* 0 seconds into the minute */
            setTime.wMilliseconds = 0;    /* 0 milliseconds into the second */
            GetSystemTime(&currentTime);
            /* Must convert to FILETIME for comparison */
            SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);
            SystemTimeToFileTime(&setTime, &setTimeAsFileTime);
            /* FIX: After a certain date, print to the console */
            if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)
            {
                printLine(""Happy New Year!"");
            }
        }
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__time_01.c,184713,"void CWE511_Logic_Time_Bomb__time_01()
{
    {
        time_t currentTime;
        /* FLAW: After a certain date, delete a file */
        time(&currentTime);
        if (currentTime > TIME_CHECK)
        {
            UNLINK(""important_file.txt"");
        }
    }
}
",1,CWE511
CWE511_Logic_Time_Bomb__time_06.c,184727,"void CWE511_Logic_Time_Bomb__time_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            time_t currentTime;
            /* FLAW: After a certain date, delete a file */
            time(&currentTime);
            if (currentTime > TIME_CHECK)
            {
                UNLINK(""important_file.txt"");
            }
        }
    }
}
",1,CWE511
CWE526_Info_Exposure_Environment_Variables__basic_15.c,184851,"void CWE526_Info_Exposure_Environment_Variables__basic_15()
{
    switch(6)
    {
    case 6:
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_13.c,184845,"void CWE526_Info_Exposure_Environment_Variables__basic_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_18.c,184858,"void CWE526_Info_Exposure_Environment_Variables__basic_18()
{
    goto sink;
sink:
    /* FLAW: environment variable exposed */
    printLine(getenv(""PATH""));
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_07.c,184828,"void CWE526_Info_Exposure_Environment_Variables__basic_07()
{
    if(staticFive==5)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_12.c,184843,"void CWE526_Info_Exposure_Environment_Variables__basic_12()
{
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
    else
    {
        /* FIX: error message is general */
        printLine(""Not in path"");
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_02.c,184813,"void CWE526_Info_Exposure_Environment_Variables__basic_02()
{
    if(1)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_05.c,184822,"void CWE526_Info_Exposure_Environment_Variables__basic_05()
{
    if(staticTrue)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_10.c,184837,"void CWE526_Info_Exposure_Environment_Variables__basic_10()
{
    if(globalTrue)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_11.c,184840,"void CWE526_Info_Exposure_Environment_Variables__basic_11()
{
    if(globalReturnsTrue())
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
    }
}
",1,CWE526
CWE526_Info_Exposure_Environment_Variables__basic_16.c,184854,"void CWE526_Info_Exposure_Environment_Variables__basic_16()
{
    while(1)
    {
        /* FLAW: environment variable exposed */
        printLine(getenv(""PATH""));
        break;
    }
}
",1,CWE526
CWE546_Suspicious_Comment__LATER_08.c,185223,"void CWE546_Suspicious_Comment__LATER_08()
{
    if(staticReturnsTrue())
    {
        /* FLAW: The following comment has the letters 'LATER' in it*/
        /* LATER: This comment has the letters 'LATER' in it, which is certainly
         * suspicious, because it could indicate this code is not finished.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__LATER_09.c,185226,"void CWE546_Suspicious_Comment__LATER_09()
{
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: The following comment has the letters 'LATER' in it*/
        /* LATER: This comment has the letters 'LATER' in it, which is certainly
         * suspicious, because it could indicate this code is not finished.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_12.c,185088,"void CWE546_Suspicious_Comment__BUG_12()
{
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: The following comment has the letters 'BUG' in it*/
        /* BUG: This comment has the letters 'BUG' in it, which is certainly
         * suspicious, because it could indicate this code has a BUG in it.
         */
        printLine(""Hello"");
    }
    else
    {
        /* FIX: Removed the suspicious comments */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_18.c,185103,"void CWE546_Suspicious_Comment__BUG_18()
{
    goto sink;
sink:
    /* FLAW: The following comment has the letters 'BUG' in it*/
    /* BUG: This comment has the letters 'BUG' in it, which is certainly
     * suspicious, because it could indicate this code has a BUG in it.
     */
    printLine(""Hello"");
}
",1,CWE546
CWE546_Suspicious_Comment__LATER_06.c,185217,"void CWE546_Suspicious_Comment__LATER_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: The following comment has the letters 'LATER' in it*/
        /* LATER: This comment has the letters 'LATER' in it, which is certainly
         * suspicious, because it could indicate this code is not finished.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_16.c,185099,"void CWE546_Suspicious_Comment__BUG_16()
{
    while(1)
    {
        /* FLAW: The following comment has the letters 'BUG' in it*/
        /* BUG: This comment has the letters 'BUG' in it, which is certainly
         * suspicious, because it could indicate this code has a BUG in it.
         */
        printLine(""Hello"");
        break;
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_05.c,185067,"void CWE546_Suspicious_Comment__BUG_05()
{
    if(staticTrue)
    {
        /* FLAW: The following comment has the letters 'BUG' in it*/
        /* BUG: This comment has the letters 'BUG' in it, which is certainly
         * suspicious, because it could indicate this code has a BUG in it.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_01.c,185056,"void CWE546_Suspicious_Comment__BUG_01()
{
    /* FLAW: The following comment has the letters 'BUG' in it*/
    /* BUG: This comment has the letters 'BUG' in it, which is certainly
     * suspicious, because it could indicate this code has a BUG in it.
     */
    printLine(""Hello"");
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_13.c,185090,"void CWE546_Suspicious_Comment__BUG_13()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: The following comment has the letters 'BUG' in it*/
        /* BUG: This comment has the letters 'BUG' in it, which is certainly
         * suspicious, because it could indicate this code has a BUG in it.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE546_Suspicious_Comment__BUG_04.c,185064,"void CWE546_Suspicious_Comment__BUG_04()
{
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: The following comment has the letters 'BUG' in it*/
        /* BUG: This comment has the letters 'BUG' in it, which is certainly
         * suspicious, because it could indicate this code has a BUG in it.
         */
        printLine(""Hello"");
    }
}
",1,CWE546
CWE563_Unused_Variable__unused_value_wchar_t_16.c,186899,"void CWE563_Unused_Variable__unused_value_wchar_t_16()
{
    wchar_t data;
    while(1)
    {
        /* POTENTIAL FLAW: Initialize, but do not use data */
        data = L'W';
        break;
    }
    while(1)
    {
        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */
        data = L'Z';
        printf(""%02lx\n"", data);
        break;
    }
}
",1,CWE563
CWE563_Unused_Variable__unused_value_struct_15.c,186774,"void CWE563_Unused_Variable__unused_value_struct_15()
{
    twoIntsStruct data;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Initialize, but do not use data */
        data.intOne = 0;
        data.intTwo = 0;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE563
CWE563_Unused_Variable__unused_value_char_73b.cpp,186342,"void CWE563_Unused_Variable__unused_value_char_73bSink(list<char> dataList)
{
    /* copy data out of dataList */
    char data = dataList.back();
    /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */
    data = 'Z';
    printHexCharLine(data);
}
",1,CWE563
CWE563_Unused_Variable__unused_value_int64_t_22a.c,186436,"void CWE563_Unused_Variable__unused_value_int64_t_22a()
{
    int64_t data;
    /* POTENTIAL FLAW: Initialize, but do not use data */
    data = 5LL;
    CWE563_Unused_Variable__unused_value_int64_t_22aGlobal = 1; /* true */
    CWE563_Unused_Variable__unused_value_int64_t_22aSink(data);
}
",1,CWE563
CWE563_Unused_Variable__unused_value_int_43.cpp,186568,"void CWE563_Unused_Variable__unused_value_int_43()
{
    int data;
    CWE563_Unused_Variable__unused_value_int_43Source(data);
    /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */
    data = 10;
    printIntLine(data);
}
",1,CWE563
CWE563_Unused_Variable__unused_init_variable_int_43.cpp,185523,"void CWE563_Unused_Variable__unused_init_variable_int_43()
{
    int data;
    CWE563_Unused_Variable__unused_init_variable_int_43Source(data);
    /* FLAW: Do not use the variable */
    /* do nothing */
    ; /* empty statement needed for some flow variants */
}
",1,CWE563
CWE563_Unused_Variable__unused_value_int_01.c,186471,"void CWE563_Unused_Variable__unused_value_int_01()
{
    int data;
    /* POTENTIAL FLAW: Initialize, but do not use data */
    data = 5;
    /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */
    data = 10;
    printIntLine(data);
}
",1,CWE563
CWE563_Unused_Variable__unused_uninit_variable_long_21.c,186047,"static void CWE563_Unused_Variable__unused_uninit_variable_long_21Sink(long data)
{
    if(CWE563_Unused_Variable__unused_uninit_variable_long_21Static)
    {
        /* FLAW: Do not use the variable */
        /* do nothing */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE563
CWE563_Unused_Variable__unused_init_variable_wchar_t_09.c,185715,"void CWE563_Unused_Variable__unused_init_variable_wchar_t_09()
{
    wchar_t data;
    /* POTENTIAL FLAW: Initialize, but do not use data */
    data = L'W';
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: Do not use the variable */
        /* do nothing */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE563
CWE563_Unused_Variable__unused_init_variable_struct_73a.cpp,185684,"void CWE563_Unused_Variable__unused_init_variable_struct_73a()
{
    twoIntsStruct data;
    list<twoIntsStruct> dataList;
    /* POTENTIAL FLAW: Initialize, but do not use data */
    data.intOne = 0;
    data.intTwo = 0;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE563_Unused_Variable__unused_init_variable_struct_73aSink(dataList);
}
",1,CWE563
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_17.c,186996,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_04.c,186959,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_04()
{
    if(STATIC_CONST_TRUE)
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_18.c,186998,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_18()
{
    goto sink;
sink:
    {
        /* FLAW: Assigning fixed address to pointer */
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_12.c,186983,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
    else
    {
        {
            /* FIX: Assign the pointer to a stack variable */
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_01.c,186951,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_01()
{
    {
        /* FLAW: Assigning fixed address to pointer */
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_11.c,186980,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_11()
{
    if(globalReturnsTrue())
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_16.c,186994,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_16()
{
    while(1)
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
        break;
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_08.c,186971,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_08()
{
    if(staticReturnsTrue())
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_02.c,186953,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_02()
{
    if(1)
    {
        {
            /* FLAW: Assigning fixed address to pointer */
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
    }
}
",1,CWE587
CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_15.c,186991,"void CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_15()
{
    switch(6)
    {
    case 6:
    {
        /* FLAW: Assigning fixed address to pointer */
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE587
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_45.cpp,187065,"static void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_45Sink()
{
    void * data = CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_45Data;
    /* POTENTIAL FLAW: Attempt to print a class member when data may be a non-object data type */
    printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_41.c,187191,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_41()
{
    void * data;
    twoIntsStruct dataGoodBuffer;
    int dataBadBuffer = 100;
    dataGoodBuffer.intOne = 0;
    dataGoodBuffer.intTwo = 0;
    /* FLAW: Set data to point to an int */
    data = &dataBadBuffer;
    CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_41Sink(data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_68b.c,187252,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_68bSink()
{
    void * data = CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_68bData;
    /* POTENTIAL FLAW: Attempt to print a struct when data may be a non-struct data type */
    printStructLine((twoIntsStruct *)data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54c.cpp,187091,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54cSink_c(void * data)
{
    CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54cSink_d(data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_02.c,187135,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_02()
{
    void * data;
    twoIntsStruct dataGoodBuffer;
    int dataBadBuffer = 100;
    dataGoodBuffer.intOne = 0;
    dataGoodBuffer.intTwo = 0;
    if(1)
    {
        /* FLAW: Set data to point to an int */
        data = &dataBadBuffer;
    }
    /* POTENTIAL FLAW: Attempt to print a struct when data may be a non-struct data type */
    printStructLine((twoIntsStruct *)data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_44.cpp,187062,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_44()
{
    void * data;
    /* define a function pointer */
    void (*funcPtr) (void *) = CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_44Sink;
    TwoIntsClass dataGoodBuffer;
    int dataBadBuffer = 100;
    dataGoodBuffer.intOne = 0;
    dataGoodBuffer.intTwo = 0;
    /* FLAW: Set data to point to an int */
    data = &dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_73b.cpp,187127,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_73bSink(list<void *> dataList)
{
    /* copy data out of dataList */
    void * data = dataList.back();
    /* POTENTIAL FLAW: Attempt to print a class member when data may be a non-object data type */
    printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_67a.c,187246,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_67a()
{
    void * data;
    CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_67_structType myStruct;
    twoIntsStruct dataGoodBuffer;
    int dataBadBuffer = 100;
    dataGoodBuffer.intOne = 0;
    dataGoodBuffer.intTwo = 0;
    /* FLAW: Set data to point to an int */
    data = &dataBadBuffer;
    myStruct.structFirst = data;
    CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_67aSink(myStruct);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54b.cpp,187089,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54bSink_b(void * data)
{
    CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__class_54bSink_c(data);
}
",1,CWE588
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_16.c,187176,"void CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_16()
{
    void * data;
    twoIntsStruct dataGoodBuffer;
    int dataBadBuffer = 100;
    dataGoodBuffer.intOne = 0;
    dataGoodBuffer.intTwo = 0;
    while(1)
    {
        /* FLAW: Set data to point to an int */
        data = &dataBadBuffer;
        break;
    }
    /* POTENTIAL FLAW: Attempt to print a struct when data may be a non-struct data type */
    printStructLine((twoIntsStruct *)data);
}
",1,CWE588
CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_41.cpp,191314,"void CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_41()
{
    int64_t * data;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_41Sink(data);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_33.cpp,190112,"void CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_33()
{
    char * data;
    char * &dataRef = data;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printHexCharLine(*data);
        /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */
        delete data;
    }
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_52b.cpp,187607,"void CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_52bSink_b(char * data)
{
    CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_52bSink_c(data);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_long_static_73a.cpp,192711,"void CWE590_Free_Memory_Not_on_Heap__delete_long_static_73a()
{
    long * data;
    list<long *> dataList;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE590_Free_Memory_Not_on_Heap__delete_long_static_73aSink(dataList);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_34.cpp,188119,"void CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_34()
{
    int64_t * data;
    unionType myUnion;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(data[0]);
        /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */
        delete [] data;
    }
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_74a.cpp,190055,"void CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        static wchar_t dataBuffer[100];
        wmemset(dataBuffer, L'A', 100-1); /* fill with 'A's */
        dataBuffer[100-1] = L'\0'; /* null terminate */
        data = dataBuffer;
    }
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_74aSink(dataMap);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_class_declare_41.cpp,190782,"void CWE590_Free_Memory_Not_on_Heap__delete_class_declare_41()
{
    TwoIntsClass * data;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_class_declare_41Sink(data);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_18.cpp,191303,"void CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_18()
{
    int64_t * data;
    data = NULL; /* Initialize data */
    goto source;
source:
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    printLongLongLine(*data);
    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */
    delete data;
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_72a.cpp,190047,"void CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    data = NULL; /* Initialize data */
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        static wchar_t dataBuffer[100];
        wmemset(dataBuffer, L'A', 100-1); /* fill with 'A's */
        dataBuffer[100-1] = L'\0'; /* null terminate */
        data = dataBuffer;
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE590_Free_Memory_Not_on_Heap__delete_array_wchar_t_static_72aSink(dataVector);
}
",1,CWE590
CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_15.cpp,189035,"void CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_15()
{
    long * data;
    data = NULL; /* Initialize data */
    switch(6)
    {
    case 6:
    {
        /* FLAW: data is allocated on the stack and deallocated in the BadSink */
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(data[0]);
    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */
    delete [] data;
}
",1,CWE590
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_74a.cpp,196334,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_74a()
{
    char * password;
    map<int, char *> passwordMap;
    /* Initialize Data */
    password = """";
    password = (char *)malloc(100*sizeof(char));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
    /* Put password in a map */
    passwordMap[0] = password;
    passwordMap[1] = password;
    passwordMap[2] = password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_74aSink(passwordMap);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_73a.cpp,196330,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_73a()
{
    char * password;
    list<char *> passwordList;
    /* Initialize Data */
    password = """";
    password = (char *)malloc(100*sizeof(char));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
    /* Put password in a list */
    passwordList.push_back(password);
    passwordList.push_back(password);
    passwordList.push_back(password);
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_73aSink(passwordList);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_72a.cpp,196326,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_72a()
{
    char * password;
    vector<char *> passwordVector;
    /* Initialize Data */
    password = """";
    password = (char *)malloc(100*sizeof(char));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
    /* Put password in a vector */
    passwordVector.insert(passwordVector.end(), 1, password);
    passwordVector.insert(passwordVector.end(), 1, password);
    passwordVector.insert(passwordVector.end(), 1, password);
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_72aSink(passwordVector);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_18.c,196224,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_18()
{
    char * password;
    /* Initialize Data */
    password = """";
    goto source;
source:
    password = (char *)malloc(100*sizeof(char));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
    {
        HANDLE pHandle;
        char * username = ""User"";
        char * domain = ""Domain"";
        /* Use the password in LogonUser() to establish that it is ""sensitive"" */
        if (LogonUserA(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
        /* POTENTIAL FLAW: Sensitive data possibly improperly locked */
        free(password);
    }
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_67a.c,196479,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_67a()
{
    wchar_t * password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_67_structType myStruct;
    /* Initialize Data */
    password = L"""";
    password = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    wcscpy(password, L""Password1234!"");
    myStruct.structFirst = password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_67aSink(myStruct);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67a.c,196318,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67a()
{
    char * password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67_structType myStruct;
    /* Initialize Data */
    password = """";
    password = (char *)malloc(100*sizeof(char));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
    myStruct.structFirst = password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67aSink(myStruct);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_73a.cpp,196491,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_73a()
{
    wchar_t * password;
    list<wchar_t *> passwordList;
    /* Initialize Data */
    password = L"""";
    password = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    wcscpy(password, L""Password1234!"");
    /* Put password in a list */
    passwordList.push_back(password);
    passwordList.push_back(password);
    passwordList.push_back(password);
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_73aSink(passwordList);
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_21.c,196388,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_21()
{
    wchar_t * password;
    /* Initialize Data */
    password = L"""";
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_21Static = 1; /* true */
    password = CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_21Source(password);
    {
        HANDLE pHandle;
        wchar_t * username = L""User"";
        wchar_t * domain = L""Domain"";
        /* Use the password in LogonUser() to establish that it is ""sensitive"" */
        if (LogonUserW(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
        /* POTENTIAL FLAW: Sensitive data possibly improperly locked */
        free(password);
    }
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_06.c,196352,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_06()
{
    wchar_t * password;
    /* Initialize Data */
    password = L"""";
    if(STATIC_CONST_FIVE==5)
    {
        password = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (password == NULL)
        {
            printLine(""Memory could not be allocated"");
            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        wcscpy(password, L""Password1234!"");
    }
    {
        HANDLE pHandle;
        wchar_t * username = L""User"";
        wchar_t * domain = L""Domain"";
        /* Use the password in LogonUser() to establish that it is ""sensitive"" */
        if (LogonUserW(
                    username,
                    domain,
                    password,
                    LOGON32_LOGON_NETWORK,
                    LOGON32_PROVIDER_DEFAULT,
                    &pHandle) != 0)
        {
            printLine(""User logged in successfully."");
            CloseHandle(pHandle);
        }
        else
        {
            printLine(""Unable to login."");
        }
        /* POTENTIAL FLAW: Sensitive data possibly improperly locked */
        free(password);
    }
}
",1,CWE591
CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_66a.c,196475,"void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_66a()
{
    wchar_t * password;
    wchar_t * passwordArray[5];
    /* Initialize Data */
    password = L"""";
    password = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (password == NULL)
    {
        printLine(""Memory could not be allocated"");
        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    wcscpy(password, L""Password1234!"");
    /* put password in array */
    passwordArray[2] = password;
    CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_66aSink(passwordArray);
}
",1,CWE591
CWE606_Unchecked_Loop_Condition__char_environment_01.c,197040,"void CWE606_Unchecked_Loop_Condition__char_environment_01()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        int i, n, intVariable;
        if (sscanf(data, ""%d"", &n) == 1)
        {
            /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
            intVariable = 0;
            for (i = 0; i < n; i++)
            {
                /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                intVariable++; /* avoid a dead/empty code block issue */
            }
            printIntLine(intVariable);
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__char_environment_12.c,197093,"void CWE606_Unchecked_Loop_Condition__char_environment_12()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    else
    {
        /* FIX: Set data to a number less than MAX_LOOP */
        strcpy(data, ""15"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i, n, intVariable;
            if (sscanf(data, ""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
    }
    else
    {
        {
            int i, n, intVariable;
            if (sscanf(data, ""%d"", &n) == 1)
            {
                /* FIX: limit loop iteration counts */
                if (n < MAX_LOOP)
                {
                    intVariable = 0;
                    for (i = 0; i < n; i++)
                    {
                        /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                        intVariable++; /* avoid a dead/empty code block issue */
                    }
                    printIntLine(intVariable);
                }
            }
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__char_console_16.c,196865,"void CWE606_Unchecked_Loop_Condition__char_console_16()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            /* Read input from the console */
            size_t dataLen = strlen(data);
            /* if there is room in data, read into it from the console */
            if (100-dataLen > 1)
            {
                /* POTENTIAL FLAW: Read data from the console */
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
            }
        }
        break;
    }
    while(1)
    {
        {
            int i, n, intVariable;
            if (sscanf(data, ""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
        break;
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__wchar_t_environment_15.c,198336,"void CWE606_Unchecked_Loop_Condition__wchar_t_environment_15()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i, n, intVariable;
        if (swscanf(data, L""%d"", &n) == 1)
        {
            /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
            intVariable = 0;
            for (i = 0; i < n; i++)
            {
                /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                intVariable++; /* avoid a dead/empty code block issue */
            }
            printIntLine(intVariable);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__wchar_t_file_15.c,198582,"void CWE606_Unchecked_Loop_Condition__wchar_t_file_15()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        /* Read input from a file */
        size_t dataLen = wcslen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i, n, intVariable;
        if (swscanf(data, L""%d"", &n) == 1)
        {
            /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
            intVariable = 0;
            for (i = 0; i < n; i++)
            {
                /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                intVariable++; /* avoid a dead/empty code block issue */
            }
            printIntLine(intVariable);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__char_connect_socket_72b.cpp,196779,"void CWE606_Unchecked_Loop_Condition__char_connect_socket_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        int i, n, intVariable;
        if (sscanf(data, ""%d"", &n) == 1)
        {
            /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
            intVariable = 0;
            for (i = 0; i < n; i++)
            {
                /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                intVariable++; /* avoid a dead/empty code block issue */
            }
            printIntLine(intVariable);
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__wchar_t_file_06.c,198539,"void CWE606_Unchecked_Loop_Condition__wchar_t_file_06()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* Read input from a file */
            size_t dataLen = wcslen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        /* Restore NUL terminator if fgetws fails */
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i, n, intVariable;
            if (swscanf(data, L""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__wchar_t_environment_12.c,198323,"void CWE606_Unchecked_Loop_Condition__wchar_t_environment_12()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    else
    {
        /* FIX: Set data to a number less than MAX_LOOP */
        wcscpy(data, L""15"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i, n, intVariable;
            if (swscanf(data, L""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
    }
    else
    {
        {
            int i, n, intVariable;
            if (swscanf(data, L""%d"", &n) == 1)
            {
                /* FIX: limit loop iteration counts */
                if (n < MAX_LOOP)
                {
                    intVariable = 0;
                    for (i = 0; i < n; i++)
                    {
                        /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                        intVariable++; /* avoid a dead/empty code block issue */
                    }
                    printIntLine(intVariable);
                }
            }
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__char_listen_socket_34.c,197637,"void CWE606_Unchecked_Loop_Condition__char_listen_socket_34()
{
    char * data;
    CWE606_Unchecked_Loop_Condition__char_listen_socket_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            /* POTENTIAL FLAW: Read data using a listen socket */
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed */
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            /* Append null terminator */
            data[dataLen + recvResult / sizeof(char)] = '\0';
            /* Eliminate CRLF */
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            int i, n, intVariable;
            if (sscanf(data, ""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
    }
}
",1,CWE606
CWE606_Unchecked_Loop_Condition__char_file_06.c,197309,"void CWE606_Unchecked_Loop_Condition__char_file_06()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* Read input from a file */
            size_t dataLen = strlen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        /* Restore NUL terminator if fgets fails */
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i, n, intVariable;
            if (sscanf(data, ""%d"", &n) == 1)
            {
                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */
                intVariable = 0;
                for (i = 0; i < n; i++)
                {
                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */
                    intVariable++; /* avoid a dead/empty code block issue */
                }
                printIntLine(intVariable);
            }
        }
    }
}
",1,CWE606
CWE617_Reachable_Assertion__fixed_45.c,199465,"void CWE617_Reachable_Assertion__fixed_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a value less than the assert value */
    data = ASSERT_VALUE-1;
    CWE617_Reachable_Assertion__fixed_45Data = data;
    CWE617_Reachable_Assertion__fixed_45Sink();
}
",1,CWE617
CWE617_Reachable_Assertion__fixed_74a.cpp,199536,"void CWE617_Reachable_Assertion__fixed_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a value less than the assert value */
    data = ASSERT_VALUE-1;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE617_Reachable_Assertion__fixed_74aSink(dataMap);
}
",1,CWE617
CWE617_Reachable_Assertion__rand_63a.c,199987,"void CWE617_Reachable_Assertion__rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE617_Reachable_Assertion__rand_63aSink(&data);
}
",1,CWE617
CWE617_Reachable_Assertion__fgets_22a.c,199273,"void CWE617_Reachable_Assertion__fgets_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    CWE617_Reachable_Assertion__fgets_22aGlobal = 1; /* true */
    data = CWE617_Reachable_Assertion__fgets_22aSource(data);
    /* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */
    assert(data > ASSERT_VALUE);
}
",1,CWE617
CWE617_Reachable_Assertion__fixed_72a.cpp,199528,"void CWE617_Reachable_Assertion__fixed_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* FLAW: Use a value less than the assert value */
    data = ASSERT_VALUE-1;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE617_Reachable_Assertion__fixed_72aSink(dataVector);
}
",1,CWE617
CWE617_Reachable_Assertion__rand_64a.c,199991,"void CWE617_Reachable_Assertion__rand_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE617_Reachable_Assertion__rand_64aSink(&data);
}
",1,CWE617
CWE617_Reachable_Assertion__rand_45.c,199948,"void CWE617_Reachable_Assertion__rand_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE617_Reachable_Assertion__rand_45Data = data;
    CWE617_Reachable_Assertion__rand_45Sink();
}
",1,CWE617
CWE617_Reachable_Assertion__fgets_43.cpp,199296,"void CWE617_Reachable_Assertion__fgets_43()
{
    int data;
    /* Initialize data */
    data = -1;
    CWE617_Reachable_Assertion__fgets_43Source(data);
    /* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */
    assert(data > ASSERT_VALUE);
}
",1,CWE617
CWE617_Reachable_Assertion__fscanf_67a.c,199681,"void CWE617_Reachable_Assertion__fscanf_67a()
{
    int data;
    CWE617_Reachable_Assertion__fscanf_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
    CWE617_Reachable_Assertion__fscanf_67aSink(myStruct);
}
",1,CWE617
CWE617_Reachable_Assertion__fscanf_68b.c,199687,"void CWE617_Reachable_Assertion__fscanf_68bSink()
{
    int data = CWE617_Reachable_Assertion__fscanf_68bData;
    /* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */
    assert(data > ASSERT_VALUE);
}
",1,CWE617
CWE665_Improper_Initialization__char_cat_63a.c,200246,"void CWE665_Improper_Initialization__char_cat_63a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Do not initialize data */
    ; /* empty statement needed for some flow variants */
    CWE665_Improper_Initialization__char_cat_63aSink(&data);
}
",1,CWE665
CWE665_Improper_Initialization__wchar_t_cat_72a.cpp,200592,"void CWE665_Improper_Initialization__wchar_t_cat_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Do not initialize data */
    ; /* empty statement needed for some flow variants */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE665_Improper_Initialization__wchar_t_cat_72aSink(dataVector);
}
",1,CWE665
CWE665_Improper_Initialization__char_ncat_17.c,200327,"void CWE665_Improper_Initialization__char_ncat_17()
{
    int i;
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Do not initialize data */
        ; /* empty statement needed for some flow variants */
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        sourceLen = strlen(source);
        /* POTENTIAL FLAW: If data is not initialized properly, strncat() may not function correctly */
        strncat(data, source, sourceLen);
        printLine(data);
    }
}
",1,CWE665
CWE665_Improper_Initialization__wchar_t_ncat_54a.c,200711,"void CWE665_Improper_Initialization__wchar_t_ncat_54a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Do not initialize data */
    ; /* empty statement needed for some flow variants */
    CWE665_Improper_Initialization__wchar_t_ncat_54aSink(data);
}
",1,CWE665
CWE665_Improper_Initialization__char_cat_16.c,200164,"void CWE665_Improper_Initialization__char_cat_16()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        /* FLAW: Do not initialize data */
        ; /* empty statement needed for some flow variants */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: If data is not initialized properly, strcat() may not function correctly */
        strcat(data, source);
        printLine(data);
    }
}
",1,CWE665
CWE665_Improper_Initialization__char_ncat_06.c,200296,"void CWE665_Improper_Initialization__char_ncat_06()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Do not initialize data */
        ; /* empty statement needed for some flow variants */
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        sourceLen = strlen(source);
        /* POTENTIAL FLAW: If data is not initialized properly, strncat() may not function correctly */
        strncat(data, source, sourceLen);
        printLine(data);
    }
}
",1,CWE665
CWE665_Improper_Initialization__char_ncat_21.c,200331,"static char * CWE665_Improper_Initialization__char_ncat_21Source(char * data)
{
    if(CWE665_Improper_Initialization__char_ncat_21Static)
    {
        /* FLAW: Do not initialize data */
        ; /* empty statement needed for some flow variants */
    }
    return data;
}
",1,CWE665
CWE665_Improper_Initialization__char_cat_73a.cpp,200274,"void CWE665_Improper_Initialization__char_cat_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Do not initialize data */
    ; /* empty statement needed for some flow variants */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE665_Improper_Initialization__char_cat_73aSink(dataList);
}
",1,CWE665
CWE665_Improper_Initialization__char_ncat_32.c,200345,"void CWE665_Improper_Initialization__char_ncat_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100];
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FLAW: Do not initialize data */
        ; /* empty statement needed for some flow variants */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            size_t sourceLen;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            sourceLen = strlen(source);
            /* POTENTIAL FLAW: If data is not initialized properly, strncat() may not function correctly */
            strncat(data, source, sourceLen);
            printLine(data);
        }
    }
}
",1,CWE665
CWE665_Improper_Initialization__wchar_t_ncat_73b.cpp,200759,"void CWE665_Improper_Initialization__wchar_t_ncat_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        size_t sourceLen;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        sourceLen = wcslen(source);
        /* POTENTIAL FLAW: If data is not initialized properly, wcsncat() may not function correctly */
        wcsncat(data, source, sourceLen);
        printWLine(data);
    }
}
",1,CWE665
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_63a.cpp,201248,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_63a()
{
    list<int>  data;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_63aSink(&data);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_73a.cpp,201290,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_73a()
{
    list<int>  data;
    list<list<int> > dataList;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_73aSink(dataList);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54d.cpp,201230,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54dSink_d(list<int>  data)
{
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54dSink_e(data);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54b.cpp,201224,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54bSink_b(list<int>  data)
{
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_54bSink_c(data);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_68a.cpp,201278,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_68a()
{
    list<int>  data;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_68aData = data;
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_68aSink();
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_12.cpp,201112,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_12()
{
    list<int>  data;
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Insert a zero into the list */
        data.push_back(100);
        data.push_back(0);
    }
    else
    {
        /* FIX: Insert non-zero values into the list */
        data.push_back(100);
        data.push_back(200);
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            list<int> ::iterator i;
            cout << ""The list contains: "";
            for( i = data.begin(); i != data.end(); i++)
            {
                if (!*i)
                {
                    data.clear();
                }
                /* POTENTIAL FLAW: Dereference the iterator, which may be invalid if data is cleared */
                cout << "" "" << *i;
            }
            cout << endl;
        }
    }
    else
    {
        {
            list<int> ::iterator i;
            cout << ""The list contains: "";
            for( i = data.begin(); i != data.end(); i++)
            {
                /* FIX: Do not make any attempt to clear the list */
                cout << "" "" << *i;
            }
            cout << endl;
        }
    }
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_72a.cpp,201284,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_72a()
{
    list<int>  data;
    vector<list<int> > dataVector;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_72aSink(dataVector);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_45.cpp,201189,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_45()
{
    list<int>  data;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_45Data = data;
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_45Sink();
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_67a.cpp,201272,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_67a()
{
    list<int>  data;
    structType myStruct;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    myStruct.structFirst = data;
    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_67aSink(myStruct);
}
",1,CWE672
CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_44.cpp,201183,"void CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_44()
{
    list<int>  data;
    /* define a function pointer */
    void (*funcPtr) (list<int> ) = CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_44Sink;
    /* POTENTIAL FLAW: Insert a zero into the list */
    data.push_back(100);
    data.push_back(0);
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE672
CWE675_Duplicate_Operations_on_Resource__fopen_65a.c,201514,"void CWE675_Duplicate_Operations_on_Resource__fopen_65a()
{
    FILE * data;
    /* define a function pointer */
    void (*funcPtr) (FILE *) = CWE675_Duplicate_Operations_on_Resource__fopen_65aSink;
    data = NULL; /* Initialize data */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    /* POTENTIAL FLAW: Close the file in the source */
    fclose(data);
    /* use the function pointer */
    funcPtr(data);
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__freopen_68a.c,201778,"void CWE675_Duplicate_Operations_on_Resource__freopen_68a()
{
    FILE * data;
    data = NULL; /* Initialize data */
    data = freopen(""BadSource_freopen.txt"",""w+"",stdin);
    /* POTENTIAL FLAW: Close the file in the source */
    fclose(data);
    CWE675_Duplicate_Operations_on_Resource__freopen_68aData = data;
    CWE675_Duplicate_Operations_on_Resource__freopen_68aSink();
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__freopen_22b.c,201648,"void CWE675_Duplicate_Operations_on_Resource__freopen_22bSink(FILE * data)
{
    if(CWE675_Duplicate_Operations_on_Resource__freopen_22bGlobal)
    {
        /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
        fclose(data);
    }
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__open_45.c,201934,"static void CWE675_Duplicate_Operations_on_Resource__open_45Sink()
{
    int data = CWE675_Duplicate_Operations_on_Resource__open_45Data;
    /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
    CLOSE(data);
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__w32CreateFile_33.cpp,202150,"void CWE675_Duplicate_Operations_on_Resource__w32CreateFile_33()
{
    HANDLE data;
    HANDLE &dataRef = data;
    data = INVALID_HANDLE_VALUE; /* Initialize data */
    data = CreateFile(""BadSource_w32CreateFile.txt"",
                      (GENERIC_WRITE|GENERIC_READ),
                      0,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    /* POTENTIAL FLAW: Close the file in the source */
    CloseHandle(data);
    {
        HANDLE data = dataRef;
        /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
        CloseHandle(data);
    }
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__open_03.c,201810,"void CWE675_Duplicate_Operations_on_Resource__open_03()
{
    int data;
    data = -1; /* Initialize data */
    if(5==5)
    {
        data = OPEN(""BadSource_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        /* POTENTIAL FLAW: Close the file in the source */
        CLOSE(data);
    }
    if(5==5)
    {
        /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
        CLOSE(data);
    }
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__fopen_45.c,201442,"static void CWE675_Duplicate_Operations_on_Resource__fopen_45Sink()
{
    FILE * data = CWE675_Duplicate_Operations_on_Resource__fopen_45Data;
    /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
    fclose(data);
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__freopen_74b.cpp,201799,"void CWE675_Duplicate_Operations_on_Resource__freopen_74bSink(map<int, FILE *> dataMap)
{
    /* copy data out of dataMap */
    FILE * data = dataMap[2];
    /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
    fclose(data);
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__open_63b.c,201997,"void CWE675_Duplicate_Operations_on_Resource__open_63bSink(int * dataPtr)
{
    int data = *dataPtr;
    /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
    CLOSE(data);
}
",1,CWE675
CWE675_Duplicate_Operations_on_Resource__open_04.c,201815,"void CWE675_Duplicate_Operations_on_Resource__open_04()
{
    int data;
    data = -1; /* Initialize data */
    if(STATIC_CONST_TRUE)
    {
        data = OPEN(""BadSource_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        /* POTENTIAL FLAW: Close the file in the source */
        CLOSE(data);
    }
    if(STATIC_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */
        CLOSE(data);
    }
}
",1,CWE675
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_74a.cpp,202822,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* FLAW: Set data to a value that will cause an integer overflow in the call to malloc() in the sink */
    data = INT_MAX / 2 + 2; /* 1073741825 */
    /* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however
     * the for loop will attempt to access indices 0-1073741824 */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_74aSink(dataMap);
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_73b.cpp,202498,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_73bSink(list<int> dataList)
{
    /* copy data out of dataList */
    int data = dataList.back();
    {
        size_t i;
        int *intPointer;
        /* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value
         * so that the for loop doing the initialization causes a buffer overflow */
        intPointer = (int*)malloc(data * sizeof(int));
        if (intPointer == NULL) {exit(-1);}
        for (i = 0; i < (size_t)data; i++)
        {
            intPointer[i] = 0; /* Potentially writes beyond the boundary of intPointer */
        }
        printIntLine(intPointer[0]);
        free(intPointer);
    }
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_53c.cpp,204056,"void CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_53cSink_c(int data)
{
    CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_53cSink_d(data);
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22b.c,202723,"int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22bSource(int data)
{
    if(CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22bGlobal)
    {
        /* FLAW: Set data to a value that will cause an integer overflow in the call to malloc() in the sink */
        data = INT_MAX / 2 + 2; /* 1073741825 */
        /* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however
         * the for loop will attempt to access indices 0-1073741824 */
    }
    return data;
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51a.c,203237,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51aSink(data);
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_21.cpp,204163,"static int CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_21Source(int data)
{
    if(CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_21Static)
    {
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
    }
    return data;
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54a.c,203255,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54aSink(data);
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66a.c,202802,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* FLAW: Set data to a value that will cause an integer overflow in the call to malloc() in the sink */
    data = INT_MAX / 2 + 2; /* 1073741825 */
    /* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however
     * the for loop will attempt to access indices 0-1073741824 */
    /* put data in array */
    dataArray[2] = data;
    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66aSink(dataArray);
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_03.c,202670,"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_03()
{
    int data;
    /* Initialize data */
    data = -1;
    if(5==5)
    {
        /* FLAW: Set data to a value that will cause an integer overflow in the call to malloc() in the sink */
        data = INT_MAX / 2 + 2; /* 1073741825 */
        /* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however
         * the for loop will attempt to access indices 0-1073741824 */
    }
    {
        size_t i;
        int *intPointer;
        /* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value
         * so that the for loop doing the initialization causes a buffer overflow */
        intPointer = (int*)malloc(data * sizeof(int));
        if (intPointer == NULL) {exit(-1);}
        for (i = 0; i < (size_t)data; i++)
        {
            intPointer[i] = 0; /* Potentially writes beyond the boundary of intPointer */
        }
        printIntLine(intPointer[0]);
        free(intPointer);
    }
}
",1,CWE680
CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_63a.cpp,204239,"void CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_63aSink(&data);
}
",1,CWE680
CWE690_NULL_Deref_From_Return__wchar_t_realloc_45.c,207517,"static void CWE690_NULL_Deref_From_Return__wchar_t_realloc_45Sink()
{
    wchar_t * data = CWE690_NULL_Deref_From_Return__wchar_t_realloc_45Data;
    /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */
    wcscpy(data, L""Initialize"");
    printWLine(data);
    free(data);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__struct_malloc_34.c,206694,"void CWE690_NULL_Deref_From_Return__struct_malloc_34()
{
    twoIntsStruct * data;
    CWE690_NULL_Deref_From_Return__struct_malloc_34_unionType myUnion;
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
    }
}
",1,CWE690
CWE690_NULL_Deref_From_Return__struct_realloc_41.c,206858,"void CWE690_NULL_Deref_From_Return__struct_realloc_41()
{
    twoIntsStruct * data;
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_realloc_41Sink(data);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__int_malloc_22a.c,205716,"void CWE690_NULL_Deref_From_Return__int_malloc_22a()
{
    int * data;
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (int *)malloc(1*sizeof(int));
    CWE690_NULL_Deref_From_Return__int_malloc_22aGlobal = 1; /* true */
    CWE690_NULL_Deref_From_Return__int_malloc_22aSink(data);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__int64_t_calloc_21.c,205066,"static void CWE690_NULL_Deref_From_Return__int64_t_calloc_21Sink(int64_t * data)
{
    if(CWE690_NULL_Deref_From_Return__int64_t_calloc_21Static)
    {
        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
    }
}
",1,CWE690
CWE690_NULL_Deref_From_Return__struct_calloc_21.c,206516,"void CWE690_NULL_Deref_From_Return__struct_calloc_21()
{
    twoIntsStruct * data;
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_calloc_21Static = 1; /* true */
    CWE690_NULL_Deref_From_Return__struct_calloc_21Sink(data);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__w32_wfopen_15.c,206989,"void CWE690_NULL_Deref_From_Return__w32_wfopen_15()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    /* POTENTIAL FLAW: Open a file without checking the return value for NULL */
    data = _wfopen(L""file.txt"", L""w+"");
    switch(6)
    {
    case 6:
        /* FLAW: if the fopen failed, data will be NULL here */
        fclose(data);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE690
CWE690_NULL_Deref_From_Return__wchar_t_realloc_66a.c,207569,"void CWE690_NULL_Deref_From_Return__wchar_t_realloc_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));
    /* put data in array */
    dataArray[2] = data;
    CWE690_NULL_Deref_From_Return__wchar_t_realloc_66aSink(dataArray);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__int_calloc_72a.cpp,205649,"void CWE690_NULL_Deref_From_Return__int_calloc_72a()
{
    int * data;
    vector<int *> dataVector;
    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (int *)calloc(1, sizeof(int));
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE690_NULL_Deref_From_Return__int_calloc_72aSink(dataVector);
}
",1,CWE690
CWE690_NULL_Deref_From_Return__fopen_61a.c,204973,"void CWE690_NULL_Deref_From_Return__fopen_61a()
{
    FILE * data;
    /* Initialize data */
    data = NULL;
    data = CWE690_NULL_Deref_From_Return__fopen_61aSource(data);
    /* FLAW: if the fopen failed, data will be NULL here */
    fclose(data);
}
",1,CWE690
CWE758_Undefined_Behavior__double_pointer_alloca_use_15.c,208025,"void CWE758_Undefined_Behavior__double_pointer_alloca_use_15()
{
    switch(6)
    {
    case 6:
    {
        double * * pointer = (double * *)ALLOCA(sizeof(double *));
        double * data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        printDoubleLine(*data);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE758
CWE758_Undefined_Behavior__int_new_use_12.cpp,208409,"void CWE758_Undefined_Behavior__int_new_use_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            int * pointer = new int;
            int data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
            delete pointer;
            printIntLine(data);
        }
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; /* FIX: Assign a value to the thing pointed to by pointer */
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
    }
}
",1,CWE758
CWE758_Undefined_Behavior__struct_malloc_use_01.c,208771,"void CWE758_Undefined_Behavior__struct_malloc_use_01()
{
    {
        twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (pointer == NULL) {exit(-1);}
        twoIntsStruct data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        free(pointer);
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
    }
}
",1,CWE758
CWE758_Undefined_Behavior__int64_t_alloca_use_16.c,208175,"void CWE758_Undefined_Behavior__int64_t_alloca_use_16()
{
    while(1)
    {
        {
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            int64_t data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
            printLongLongLine(data);
        }
        break;
    }
}
",1,CWE758
CWE758_Undefined_Behavior__wchar_t_pointer_alloca_use_15.c,209065,"void CWE758_Undefined_Behavior__wchar_t_pointer_alloca_use_15()
{
    switch(6)
    {
    case 6:
    {
        wchar_t * * pointer = (wchar_t * *)ALLOCA(sizeof(wchar_t *));
        wchar_t * data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        printWLine(data);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE758
CWE758_Undefined_Behavior__wchar_t_pointer_malloc_use_01.c,209074,"void CWE758_Undefined_Behavior__wchar_t_pointer_malloc_use_01()
{
    {
        wchar_t * * pointer = (wchar_t * *)malloc(sizeof(wchar_t *));
        if (pointer == NULL) {exit(-1);}
        wchar_t * data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        free(pointer);
        printWLine(data);
    }
}
",1,CWE758
CWE758_Undefined_Behavior__char_pointer_malloc_use_01.c,207789,"void CWE758_Undefined_Behavior__char_pointer_malloc_use_01()
{
    {
        char * * pointer = (char * *)malloc(sizeof(char *));
        if (pointer == NULL) {exit(-1);}
        char * data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        free(pointer);
        printLine(data);
    }
}
",1,CWE758
CWE758_Undefined_Behavior__w32_bare_return_01.c,209016,"static int CWE758_Undefined_Behavior__w32_bare_return_01_helper(void)
{
    /* FLAW: bare return in a function with an explicit return type of int */
    return;
}
",1,CWE758
CWE758_Undefined_Behavior__class_new_use_18.cpp,207934,"void CWE758_Undefined_Behavior__class_new_use_18()
{
    goto sink;
sink:
    {
        TwoIntsClass * pointer = new TwoIntsClass;
        TwoIntsClass data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
        delete pointer;
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
    }
}
",1,CWE758
CWE758_Undefined_Behavior__int_new_use_03.cpp,208382,"void CWE758_Undefined_Behavior__int_new_use_03()
{
    if(5==5)
    {
        {
            int * pointer = new int;
            int data = *pointer; /* FLAW: the value pointed to by pointer is undefined */
            delete pointer;
            printIntLine(data);
        }
    }
}
",1,CWE758
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_74a.cpp,210617,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_environment_74aSink(dataMap);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_72a.cpp,209643,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_72a()
{
    char * data;
    vector<char *> dataVector;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0';
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_72aSink(dataVector);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_67b.c,209798,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_67bSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the
     * memory block not at the start of the buffer */
    for (; *data != '\0'; data++)
    {
        if (*data == SEARCH_CHAR)
        {
            printLine(""We have a match!"");
            break;
        }
    }
    free(data);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_21.c,210832,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_21()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    /* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */
    wcscpy(data, BAD_SOURCE_FIXED_STRING);
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_21Static = 1; /* true */
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_21Sink(data);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_73a.cpp,210935,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    /* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */
    wcscpy(data, BAD_SOURCE_FIXED_STRING);
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_73aSink(dataList);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_67a.c,210923,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_67a()
{
    wchar_t * data;
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_67_structType myStruct;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    /* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */
    wcscpy(data, BAD_SOURCE_FIXED_STRING);
    myStruct.structFirst = data;
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_67aSink(myStruct);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_43.cpp,209411,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_43()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0';
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_43Source(data);
    /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the
     * memory block not at the start of the buffer */
    for (; *data != '\0'; data++)
    {
        if (*data == SEARCH_CHAR)
        {
            printLine(""We have a match!"");
            break;
        }
    }
    free(data);
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_13.c,210816,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_fixed_string_13()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    /* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */
    wcscpy(data, BAD_SOURCE_FIXED_STRING);
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the
         * memory block not at the start of the buffer */
        for (; *data != L'\0'; data++)
        {
            if (*data == SEARCH_CHAR)
            {
                printLine(""We have a match!"");
                break;
            }
        }
        free(data);
    }
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_34.c,211010,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_34()
{
    wchar_t * data;
    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_34_unionType myUnion;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0';
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            /* POTENTIAL FLAW: Read data using a listen socket */
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed */
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            /* Append null terminator */
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            /* Eliminate CRLF */
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the
         * memory block not at the start of the buffer */
        for (; *data != L'\0'; data++)
        {
            if (*data == SEARCH_CHAR)
            {
                printLine(""We have a match!"");
                break;
            }
        }
        free(data);
    }
}
",1,CWE761
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_74b.cpp,209814,"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the
     * memory block not at the start of the buffer */
    for (; *data != '\0'; data++)
    {
        if (*data == SEARCH_CHAR)
        {
            printLine(""We have a match!"");
            break;
        }
    }
    free(data);
}
",1,CWE761
CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_43.cpp,221557,"void CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_43()
{
    char * data;
    /* Initialize data*/
    data = NULL;
    CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_43Source(data);
    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
     * require a call to delete [] to deallocate the memory */
    delete data;
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_45.cpp,221568,"static void CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_45Sink()
{
    char * data = CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_45Data;
    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
     * require a call to delete [] to deallocate the memory */
    delete data;
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__delete_char_malloc_33.cpp,216618,"void CWE762_Mismatched_Memory_Management_Routines__delete_char_malloc_33()
{
    char * data;
    char * &dataRef = data;
    /* Initialize data*/
    data = NULL;
    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    {
        char * data = dataRef;
        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
         * require a call to free() to deallocate the memory */
        delete data;
    }
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__new_free_wchar_t_14.cpp,228139,"void CWE762_Mismatched_Memory_Management_Routines__new_free_wchar_t_14()
{
    wchar_t * data;
    /* Initialize data*/
    data = NULL;
    if(globalFive==5)
    {
        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */
        data = new wchar_t;
    }
    if(globalFive==5)
    {
        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may
         * require a call to delete to deallocate the memory */
        free(data);
    }
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__strdup_delete_array_wchar_t_67a.cpp,228786,"void CWE762_Mismatched_Memory_Management_Routines__strdup_delete_array_wchar_t_67a()
{
    wchar_t * data;
    structType myStruct;
    /* Initialize data*/
    data = NULL;
    {
        wchar_t myString[] = L""myString"";
        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */
        data = wcsdup(myString);
    }
    myStruct.structFirst = data;
    CWE762_Mismatched_Memory_Management_Routines__strdup_delete_array_wchar_t_67aSink(myStruct);
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__delete_class_malloc_45.cpp,217386,"static void CWE762_Mismatched_Memory_Management_Routines__delete_class_malloc_45Sink()
{
    TwoIntsClass * data = CWE762_Mismatched_Memory_Management_Routines__delete_class_malloc_45Data;
    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
     * require a call to free() to deallocate the memory */
    delete data;
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__delete_array_char_realloc_22b.cpp,211688,"void CWE762_Mismatched_Memory_Management_Routines__delete_array_char_realloc_22bSink(char * data)
{
    if(CWE762_Mismatched_Memory_Management_Routines__delete_array_char_realloc_22bGlobal)
    {
        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may
         * require a call to free() to deallocate the memory */
        delete [] data;
    }
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__delete_struct_calloc_52b.cpp,220107,"void CWE762_Mismatched_Memory_Management_Routines__delete_struct_calloc_52bSink_b(twoIntsStruct * data)
{
    CWE762_Mismatched_Memory_Management_Routines__delete_struct_calloc_52bSink_c(data);
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__new_array_delete_class_61a.cpp,221862,"void CWE762_Mismatched_Memory_Management_Routines__new_array_delete_class_61a()
{
    TwoIntsClass * data;
    /* Initialize data*/
    data = NULL;
    data = CWE762_Mismatched_Memory_Management_Routines__new_array_delete_class_61aSource(data);
    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
     * require a call to delete [] to deallocate the memory */
    delete data;
}
",1,CWE762
CWE762_Mismatched_Memory_Management_Routines__delete_long_malloc_21.cpp,219548,"static void CWE762_Mismatched_Memory_Management_Routines__delete_long_malloc_21Sink(long * data)
{
    if(CWE762_Mismatched_Memory_Management_Routines__delete_long_malloc_21Static)
    {
        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may
         * require a call to free() to deallocate the memory */
        delete data;
    }
}
",1,CWE762
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_12.c,229340,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_12()
{
    FILE * data;
    data = NULL;
    /* POTENTIAL FLAW: Create a file handle using fopen() that may not be closed properly */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Point data to another file handle without closing the handle from the source */
        data = fopen(""BadSink_fopen.txt"", ""w+"");
        /* avoid incidental for not closing the file handle */
        if (data != NULL)
        {
            fclose(data);
        }
    }
    else
    {
        /* FIX: Close the file from the source before pointing data to a new file handle */
        if (data != NULL)
        {
            fclose(data);
        }
        data = fopen(""GoodSink_fopen.txt"", ""w+"");
        /* avoid incidental for not closing the file handle */
        if (data != NULL)
        {
            fclose(data);
        }
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_74b.cpp,229467,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_74bSink(map<int, FILE *> dataMap)
{
    /* copy data out of dataMap */
    FILE * data = dataMap[2];
    /* FLAW: Point data to another file handle without closing the handle from the source */
    data = fopen(""BadSink_fopen.txt"", ""w+"");
    /* avoid incidental for not closing the file handle */
    if (data != NULL)
    {
        fclose(data);
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_67b.c,229451,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_67bSink(CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_67_structType myStruct)
{
    FILE * data = myStruct.structFirst;
    /* FLAW: Point data to another file handle without closing the handle from the source */
    data = fopen(""BadSink_fopen.txt"", ""w+"");
    /* avoid incidental for not closing the file handle */
    if (data != NULL)
    {
        fclose(data);
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_68a.c,229775,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_68a()
{
    HANDLE data;
    /* Initialize data */
    data = INVALID_HANDLE_VALUE;
    /* POTENTIAL FLAW: Create a file handle using CreateFile() that may not be closed properly */
    data = CreateFile(""BadSource_w32CreateFile.txt"",
                      (GENERIC_WRITE|GENERIC_READ),
                      0,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_68aDataForBadSink = data;
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_68aSink();
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_34.c,229697,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_34()
{
    HANDLE data;
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_34_unionType myUnion;
    /* Initialize data */
    data = INVALID_HANDLE_VALUE;
    /* POTENTIAL FLAW: Create a file handle using CreateFile() that may not be closed properly */
    data = CreateFile(""BadSource_w32CreateFile.txt"",
                      (GENERIC_WRITE|GENERIC_READ),
                      0,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    myUnion.unionFirst = data;
    {
        HANDLE data = myUnion.unionSecond;
        /* FLAW: Point data to another file handle without closing the handle from the source */
        data = CreateFile(""BadSink_w32CreateFile.txt"",
                          (GENERIC_WRITE|GENERIC_READ),
                          0,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
        /* avoid incidental for not closing the file handle */
        if (data != INVALID_HANDLE_VALUE)
        {
            CloseHandle(data);
        }
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_34.c,229536,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_34()
{
    int data;
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Create a file descriptor using open() that may not be closed properly */
    data = OPEN(""BadSource_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        /* FLAW: Assign data to another file descriptor without closing the descriptor from the source */
        data = OPEN(""BadSink_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
        /* avoid incidental for not closing the file */
        if (data != -1)
        {
            CLOSE(data);
        }
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_67b.c,229612,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_67bSink(CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__open_67_structType myStruct)
{
    int data = myStruct.structFirst;
    /* FLAW: Assign data to another file descriptor without closing the descriptor from the source */
    data = OPEN(""BadSink_open.txt"", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
    /* avoid incidental for not closing the file */
    if (data != -1)
    {
        CLOSE(data);
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_45.c,229716,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_45()
{
    HANDLE data;
    /* Initialize data */
    data = INVALID_HANDLE_VALUE;
    /* POTENTIAL FLAW: Create a file handle using CreateFile() that may not be closed properly */
    data = CreateFile(""BadSource_w32CreateFile.txt"",
                      (GENERIC_WRITE|GENERIC_READ),
                      0,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_45Data = data;
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__w32CreateFile_45Sink();
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_34.c,229375,"void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_34()
{
    FILE * data;
    CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_34_unionType myUnion;
    data = NULL;
    /* POTENTIAL FLAW: Create a file handle using fopen() that may not be closed properly */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    myUnion.unionFirst = data;
    {
        FILE * data = myUnion.unionSecond;
        /* FLAW: Point data to another file handle without closing the handle from the source */
        data = fopen(""BadSink_fopen.txt"", ""w+"");
        /* avoid incidental for not closing the file handle */
        if (data != NULL)
        {
            fclose(data);
        }
    }
}
",1,CWE773
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_21.c,229357,"static void CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_21Sink(FILE * data)
{
    if(CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_21Static)
    {
        /* FLAW: Point data to another file handle without closing the handle from the source */
        data = fopen(""BadSink_fopen.txt"", ""w+"");
        /* avoid incidental for not closing the file handle */
        if (data != NULL)
        {
            fclose(data);
        }
    }
}
",1,CWE773
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_15.c,229831,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_15()
{
    FILE * data;
    data = NULL;
    /* POTENTIAL FLAW: Open a file without closing it */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    switch(6)
    {
    case 6:
        /* FLAW: No attempt to close the file */
        ; /* empty statement needed for some flow variants */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_41.c,230182,"static void CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_41Sink(HANDLE data)
{
    /* FLAW: No attempt to close the file */
    ; /* empty statement needed for some flow variants */
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_02.c,229793,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_02()
{
    FILE * data;
    data = NULL;
    /* POTENTIAL FLAW: Open a file without closing it */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    if(1)
    {
        /* FLAW: No attempt to close the file */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_42.c,229865,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_42()
{
    FILE * data;
    data = NULL;
    data = CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_42Source(data);
    /* FLAW: No attempt to close the file */
    ; /* empty statement needed for some flow variants */
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_62a.cpp,229912,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_62a()
{
    FILE * data;
    data = NULL;
    CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_62aSource(data);
    /* FLAW: No attempt to close the file */
    ; /* empty statement needed for some flow variants */
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67a.c,229932,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67a()
{
    FILE * data;
    CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67_structType myStruct;
    data = NULL;
    /* POTENTIAL FLAW: Open a file without closing it */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    myStruct.structFirst = data;
    CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67aSink(myStruct);
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22a.c,229846,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22a()
{
    FILE * data;
    data = NULL;
    /* POTENTIAL FLAW: Open a file without closing it */
    data = fopen(""BadSource_fopen.txt"", ""w+"");
    CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22aGlobal = 1; /* true */
    CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22aSink(data);
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_45.c,230198,"static void CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_45Sink()
{
    HANDLE data = CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_45Data;
    /* FLAW: No attempt to close the file */
    ; /* empty statement needed for some flow variants */
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22b.c,229849,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22bSink(FILE * data)
{
    if(CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_22bGlobal)
    {
        /* FLAW: No attempt to close the file */
        ; /* empty statement needed for some flow variants */
    }
}
",1,CWE775
CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67b.c,229934,"void CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67bSink(CWE775_Missing_Release_of_File_Descriptor_or_Handle__fopen_no_close_67_structType myStruct)
{
    FILE * data = myStruct.structFirst;
    /* FLAW: No attempt to close the file */
    ; /* empty statement needed for some flow variants */
}
",1,CWE775
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_32.c,236643,"void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                /* POTENTIAL FLAW: Read data using a connect socket */
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                /* Abort on error or the connection was closed */
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                /* Append null terminator */
                data[dataLen + recvResult / sizeof(char)] = '\0';
                /* Eliminate CRLF */
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            /* spawnvp - searches for the location of the command among
             * the directories specified by the PATH environment variable */
            /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
            _spawnvp(_P_WAIT, COMMAND_INT, args);
        }
    }
}
",1,CWE78
CWE78_OS_Command_Injection__wchar_t_environment_system_15.c,247085,"void CWE78_OS_Command_Injection__wchar_t_environment_system_15()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    switch(6)
    {
    case 6:
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
",1,CWE78
CWE78_OS_Command_Injection__char_connect_socket_execl_66b.c,235592,"void CWE78_OS_Command_Injection__char_connect_socket_execl_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    /* execl - specify the path where the command is located */
    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
",1,CWE78
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41.c,236166,"void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41Sink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        /* execvp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
        EXECVP(COMMAND_INT, args);
    }
}
",1,CWE78
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_73b.cpp,236252,"void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        /* execvp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
        EXECVP(COMMAND_INT, args);
    }
}
",1,CWE78
CWE78_OS_Command_Injection__char_connect_socket_execl_45.c,235538,"static void CWE78_OS_Command_Injection__char_connect_socket_execl_45Sink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_execl_45Data;
    /* execl - specify the path where the command is located */
    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
",1,CWE78
CWE78_OS_Command_Injection__char_environment_popen_68a.c,238979,"void CWE78_OS_Command_Injection__char_environment_popen_68a()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_popen_68aData = data;
    CWE78_OS_Command_Injection__char_environment_popen_68aSink();
}
",1,CWE78
CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21.c,243392,"void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21Static = 1; /* true */
    data = CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21Source(data);
    /* wexeclp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
",1,CWE78
CWE78_OS_Command_Injection__char_connect_socket_system_66b.c,235914,"void CWE78_OS_Command_Injection__char_connect_socket_system_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
",1,CWE78
CWE78_OS_Command_Injection__char_console_w32spawnl_45.c,237631,"static void CWE78_OS_Command_Injection__char_console_w32spawnl_45Sink()
{
    char * data = CWE78_OS_Command_Injection__char_console_w32spawnl_45Data;
    /* spawnl - specify the path where the command is located */
    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
",1,CWE78
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_22a.cpp,234642,"void CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_22a()
{
    size_t data;
    /* Initialize data */
    data = 0;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%zu"", &data);
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_22aGlobal = 1; /* true */
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_22aSink(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_45.cpp,235179,"void CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_45()
{
    size_t data;
    /* Initialize data */
    data = 0;
    /* POTENTIAL FLAW: Set data to a random value */
    data = rand();
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_45Data = data;
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_45Sink();
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64a.c,231554,"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64a()
{
    size_t data;
    /* Initialize data */
    data = 0;
    /* POTENTIAL FLAW: Set data to a random value */
    data = rand();
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64aSink(&data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54b.cpp,234968,"void CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54bSink_b(size_t data)
{
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54bSink_c(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66a.c,231074,"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66a()
{
    size_t data;
    size_t dataArray[5];
    /* Initialize data */
    data = 0;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%zu"", &data);
    /* put data in array */
    dataArray[2] = data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66aSink(dataArray);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_54d.cpp,233744,"void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_54dSink_d(size_t data)
{
    CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_54dSink_e(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54d.cpp,234974,"void CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54dSink_d(size_t data)
{
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_listen_socket_54dSink_e(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_53b.cpp,232988,"void CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_53bSink_b(size_t data)
{
    CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_53bSink_c(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_52b.cpp,235193,"void CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_52bSink_b(size_t data)
{
    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_rand_52bSink_c(data);
}
",1,CWE789
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51a.c,231494,"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51a()
{
    size_t data;
    /* Initialize data */
    data = 0;
    /* POTENTIAL FLAW: Set data to a random value */
    data = rand();
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51aSink(data);
}
",1,CWE789
CWE90_LDAP_Injection__w32_wchar_t_environment_10.c,252545,"void CWE90_LDAP_Injection__w32_wchar_t_environment_10()
{
    wchar_t * data;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                wcsncat(data+dataLen, environment, 256-dataLen-1);
            }
        }
    }
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        wchar_t filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snwprintf(filter, 256-1, L""(cn=%s)"", data);
        pLdapConnection = ldap_initW(L""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sW(
                            pLdapConnection,
                            L""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_wchar_t_environment_67a.c,252660,"void CWE90_LDAP_Injection__w32_wchar_t_environment_67a()
{
    wchar_t * data;
    CWE90_LDAP_Injection__w32_wchar_t_environment_67_structType myStruct;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 256-dataLen-1);
        }
    }
    myStruct.structFirst = data;
    CWE90_LDAP_Injection__w32_wchar_t_environment_67aSink(myStruct);
}
",1,CWE90
CWE90_LDAP_Injection__w32_wchar_t_file_15.c,252720,"void CWE90_LDAP_Injection__w32_wchar_t_file_15()
{
    wchar_t * data;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        /* Read input from a file */
        size_t dataLen = wcslen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (256-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        wchar_t filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snwprintf(filter, 256-1, L""(cn=%s)"", data);
        pLdapConnection = ldap_initW(L""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sW(
                            pLdapConnection,
                            L""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_char_console_15.c,251593,"void CWE90_LDAP_Injection__w32_char_console_15()
{
    char * data;
    char dataBuffer[256] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (256-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        char filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snprintf(filter, 256-1, ""(cn=%s)"", data);
        pLdapConnection = ldap_initA(""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sA(
                            pLdapConnection,
                            ""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_char_environment_32.c,251777,"void CWE90_LDAP_Injection__w32_char_environment_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[256] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            /* Append input from an environment variable to data */
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                strncat(data+dataLen, environment, 256-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            LDAP* pLdapConnection = NULL;
            ULONG connectSuccess = 0L;
            ULONG searchSuccess = 0L;
            LDAPMessage *pMessage = NULL;
            char filter[256];
            /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
            _snprintf(filter, 256-1, ""(cn=%s)"", data);
            pLdapConnection = ldap_initA(""localhost"", LDAP_PORT);
            if (pLdapConnection == NULL)
            {
                printLine(""Initialization failed"");
                exit(1);
            }
            connectSuccess = ldap_connect(pLdapConnection, NULL);
            if (connectSuccess != LDAP_SUCCESS)
            {
                printLine(""Connection failed"");
                exit(1);
            }
            searchSuccess = ldap_search_ext_sA(
                                pLdapConnection,
                                ""base"",
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                NULL,
                                0,
                                NULL,
                                NULL,
                                LDAP_NO_LIMIT,
                                LDAP_NO_LIMIT,
                                &pMessage);
            if (searchSuccess != LDAP_SUCCESS)
            {
                printLine(""Search failed"");
                if (pMessage != NULL)
                {
                    ldap_msgfree(pMessage);
                }
                exit(1);
            }
            /* Typically you would do something with the search results, but this is a test case and we can ignore them */
            /* Free the results to avoid incidentals */
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            /* Close the connection */
            ldap_unbind(pLdapConnection);
        }
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_char_connect_socket_21.c,251442,"void CWE90_LDAP_Injection__w32_char_connect_socket_21()
{
    char * data;
    char dataBuffer[256] = """";
    data = dataBuffer;
    CWE90_LDAP_Injection__w32_char_connect_socket_21Static = 1; /* true */
    data = CWE90_LDAP_Injection__w32_char_connect_socket_21Source(data);
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        char filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snprintf(filter, 256-1, ""(cn=%s)"", data);
        pLdapConnection = ldap_initA(""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sA(
                            pLdapConnection,
                            ""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_wchar_t_console_31.c,252419,"void CWE90_LDAP_Injection__w32_wchar_t_console_31()
{
    wchar_t * data;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = wcslen(data);
        /* if there is room in data, read into it from the console */
        if (256-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgetws() */
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                data[dataLen] = L'\0';
            }
        }
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            LDAP* pLdapConnection = NULL;
            ULONG connectSuccess = 0L;
            ULONG searchSuccess = 0L;
            LDAPMessage *pMessage = NULL;
            wchar_t filter[256];
            /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
            _snwprintf(filter, 256-1, L""(cn=%s)"", data);
            pLdapConnection = ldap_initW(L""localhost"", LDAP_PORT);
            if (pLdapConnection == NULL)
            {
                printLine(""Initialization failed"");
                exit(1);
            }
            connectSuccess = ldap_connect(pLdapConnection, NULL);
            if (connectSuccess != LDAP_SUCCESS)
            {
                printLine(""Connection failed"");
                exit(1);
            }
            searchSuccess = ldap_search_ext_sW(
                                pLdapConnection,
                                L""base"",
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                NULL,
                                0,
                                NULL,
                                NULL,
                                LDAP_NO_LIMIT,
                                LDAP_NO_LIMIT,
                                &pMessage);
            if (searchSuccess != LDAP_SUCCESS)
            {
                printLine(""Search failed"");
                if (pMessage != NULL)
                {
                    ldap_msgfree(pMessage);
                }
                exit(1);
            }
            /* Typically you would do something with the search results, but this is a test case and we can ignore them */
            /* Free the results to avoid incidentals */
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            /* Close the connection */
            ldap_unbind(pLdapConnection);
        }
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_char_file_11.c,251904,"void CWE90_LDAP_Injection__w32_char_file_11()
{
    char * data;
    char dataBuffer[256] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            /* Read input from a file */
            size_t dataLen = strlen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (256-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        /* Restore NUL terminator if fgets fails */
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        char filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snprintf(filter, 256-1, ""(cn=%s)"", data);
        pLdapConnection = ldap_initA(""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sA(
                            pLdapConnection,
                            ""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_wchar_t_connect_socket_21.c,252247,"void CWE90_LDAP_Injection__w32_wchar_t_connect_socket_21()
{
    wchar_t * data;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    CWE90_LDAP_Injection__w32_wchar_t_connect_socket_21Static = 1; /* true */
    data = CWE90_LDAP_Injection__w32_wchar_t_connect_socket_21Source(data);
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        wchar_t filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snwprintf(filter, 256-1, L""(cn=%s)"", data);
        pLdapConnection = ldap_initW(L""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sW(
                            pLdapConnection,
                            L""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
CWE90_LDAP_Injection__w32_wchar_t_listen_socket_03.c,252846,"void CWE90_LDAP_Injection__w32_wchar_t_listen_socket_03()
{
    wchar_t * data;
    wchar_t dataBuffer[256] = L"""";
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                /* POTENTIAL FLAW: Read data using a listen socket */
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed */
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                /* Append null terminator */
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                /* Eliminate CRLF */
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        LDAP* pLdapConnection = NULL;
        ULONG connectSuccess = 0L;
        ULONG searchSuccess = 0L;
        LDAPMessage *pMessage = NULL;
        wchar_t filter[256];
        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/
        _snwprintf(filter, 256-1, L""(cn=%s)"", data);
        pLdapConnection = ldap_initW(L""localhost"", LDAP_PORT);
        if (pLdapConnection == NULL)
        {
            printLine(""Initialization failed"");
            exit(1);
        }
        connectSuccess = ldap_connect(pLdapConnection, NULL);
        if (connectSuccess != LDAP_SUCCESS)
        {
            printLine(""Connection failed"");
            exit(1);
        }
        searchSuccess = ldap_search_ext_sW(
                            pLdapConnection,
                            L""base"",
                            LDAP_SCOPE_SUBTREE,
                            filter,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            LDAP_NO_LIMIT,
                            LDAP_NO_LIMIT,
                            &pMessage);
        if (searchSuccess != LDAP_SUCCESS)
        {
            printLine(""Search failed"");
            if (pMessage != NULL)
            {
                ldap_msgfree(pMessage);
            }
            exit(1);
        }
        /* Typically you would do something with the search results, but this is a test case and we can ignore them */
        /* Free the results to avoid incidentals */
        if (pMessage != NULL)
        {
            ldap_msgfree(pMessage);
        }
        /* Close the connection */
        ldap_unbind(pLdapConnection);
    }
}
",1,CWE90
