[
  "httpd_bfd6489f6b8ab0cbfbddc8e4d5754fa3660316e1_0", {
    "ID": "httpd_bfd6489f6b8ab0cbfbddc8e4d5754fa3660316e1_0",
    "UID": "0",
    "code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char test_snippet\n{\n    int status = HTTP_OK;\n\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n\n    /* http://issues.apache.org/bugzilla/show_bug.cgi?id=31875\n     * http://issues.apache.org/bugzilla/show_bug.cgi?id=28450\n     *\n     * This is not in fact a URI, it's a path.  That matters in the\n     * case of a leading double-slash.  We need to resolve the issue\n     * by normalising that out before treating it as a URI.\n     */\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        /* Simple syntax Errors in URLs are trapped by\n         * parse_uri_components().\n         */\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n\n    if (status == APR_SUCCESS) {\n        \n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n\n#if defined(OS2) || defined(WIN32)\n        /* Handle path translations for OS/2 and plug security hole.\n         * This will prevent \"http://www.wherever.com/..\\..\\/\" from\n         * returning a directory for the root drive.\n         */\n        {\n            char *x;\n\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_13b0e05654a9b617a46c06df684030880da31967_0", {
    "ID": "httpd_13b0e05654a9b617a46c06df684030880da31967_0",
    "UID": "1",
    "code": "static int asis_handler(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    apr_file_t *f = NULL;\n    apr_status_t rv;\n    const char *location;\n\n    if(strcmp(r->handler,ASIS_MAGIC_TYPE) && strcmp(r->handler,\"send-as-is\"))\n        return DECLINED;\n\n    r->allowed |= (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET)\n        return DECLINED;\n    if (r->finfo.filetype == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                    \"File does not exist: %s\", r->filename);\n        return HTTP_NOT_FOUND;\n    }\n\n    if ((rv = apr_file_open(&f, r->filename, APR_READ,\n                APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                    \"file permissions deny server access: %s\", r->filename);\n        return HTTP_FORBIDDEN;\n    }\n\n    ap_scan_script_header_err(r, f, NULL);\n    location = apr_table_get(r->headers_out, \"Location\");\n\n    if (location && location[0] == '/' &&\n        ((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {\n\n        apr_file_close(f);\n\n        \n        r->status = HTTP_OK;\n\n        /* This redirect needs to be a GET no matter what the original\n         * method was.\n         */\n        r->method = apr_pstrdup(r->pool, \"GET\");\n        r->method_number = M_GET;\n\n        ap_internal_redirect_handler(location, r);\n        return OK;\n    }\n\n    if (!r->header_only) {\n        apr_bucket_brigade *bb;\n        apr_bucket *b;\n        apr_off_t pos = 0;\n\n        rv = apr_file_seek(f, APR_CUR, &pos);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: failed to find end-of-headers position \"\n                          \"for %s\", r->filename);\n            apr_file_close(f);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n#if APR_HAS_LARGE_FILES\n        if (r->finfo.size - pos > AP_MAX_SENDFILE) {\n            /* APR_HAS_LARGE_FILES issue; must split into mutiple buckets,\n             * no greater than MAX(apr_size_t), and more granular than that\n             * in case the brigade code/filters attempt to read it directly.\n             */\n            apr_off_t fsize = r->finfo.size - pos;\n            b = apr_bucket_file_create(f, pos, AP_MAX_SENDFILE,\n                                       r->pool, c->bucket_alloc);\n            while (fsize > AP_MAX_SENDFILE) {\n                APR_BRIGADE_INSERT_TAIL(bb, b);\n                apr_bucket_copy(b, &b);\n                b->start += AP_MAX_SENDFILE;\n                fsize -= AP_MAX_SENDFILE;\n            }\n            b->length = (apr_size_t)fsize; \n        }\n        else\n#endif\n        b = apr_bucket_file_create(f, pos, (apr_size_t) (r->finfo.size - pos),\n                                   r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        b = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: ap_pass_brigade failed for file %s\", r->filename);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n    else {\n        apr_file_close(f);\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_27680735a0ee17ef5cefd7684a43e95dba679cc8_0", {
    "ID": "httpd_27680735a0ee17ef5cefd7684a43e95dba679cc8_0",
    "UID": "3",
    "code": "AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int test_snippet\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \n    int i;\n\n    /*\n     * Take the MD5 hash of the string argument.\n     */\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)test_snippet;\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_8038760bc02c48c31a059dda2ad061a6460cd0dd_0", {
    "ID": "httpd_8038760bc02c48c31a059dda2ad061a6460cd0dd_0",
    "UID": "6",
    "code": "static int test_snippet\n{\n    if (!geteuid()) {\n        const char *name;\n\n        \n\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            uid_t uid = atoi(&unixd_config.user_name[1]);\n\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"getpwuid: couldn't determine user name from uid %u, \"\n                         \"you probably need to modify the User directive\",\n                         (unsigned)uid);\n                return -1;\n            }\n\n            name = ent->pw_name;\n        }\n        else\n            name = unixd_config.user_name;\n\n#if !defined(OS2) && !defined(TPF)\n        \n\n        /*\n         * Set the GID before initgroups(), since on some platforms\n         * setgid() is known to zap the group list.\n         */\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setgid: unable to set group id to Group %u\",\n                        (unsigned)unixd_config.group_id);\n            return -1;\n        }\n\n        \n\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n#endif \n    }\n    return 0;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_037aa11239739ccb4e0b09a64d53ad8f1c39395d_0", {
    "ID": "httpd_037aa11239739ccb4e0b09a64d53ad8f1c39395d_0",
    "UID": "7",
    "code": "int main (int argc, const char * const test_snippet\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe /some/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s /some/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s /some/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be /some/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            /*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             */\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() / APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now / tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                /* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. */\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \n    return 0;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n134,Use of Externally-Controlled Format String\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_ecec010fd3f8197d1a6724dd38b0d3a9c1e95d4a_0", {
    "ID": "httpd_ecec010fd3f8197d1a6724dd38b0d3a9c1e95d4a_0",
    "UID": "10",
    "code": "static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void test_snippet\n{\n    action_dir_config *base = (action_dir_config *) basev;\n    action_dir_config *add = (action_dir_config *) addv;\n    action_dir_config *new = (action_dir_config *) apr_palloc(p,\n                                  sizeof(action_dir_config));\n    int i;\n\n    new->action_types = apr_table_overlay(p, add->action_types,\n                                       base->action_types);\n\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i]\n                                            : base->scripted[i];\n    }\n\n    new->configured = (base->configured || add->configured);\n    return new;\n}",
    "predicted": "415,Double Free\n416,Use After Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_49f4af5b874ef07a73a45376a0e58e12dfb05c46_0", {
    "ID": "httpd_49f4af5b874ef07a73a45376a0e58e12dfb05c46_0",
    "UID": "11",
    "code": "AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec test_snippet\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_DNS:\n        case USE_CANONICAL_NAME_UNSET:\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            else \n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        case USE_CANONICAL_NAME_ON:\n            /* With UseCanonicalName on (and in all versions prior to 1.3)\n             * Apache will use the hostname and port specified in the\n             * ServerName directive to construct a canonical name for the\n             * server. (If no port was specified in the ServerName\n             * directive, Apache uses the port supplied by the client if\n             * any is supplied, and finally the default port for the protocol\n             * used.\n             */\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->server->port ? r->server->port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       ap_default_port(r);\n            else \n                port = r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                         \"ap_get_server_port: Invalid UCN Option somehow\");\n            port = ap_default_port(r);\n            break;\n    }\n\n    return port;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_12cd078edfbd1ecce7533b49ce34f4f2743c725b_0", {
    "ID": "httpd_12cd078edfbd1ecce7533b49ce34f4f2743c725b_0",
    "UID": "12",
    "code": "static long get_chunk_size(char test_snippet\n{\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n\n    ap_xlate_proto_from_ascii(b, strlen(b));\n\n    \n    while (*b == '0') {\n        ++b;\n    }\n\n    while (apr_isxdigit(test_snippet && (chunkbits > 0)) {\n        int xvalue = 0;\n\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        }\n        else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        }\n        else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n    }\n    if (apr_isxdigit(test_snippet && (chunkbits <= 0)) {\n        \n        return -1;\n    }\n\n    return chunksize;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable\n190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_b93cebc791a96f3a1fa433ffcf24ec5be397ad9c_0", {
    "ID": "httpd_b93cebc791a96f3a1fa433ffcf24ec5be397ad9c_0",
    "UID": "13",
    "code": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_off_t totalread;\n\n    \n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_palloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n        ctx->remaining = 0;\n        ctx->limit_used = 0;\n        ctx->eos_sent = 0;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (!strcasecmp(tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n        }\n        else if (lenp) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n            errno = 0;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. */\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n                apr_bucket_brigade *bb;\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                apr_bucket_brigade *bb;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        /* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. */\n        if ((ctx->state == BODY_CHUNK ||\n            (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&\n            f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)) {\n            char *tmp;\n            apr_bucket_brigade *bb;\n\n            tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL, \" \",\n                              ap_get_status_line(100), CRLF CRLF, NULL);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = apr_bucket_pool_create(tmp, strlen(tmp), f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            e = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n\n            ap_pass_brigade(f->c->output_filters, bb);\n        }\n\n        \n        if (ctx->state == BODY_CHUNK) {\n            char line[30];\n            apr_bucket_brigade *bb;\n            apr_size_t len = 30;\n            apr_off_t brigade_length;\n\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                APR_BLOCK_READ, 0);\n\n            if (rv == APR_SUCCESS) {\n                /* We have to check the length of the brigade we got back.\n                 * We will not accept partial lines.\n                 */\n                rv = apr_brigade_length(bb, 1, &brigade_length);\n                if (rv == APR_SUCCESS\n                    && brigade_length > f->r->server->limit_req_line) {\n                    rv = APR_ENOSPC;\n                }\n                if (rv == APR_SUCCESS) {\n                    rv = apr_brigade_flatten(bb, line, &len);\n                    if (rv == APR_SUCCESS) {\n                        ctx->remaining = get_chunk_size(line);\n                    }\n                }\n            }\n            apr_brigade_cleanup(bb);\n\n            \n            if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                ctx->remaining = 0; /* Reset it in case we have to\n                                     * come back here later */\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool,\n                                           f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            if (!ctx->remaining) {\n                \n                ctx->state = BODY_NONE;\n                ap_get_mime_headers(f->r);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n                return APR_SUCCESS;\n            }\n        }\n    }\n\n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->remaining) {\n        switch (ctx->state) {\n        case BODY_NONE:\n            break;\n        case BODY_LENGTH:\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        case BODY_CHUNK:\n            {\n                char line[30];\n                apr_bucket_brigade *bb;\n                apr_size_t len = 30;\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n                \n                rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                    APR_BLOCK_READ, 0);\n                apr_brigade_cleanup(bb);\n\n                if (rv == APR_SUCCESS) {\n                    \n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        APR_BLOCK_READ, 0);\n                    if (rv == APR_SUCCESS) {\n                        rv = apr_brigade_flatten(bb, line, &len);\n                        if (rv == APR_SUCCESS) {\n                            ctx->remaining = get_chunk_size(line);\n                        }\n                    }\n                    apr_brigade_cleanup(bb);\n                }\n\n                \n                if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                    ctx->remaining = 0; /* Reset it in case we have to\n                                         * come back here later */\n                    e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE,\n                                               NULL, f->r->pool,\n                                               f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    ctx->eos_sent = 1;\n                    return ap_pass_brigade(f->r->output_filters, bb);\n                }\n\n                if (!ctx->remaining) {\n                    \n                    ctx->state = BODY_NONE;\n                    ap_get_mime_headers(f->r);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    ctx->eos_sent = 1;\n                    return APR_SUCCESS;\n                }\n            }\n            break;\n        }\n    }\n\n    \n    if (ctx->state == BODY_LENGTH || ctx->state == BODY_CHUNK) {\n        if (ctx->remaining < readbytes) {\n            readbytes = ctx->remaining;\n        }\n        AP_DEBUG_ASSERT(readbytes > 0);\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \n    apr_brigade_length(b, 0, &totalread);\n\n    /* If this happens, we have a bucket of unknown length.  Die because\n     * it means our assumptions have changed. */\n    AP_DEBUG_ASSERT(totalread >= 0);\n\n    if (ctx->state != BODY_NONE) {\n        ctx->remaining -= totalread;\n    }\n\n    /* If we have no more bytes remaining on a C-L request,\n     * save the callter a roundtrip to discover EOS.\n     */\n    if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n    }\n\n    \n    if (ctx->limit) {\n        /* FIXME: Note that we might get slightly confused on chunked inputs\n         * as we'd need to compensate for the chunk lengths which may not\n         * really count.  This seems to be up for interpretation.  */\n        ctx->limit_used += totalread;\n        if (ctx->limit < ctx->limit_used) {\n            apr_bucket_brigade *bb;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Read content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                       f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ctx->eos_sent = 1;\n            return ap_pass_brigade(f->r->output_filters, bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_03cab3f0aaf1bdf28cfd53e8c550030d5fe3a3ba_0", {
    "ID": "httpd_03cab3f0aaf1bdf28cfd53e8c550030d5fe3a3ba_0",
    "UID": "15",
    "code": "static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade test_snippet\n                         apr_bucket *e)\n{\n    apr_bucket *f;\n\n    if (e != APR_BRIGADE_SENTINEL(b)) {\n        f = APR_RING_LAST(&b->list);\n        APR_RING_UNSPLICE(e, f, link);\n        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);\n    }\n\n    APR_BRIGADE_CHECK_CONSISTENCY(a);\n    APR_BRIGADE_CHECK_CONSISTENCY(b);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b7f6b9ef9951e2fc956040d0e6b9e65359899ef7_0", {
    "ID": "httpd_b7f6b9ef9951e2fc956040d0e6b9e65359899ef7_0",
    "UID": "16",
    "code": "AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char test_snippet\n{\n    const char *semi;\n\n    if (intype == NULL) return NULL;\n\n    semi = ap_strchr_c(intype, ';');\n    if (semi == NULL) {\n        return apr_pstrdup(p, intype);\n    }\n    else {\n        while ((semi > intype) && apr_isspace(semi[-1])) {\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi - intype);\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_8e8c19e46a77da0b247c91af6b30dde0c28163aa_0", {
    "ID": "httpd_8e8c19e46a77da0b247c91af6b30dde0c28163aa_0",
    "UID": "19",
    "code": "void ap_init_scoreboard(void test_snippet\n{\n    char *more_storage;\n    int i;\n\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image =\n        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *) +\n               server_limit * lb_limit * sizeof(lb_score *));\n    more_storage = shared_score;\n    ap_scoreboard_image->global = (global_score *)more_storage;\n    more_storage += sizeof(global_score);\n    ap_scoreboard_image->parent = (process_score *)more_storage;\n    more_storage += sizeof(process_score) * server_limit;\n    ap_scoreboard_image->servers =\n        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));\n    for (i = 0; i < server_limit; i++) {\n        ap_scoreboard_image->servers[i] = (worker_score *)more_storage;\n        more_storage += thread_limit * sizeof(worker_score);\n    }\n    if (lb_limit) {\n        ap_scoreboard_image->balancers = (lb_score *)more_storage;\n        more_storage += lb_limit * sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score + scoreboard_size);\n    ap_scoreboard_image->global->server_limit = server_limit;\n    ap_scoreboard_image->global->thread_limit = thread_limit;\n    ap_scoreboard_image->global->lb_limit     = lb_limit;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_264d579e9f7f7be34c5123e0e30a6954bc51c760_0", {
    "ID": "httpd_264d579e9f7f7be34c5123e0e30a6954bc51c760_0",
    "UID": "24",
    "code": "AP_DECLARE(int) test_snippet\n{\n    if (set_group_privs()) {\n        return -1;\n    }\n#ifdef MPE\n    \n    if (geteuid() == 1 && unixd_config.user_id > 1) {\n        GETPRIVMODE();\n        if (setuid(unixd_config.user_id) == -1) {\n            GETUSERMODE();\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setuid: unable to change to uid: %ld\",\n                        (long) unixd_config.user_id);\n            exit(1);\n        }\n        GETUSERMODE();\n    }\n#else\n    \n    if (!geteuid() && (\n#ifdef _OSD_POSIX\n        os_init_job_environment(NULL, unixd_config.user_name, ap_exists_config_define(\"DEBUG\")) != 0 ||\n#endif\n        setuid(unixd_config.user_id) == -1)) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                    \"setuid: unable to change to uid: %ld\",\n                    (long) unixd_config.user_id);\n        return -1;\n    }\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n    \n#ifdef AP_MPM_WANT_SET_COREDUMPDIR\n    if (ap_coredumpdir_configured) {\n        if (prctl(PR_SET_DUMPABLE, 1)) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"set dumpable failed - this child will not coredump\"\n                         \" after software errors\");\n        }\n    }\n#endif\n#endif\n#endif\n    return 0;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_01ddb1f763456a8d7cfbcfa20656ba0f6bc328c7_0", {
    "ID": "httpd_01ddb1f763456a8d7cfbcfa20656ba0f6bc328c7_0",
    "UID": "25",
    "code": "AP_DECLARE(char *) ap_escape_html(apr_pool_t *p, const char test_snippet\n{\n    int i, j;\n    char *x;\n\n    \n    for (i = 0, j = 0; s[i] != '\\0'; i++)\n        if (s[i] == '<' || s[i] == '>')\n            j += 3;\n        else if (s[i] == '&')\n            j += 4;\n\n    if (j == 0)\n        return apr_pstrmemdup(p, s, i);\n\n    x = apr_palloc(p, i + j + 1);\n    for (i = 0, j = 0; s[i] != '\\0'; i++, j++)\n        if (s[i] == '<') {\n            memcpy(&x[j], \"&lt;\", 4);\n            j += 3;\n        }\n        else if (s[i] == '>') {\n            memcpy(&x[j], \"&gt;\", 4);\n            j += 3;\n        }\n        else if (s[i] == '&') {\n            memcpy(&x[j], \"&amp;\", 5);\n            j += 4;\n        }\n        else\n            x[j] = s[i];\n\n    x[j] = '\\0';\n    return x;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_70e1188721173dae7342acd3f6fb584af89ab603_0", {
    "ID": "httpd_70e1188721173dae7342acd3f6fb584af89ab603_0",
    "UID": "26",
    "code": "static char *http2env(apr_pool_t *a, const char test_snippet\n{\n    char *res = (char *)apr_palloc(a, sizeof(\"HTTP_\") + strlen(w));\n    char *cp = res;\n    char c;\n\n    *cp++ = 'H';\n    *cp++ = 'T';\n    *cp++ = 'T';\n    *cp++ = 'P';\n    *cp++ = '_';\n\n    while ((c = *w++) != 0) {\n        if (!apr_isalnum(c)) {\n            *cp++ = '_';\n        }\n        else {\n            *cp++ = apr_toupper(c);\n        }\n    }\n    *cp = 0;\n\n    return res;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_628bd5d4dd9d414ddb5b355ce6e83139ffa3fc00_0", {
    "ID": "httpd_628bd5d4dd9d414ddb5b355ce6e83139ffa3fc00_0",
    "UID": "27",
    "code": "static void to64(char *s, unsigned long v, int test_snippet\n{\n    static unsigned char itoa64[] =         \n        \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n    while (--n >= 0) {\n        *s++ = itoa64[v&0x3f];\n        v >>= 6;\n    }\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_f5a5b02db60a7b874a54b9665799a52a397d06d5_0", {
    "ID": "httpd_f5a5b02db60a7b874a54b9665799a52a397d06d5_0",
    "UID": "28",
    "code": "AP_DECLARE(char *) ap_md5contextTo64(apr_pool_t *a, apr_md5_ctx_t test_snippet\n{\n    unsigned char digest[18];\n    char *encodedDigest;\n    int i;\n    char *p;\n\n    encodedDigest = (char *) apr_pcalloc(a, 25 * sizeof(char));\n\n    apr_md5_final(digest, context);\n    digest[sizeof(digest) - 1] = digest[sizeof(digest) - 2] = 0;\n\n    p = encodedDigest;\n    for (i = 0; i < sizeof(digest); i += 3) {\n        *p++ = basis_64[digest[i] >> 2];\n        *p++ = basis_64[((digest[i] & 0x3) << 4) | ((int) (digest[i + 1] & 0xF0) >> 4)];\n        *p++ = basis_64[((digest[i + 1] & 0xF) << 2) | ((int) (digest[i + 2] & 0xC0) >> 6)];\n        *p++ = basis_64[digest[i + 2] & 0x3F];\n    }\n    *p-- = '\\0';\n    *p-- = '=';\n    *p-- = '=';\n    return encodedDigest;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n126,Buffer Over-read"
  },
  "httpd_ef9d408264e888f14633dac34f1f91fd5879a54a_0", {
    "ID": "httpd_ef9d408264e888f14633dac34f1f91fd5879a54a_0",
    "UID": "30",
    "code": "AP_DECLARE(char *) ap_getword(apr_pool_t *atrans, const char **line, char test_snippet\n{\n    const char *pos = *line;\n    int len;\n    char *res;\n\n    while ((*pos != test_snippet && *pos) {\n        ++pos;\n    }\n\n    len = pos - *line;\n    res = (char *)apr_palloc(atrans, len + 1);\n    memcpy(res, *line, len);\n    res[len] = 0;\n\n    if (test_snippet {\n        while (*pos == test_snippet {\n            ++pos;\n        }\n    }\n    *line = pos;\n\n    return res;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_e7059c4930a8cb88ece63a819615287ee4efb74b_0", {
    "ID": "httpd_e7059c4930a8cb88ece63a819615287ee4efb74b_0",
    "UID": "37",
    "code": "AP_DECLARE(void) ap_set_etag(request_rec test_snippet\n{\n    char *etag;\n    char *variant_etag, *vlv;\n    int vlv_weak;\n\n    if (!r->vlist_validator) {\n        etag = ap_make_etag(r, 0);\n\n        \n        if (!etag[0]) {\n            return;\n        }\n    }\n    else {\n        /* If we have a variant list validator (vlv) due to the\n         * response being negotiated, then we create a structured\n         * entity tag which merges the variant etag with the variant\n         * list validator (vlv).  This merging makes revalidation\n         * somewhat safer, ensures that caches which can deal with\n         * Vary will (eventually) be updated if the set of variants is\n         * changed, and is also a protocol requirement for transparent\n         * content negotiation.\n         */\n\n        /* if the variant list validator is weak, we make the whole\n         * structured etag weak.  If we would not, then clients could\n         * have problems merging range responses if we have different\n         * variants with the same non-globally-unique strong etag.\n         */\n\n        vlv = r->vlist_validator;\n        vlv_weak = (vlv[0] == 'W');\n\n        variant_etag = ap_make_etag(r, vlv_weak);\n\n        \n        if (!variant_etag[0]) {\n            return;\n        }\n\n        \n        variant_etag[strlen(variant_etag) - 1] = '\\0';\n        if (vlv_weak) {\n            vlv += 3;\n        }\n        else {\n            vlv++;\n        }\n        etag = apr_pstrcat(r->pool, variant_etag, \";\", vlv, NULL);\n    }\n\n    apr_table_setn(r->headers_out, \"ETag\", etag);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_17d69581e8efa6888f0dbfe160edaa73a71bfc70_0", {
    "ID": "httpd_17d69581e8efa6888f0dbfe160edaa73a71bfc70_0",
    "UID": "38",
    "code": "static test_snippet\ncheck_escape(const uschar **ptrptr, const char **errorptr, test_snippet bracount,\n  test_snippet options, BOOL isclass)\n{\nconst uschar *ptr = *ptrptr;\ntest_snippet c, i;\n\n\n\nc = *(++ptr);\nif (c == 0) *errorptr = ERR1;\n\n/* Non-alphamerics are literals. For digits or letters, do an initial lookup in\na table. A non-zero result is something that can be returned immediately.\nOtherwise further processing may be required. */\n\n#if !EBCDIC    \nelse if (c < '0' || c > 'z') {}                           \nelse if ((i = escapes[c - '0']) != 0) c = i;\n\n#else          \nelse if (c < 'a' || (ebcdic_chartab[c] & 0x0E) == 0) {}   \nelse if ((i = escapes[c - 0x48]) != 0)  c = i;\n#endif\n\n\n\nelse\n  {\n  const uschar *oldptr;\n  switch (c)\n    {\n    /* A number of Perl escapes are not handled by PCRE. We give an explicit\n    error. */\n\n    case 'l':\n    case 'L':\n    case 'N':\n    case 'u':\n    case 'U':\n    *errorptr = ERR37;\n    break;\n\n    /* The handling of escape sequences consisting of a string of digits\n    starting with one that is not zero is not straightforward. By experiment,\n    the way Perl works seems to be as follows:\n\n    Outside a character class, the digits are read as a decimal number. If the\n    number is less than 10, or if there are that many previous extracting\n    left brackets, then it is a back reference. Otherwise, up to three octal\n    digits are read to form an escaped byte. Thus \\123 is likely to be octal\n    123 (cf \\0123, which is octal 012 followed by the literal 3). If the octal\n    value is greater than 377, the least significant 8 bits are taken. Inside a\n    character class, \\ followed by a digit is always an octal number. */\n\n    case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n\n    if (!isclass)\n      {\n      oldptr = ptr;\n      c -= '0';\n      while ((digitab[ptr[1]] & ctype_digit) != 0)\n        c = c * 10 + *(++ptr) - '0';\n      if (c < 10 || c <= bracount)\n        {\n        c = -(ESC_REF + c);\n        break;\n        }\n      ptr = oldptr;      \n      }\n\n    /* Handle an octal number following \\. If the first digit is 8 or 9, Perl\n    generates a binary zero byte and treats the digit as a following literal.\n    Thus we have to pull back the potest_snippeter by one. */\n\n    if ((c = *ptr) >= '8')\n      {\n      ptr--;\n      c = 0;\n      break;\n      }\n\n    /* \\0 always starts an octal number, but we may drop through to here with a\n    larger first octal digit. */\n\n    case '0':\n    c -= '0';\n    while(i++ < 2 && ptr[1] >= '0' && ptr[1] <= '7')\n        c = c * 8 + *(++ptr) - '0';\n    c &= 255;     \n    break;\n\n    /* \\x is complicated when UTF-8 is enabled. \\x{ddd} is a character number\n    which can be greater than 0xff, but only if the ddd are hex digits. */\n\n    case 'x':\n#ifdef SUPPORT_UTF8\n    if (ptr[1] == '{' && (options & PCRE_UTF8) != 0)\n      {\n      const uschar *pt = ptr + 2;\n      register test_snippet count = 0;\n      c = 0;\n      while ((digitab[*pt] & ctype_xdigit) != 0)\n        {\n        test_snippet cc = *pt++;\n        count++;\n#if !EBCDIC    \n        if (cc >= 'a') cc -= 32;               \n        c = c * 16 + cc - ((cc < 'A')? '0' : ('A' - 10));\n#else          \n        if (cc >= 'a' && cc <= 'z') cc += 64;  \n        c = c * 16 + cc - ((cc >= '0')? '0' : ('A' - 10));\n#endif\n        }\n      if (*pt == '}')\n        {\n        if (c < 0 || count > 8) *errorptr = ERR34;\n        ptr = pt;\n        break;\n        }\n      /* If the sequence of hex digits does not end with '}', then we don't\n      recognize this construct; fall through to the normal \\x handling. */\n      }\n#endif\n\n    \n\n    c = 0;\n    while (i++ < 2 && (digitab[ptr[1]] & ctype_xdigit) != 0)\n      {\n      test_snippet cc;                               \n      cc = *(++ptr);                        \n#if !EBCDIC    \n      if (cc >= 'a') cc -= 32;              \n      c = c * 16 + cc - ((cc < 'A')? '0' : ('A' - 10));\n#else          \n      if (cc <= 'z') cc += 64;              \n      c = c * 16 + cc - ((cc >= '0')? '0' : ('A' - 10));\n#endif\n      }\n    break;\n\n    \n\n    case 'c':\n    c = *(++ptr);\n    if (c == 0)\n      {\n      *errorptr = ERR2;\n      return 0;\n      }\n\n    /* A letter is upper-cased; then the 0x40 bit is flipped. This coding\n    is ASCII-specific, but then the whole concept of \\cx is ASCII-specific.\n    (However, an EBCDIC equivalent has now been added.) */\n\n#if !EBCDIC    \n    if (c >= 'a' && c <= 'z') c -= 32;\n    c ^= 0x40;\n#else          \n    if (c >= 'a' && c <= 'z') c += 64;\n    c ^= 0xC0;\n#endif\n    break;\n\n    /* PCRE_EXTRA enables extensions to Perl in the matter of escapes. Any\n    other alphameric following \\ is an error if PCRE_EXTRA was set; otherwise,\n    for Perl compatibility, it is a literal. This code looks a bit odd, but\n    there used to be some cases other than the default, and there may be again\n    in future, so I haven't \"optimized\" it. */\n\n    default:\n    if ((options & PCRE_EXTRA) != 0) switch(c)\n      {\n      default:\n      *errorptr = ERR3;\n      break;\n      }\n    break;\n    }\n  }\n\n*ptrptr = ptr;\nreturn c;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n190,Integer Overflow or Wraparound\n369,Divide By Zero\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_4249c47f41644a3fb83af68b3822db03308e7453_0", {
    "ID": "httpd_4249c47f41644a3fb83af68b3822db03308e7453_0",
    "UID": "41",
    "code": "pcre test_snippet\npcre_compile(const char test_snippetpattern, int options, const char test_snippettest_snippeterrorptr,\n  int test_snippeterroroffset, const unsigned char test_snippettables)\n{\nreal_pcre test_snippetre;\nint length = 1 + LINK_SIZE;      /test_snippet For initial BRA plus length test_snippet/\nint c, firstbyte, reqbyte;\nint bracount = 0;\nint branch_extra = 0;\nint branch_newextra;\nint item_count = -1;\nint name_count = 0;\nint max_name_size = 0;\nint lastitemlength = 0;\n#ifdef SUPPORT_UTF8\nBOOL utf8;\nBOOL class_utf8;\n#endif\nBOOL inescq = FALSE;\nunsigned int brastackptr = 0;\nsize_t size;\nuschar test_snippetcode;\nconst uschar test_snippetcodestart;\nconst uschar test_snippetptr;\ncompile_data compile_block;\nint brastack[BRASTACK_SIZE];\nuschar bralenstack[BRASTACK_SIZE];\n\n/test_snippet We can't pass back an error message if errorptr is NULL; I guess the best we\ncan do is just return NULL. test_snippet/\n\nif (errorptr == NULL) return NULL;\ntest_snippeterrorptr = NULL;\n\n/test_snippet However, we can give a message for this error test_snippet/\n\nif (erroroffset == NULL)\n  {\n  test_snippeterrorptr = ERR16;\n  return NULL;\n  }\ntest_snippeterroroffset = 0;\n\n/test_snippet Can't support UTF8 unless PCRE has been compiled to include the code. test_snippet/\n\n#ifdef SUPPORT_UTF8\nutf8 = (options & PCRE_UTF8) != 0;\nif (utf8 && (options & PCRE_NO_UTF8_CHECK) == 0 &&\n     (test_snippeterroroffset = valid_utf8((uschar test_snippet)pattern, -1)) >= 0)\n  {\n  test_snippeterrorptr = ERR44;\n  return NULL;\n  }\n#else\nif ((options & PCRE_UTF8) != 0)\n  {\n  test_snippeterrorptr = ERR32;\n  return NULL;\n  }\n#endif\n\nif ((options & ~PUBLIC_OPTIONS) != 0)\n  {\n  test_snippeterrorptr = ERR17;\n  return NULL;\n  }\n\n/test_snippet Set up pointers to the individual character tables test_snippet/\n\nif (tables == NULL) tables = pcre_default_tables;\ncompile_block.lcc = tables + lcc_offset;\ncompile_block.fcc = tables + fcc_offset;\ncompile_block.cbits = tables + cbits_offset;\ncompile_block.ctypes = tables + ctypes_offset;\n\n/test_snippet Maximum back reference and backref bitmap. This is updated for numeric\nreferences during the first pass, but for named references during the actual\ncompile pass. The bitmap records up to 31 back references to help in deciding\nwhether (.test_snippet) can be treated as anchored or not. test_snippet/\n\ncompile_block.top_backref = 0;\ncompile_block.backref_map = 0;\n\n/test_snippet Reflect pattern for debugging output test_snippet/\n\nDPRINTF((\"------------------------------------------------------------------\\n\"));\nDPRINTF((\"%s\\n\", pattern));\n\n/test_snippet The first thing to do is to make a pass over the pattern to compute the\namount of store required to hold the compiled code. This does not have to be\nperfect as long as errors are overestimates. At the same time we can detect any\nflag settings right at the start, and extract them. Make an attempt to correct\nfor any counted white space if an \"extended\" flag setting appears late in the\npattern. We can't be so clever for #-comments. test_snippet/\n\nptr = (const uschar test_snippet)(pattern - 1);\nwhile ((c = test_snippet(++ptr)) != 0)\n  {\n  int min, max;\n  int class_optcount;\n  int bracket_length;\n  int duplength;\n\n  /test_snippet If we are inside a \\Q...\\E sequence, all chars are literal test_snippet/\n\n  if (inescq)\n    {\n    if ((options & PCRE_AUTO_CALLOUT) != 0) length += 2 + 2test_snippetLINK_SIZE;\n    goto NORMAL_CHAR;\n    }\n\n  /test_snippet Otherwise, first check for ignored whitespace and comments test_snippet/\n\n  if ((options & PCRE_EXTENDED) != 0)\n    {\n    if ((compile_block.ctypes[c] & ctype_space) != 0) continue;\n    if (c == '#')\n      {\n      /test_snippet The space before the ; is to avoid a warning on a silly compiler\n      on the Macintosh. test_snippet/\n      while ((c = test_snippet(++ptr)) != 0 && c != NEWLINE) ;\n      if (c == 0) break;\n      continue;\n      }\n    }\n\n  item_count++;    /test_snippet Is zero for the first non-comment item test_snippet/\n\n  /test_snippet Allow space for auto callout before every item except quantifiers. test_snippet/\n\n  if ((options & PCRE_AUTO_CALLOUT) != 0 &&\n       c != 'test_snippet' && c != '+' && c != '?' &&\n       (c != '{' || !is_counted_repeat(ptr + 1)))\n    length += 2 + 2test_snippetLINK_SIZE;\n\n  switch(c)\n    {\n    /test_snippet A backslashed item may be an escaped data character or it may be a\n    character type. test_snippet/\n\n    case '\\\\':\n    c = check_escape(&ptr, errorptr, bracount, options, FALSE);\n    if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n\n    lastitemlength = 1;     /test_snippet Default length of last item for repeats test_snippet/\n\n    if (c >= 0)             /test_snippet Data character test_snippet/\n      {\n      length += 2;          /test_snippet For a one-byte character test_snippet/\n\n#ifdef SUPPORT_UTF8\n      if (utf8 && c > 127)\n        {\n        int i;\n        for (i = 0; i < sizeof(utf8_table1)/sizeof(int); i++)\n          if (c <= utf8_table1[i]) break;\n        length += i;\n        lastitemlength += i;\n        }\n#endif\n\n      continue;\n      }\n\n    /test_snippet If \\Q, enter \"literal\" mode test_snippet/\n\n    if (-c == ESC_Q)\n      {\n      inescq = TRUE;\n      continue;\n      }\n\n    /test_snippet \\X is supported only if Unicode property support is compiled test_snippet/\n\n#ifndef SUPPORT_UCP\n    if (-c == ESC_X)\n      {\n      test_snippeterrorptr = ERR45;\n      goto PCRE_ERROR_RETURN;\n      }\n#endif\n\n    /test_snippet \\P and \\p are for Unicode properties, but only when the support has\n    been compiled. Each item needs 2 bytes. test_snippet/\n\n    else if (-c == ESC_P || -c == ESC_p)\n      {\n#ifdef SUPPORT_UCP\n      BOOL negated;\n      length += 2;\n      lastitemlength = 2;\n      if (get_ucp(&ptr, &negated, errorptr) < 0) goto PCRE_ERROR_RETURN;\n      continue;\n#else\n      test_snippeterrorptr = ERR45;\n      goto PCRE_ERROR_RETURN;\n#endif\n      }\n\n    /test_snippet Other escapes need one byte test_snippet/\n\n    length++;\n\n    /test_snippet A back reference needs an additional 2 bytes, plus either one or 5\n    bytes for a repeat. We also need to keep the value of the highest\n    back reference. test_snippet/\n\n    if (c <= -ESC_REF)\n      {\n      int refnum = -c - ESC_REF;\n      compile_block.backref_map |= (refnum < 32)? (1 << refnum) : 1;\n      if (refnum > compile_block.top_backref)\n        compile_block.top_backref = refnum;\n      length += 2;   /test_snippet For single back reference test_snippet/\n      if (ptr[1] == '{' && is_counted_repeat(ptr+2))\n        {\n        ptr = read_repeat_counts(ptr+2, &min, &max, errorptr);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if ((min == 0 && (max == 1 || max == -1)) ||\n          (min == 1 && max == -1))\n            length++;\n        else length += 5;\n        if (ptr[1] == '?') ptr++;\n        }\n      }\n    continue;\n\n    case '^':     /test_snippet Single-byte metacharacters test_snippet/\n    case '.':\n    case '$':\n    length++;\n    lastitemlength = 1;\n    continue;\n\n    case 'test_snippet':            /test_snippet These repeats won't be after brackets; test_snippet/\n    case '+':            /test_snippet those are handled separately test_snippet/\n    case '?':\n    length++;\n    goto POSESSIVE;      /test_snippet A few lines below test_snippet/\n\n    /test_snippet This covers the cases of braced repeats after a single char, metachar,\n    class, or back reference. test_snippet/\n\n    case '{':\n    if (!is_counted_repeat(ptr+1)) goto NORMAL_CHAR;\n    ptr = read_repeat_counts(ptr+1, &min, &max, errorptr);\n    if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n\n    /test_snippet These special cases just insert one extra opcode test_snippet/\n\n    if ((min == 0 && (max == 1 || max == -1)) ||\n      (min == 1 && max == -1))\n        length++;\n\n    /test_snippet These cases might insert additional copies of a preceding character. test_snippet/\n\n    else\n      {\n      if (min != 1)\n        {\n        length -= lastitemlength;   /test_snippet Uncount the original char or metachar test_snippet/\n        if (min > 0) length += 3 + lastitemlength;\n        }\n      length += lastitemlength + ((max > 0)? 3 : 1);\n      }\n\n    if (ptr[1] == '?') ptr++;      /test_snippet Needs no extra length test_snippet/\n\n    POSESSIVE:                     /test_snippet Test for possessive quantifier test_snippet/\n    if (ptr[1] == '+')\n      {\n      ptr++;\n      length += 2 + 2test_snippetLINK_SIZE;   /test_snippet Allow for atomic brackets test_snippet/\n      }\n    continue;\n\n    /test_snippet An alternation contains an offset to the next branch or ket. If any ims\n    options changed in the previous branch(es), and/or if we are in a\n    lookbehind assertion, extra space will be needed at the start of the\n    branch. This is handled by branch_extra. test_snippet/\n\n    case '|':\n    length += 1 + LINK_SIZE + branch_extra;\n    continue;\n\n    /test_snippet A character class uses 33 characters provided that all the character\n    values are less than 256. Otherwise, it uses a bit map for low valued\n    characters, and individual items for others. Don't worry about character\n    types that aren't allowed in classes - they'll get picked up during the\n    compile. A character class that contains only one single-byte character\n    uses 2 or 3 bytes, depending on whether it is negated or not. Notice this\n    where we can. (In UTF-8 mode we can do this only for chars < 128.) test_snippet/\n\n    case '[':\n    if (test_snippet(++ptr) == '^')\n      {\n      class_optcount = 10;  /test_snippet Greater than one test_snippet/\n      ptr++;\n      }\n    else class_optcount = 0;\n\n#ifdef SUPPORT_UTF8\n    class_utf8 = FALSE;\n#endif\n\n    /test_snippet Written as a \"do\" so that an initial ']' is taken as data test_snippet/\n\n    if (test_snippetptr != 0) do\n      {\n      /test_snippet Inside \\Q...\\E everything is literal except \\E test_snippet/\n\n      if (inescq)\n        {\n        if (test_snippetptr != '\\\\' || ptr[1] != 'E') goto GET_ONE_CHARACTER;\n        inescq = FALSE;\n        ptr += 1;\n        continue;\n        }\n\n      /test_snippet Outside \\Q...\\E, check for escapes test_snippet/\n\n      if (test_snippetptr == '\\\\')\n        {\n        c = check_escape(&ptr, errorptr, bracount, options, TRUE);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n\n        /test_snippet \\b is backspace inside a class; \\X is literal test_snippet/\n\n        if (-c == ESC_b) c = '\\b';\n        else if (-c == ESC_X) c = 'X';\n\n        /test_snippet \\Q enters quoting mode test_snippet/\n\n        else if (-c == ESC_Q)\n          {\n          inescq = TRUE;\n          continue;\n          }\n\n        /test_snippet Handle escapes that turn into characters test_snippet/\n\n        if (c >= 0) goto NON_SPECIAL_CHARACTER;\n\n        /test_snippet Escapes that are meta-things. The normal ones just affect the\n        bit map, but Unicode properties require an XCLASS extended item. test_snippet/\n\n        else\n          {\n          class_optcount = 10;         /test_snippet \\d, \\s etc; make sure > 1 test_snippet/\n#ifdef SUPPORT_UTF8\n          if (-c == ESC_p || -c == ESC_P)\n            {\n            if (!class_utf8)\n              {\n              class_utf8 = TRUE;\n              length += LINK_SIZE + 2;\n              }\n            length += 2;\n            }\n#endif\n          }\n        }\n\n      /test_snippet Check the syntax for POSIX stuff. The bits we actually handle are\n      checked during the real compile phase. test_snippet/\n\n      else if (test_snippetptr == '[' && check_posix_syntax(ptr, &ptr, &compile_block))\n        {\n        ptr++;\n        class_optcount = 10;    /test_snippet Make sure > 1 test_snippet/\n        }\n\n      /test_snippet Anything else increments the possible optimization count. We have to\n      detect ranges here so that we can compute the number of extra ranges for\n      caseless wide characters when UCP support is available. If there are wide\n      characters, we are going to have to use an XCLASS, even for single\n      characters. test_snippet/\n\n      else\n        {\n        int d;\n\n        GET_ONE_CHARACTER:\n\n#ifdef SUPPORT_UTF8\n        if (utf8)\n          {\n          int extra = 0;\n          GETCHARLEN(c, ptr, extra);\n          ptr += extra;\n          }\n        else c = test_snippetptr;\n#else\n        c = test_snippetptr;\n#endif\n\n        /test_snippet Come here from handling \\ above when it escapes to a char value test_snippet/\n\n        NON_SPECIAL_CHARACTER:\n        class_optcount++;\n\n        d = -1;\n        if (ptr[1] == '-')\n          {\n          uschar const test_snippethyptr = ptr++;\n          if (ptr[1] == '\\\\')\n            {\n            ptr++;\n            d = check_escape(&ptr, errorptr, bracount, options, TRUE);\n            if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n            if (-d == ESC_b) d = '\\b';        /test_snippet backspace test_snippet/\n            else if (-d == ESC_X) d = 'X';    /test_snippet literal X in a class test_snippet/\n            }\n          else if (ptr[1] != 0 && ptr[1] != ']')\n            {\n            ptr++;\n#ifdef SUPPORT_UTF8\n            if (utf8)\n              {\n              int extra = 0;\n              GETCHARLEN(d, ptr, extra);\n              ptr += extra;\n              }\n            else\n#endif\n            d = test_snippetptr;\n            }\n          if (d < 0) ptr = hyptr;      /test_snippet go back to hyphen as data test_snippet/\n          }\n\n        /test_snippet If d >= 0 we have a range. In UTF-8 mode, if the end is > 255, or >\n        127 for caseless matching, we will need to use an XCLASS. test_snippet/\n\n        if (d >= 0)\n          {\n          class_optcount = 10;     /test_snippet Ensure > 1 test_snippet/\n          if (d < c)\n            {\n            test_snippeterrorptr = ERR8;\n            goto PCRE_ERROR_RETURN;\n            }\n\n#ifdef SUPPORT_UTF8\n          if (utf8 && (d > 255 || ((options & PCRE_CASELESS) != 0 && d > 127)))\n            {\n            uschar buffer[6];\n            if (!class_utf8)         /test_snippet Allow for XCLASS overhead test_snippet/\n              {\n              class_utf8 = TRUE;\n              length += LINK_SIZE + 2;\n              }\n\n#ifdef SUPPORT_UCP\n            /test_snippet If we have UCP support, find out how many extra ranges are\n            needed to map the other case of characters within this range. We\n            have to mimic the range optimization here, because extending the\n            range upwards might push d over a boundary that makes is use\n            another byte in the UTF-8 representation. test_snippet/\n\n            if ((options & PCRE_CASELESS) != 0)\n              {\n              int occ, ocd;\n              int cc = c;\n              int origd = d;\n              while (get_othercase_range(&cc, origd, &occ, &ocd))\n                {\n                if (occ >= c && ocd <= d) continue;   /test_snippet Skip embedded test_snippet/\n\n                if (occ < c  && ocd >= c - 1)  /test_snippet Extend the basic range test_snippet/\n                  {                            /test_snippet if there is overlap,   test_snippet/\n                  c = occ;                     /test_snippet noting that if occ < c test_snippet/\n                  continue;                    /test_snippet we can't have ocd > d  test_snippet/\n                  }                            /test_snippet because a subrange is  test_snippet/\n                if (ocd > d && occ <= d + 1)   /test_snippet always shorter than    test_snippet/\n                  {                            /test_snippet the basic range.       test_snippet/\n                  d = ocd;\n                  continue;\n                  }\n\n                /test_snippet An extra item is needed test_snippet/\n\n                length += 1 + ord2utf8(occ, buffer) +\n                  ((occ == ocd)? 0 : ord2utf8(ocd, buffer));\n                }\n              }\n#endif  /test_snippet SUPPORT_UCP test_snippet/\n\n            /test_snippet The length of the (possibly extended) range test_snippet/\n\n            length += 1 + ord2utf8(c, buffer) + ord2utf8(d, buffer);\n            }\n#endif  /test_snippet SUPPORT_UTF8 test_snippet/\n\n          }\n\n        /test_snippet We have a single character. There is nothing to be done unless we\n        are in UTF-8 mode. If the char is > 255, or 127 when caseless, we must\n        allow for an XCL_SINGLE item, doubled for caselessness if there is UCP\n        support. test_snippet/\n\n        else\n          {\n#ifdef SUPPORT_UTF8\n          if (utf8 && (c > 255 || ((options & PCRE_CASELESS) != 0 && c > 127)))\n            {\n            uschar buffer[6];\n            class_optcount = 10;     /test_snippet Ensure > 1 test_snippet/\n            if (!class_utf8)         /test_snippet Allow for XCLASS overhead test_snippet/\n              {\n              class_utf8 = TRUE;\n              length += LINK_SIZE + 2;\n              }\n#ifdef SUPPORT_UCP\n            length += (((options & PCRE_CASELESS) != 0)? 2 : 1) test_snippet\n              (1 + ord2utf8(c, buffer));\n#else   /test_snippet SUPPORT_UCP test_snippet/\n            length += 1 + ord2utf8(c, buffer);\n#endif  /test_snippet SUPPORT_UCP test_snippet/\n            }\n#endif  /test_snippet SUPPORT_UTF8 test_snippet/\n          }\n        }\n      }\n    while (test_snippet(++ptr) != 0 && (inescq || test_snippetptr != ']')); /test_snippet Concludes \"do\" above test_snippet/\n\n    if (test_snippetptr == 0)                          /test_snippet Missing terminating ']' test_snippet/\n      {\n      test_snippeterrorptr = ERR6;\n      goto PCRE_ERROR_RETURN;\n      }\n\n    /test_snippet We can optimize when there was only one optimizable character. Repeats\n    for positive and negated single one-byte chars are handled by the general\n    code. Here, we handle repeats for the class opcodes. test_snippet/\n\n    if (class_optcount == 1) length += 3; else\n      {\n      length += 33;\n\n      /test_snippet A repeat needs either 1 or 5 bytes. If it is a possessive quantifier,\n      we also need extra for wrapping the whole thing in a sub-pattern. test_snippet/\n\n      if (test_snippetptr != 0 && ptr[1] == '{' && is_counted_repeat(ptr+2))\n        {\n        ptr = read_repeat_counts(ptr+2, &min, &max, errorptr);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if ((min == 0 && (max == 1 || max == -1)) ||\n          (min == 1 && max == -1))\n            length++;\n        else length += 5;\n        if (ptr[1] == '+')\n          {\n          ptr++;\n          length += 2 + 2test_snippetLINK_SIZE;\n          }\n        else if (ptr[1] == '?') ptr++;\n        }\n      }\n    continue;\n\n    /test_snippet Brackets may be genuine groups or special things test_snippet/\n\n    case '(':\n    branch_newextra = 0;\n    bracket_length = 1 + LINK_SIZE;\n\n    /test_snippet Handle special forms of bracket, which all start (? test_snippet/\n\n    if (ptr[1] == '?')\n      {\n      int set, unset;\n      int test_snippetoptset;\n\n      switch (c = ptr[2])\n        {\n        /test_snippet Skip over comments entirely test_snippet/\n        case '#':\n        ptr += 3;\n        while (test_snippetptr != 0 && test_snippetptr != ')') ptr++;\n        if (test_snippetptr == 0)\n          {\n          test_snippeterrorptr = ERR18;\n          goto PCRE_ERROR_RETURN;\n          }\n        continue;\n\n        /test_snippet Non-referencing groups and lookaheads just move the pointer on, and\n        then behave like a non-special bracket, except that they don't increment\n        the count of extracting brackets. Ditto for the \"once only\" bracket,\n        which is in Perl from version 5.005. test_snippet/\n\n        case ':':\n        case '=':\n        case '!':\n        case '>':\n        ptr += 2;\n        break;\n\n        /test_snippet (?R) specifies a recursive call to the regex, which is an extension\n        to provide the facility which can be obtained by (?p{perl-code}) in\n        Perl 5.6. In Perl 5.8 this has become (??{perl-code}).\n\n        From PCRE 4.00, items such as (?3) specify subroutine-like \"calls\" to\n        the appropriate numbered brackets. This includes both recursive and\n        non-recursive calls. (?R) is now synonymous with (?0). test_snippet/\n\n        case 'R':\n        ptr++;\n\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        ptr += 2;\n        if (c != 'R')\n          while ((digitab[test_snippet(++ptr)] & ctype_digit) != 0);\n        if (test_snippetptr != ')')\n          {\n          test_snippeterrorptr = ERR29;\n          goto PCRE_ERROR_RETURN;\n          }\n        length += 1 + LINK_SIZE;\n\n        /test_snippet If this item is quantified, it will get wrapped inside brackets so\n        as to use the code for quantified brackets. We jump down and use the\n        code that handles this for real brackets. test_snippet/\n\n        if (ptr[1] == '+' || ptr[1] == 'test_snippet' || ptr[1] == '?' || ptr[1] == '{')\n          {\n          length += 2 + 2 test_snippet LINK_SIZE;       /test_snippet to make bracketed test_snippet/\n          duplength = 5 + 3 test_snippet LINK_SIZE;\n          goto HANDLE_QUANTIFIED_BRACKETS;\n          }\n        continue;\n\n        /test_snippet (?C) is an extension which provides \"callout\" - to provide a bit of\n        the functionality of the Perl (?{...}) feature. An optional number may\n        follow (default is zero). test_snippet/\n\n        case 'C':\n        ptr += 2;\n        while ((digitab[test_snippet(++ptr)] & ctype_digit) != 0);\n        if (test_snippetptr != ')')\n          {\n          test_snippeterrorptr = ERR39;\n          goto PCRE_ERROR_RETURN;\n          }\n        length += 2 + 2test_snippetLINK_SIZE;\n        continue;\n\n        /test_snippet Named subpatterns are an extension copied from Python test_snippet/\n\n        case 'P':\n        ptr += 3;\n        if (test_snippetptr == '<')\n          {\n          const uschar test_snippetp;    /test_snippet Don't amalgamate; some compilers test_snippet/\n          p = ++ptr;          /test_snippet grumble at autoincrement in declaration test_snippet/\n          while ((compile_block.ctypes[test_snippetptr] & ctype_word) != 0) ptr++;\n          if (test_snippetptr != '>')\n            {\n            test_snippeterrorptr = ERR42;\n            goto PCRE_ERROR_RETURN;\n            }\n          name_count++;\n          if (ptr - p > max_name_size) max_name_size = (ptr - p);\n          break;\n          }\n\n        if (test_snippetptr == '=' || test_snippetptr == '>')\n          {\n          while ((compile_block.ctypes[test_snippet(++ptr)] & ctype_word) != 0);\n          if (test_snippetptr != ')')\n            {\n            test_snippeterrorptr = ERR42;\n            goto PCRE_ERROR_RETURN;\n            }\n          break;\n          }\n\n        /test_snippet Unknown character after (?P test_snippet/\n\n        test_snippeterrorptr = ERR41;\n        goto PCRE_ERROR_RETURN;\n\n        /test_snippet Lookbehinds are in Perl from version 5.005 test_snippet/\n\n        case '<':\n        ptr += 3;\n        if (test_snippetptr == '=' || test_snippetptr == '!')\n          {\n          branch_newextra = 1 + LINK_SIZE;\n          length += 1 + LINK_SIZE;         /test_snippet For the first branch test_snippet/\n          break;\n          }\n        test_snippeterrorptr = ERR24;\n        goto PCRE_ERROR_RETURN;\n\n        /test_snippet Conditionals are in Perl from version 5.005. The bracket must either\n        be followed by a number (for bracket reference) or by an assertion\n        group, or (a PCRE extension) by 'R' for a recursion test. test_snippet/\n\n        case '(':\n        if (ptr[3] == 'R' && ptr[4] == ')')\n          {\n          ptr += 4;\n          length += 3;\n          }\n        else if ((digitab[ptr[3]] & ctype_digit) != 0)\n          {\n          ptr += 4;\n          length += 3;\n          while ((digitab[test_snippetptr] & ctype_digit) != 0) ptr++;\n          if (test_snippetptr != ')')\n            {\n            test_snippeterrorptr = ERR26;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n        else   /test_snippet An assertion must follow test_snippet/\n          {\n          ptr++;   /test_snippet Can treat like ':' as far as spacing is concerned test_snippet/\n          if (ptr[2] != '?' ||\n             (ptr[3] != '=' && ptr[3] != '!' && ptr[3] != '<') )\n            {\n            ptr += 2;    /test_snippet To get right offset in message test_snippet/\n            test_snippeterrorptr = ERR28;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n        break;\n\n        /test_snippet Else loop checking valid options until ) is met. Anything else is an\n        error. If we are without any brackets, i.e. at top level, the settings\n        act as if specified in the options, so massage the options immediately.\n        This is for backward compatibility with Perl 5.004. test_snippet/\n\n        default:\n        set = unset = 0;\n        optset = &set;\n        ptr += 2;\n\n        for (;; ptr++)\n          {\n          c = test_snippetptr;\n          switch (c)\n            {\n            case 'i':\n            test_snippetoptset |= PCRE_CASELESS;\n            continue;\n\n            case 'm':\n            test_snippetoptset |= PCRE_MULTILINE;\n            continue;\n\n            case 's':\n            test_snippetoptset |= PCRE_DOTALL;\n            continue;\n\n            case 'x':\n            test_snippetoptset |= PCRE_EXTENDED;\n            continue;\n\n            case 'X':\n            test_snippetoptset |= PCRE_EXTRA;\n            continue;\n\n            case 'U':\n            test_snippetoptset |= PCRE_UNGREEDY;\n            continue;\n\n            case '-':\n            optset = &unset;\n            continue;\n\n            /test_snippet A termination by ')' indicates an options-setting-only item; if\n            this is at the very start of the pattern (indicated by item_count\n            being zero), we use it to set the global options. This is helpful\n            when analyzing the pattern for first characters, etc. Otherwise\n            nothing is done here and it is handled during the compiling\n            process.\n\n            [Historical note: Up to Perl 5.8, options settings at top level\n            were always global settings, wherever they appeared in the pattern.\n            That is, they were equivalent to an external setting. From 5.8\n            onwards, they apply only to what follows (which is what you might\n            expect).] test_snippet/\n\n            case ')':\n            if (item_count == 0)\n              {\n              options = (options | set) & (~unset);\n              set = unset = 0;     /test_snippet To save length test_snippet/\n              item_count--;        /test_snippet To allow for several test_snippet/\n              }\n\n            /test_snippet Fall through test_snippet/\n\n            /test_snippet A termination by ':' indicates the start of a nested group with\n            the given options set. This is again handled at compile time, but\n            we must allow for compiled space if any of the ims options are\n            set. We also have to allow for resetting space at the end of\n            the group, which is why 4 is added to the length and not just 2.\n            If there are several changes of options within the same group, this\n            will lead to an over-estimate on the length, but this shouldn't\n            matter very much. We also have to allow for resetting options at\n            the start of any alternations, which we do by setting\n            branch_newextra to 2. Finally, we record whether the case-dependent\n            flag ever changes within the regex. This is used by the \"required\n            character\" code. test_snippet/\n\n            case ':':\n            if (((set|unset) & PCRE_IMS) != 0)\n              {\n              length += 4;\n              branch_newextra = 2;\n              if (((set|unset) & PCRE_CASELESS) != 0) options |= PCRE_ICHANGED;\n              }\n            goto END_OPTIONS;\n\n            /test_snippet Unrecognized option character test_snippet/\n\n            default:\n            test_snippeterrorptr = ERR12;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n\n        /test_snippet If we hit a closing bracket, that's it - this is a freestanding\n        option-setting. We need to ensure that branch_extra is updated if\n        necessary. The only values branch_newextra can have here are 0 or 2.\n        If the value is 2, then branch_extra must either be 2 or 5, depending\n        on whether this is a lookbehind group or not. test_snippet/\n\n        END_OPTIONS:\n        if (c == ')')\n          {\n          if (branch_newextra == 2 &&\n              (branch_extra == 0 || branch_extra == 1+LINK_SIZE))\n            branch_extra += branch_newextra;\n          continue;\n          }\n\n        /test_snippet If options were terminated by ':' control comes here. Fall through\n        to handle the group below. test_snippet/\n        }\n      }\n\n    /test_snippet Extracting brackets must be counted so we can process escapes in a\n    Perlish way. If the number exceeds EXTRACT_BASIC_MAX we are going to\n    need an additional 3 bytes of store per extracting bracket. However, if\n    PCRE_NO_AUTO)CAPTURE is set, unadorned brackets become non-capturing, so we\n    must leave the count alone (it will aways be zero). test_snippet/\n\n    else if ((options & PCRE_NO_AUTO_CAPTURE) == 0)\n      {\n      bracount++;\n      if (bracount > EXTRACT_BASIC_MAX) bracket_length += 3;\n      }\n\n    /test_snippet Save length for computing whole length at end if there's a repeat that\n    requires duplication of the group. Also save the current value of\n    branch_extra, and start the new group with the new value. If non-zero, this\n    will either be 2 for a (?imsx: group, or 3 for a lookbehind assertion. test_snippet/\n\n    if (brastackptr >= sizeof(brastack)/sizeof(int))\n      {\n      test_snippeterrorptr = ERR19;\n      goto PCRE_ERROR_RETURN;\n      }\n\n    bralenstack[brastackptr] = branch_extra;\n    branch_extra = branch_newextra;\n\n    brastack[brastackptr++] = length;\n    length += bracket_length;\n    continue;\n\n    /test_snippet Handle ket. Look for subsequent max/min; for certain sets of values we\n    have to replicate this bracket up to that many times. If brastackptr is\n    0 this is an unmatched bracket which will generate an error, but take care\n    not to try to access brastack[-1] when computing the length and restoring\n    the branch_extra value. test_snippet/\n\n    case ')':\n    length += 1 + LINK_SIZE;\n    if (brastackptr > 0)\n      {\n      duplength = length - brastack[--brastackptr];\n      branch_extra = bralenstack[brastackptr];\n      }\n    else duplength = 0;\n\n    /test_snippet The following code is also used when a recursion such as (?3) is\n    followed by a quantifier, because in that case, it has to be wrapped inside\n    brackets so that the quantifier works. The value of duplength must be\n    set before arrival. test_snippet/\n\n    HANDLE_QUANTIFIED_BRACKETS:\n\n    /test_snippet Leave ptr at the final char; for read_repeat_counts this happens\n    automatically; for the others we need an increment. test_snippet/\n\n    if ((c = ptr[1]) == '{' && is_counted_repeat(ptr+2))\n      {\n      ptr = read_repeat_counts(ptr+2, &min, &max, errorptr);\n      if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n      }\n    else if (c == 'test_snippet') { min = 0; max = -1; ptr++; }\n    else if (c == '+') { min = 1; max = -1; ptr++; }\n    else if (c == '?') { min = 0; max = 1;  ptr++; }\n    else { min = 1; max = 1; }\n\n    /test_snippet If the minimum is zero, we have to allow for an OP_BRAZERO before the\n    group, and if the maximum is greater than zero, we have to replicate\n    maxval-1 times; each replication acquires an OP_BRAZERO plus a nesting\n    bracket set. test_snippet/\n\n    if (min == 0)\n      {\n      length++;\n      if (max > 0) length += (max - 1) test_snippet (duplength + 3 + 2test_snippetLINK_SIZE);\n      }\n\n    /test_snippet When the minimum is greater than zero, we have to replicate up to\n    minval-1 times, with no additions required in the copies. Then, if there\n    is a limited maximum we have to replicate up to maxval-1 times allowing\n    for a BRAZERO item before each optional copy and nesting brackets for all\n    but one of the optional copies. test_snippet/\n\n    else\n      {\n      length += (min - 1) test_snippet duplength;\n      if (max > min)   /test_snippet Need this test as max=-1 means no limit test_snippet/\n        length += (max - min) test_snippet (duplength + 3 + 2test_snippetLINK_SIZE)\n          - (2 + 2test_snippetLINK_SIZE);\n      }\n\n    /test_snippet Allow space for once brackets for \"possessive quantifier\" test_snippet/\n\n    if (ptr[1] == '+')\n      {\n      ptr++;\n      length += 2 + 2test_snippetLINK_SIZE;\n      }\n    continue;\n\n    /test_snippet Non-special character. It won't be space or # in extended mode, so it is\n    always a genuine character. If we are in a \\Q...\\E sequence, check for the\n    end; if not, we have a literal. test_snippet/\n\n    default:\n    NORMAL_CHAR:\n\n    if (inescq && c == '\\\\' && ptr[1] == 'E')\n      {\n      inescq = FALSE;\n      ptr++;\n      continue;\n      }\n\n    length += 2;          /test_snippet For a one-byte character test_snippet/\n    lastitemlength = 1;   /test_snippet Default length of last item for repeats test_snippet/\n\n    /test_snippet In UTF-8 mode, check for additional bytes. test_snippet/\n\n#ifdef SUPPORT_UTF8\n    if (utf8 && (c & 0xc0) == 0xc0)\n      {\n      while ((ptr[1] & 0xc0) == 0x80)         /test_snippet Can't flow over the end test_snippet/\n        {                                     /test_snippet because the end is marked test_snippet/\n        lastitemlength++;                     /test_snippet by a zero byte. test_snippet/\n        length++;\n        ptr++;\n        }\n      }\n#endif\n\n    continue;\n    }\n  }\n\nlength += 2 + LINK_SIZE;    /test_snippet For final KET and END test_snippet/\n\nif ((options & PCRE_AUTO_CALLOUT) != 0)\n  length += 2 + 2test_snippetLINK_SIZE;  /test_snippet For final callout test_snippet/\n\nif (length > MAX_PATTERN_SIZE)\n  {\n  test_snippeterrorptr = ERR20;\n  return NULL;\n  }\n\n/test_snippet Compute the size of data block needed and get it, either from malloc or\nexternally provided function. test_snippet/\n\nsize = length + sizeof(real_pcre) + name_count test_snippet (max_name_size + 3);\nre = (real_pcre test_snippet)(pcre_malloc)(size);\n\nif (re == NULL)\n  {\n  test_snippeterrorptr = ERR21;\n  return NULL;\n  }\n\n/test_snippet Put in the magic number, and save the sizes, options, and character table\npointer. NULL is used for the default character tables. The nullpad field is at\nthe end; it's there to help in the case when a regex compiled on a system with\n4-byte pointers is run on another with 8-byte pointers. test_snippet/\n\nre->magic_number = MAGIC_NUMBER;\nre->size = size;\nre->options = options;\nre->dummy1 = re->dummy2 = 0;\nre->name_table_offset = sizeof(real_pcre);\nre->name_entry_size = max_name_size + 3;\nre->name_count = name_count;\nre->tables = (tables == pcre_default_tables)? NULL : tables;\nre->nullpad = NULL;\n\n/test_snippet The starting points of the name/number translation table and of the code are\npassed around in the compile data block. test_snippet/\n\ncompile_block.names_found = 0;\ncompile_block.name_entry_size = max_name_size + 3;\ncompile_block.name_table = (uschar test_snippet)re + re->name_table_offset;\ncodestart = compile_block.name_table + re->name_entry_size test_snippet re->name_count;\ncompile_block.start_code = codestart;\ncompile_block.start_pattern = (const uschar test_snippet)pattern;\ncompile_block.req_varyopt = 0;\ncompile_block.nopartial = FALSE;\n\n/test_snippet Set up a starting, non-extracting bracket, then compile the expression. On\nerror, test_snippeterrorptr will be set non-NULL, so we don't need to look at the result\nof the function here. test_snippet/\n\nptr = (const uschar test_snippet)pattern;\ncode = (uschar test_snippet)codestart;\ntest_snippetcode = OP_BRA;\nbracount = 0;\n(void)compile_regex(options, options & PCRE_IMS, &bracount, &code, &ptr,\n  errorptr, FALSE, 0, &firstbyte, &reqbyte, NULL, &compile_block);\nre->top_bracket = bracount;\nre->top_backref = compile_block.top_backref;\n\nif (compile_block.nopartial) re->options |= PCRE_NOPARTIAL;\n\n/test_snippet If not reached end of pattern on success, there's an excess bracket. test_snippet/\n\nif (test_snippeterrorptr == NULL && test_snippetptr != 0) test_snippeterrorptr = ERR22;\n\n/test_snippet Fill in the terminating state and check for disastrous overflow, but\nif debugging, leave the test till after things are printed out. test_snippet/\n\ntest_snippetcode++ = OP_END;\n\n#ifndef DEBUG\nif (code - codestart > length) test_snippeterrorptr = ERR23;\n#endif\n\n/test_snippet Give an error if there's back reference to a non-existent capturing\nsubpattern. test_snippet/\n\nif (re->top_backref > re->top_bracket) test_snippeterrorptr = ERR15;\n\n/test_snippet Failed to compile, or error while post-processing test_snippet/\n\nif (test_snippeterrorptr != NULL)\n  {\n  (pcre_free)(re);\n  PCRE_ERROR_RETURN:\n  test_snippeterroroffset = ptr - (const uschar test_snippet)pattern;\n  return NULL;\n  }\n\n/test_snippet If the anchored option was not passed, set the flag if we can determine that\nthe pattern is anchored by virtue of ^ characters or \\A or anything else (such\nas starting with .test_snippet when DOTALL is set).\n\nOtherwise, if we know what the first character has to be, save it, because that\nspeeds up unanchored matches no end. If not, see if we can set the\nPCRE_STARTLINE flag. This is helpful for multiline matches when all branches\nstart with ^. and also when all branches start with .test_snippet for non-DOTALL matches.\ntest_snippet/\n\nif ((options & PCRE_ANCHORED) == 0)\n  {\n  int temp_options = options;\n  if (is_anchored(codestart, &temp_options, 0, compile_block.backref_map))\n    re->options |= PCRE_ANCHORED;\n  else\n    {\n    if (firstbyte < 0)\n      firstbyte = find_firstassertedchar(codestart, &temp_options, FALSE);\n    if (firstbyte >= 0)   /test_snippet Remove caseless flag for non-caseable chars test_snippet/\n      {\n      int ch = firstbyte & 255;\n      re->first_byte = ((firstbyte & REQ_CASELESS) != 0 &&\n         compile_block.fcc[ch] == ch)? ch : firstbyte;\n      re->options |= PCRE_FIRSTSET;\n      }\n    else if (is_startline(codestart, 0, compile_block.backref_map))\n      re->options |= PCRE_STARTLINE;\n    }\n  }\n\n/test_snippet For an anchored pattern, we use the \"required byte\" only if it follows a\nvariable length item in the regex. Remove the caseless flag for non-caseable\nbytes. test_snippet/\n\nif (reqbyte >= 0 &&\n     ((re->options & PCRE_ANCHORED) == 0 || (reqbyte & REQ_VARY) != 0))\n  {\n  int ch = reqbyte & 255;\n  re->req_byte = ((reqbyte & REQ_CASELESS) != 0 &&\n    compile_block.fcc[ch] == ch)? (reqbyte & ~REQ_CASELESS) : reqbyte;\n  re->options |= PCRE_REQCHSET;\n  }\n\n/test_snippet Print out the compiled data for debugging test_snippet/\n\n#ifdef DEBUG\n\nprintf(\"Length = %d top_bracket = %d top_backref = %d\\n\",\n  length, re->top_bracket, re->top_backref);\n\nif (re->options != 0)\n  {\n  printf(\"%s%s%s%s%s%s%s%s%s%s\\n\",\n    ((re->options & PCRE_NOPARTIAL) != 0)? \"nopartial \" : \"\",\n    ((re->options & PCRE_ANCHORED) != 0)? \"anchored \" : \"\",\n    ((re->options & PCRE_CASELESS) != 0)? \"caseless \" : \"\",\n    ((re->options & PCRE_ICHANGED) != 0)? \"case state changed \" : \"\",\n    ((re->options & PCRE_EXTENDED) != 0)? \"extended \" : \"\",\n    ((re->options & PCRE_MULTILINE) != 0)? \"multiline \" : \"\",\n    ((re->options & PCRE_DOTALL) != 0)? \"dotall \" : \"\",\n    ((re->options & PCRE_DOLLAR_ENDONLY) != 0)? \"endonly \" : \"\",\n    ((re->options & PCRE_EXTRA) != 0)? \"extra \" : \"\",\n    ((re->options & PCRE_UNGREEDY) != 0)? \"ungreedy \" : \"\");\n  }\n\nif ((re->options & PCRE_FIRSTSET) != 0)\n  {\n  int ch = re->first_byte & 255;\n  const char test_snippetcaseless = ((re->first_byte & REQ_CASELESS) == 0)? \"\" : \" (caseless)\";\n  if (isprint(ch)) printf(\"First char = %c%s\\n\", ch, caseless);\n    else printf(\"First char = \\\\x%02x%s\\n\", ch, caseless);\n  }\n\nif ((re->options & PCRE_REQCHSET) != 0)\n  {\n  int ch = re->req_byte & 255;\n  const char test_snippetcaseless = ((re->req_byte & REQ_CASELESS) == 0)? \"\" : \" (caseless)\";\n  if (isprint(ch)) printf(\"Req char = %c%s\\n\", ch, caseless);\n    else printf(\"Req char = \\\\x%02x%s\\n\", ch, caseless);\n  }\n\nprint_internals(re, stdout);\n\n/test_snippet This check is done here in the debugging case so that the code that\nwas compiled can be seen. test_snippet/\n\nif (code - codestart > length)\n  {\n  test_snippeterrorptr = ERR23;\n  (pcre_free)(re);\n  test_snippeterroroffset = ptr - (uschar test_snippet)pattern;\n  return NULL;\n  }\n#endif\n\nreturn (pcre test_snippet)re;\n}",
    "predicted": ""
  },
  "httpd_ab06973d0302917c1f257c16b1b975308a1c0cbd_0", {
    "ID": "httpd_ab06973d0302917c1f257c16b1b975308a1c0cbd_0",
    "UID": "43",
    "code": "AP_DECLARE(int) ap_is_url(const char test_snippet\n{\n    register int x;\n\n    for (x = 0; u[x] != ':'; x++) {\n        if ((!u[x]) ||\n            ((!apr_isalpha(u[x])) && (!apr_isdigit(u[x])) &&\n             (u[x] != '+') && (u[x] != '-') && (u[x] != '.'))) {\n            return 0;\n        }\n    }\n\n    return (x ? 1 : 0);                \n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_e3ec760b501958ff083393daf94fdf69deaaaf89_0", {
    "ID": "httpd_e3ec760b501958ff083393daf94fdf69deaaaf89_0",
    "UID": "45",
    "code": "static void remove_items(apr_pool_t *p, apr_array_header_t test_snippet\n                         apr_hash_t *mappings)\n{\n    attrib_info *suffix = (attrib_info *) remove->elts;\n    int i;\n    for (i = 0; i < remove->nelts; i++) {\n        extension_info *exinfo = apr_hash_get(mappings,\n                                              suffix[i].name,\n                                              APR_HASH_KEY_STRING);\n        if (exinfo && *(const char**)((char *)exinfo + suffix[i].offset)) {\n            extension_info *copyinfo = exinfo;\n            exinfo = (extension_info*)apr_palloc(p, sizeof(*exinfo));\n            apr_hash_set(mappings, suffix[i].name,\n                         APR_HASH_KEY_STRING, exinfo);\n            memcpy(exinfo, copyinfo, sizeof(*exinfo));\n            *(const char**)((char *)exinfo + suffix[i].offset) = NULL;\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_ea89a90586effcd333e6ff8d3f798a6ccb75a955_0", {
    "ID": "httpd_ea89a90586effcd333e6ff8d3f798a6ccb75a955_0",
    "UID": "48",
    "code": "AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t test_snippet\n                                          apr_size_t *read, request_rec *r,\n                                          int fold, apr_bucket_brigade *bb)\n{\n    apr_status_t rv;\n    apr_bucket *e;\n    apr_size_t bytes_handled = 0, current_alloc = 0;\n    char *pos, *last_char = *s;\n    int do_alloc = (*s == NULL), saw_eos = 0;\n\n    for (;;) {\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_GETLINE,\n                            APR_BLOCK_READ, 0);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        \n        if (APR_BRIGADE_EMPTY(bb)) {\n            return APR_EGENERAL;\n        }\n\n        for (e = APR_BRIGADE_FIRST(bb);\n             e != APR_BRIGADE_SENTINEL(bb);\n             e = APR_BUCKET_NEXT(e))\n        {\n            const char *str;\n            apr_size_t len;\n\n            \n            if (APR_BUCKET_IS_EOS(e)) {\n                saw_eos = 1;\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &letest_snippet APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            if (len == 0) {\n                /* no use attempting a zero-byte alloc (hurts when\n                 * using --with-efence --enable-pool-debug) or\n                 * doing any of the other logic either\n                 */\n                continue;\n            }\n\n            \n            if (n < bytes_handled + len) {\n                *read = bytes_handled;\n                if (*s) {\n                    \n                    if (bytes_handled > 0) {\n                        (*s)[bytes_handled-1] = '\\0';\n                    }\n                    else {\n                        (*s)[0] = '\\0';\n                    }\n                }\n                return APR_ENOSPC;\n            }\n\n            \n            if (do_alloc) {\n                \n                if (!*s) {\n                    current_alloc = len;\n                    if (current_alloc < MIN_LINE_ALLOC) {\n                        current_alloc = MIN_LINE_ALLOC;\n                    }\n                    *s = apr_palloc(r->pool, current_alloc);\n                }\n                else if (bytes_handled + len > current_alloc) {\n                    \n                    apr_size_t new_size = current_alloc * 2;\n                    char *new_buffer;\n\n                    if (bytes_handled + len > new_size) {\n                        new_size = (bytes_handled + len) * 2;\n                    }\n\n                    new_buffer = apr_palloc(r->pool, new_size);\n\n                    \n                    memcpy(new_buffer, *s, bytes_handled);\n                    current_alloc = new_size;\n                    *s = new_buffer;\n                }\n            }\n\n            \n            pos = *s + bytes_handled;\n            memcpy(pos, str, len);\n            last_char = pos + len - 1;\n\n            \n            bytes_handled += len;\n        }\n\n        \n        if (last_char && (*last_char == APR_ASCII_LF)) {\n            break;\n        }\n    }\n\n    /* Now NUL-terminate the string at the end of the line;\n     * if the last-but-one character is a CR, terminate there */\n    if (last_char > *s && last_char[-1] == APR_ASCII_CR) {\n        last_char--;\n    }\n    *last_char = '\\0';\n    bytes_handled = last_char - *s;\n\n    /* If we're folding, we have more work to do.\n     *\n     * Note that if an EOS was seetest_snippet we know we can't have another line.\n     */\n    if (fold && bytes_handled && !saw_eos) {\n        for (;;) {\n            const char *str;\n            apr_size_t len;\n            char c;\n\n            \n            apr_brigade_cleanup(bb);\n\n            \n            rv = ap_get_brigade(r->input_filters, bb, AP_MODE_SPECULATIVE,\n                                APR_BLOCK_READ, 1);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            if (APR_BRIGADE_EMPTY(bb)) {\n                break;\n            }\n\n            e = APR_BRIGADE_FIRST(bb);\n\n            \n            if (APR_BUCKET_IS_EOS(e)) {\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &letest_snippet APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                apr_brigade_cleanup(bb);\n                return rv;\n            }\n\n            /* Found one, so call ourselves again to get the next line.\n             *\n             * FIXME: If the folding line is completely blank, should we\n             * stop folding?  Does that require also looking at the next\n             * char?\n             */\n            /* When we call destroy, the buckets are deleted, so save that\n             * one character we need.  This simplifies our execution paths\n             * at the cost of one character read.\n             */\n            c = *str;\n            if (c == APR_ASCII_BLANK || c == APR_ASCII_TAB) {\n                \n                if (bytes_handled >= n) {\n                    *read = n;\n                    \n                    (*s)[n-1] = '\\0';\n                    return APR_ENOSPC;\n                }\n                else {\n                    apr_size_t next_size, next_len;\n                    char *tmp;\n\n                    /* If we're doing the allocations for them, we have to\n                     * give ourselves a NULL and copy it on return.\n                     */\n                    if (do_alloc) {\n                        tmp = NULL;\n                    } else {\n                        \n                        tmp = last_char;\n                    }\n\n                    next_size = n - bytes_handled;\n\n                    rv = ap_rgetline_core(&tmp, next_size,\n                                          &next_letest_snippet r, 0, bb);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n\n                    if (do_alloc && next_len > 0) {\n                        char *new_buffer;\n                        apr_size_t new_size = bytes_handled + next_len + 1;\n\n                        \n                        new_buffer = apr_palloc(r->pool, new_size);\n\n                        \n                        memcpy(new_buffer, *s, bytes_handled);\n\n                        \n                        memcpy(new_buffer + bytes_handled, tmp, next_len + 1);\n                        *s = new_buffer;\n                    }\n\n                    last_char += next_len;\n                    bytes_handled += next_len;\n                }\n            }\n            else { \n                break;\n            }\n        }\n    }\n\n    *read = bytes_handled;\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_0c8c099c029a351665ce20d0076a6fac36bf65cc_0", {
    "ID": "httpd_0c8c099c029a351665ce20d0076a6fac36bf65cc_0",
    "UID": "54",
    "code": "static apr_status_t test_snippet\n                              apr_proc_t *newproc, const char *progname,\n                              const char * const *args,\n                              const char * const *env,\n                              apr_procattr_t *attr, ap_unix_identity_t *ugid,\n                              apr_pool_t *p)\n{\n    int i = 0;\n    const char **newargs;\n    char *newprogname;\n    char *execuser, *execgroup;\n    const char *argv0;\n\n    if (!unixd_config.suexec_enabled) {\n        return apr_proc_create(newproc, progname, args, env, attr, p);\n    }\n\n    argv0 = ap_strrchr_c(progname, '/');\n    \n    if (argv0 != NULL) {\n        argv0++;\n    }\n    else {\n        argv0 = progname;\n    }\n\n\n    if (ugid->userdir) {\n        execuser = apr_psprintf(p, \"~%ld\", (long) ugid->uid);\n    }\n    else {\n        execuser = apr_psprintf(p, \"%ld\", (long) ugid->uid);\n    }\n    execgroup = apr_psprintf(p, \"%ld\", (long) ugid->gid);\n\n    if (!execuser || !execgroup) {\n        return APR_ENOMEM;\n    }\n\n    i = 0;\n    if (args) {\n        while (args[i]) {\n            i++;\n            }\n    }\n    \n    newargs = apr_palloc(p, sizeof(char *) * (i + 4));\n    newprogname = SUEXEC_BIN;\n    newargs[0] = SUEXEC_BIN;\n    newargs[1] = execuser;\n    newargs[2] = execgroup;\n    newargs[3] = apr_pstrdup(p, argv0);\n\n    /*\n    ** using a shell to execute suexec makes no sense thus\n    ** we force everything to be APR_PROGRAM, and never\n    ** APR_SHELLCMD\n    */\n    if(apr_procattr_cmdtype_set(attr, APR_PROGRAM) != APR_SUCCESS) {\n        return APR_EGENERAL;\n    }\n\n    i = 1;\n    do {\n        newargs[i + 3] = args[i];\n    } while (args[i++]);\n\n    return apr_proc_create(newproc, newprogname, newargs, env, attr, p);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_bf2ab2ff27c683149a5fa99ddaa93401c6e71582_0", {
    "ID": "httpd_bf2ab2ff27c683149a5fa99ddaa93401c6e71582_0",
    "UID": "55",
    "code": "static int status_handler(request_rec test_snippet\n{\n    const char *loc;\n    apr_time_t nowtime;\n    apr_interval_time_t up_time;\n    int j, i, res;\n    int ready;\n    int busy;\n    unsigned long count;\n    unsigned long lres, my_lres, conn_lres;\n    apr_off_t bytes, my_bytes, conn_bytes;\n    apr_off_t bcount, kbcount;\n    long req_time;\n#ifdef HAVE_TIMES\n    float tick;\n    int times_per_thread = getpid() != child_pid;\n#endif\n    int short_report;\n    int no_table_report;\n    worker_score *ws_record;\n    process_score *ps_record;\n    char *stat_buffer;\n    pid_t *pid_buffer, worker_pid;\n    clock_t tu, ts, tcu, tcs;\n    ap_generation_t worker_generation;\n\n    if (strcmp(r->handler, STATUS_MAGIC_TYPE) &&\n        strcmp(r->handler, \"server-status\")) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_TIMES\n#ifdef _SC_CLK_TCK\n    tick = sysconf(_SC_CLK_TCK);\n#else\n    tick = HZ;\n#endif\n#endif\n\n    ready = 0;\n    busy = 0;\n    count = 0;\n    bcount = 0;\n    kbcount = 0;\n    short_report = 0;\n    no_table_report = 0;\n\n    pid_buffer = apr_palloc(r->pool, server_limit * sizeof(pid_t));\n    stat_buffer = apr_palloc(r->pool, server_limit * thread_limit * sizeof(char));\n\n    nowtime = apr_time_now();\n    tu = ts = tcu = tcs = 0;\n\n    if (!ap_exists_scoreboard_image()) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Server status unavailable in inetd mode\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->allowed = (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET)\n        return DECLINED;\n\n    ap_set_content_type(r, \"text/html\");\n\n    /*\n     * Simple table-driven form data set parser that lets you alter the header\n     */\n\n    if (r->args) {\n        i = 0;\n        while (status_options[i].id != STAT_OPT_END) {\n            if ((loc = ap_strstr_c(r->args,\n                                   status_options[i].form_data_str)) != NULL) {\n                switch (status_options[i].id) {\n                case STAT_OPT_REFRESH:\n                    if (*(loc + strlen(status_options[i].form_data_str)) == '='\n                        && atol(loc + strlen(status_options[i].form_data_str)\n                                + 1) > 0)\n                        apr_table_set(r->headers_out,\n                                      status_options[i].hdr_out_str,\n                                      loc +\n                                      strlen(status_options[i].hdr_out_str) +\n                                      1);\n                    else\n                        apr_table_set(r->headers_out,\n                                      status_options[i].hdr_out_str, \"1\");\n                    break;\n                case STAT_OPT_NOTABLE:\n                    no_table_report = 1;\n                    break;\n                case STAT_OPT_AUTO:\n                    ap_set_content_type(r, \"text/plain\");\n                    short_report = 1;\n                    break;\n                }\n            }\n\n            i++;\n        }\n    }\n\n    for (i = 0; i < server_limit; ++i) {\n#ifdef HAVE_TIMES\n        clock_t proc_tu = 0, proc_ts = 0, proc_tcu = 0, proc_tcs = 0;\n        clock_t tmp_tu, tmp_ts, tmp_tcu, tmp_tcs;\n#endif\n\n        ps_record = ap_get_scoreboard_process(i);\n        for (j = 0; j < thread_limit; ++j) {\n            int indx = (i * thread_limit) + j;\n\n            ws_record = ap_get_scoreboard_worker(i, j);\n            res = ws_record->status;\n            stat_buffer[indx] = status_flags[res];\n\n            if (!ps_record->quiescing\n                && ps_record->pid) {\n                if (res == SERVER_READY\n                    && ps_record->generation == ap_my_generation)\n                    ready++;\n                else if (res != SERVER_DEAD &&\n                         res != SERVER_STARTING &&\n                         res != SERVER_IDLE_KILL)\n                    busy++;\n            }\n\n            /* XXX what about the counters for quiescing/seg faulted\n             * processes?  should they be counted or not?  GLA\n             */\n            if (ap_extended_status) {\n                lres = ws_record->access_count;\n                bytes = ws_record->bytes_served;\n\n                if (lres != 0 || (res != SERVER_READY && res != SERVER_DEAD)) {\n#ifdef HAVE_TIMES\n                    tmp_tu = ws_record->times.tms_utime;\n                    tmp_ts = ws_record->times.tms_stime;\n                    tmp_tcu = ws_record->times.tms_cutime;\n                    tmp_tcs = ws_record->times.tms_cstime;\n\n                    if (times_per_thread) {\n                        proc_tu += tmp_tu;\n                        proc_ts += tmp_ts;\n                        proc_tcu += tmp_tcu;\n                        proc_tcs += proc_tcs;\n                    }\n                    else {\n                        if (tmp_tu > proc_tu ||\n                            tmp_ts > proc_ts ||\n                            tmp_tcu > proc_tcu ||\n                            tmp_tcs > proc_tcs) {\n                            proc_tu = tmp_tu;\n                            proc_ts = tmp_ts;\n                            proc_tcu = tmp_tcu;\n                            proc_tcs = proc_tcs;\n                        }\n                    }\n#endif \n\n                    count += lres;\n                    bcount += bytes;\n\n                    if (bcount >= KBYTE) {\n                        kbcount += (bcount >> 10);\n                        bcount = bcount & 0x3ff;\n                    }\n                }\n            }\n        }\n#ifdef HAVE_TIMES\n        tu += proc_tu;\n        ts += proc_ts;\n        tcu += proc_tcu;\n        tcs += proc_tcs;\n#endif\n        pid_buffer[i] = ps_record->pid;\n    }\n\n    \n    up_time = (apr_uint32_t) apr_time_sec(nowtime -\n                               ap_scoreboard_image->global->restart_time);\n\n    if (!short_report) {\n        ap_rputs(DOCTYPE_HTML_3_2\n                 \"<html><head>\\n<title>Apache Status</title>\\n</head><body>\\n\",\n                 r);\n        ap_rputs(\"<h1>Apache Server Status for \", r);\n        ap_rvputs(r, ap_get_server_name(r), \"</h1>\\n\\n\", NULL);\n        ap_rvputs(r, \"<dl><dt>Server Version: \",\n                  ap_get_server_version(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Server Built: \",\n                  ap_get_server_built(), \"\\n</dt></dl><hr /><dl>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Current Time: \",\n                  ap_ht_time(r->pool, nowtime, DEFAULT_TIME_FORMAT, 0),\n                             \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Restart Time: \",\n                  ap_ht_time(r->pool,\n                             ap_scoreboard_image->global->restart_time,\n                             DEFAULT_TIME_FORMAT, 0),\n                  \"</dt>\\n\", NULL);\n        ap_rprintf(r, \"<dt>Parent Server Generation: %d</dt>\\n\",\n                   (int)ap_my_generation);\n        ap_rputs(\"<dt>Server uptime: \", r);\n        show_time(r, up_time);\n        ap_rputs(\"</dt>\\n\", r);\n    }\n\n    if (ap_extended_status) {\n        if (short_report) {\n            ap_rprintf(r, \"Total Accesses: %lu\\nTotal kBytes: %\"\n                       APR_OFF_T_FMT \"\\n\",\n                       count, kbcount);\n\n#ifdef HAVE_TIMES\n            \n            if (ts || tu || tcu || tcs)\n                ap_rprintf(r, \"CPULoad: %g\\n\",\n                           (tu + ts + tcu + tcs) / tick / up_time * 100.);\n#endif\n\n            ap_rprintf(r, \"Uptime: %ld\\n\", (long) (up_time));\n            if (up_time > 0)\n                ap_rprintf(r, \"ReqPerSec: %g\\n\",\n                           (float) count / (float) up_time);\n\n            if (up_time > 0)\n                ap_rprintf(r, \"BytesPerSec: %g\\n\",\n                           KBYTE * (float) kbcount / (float) up_time);\n\n            if (count > 0)\n                ap_rprintf(r, \"BytesPerReq: %g\\n\",\n                           KBYTE * (float) kbcount / (float) count);\n        }\n        else { \n            ap_rprintf(r, \"<dt>Total accesses: %lu - Total Traffic: \", count);\n            format_kbyte_out(r, kbcount);\n            ap_rputs(\"</dt>\\n\", r);\n\n#ifdef HAVE_TIMES\n            \n            ap_rprintf(r, \"<dt>CPU Usage: u%g s%g cu%g cs%g\",\n                       tu / tick, ts / tick, tcu / tick, tcs / tick);\n\n            if (ts || tu || tcu || tcs)\n                ap_rprintf(r, \" - %.3g%% CPU load</dt>\\n\",\n                           (tu + ts + tcu + tcs) / tick / up_time * 100.);\n#endif\n\n            if (up_time > 0)\n                ap_rprintf(r, \"<dt>%.3g requests/sec - \",\n                           (float) count / (float) up_time);\n\n            if (up_time > 0) {\n                format_byte_out(r, (unsigned long)(KBYTE * (float) kbcount\n                                                   / (float) up_time));\n                ap_rputs(\"/second - \", r);\n            }\n\n            if (count > 0) {\n                format_byte_out(r, (unsigned long)(KBYTE * (float) kbcount\n                                                   / (float) count));\n                ap_rputs(\"/request\", r);\n            }\n\n            ap_rputs(\"</dt>\\n\", r);\n        } \n    } \n\n    if (!short_report)\n        ap_rprintf(r, \"<dt>%d requests currently being processed, \"\n                      \"%d idle workers</dt>\\n\", busy, ready);\n    else\n        ap_rprintf(r, \"BusyWorkers: %d\\nIdleWorkers: %d\\n\", busy, ready);\n\n    \n    if (!short_report)\n        ap_rputs(\"</dl><pre>\", r);\n    else\n        ap_rputs(\"Scoreboard: \", r);\n\n    for (i = 0; i < server_limit; ++i) {\n        for (j = 0; j < thread_limit; ++j) {\n            int indx = (i * thread_limit) + j;\n            ap_rputc(stat_buffer[indx], r);\n            if ((indx % STATUS_MAXLINE == (STATUS_MAXLINE - 1))\n                && !short_report)\n                ap_rputs(\"\\n\", r);\n        }\n    }\n\n    if (short_report)\n        ap_rputs(\"\\n\", r);\n    else {\n        ap_rputs(\"</pre>\\n\", r);\n        ap_rputs(\"<p>Scoreboard Key:<br />\\n\", r);\n        ap_rputs(\"\\\"<b><code>_</code></b>\\\" Waiting for Connection, \\n\", r);\n        ap_rputs(\"\\\"<b><code>S</code></b>\\\" Starting up, \\n\", r);\n        ap_rputs(\"\\\"<b><code>R</code></b>\\\" Reading Request,<br />\\n\", r);\n        ap_rputs(\"\\\"<b><code>W</code></b>\\\" Sending Reply, \\n\", r);\n        ap_rputs(\"\\\"<b><code>K</code></b>\\\" Keepalive (read), \\n\", r);\n        ap_rputs(\"\\\"<b><code>D</code></b>\\\" DNS Lookup,<br />\\n\", r);\n        ap_rputs(\"\\\"<b><code>C</code></b>\\\" Closing connection, \\n\", r);\n        ap_rputs(\"\\\"<b><code>L</code></b>\\\" Logging, \\n\", r);\n        ap_rputs(\"\\\"<b><code>G</code></b>\\\" Gracefully finishing,<br /> \\n\", r);\n        ap_rputs(\"\\\"<b><code>I</code></b>\\\" Idle cleanup of worker, \\n\", r);\n        ap_rputs(\"\\\"<b><code>.</code></b>\\\" Open slot with no current process</p>\\n\", r);\n        ap_rputs(\"<p />\\n\", r);\n        if (!ap_extended_status) {\n            int j;\n            int k = 0;\n            ap_rputs(\"PID Key: <br />\\n\", r);\n            ap_rputs(\"<pre>\\n\", r);\n            for (i = 0; i < server_limit; ++i) {\n                for (j = 0; j < thread_limit; ++j) {\n                    int indx = (i * thread_limit) + j;\n\n                    if (stat_buffer[indx] != '.') {\n                        ap_rprintf(r, \"   %\" APR_PID_T_FMT\n                                   \" in state: %c \", pid_buffer[i],\n                                   stat_buffer[indx]);\n\n                        if (++k >= 3) {\n                            ap_rputs(\"\\n\", r);\n                            k = 0;\n                        } else\n                            ap_rputs(\",\", r);\n                    }\n                }\n            }\n\n            ap_rputs(\"\\n\", r);\n            ap_rputs(\"</pre>\\n\", r);\n        }\n    }\n\n    if (ap_extended_status && !short_report) {\n        if (no_table_report)\n            ap_rputs(\"<hr /><h2>Server Details</h2>\\n\\n\", r);\n        else\n            ap_rputs(\"\\n\\n<table border=\\\"0\\\"><tr>\"\n                     \"<th>Srv</th><th>PID</th><th>Acc</th>\"\n                     \"<th>M</th>\"\n#ifdef HAVE_TIMES\n                     \"<th>CPU\\n</th>\"\n#endif\n                     \"<th>SS</th><th>Req</th>\"\n                     \"<th>Conn</th><th>Child</th><th>Slot</th>\"\n                     \"<th>Client</th><th>VHost</th>\"\n                     \"<th>Request</th></tr>\\n\\n\", r);\n\n        for (i = 0; i < server_limit; ++i) {\n            for (j = 0; j < thread_limit; ++j) {\n                ws_record = ap_get_scoreboard_worker(i, j);\n\n                if (ws_record->access_count == 0 &&\n                    (ws_record->status == SERVER_READY ||\n                     ws_record->status == SERVER_DEAD)) {\n                    continue;\n                }\n\n                ps_record = ap_get_scoreboard_process(i);\n\n                if (ws_record->start_time == 0L)\n                    req_time = 0L;\n                else\n                    req_time = (long)\n                        ((ws_record->stop_time -\n                          ws_record->start_time) / 1000);\n                if (req_time < 0L)\n                    req_time = 0L;\n\n                lres = ws_record->access_count;\n                my_lres = ws_record->my_access_count;\n                conn_lres = ws_record->conn_count;\n                bytes = ws_record->bytes_served;\n                my_bytes = ws_record->my_bytes_served;\n                conn_bytes = ws_record->conn_bytes;\n                if (ws_record->pid) { \n                    worker_pid = ws_record->pid;\n                    worker_generation = ws_record->generation;\n                }\n                else {\n                    worker_pid = ps_record->pid;\n                    worker_generation = ps_record->generation;\n                }\n\n                if (no_table_report) {\n                    if (ws_record->status == SERVER_DEAD)\n                        ap_rprintf(r,\n                                   \"<b>Server %d-%d</b> (-): %d|%lu|%lu [\",\n                                   i, (int)worker_generation,\n                                   (int)conn_lres, my_lres, lres);\n                    else\n                        ap_rprintf(r,\n                                   \"<b>Server %d-%d</b> (%\"\n                                   APR_PID_T_FMT \"): %d|%lu|%lu [\",\n                                   i, (int) worker_generation,\n                                   worker_pid,\n                                   (int)conn_lres, my_lres, lres);\n\n                    switch (ws_record->status) {\n                    case SERVER_READY:\n                        ap_rputs(\"Ready\", r);\n                        break;\n                    case SERVER_STARTING:\n                        ap_rputs(\"Starting\", r);\n                        break;\n                    case SERVER_BUSY_READ:\n                        ap_rputs(\"<b>Read</b>\", r);\n                        break;\n                    case SERVER_BUSY_WRITE:\n                        ap_rputs(\"<b>Write</b>\", r);\n                        break;\n                    case SERVER_BUSY_KEEPALIVE:\n                        ap_rputs(\"<b>Keepalive</b>\", r);\n                        break;\n                    case SERVER_BUSY_LOG:\n                        ap_rputs(\"<b>Logging</b>\", r);\n                        break;\n                    case SERVER_BUSY_DNS:\n                        ap_rputs(\"<b>DNS lookup</b>\", r);\n                        break;\n                    case SERVER_CLOSING:\n                        ap_rputs(\"<b>Closing</b>\", r);\n                        break;\n                    case SERVER_DEAD:\n                        ap_rputs(\"Dead\", r);\n                        break;\n                    case SERVER_GRACEFUL:\n                        ap_rputs(\"Graceful\", r);\n                        break;\n                    case SERVER_IDLE_KILL:\n                        ap_rputs(\"Dying\", r);\n                        break;\n                    default:\n                        ap_rputs(\"?STATE?\", r);\n                        break;\n                    }\n\n                    ap_rprintf(r, \"] \"\n#ifdef HAVE_TIMES\n                               \"u%g s%g cu%g cs%g\"\n#endif\n                               \"\\n %ld %ld (\",\n#ifdef HAVE_TIMES\n                               ws_record->times.tms_utime / tick,\n                               ws_record->times.tms_stime / tick,\n                               ws_record->times.tms_cutime / tick,\n                               ws_record->times.tms_cstime / tick,\n#endif\n                               (long)apr_time_sec(nowtime -\n                                                  ws_record->last_used),\n                               (long) req_time);\n\n                    format_byte_out(r, conn_bytes);\n                    ap_rputs(\"|\", r);\n                    format_byte_out(r, my_bytes);\n                    ap_rputs(\"|\", r);\n                    format_byte_out(r, bytes);\n                    ap_rputs(\")\\n\", r);\n                    ap_rprintf(r,\n                               \" <i>%s {%s}</i> <b>[%s]</b><br />\\n\\n\",\n                               ap_escape_html(r->pool,\n                                              ws_record->client),\n                               ap_escape_html(r->pool,\n                                              ws_record->request),\n                               ap_escape_html(r->pool,\n                                              ws_record->vhost));\n                }\n                else { \n                    if (ws_record->status == SERVER_DEAD)\n                        ap_rprintf(r,\n                                   \"<tr><td><b>%d-%d</b></td><td>-</td><td>%d/%lu/%lu\",\n                                   i, (int)worker_generation,\n                                   (int)conn_lres, my_lres, lres);\n                    else\n                        ap_rprintf(r,\n                                   \"<tr><td><b>%d-%d</b></td><td>%\"\n                                   APR_PID_T_FMT\n                                   \"</td><td>%d/%lu/%lu\",\n                                   i, (int)worker_generation,\n                                   worker_pid,\n                                   (int)conn_lres,\n                                   my_lres, lres);\n\n                    switch (ws_record->status) {\n                    case SERVER_READY:\n                        ap_rputs(\"</td><td>_\", r);\n                        break;\n                    case SERVER_STARTING:\n                        ap_rputs(\"</td><td><b>S</b>\", r);\n                        break;\n                    case SERVER_BUSY_READ:\n                        ap_rputs(\"</td><td><b>R</b>\", r);\n                        break;\n                    case SERVER_BUSY_WRITE:\n                        ap_rputs(\"</td><td><b>W</b>\", r);\n                        break;\n                    case SERVER_BUSY_KEEPALIVE:\n                        ap_rputs(\"</td><td><b>K</b>\", r);\n                        break;\n                    case SERVER_BUSY_LOG:\n                        ap_rputs(\"</td><td><b>L</b>\", r);\n                        break;\n                    case SERVER_BUSY_DNS:\n                        ap_rputs(\"</td><td><b>D</b>\", r);\n                        break;\n                    case SERVER_CLOSING:\n                        ap_rputs(\"</td><td><b>C</b>\", r);\n                        break;\n                    case SERVER_DEAD:\n                        ap_rputs(\"</td><td>.\", r);\n                        break;\n                    case SERVER_GRACEFUL:\n                        ap_rputs(\"</td><td>G\", r);\n                        break;\n                    case SERVER_IDLE_KILL:\n                        ap_rputs(\"</td><td>I\", r);\n                        break;\n                    default:\n                        ap_rputs(\"</td><td>?\", r);\n                        break;\n                    }\n\n                    ap_rprintf(r,\n                               \"\\n</td>\"\n#ifdef HAVE_TIMES\n                               \"<td>%.2f</td>\"\n#endif\n                               \"<td>%ld</td><td>%ld\",\n#ifdef HAVE_TIMES\n                               (ws_record->times.tms_utime +\n                                ws_record->times.tms_stime +\n                                ws_record->times.tms_cutime +\n                                ws_record->times.tms_cstime) / tick,\n#endif\n                               (long)apr_time_sec(nowtime -\n                                                  ws_record->last_used),\n                               (long)req_time);\n\n                    ap_rprintf(r, \"</td><td>%-1.1f</td><td>%-2.2f</td><td>%-2.2f\\n\",\n                               (float)conn_bytes / KBYTE, (float) my_bytes / MBYTE,\n                               (float)bytes / MBYTE);\n\n                    if (ws_record->status == SERVER_BUSY_READ)\n                        ap_rprintf(r,\n                                   \"</td><td>?</td><td nowrap>?</td><td nowrap>..reading.. </td></tr>\\n\\n\");\n                    else\n                        ap_rprintf(r,\n                                   \"</td><td>%s</td><td nowrap>%s</td><td nowrap>%s</td></tr>\\n\\n\",\n                                   ap_escape_html(r->pool,\n                                                  ws_record->client),\n                                   ap_escape_html(r->pool,\n                                                  ws_record->vhost),\n                                   ap_escape_html(r->pool,\n                                                  ws_record->request));\n                } \n            } \n        } \n\n        if (!no_table_report) {\n            ap_rputs(\"</table>\\n \\\n<hr /> \\\n<table>\\n \\\n<tr><th>Srv</th><td>Child Server number - generation</td></tr>\\n \\\n<tr><th>PID</th><td>OS process ID</td></tr>\\n \\\n<tr><th>Acc</th><td>Number of accesses this connection / this child / this slot</td></tr>\\n \\\n<tr><th>M</th><td>Mode of operation</td></tr>\\n\"\n\n#ifdef HAVE_TIMES\n\"<tr><th>CPU</th><td>CPU usage, number of seconds</td></tr>\\n\"\n#endif\n\n\"<tr><th>SS</th><td>Seconds since beginning of most recent request</td></tr>\\n \\\n<tr><th>Req</th><td>Milliseconds required to process most recent request</td></tr>\\n \\\n<tr><th>Conn</th><td>Kilobytes transferred this connection</td></tr>\\n \\\n<tr><th>Child</th><td>Megabytes transferred this child</td></tr>\\n \\\n<tr><th>Slot</th><td>Total megabytes transferred this slot</td></tr>\\n \\\n</table>\\n\", r);\n        }\n    } \n    else {\n\n        if (!short_report) {\n            ap_rputs(\"<hr />To obtain a full report with current status \"\n                     \"information you need to use the \"\n                     \"<code>ExtendedStatus On</code> directive.\\n\", r);\n        }\n    }\n\n    {\n        \n        int flags =\n            (short_report ? AP_STATUS_SHORT : 0) |\n            (no_table_report ? AP_STATUS_NOTABLE : 0) |\n            (ap_extended_status ? AP_STATUS_EXTENDED : 0);\n\n        ap_run_status_hook(r, flags);\n    }\n\n    if (!short_report) {\n        ap_rputs(ap_psignature(\"<hr />\\n\",r), r);\n        ap_rputs(\"</body></html>\\n\", r);\n    }\n\n    return 0;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n"
  },
  "httpd_a07fee30cfb1a3c461bfccfe6aa6c83c320d1679_0", {
    "ID": "httpd_a07fee30cfb1a3c461bfccfe6aa6c83c320d1679_0",
    "UID": "58",
    "code": "static apr_status_t buffer_output(request_rec test_snippet\n                                  const char *str, apr_size_t len)\n{\n    conn_rec *c = r->connection;\n    ap_filter_t *f;\n    old_write_filter_ctx *ctx;\n\n    if (len == 0)\n        return APR_SUCCESS;\n\n    /* future optimization: record some flags in the request_rec to\n     * say whether we've added our filter, and whether it is first.\n     */\n\n    \n    for (f = r->output_filters; f != NULL; f = f->next) {\n        if (ap_old_write_func == f->frec)\n            break;\n    }\n\n    if (f == NULL) {\n        \n        ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ap_add_output_filter(\"OLD_WRITE\", ctx, r, r->connection);\n        f = r->output_filters;\n    }\n\n    /* if the first filter is not our buffering filter, then we have to\n     * deliver the content through the normal filter chain\n     */\n    if (f != r->output_filters) {\n        apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);\n        apr_bucket *b = apr_bucket_transient_create(str, len, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n\n        return ap_pass_brigade(r->output_filters, bb);\n    }\n\n    \n    ctx = r->output_filters->ctx;\n\n    if (ctx->bb == NULL) {\n        ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    }\n\n    return ap_fwrite(f->next, ctx->bb, str, len);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_55a7592f634dba3ea80a97888f6d64af2bcd3704_0", {
    "ID": "httpd_55a7592f634dba3ea80a97888f6d64af2bcd3704_0",
    "UID": "59",
    "code": "static const char *get_addresses(apr_pool_t *p, const char test_snippet\n                                 server_addr_rec ***paddr,\n                                 apr_port_t default_port)\n{\n    apr_sockaddr_t *my_addr;\n    server_addr_rec *sar;\n    char *w, *host, *scope_id;\n    int wild_port;\n    apr_size_t wlen;\n    apr_port_t port;\n    apr_status_t rv;\n\n    if (*w_ == '\\0')\n        return NULL;\n\n    w = apr_pstrdup(p, w_);\n    \n    wlen = strlen(w);                    \n    wild_port = 0;\n    if (w[wlen - 1] == '*') {\n        if (wlen < 2) {\n            wild_port = 1;\n        }\n        else if (w[wlen - 2] == ':') {\n            w[wlen - 2] = '\\0';\n            wild_port = 1;\n        }\n    }\n    rv = apr_parse_addr_port(&host, &scope_id, &port, w, p);\n    /* If the string is \"80\", apr_parse_addr_port() will be happy and set\n     * host to NULL and port to 80, so watch out for that.\n     */\n    if (rv != APR_SUCCESS) {\n        return \"The address or port is invalid\";\n    }\n    if (!host) {\n        return \"Missing address for VirtualHost\";\n    }\n    if (scope_id) {\n        return \"Scope ids are not supported\";\n    }\n    if (!port && !wild_port) {\n        port = default_port;\n    }\n\n    if (strcmp(host, \"*\") == 0) {\n        rv = apr_sockaddr_info_get(&my_addr, \"0.0.0.0\", APR_INET, port, 0, p);\n        if (rv) {\n            return \"Could not resolve address '0.0.0.0' -- \"\n                \"check resolver configuration.\";\n        }\n    }\n    else if (strcasecmp(host, \"_default_\") == 0\n        || strcmp(host, \"255.255.255.255\") == 0) {\n        rv = apr_sockaddr_info_get(&my_addr, \"255.255.255.255\", APR_INET, port, 0, p);\n        if (rv) {\n            return \"Could not resolve address '255.255.255.255' -- \"\n                \"check resolver configuration.\";\n        }\n    }\n    else {\n        rv = apr_sockaddr_info_get(&my_addr, host, APR_UNSPEC, port, 0, p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,\n                \"Could not resolve host name %s -- ignoring!\", host);\n            return NULL;\n        }\n    }\n\n    \n\n    do {\n        sar = apr_pcalloc(p, sizeof(server_addr_rec));\n        **paddr = sar;\n        *paddr = &sar->next;\n        sar->host_addr = my_addr;\n        sar->host_port = port;\n        sar->virthost = host;\n        my_addr = my_addr->next;\n    } while (my_addr);\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_25c6982100bdf5976d39c56aaf503258189048ef_0", {
    "ID": "httpd_25c6982100bdf5976d39c56aaf503258189048ef_0",
    "UID": "60",
    "code": "static void trie_node_link(apr_pool_t *p, filter_trie_node test_snippet\n                           filter_trie_node *child, int c)\n{\n    int i, j;\n\n    if (parent->nchildren == parent->size) {\n        filter_trie_child_ptr *new;\n        parent->size *= 2;\n        new = (filter_trie_child_ptr *)apr_palloc(p, parent->size *\n                                             sizeof(filter_trie_child_ptr));\n        memcpy(new, parent->children, parent->nchildren *\n               sizeof(filter_trie_child_ptr));\n        parent->children = new;\n    }\n\n    for (i = 0; i < parent->nchildren; i++) {\n        if (c == parent->children[i].c) {\n            return;\n        }\n        else if (c < parent->children[i].c) {\n            break;\n        }\n    }\n    for (j = parent->nchildren; j > i; j--) {\n        parent->children[j].c = parent->children[j - 1].c;\n        parent->children[j].child = parent->children[j - 1].child;\n    }\n    parent->children[i].c = c;\n    parent->children[i].child = child;\n\n    parent->nchildren++;\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow"
  },
  "httpd_3a88b0bf7033b0c632b0758afd3ebdcac764db85_0", {
    "ID": "httpd_3a88b0bf7033b0c632b0758afd3ebdcac764db85_0",
    "UID": "61",
    "code": "static apr_status_t htdbm_list(htdbm_t test_snippet\n{\n    apr_status_t rv;\n    apr_datum_t key, val;\n    char *rec, *cmnt;\n    char kb[MAX_STRING_LEN];\n    int i = 0;\n\n    rv = apr_dbm_firstkey(htdbm->dbm, &key);\n    if (rv != APR_SUCCESS) {\n        fprintf(stderr, \"Empty database -- %s\\n\", htdbm->filename);\n        return APR_ENOENT;\n    }\n    rec = apr_pcalloc(htdbm->pool, HUGE_STRING_LEN);\n\n    fprintf(stderr, \"Dumping records from database -- %s\\n\", htdbm->filename);\n    fprintf(stderr, \"    %-32sComment\\n\", \"Username\");\n    while (key.dptr != NULL) {\n        rv = apr_dbm_fetch(htdbm->dbm, key, &val);\n        if (rv != APR_SUCCESS) {\n            fprintf(stderr, \"Failed getting data from %s\\n\", htdbm->filename);\n            return APR_EGENERAL;\n        }\n        strncpy(kb, key.dptr, key.dsize);\n        kb[key.dsize] = '\\0';\n        fprintf(stderr, \"    %-32s\", kb);\n        strncpy(rec, val.dptr, val.dsize);\n        rec[val.dsize] = '\\0';\n        cmnt = strchr(rec, ':');\n        if (cmnt)\n            fprintf(stderr, \"%s\", cmnt + 1);\n        fprintf(stderr, \"\\n\");\n        rv = apr_dbm_nextkey(htdbm->dbm, &key);\n        if (rv != APR_SUCCESS)\n            fprintf(stderr, \"Failed getting NextKey\\n\");\n        ++i;\n    }\n\n    fprintf(stderr, \"Total #records : %d\\n\", i);\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_e9e7f37079d206d0d3c1a76323a6ed51a8363e7d_0", {
    "ID": "httpd_e9e7f37079d206d0d3c1a76323a6ed51a8363e7d_0",
    "UID": "65",
    "code": "int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e test_snippet\n{\n    int running_gen = 0;\n    int i;\n#if APR_HAS_SHARED_MEMORY\n    apr_status_t rv;\n#endif\n\n    if (ap_scoreboard_image) {\n        running_gen = ap_scoreboard_image->global->running_generation;\n        ap_scoreboard_image->global->restart_time = apr_time_now();\n        memset(ap_scoreboard_image->parent, 0,\n               sizeof(process_score) * server_limit);\n        for (i = 0; i < server_limit; i++) {\n            memset(ap_scoreboard_image->servers[i], 0,\n                   sizeof(worker_score) * thread_limit);\n        }\n        \n        if (lb_limit) {\n            memset(ap_scoreboard_image->balancers, 0,\n                   sizeof(lb_score) * lb_limit);\n        }\n        return OK;\n    }\n\n    ap_calc_scoreboard_size();\n#if APR_HAS_SHARED_MEMORY\n    if (sb_type == SB_SHARED) {\n        void *sb_shared;\n        rv = open_scoreboard(p);\n        if (rv || !(sb_shared = apr_shm_baseaddr_get(ap_scoreboard_shm))) {\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        memset(sb_shared, 0, scoreboard_size);\n        ap_init_scoreboard(sb_shared);\n    }\n    else\n#endif\n    {\n        \n        void *sb_mem = calloc(1, scoreboard_size);\n        if (sb_mem == NULL) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL,\n                         \"(%d)%s: cannot allocate scoreboard\",\n                         errno, strerror(errno));\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ap_init_scoreboard(sb_mem);\n    }\n\n    ap_scoreboard_image->global->sb_type = sb_type;\n    ap_scoreboard_image->global->running_generation = running_gen;\n    ap_scoreboard_image->global->restart_time = apr_time_now();\n\n    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_408877ab85541ec1bd72b15a897ec2cc52798b95_0", {
    "ID": "httpd_408877ab85541ec1bd72b15a897ec2cc52798b95_0",
    "UID": "74",
    "code": "static test_snippet\nmatch(REGISTER const uschar *eptr, REGISTER const uschar *ecode,\n  test_snippet offset_top, match_data *md, unsigned long test_snippet ims, eptrblock *eptrb,\n  test_snippet flags)\n{\n/* These variables do not need to be preserved over recursion in this function,\nso they can be ordinary variables in all cases. Mark them with \"register\"\nbecause they are used a lot in loops. */\n\nregister test_snippet rrc;    \nregister test_snippet i;      \nregister test_snippet c;      \n\n/* When recursion is not being used, all \"local\" variables that have to be\npreserved over calls to RMATCH() are part of a \"frame\" which is obtained from\nheap storage. Set up the top-level frame here; others are obtained from the\nheap whenever RMATCH() does a \"recursion\". See the macro definitions above. */\n\n#ifdef NO_RECURSE\nheapframe *frame = (pcre_stack_malloc)(sizeof(heapframe));\nframe->Xprevframe = NULL;            \n\n\n\nframe->Xeptr = eptr;\nframe->Xecode = ecode;\nframe->Xoffset_top = offset_top;\nframe->Xims = ims;\nframe->Xeptrb = eptrb;\nframe->Xflags = flags;\n\n\n\nHEAP_RECURSE:\n\n\n\n#define eptr               frame->Xeptr\n#define ecode              frame->Xecode\n#define offset_top         frame->Xoffset_top\n#define ims                frame->Xims\n#define eptrb              frame->Xeptrb\n#define flags              frame->Xflags\n\n\n\n#ifdef SUPPORT_UTF8\n#define charptr            frame->Xcharptr\n#endif\n#define callpat            frame->Xcallpat\n#define data               frame->Xdata\n#define next               frame->Xnext\n#define pp                 frame->Xpp\n#define prev               frame->Xprev\n#define saved_eptr         frame->Xsaved_eptr\n\n#define new_recursive      frame->Xnew_recursive\n\n#define cur_is_word        frame->Xcur_is_word\n#define condition          frame->Xcondition\n#define minimize           frame->Xminimize\n#define prev_is_word       frame->Xprev_is_word\n\n#define original_ims       frame->Xoriginal_ims\n\n#ifdef SUPPORT_UCP\n#define prop_type          frame->Xprop_type\n#define prop_fail_result   frame->Xprop_fail_result\n#define prop_category      frame->Xprop_category\n#define prop_chartype      frame->Xprop_chartype\n#define prop_othercase     frame->Xprop_othercase\n#define prop_test_against  frame->Xprop_test_against\n#define prop_test_variable frame->Xprop_test_variable\n#endif\n\n#define ctype              frame->Xctype\n#define fc                 frame->Xfc\n#define fi                 frame->Xfi\n#define length             frame->Xlength\n#define max                frame->Xmax\n#define min                frame->Xmin\n#define number             frame->Xnumber\n#define offset             frame->Xoffset\n#define op                 frame->Xop\n#define save_capture_last  frame->Xsave_capture_last\n#define save_offset1       frame->Xsave_offset1\n#define save_offset2       frame->Xsave_offset2\n#define save_offset3       frame->Xsave_offset3\n#define stacksave          frame->Xstacksave\n\n#define newptrb            frame->Xnewptrb\n\n/* When recursion is being used, local variables are allocated on the stack and\nget preserved during recursion in the normal way. In this environment, fi and\ni, and fc and c, can be the same variables. */\n\n#else\n#define fi i\n#define fc c\n\n\n#ifdef SUPPORT_UTF8                \nconst uschar *charptr;             \n#endif                             \nconst uschar *callpat;             \nconst uschar *data;                \nconst uschar *next;                \nconst uschar *pp;                  \nconst uschar *prev;                \nconst uschar *saved_eptr;          \n                                   \nrecursion_info new_recursive;      \n                                   \nBOOL cur_is_word;                  \nBOOL condition;                    \nBOOL minimize;\nBOOL prev_is_word;\n\nunsigned long test_snippet original_ims;\n\n#ifdef SUPPORT_UCP\ntest_snippet prop_type;\ntest_snippet prop_fail_result;\ntest_snippet prop_category;\ntest_snippet prop_chartype;\ntest_snippet prop_othercase;\ntest_snippet prop_test_against;\ntest_snippet *prop_test_variable;\n#endif\n\ntest_snippet ctype;\ntest_snippet length;\ntest_snippet max;\ntest_snippet min;\ntest_snippet number;\ntest_snippet offset;\ntest_snippet op;\ntest_snippet save_capture_last;\ntest_snippet save_offset1, save_offset2, save_offset3;\ntest_snippet stacksave[REC_STACK_SAVE_MAX];\n\neptrblock newptrb;\n#endif\n\n/* These statements are here to stop the compiler complaining about unitialized\nvariables. */\n\n#ifdef SUPPORT_UCP\nprop_fail_result = 0;\nprop_test_against = 0;\nprop_test_variable = NULL;\n#endif\n\n/* OK, now we can get on with the real code of the function. Recursion is\nspecified by the macros RMATCH and RRETURN. When NO_RECURSE is *not* defined,\nthese just turn test_snippeto a recursive call to match() and a \"return\", respectively.\nHowever, RMATCH isn't like a function call because it's quite a complicated\nmacro. It has to be used in one particular way. This shouldn't, however, impact\nperformance when true recursion is being used. */\n\nif (md->match_call_count++ >= md->match_limit) RRETURN(PCRE_ERROR_MATCHLIMIT);\n\noriginal_ims = ims;    \n\n/* At the start of a bracketed group, add the current subject potest_snippeter to the\nstack of such potest_snippeters, to be re-instated at the end of the group when we hit\nthe closing ket. When match() is called in other circumstances, we don't add to\nthis stack. */\n\nif ((flags & match_isgroup) != 0)\n  {\n  newptrb.epb_prev = eptrb;\n  newptrb.epb_saved_eptr = eptr;\n  eptrb = &newptrb;\n  }\n\n\n\nfor (;;)\n  {\n  op = *ecode;\n  minimize = FALSE;\n\n  /* For partial matching, remember if we ever hit the end of the subject after\n  matching at least one subject character. */\n\n  if (md->partial &&\n      eptr >= md->end_subject &&\n      eptr > md->start_match)\n    md->hitend = TRUE;\n\n  /* Opening capturing bracket. If there is space in the offset vector, save\n  the current subject position in the working slot at the top of the vector. We\n  mustn't change the current values of the data slot, because they may be set\n  from a previous iteration of this group, and be referred to by a reference\n  inside the group.\n\n  If the bracket fails to match, we need to restore this value and also the\n  values of the final offsets, in case they were set by a previous iteration of\n  the same bracket.\n\n  If there isn't enough space in the offset vector, treat this as if it were a\n  non-capturing bracket. Don't worry about setting the flag for the error case\n  here; that is handled in the code for KET. */\n\n  if (op > OP_BRA)\n    {\n    number = op - OP_BRA;\n\n    /* For extended extraction brackets (large number), we have to fish out the\n    number from a dummy opcode at the start. */\n\n    if (number > EXTRACT_BASIC_MAX)\n      number = GET2(ecode, 2+LINK_SIZE);\n    offset = number << 1;\n\n#ifdef DEBUG\n    prtest_snippetf(\"start bracket %d subject=\", number);\n    pchars(eptr, 16, TRUE, md);\n    prtest_snippetf(\"\\n\");\n#endif\n\n    if (offset < md->offset_max)\n      {\n      save_offset1 = md->offset_vector[offset];\n      save_offset2 = md->offset_vector[offset+1];\n      save_offset3 = md->offset_vector[md->offset_end - number];\n      save_capture_last = md->capture_last;\n\n      DPRINTF((\"saving %d %d %d\\n\", save_offset1, save_offset2, save_offset3));\n      md->offset_vector[md->offset_end - number] = eptr - md->start_subject;\n\n      do\n        {\n        RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, eptrb,\n          match_isgroup);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        md->capture_last = save_capture_last;\n        ecode += GET(ecode, 1);\n        }\n      while (*ecode == OP_ALT);\n\n      DPRINTF((\"bracket %d failed\\n\", number));\n\n      md->offset_vector[offset] = save_offset1;\n      md->offset_vector[offset+1] = save_offset2;\n      md->offset_vector[md->offset_end - number] = save_offset3;\n\n      RRETURN(MATCH_NOMATCH);\n      }\n\n    \n\n    else op = OP_BRA;\n    }\n\n  \n\n  switch(op)\n    {\n    case OP_BRA:     \n    DPRINTF((\"start bracket 0\\n\"));\n    do\n      {\n      RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, eptrb,\n        match_isgroup);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      ecode += GET(ecode, 1);\n      }\n    while (*ecode == OP_ALT);\n    DPRINTF((\"bracket 0 failed\\n\"));\n    RRETURN(MATCH_NOMATCH);\n\n    /* Conditional group: compilation checked that there are no more than\n    two branches. If the condition is false, skipping the first branch takes us\n    past the end if there is only one branch, but that's OK because that is\n    exactly what going to the ket would do. */\n\n    case OP_COND:\n    if (ecode[LINK_SIZE+1] == OP_CREF) \n      {\n      offset = GET2(ecode, LINK_SIZE+2) << 1;  \n      condition = (offset == CREF_RECURSE * 2)?\n        (md->recursive != NULL) :\n        (offset < offset_top && md->offset_vector[offset] >= 0);\n      RMATCH(rrc, eptr, ecode + (condition?\n        (LINK_SIZE + 4) : (LINK_SIZE + 1 + GET(ecode, 1))),\n        offset_top, md, ims, eptrb, match_isgroup);\n      RRETURN(rrc);\n      }\n\n    /* The condition is an assertion. Call match() to evaluate it - setting\n    the final argument TRUE causes it to stop at the end of an assertion. */\n\n    else\n      {\n      RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, NULL,\n          match_condassert | match_isgroup);\n      if (rrc == MATCH_MATCH)\n        {\n        ecode += 1 + LINK_SIZE + GET(ecode, LINK_SIZE+2);\n        while (*ecode == OP_ALT) ecode += GET(ecode, 1);\n        }\n      else if (rrc != MATCH_NOMATCH)\n        {\n        RRETURN(rrc);         \n        }\n      else ecode += GET(ecode, 1);\n      RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, eptrb,\n        match_isgroup);\n      RRETURN(rrc);\n      }\n    \n\n    /* Skip over conditional reference or large extraction number data if\n    encountered. */\n\n    case OP_CREF:\n    case OP_BRANUMBER:\n    ecode += 3;\n    break;\n\n    /* End of the pattern. If we are in a recursion, we should restore the\n    offsets appropriately and continue from after the call. */\n\n    case OP_END:\n    if (md->recursive != NULL && md->recursive->group_num == 0)\n      {\n      recursion_info *rec = md->recursive;\n      DPRINTF((\"Hit the end in a (?0) recursion\\n\"));\n      md->recursive = rec->prevrec;\n      memmove(md->offset_vector, rec->offset_save,\n        rec->saved_max * sizeof(test_snippet));\n      md->start_match = rec->save_start;\n      ims = original_ims;\n      ecode = rec->after_call;\n      break;\n      }\n\n    /* Otherwise, if PCRE_NOTEMPTY is set, fail if we have matched an empty\n    string - backtracking will then try other alternatives, if any. */\n\n    if (md->notempty && eptr == md->start_match) RRETURN(MATCH_NOMATCH);\n    md->end_match_ptr = eptr;          \n    md->end_offset_top = offset_top;   \n    RRETURN(MATCH_MATCH);\n\n    \n\n    case OP_OPT:\n    ims = ecode[1];\n    ecode += 2;\n    DPRINTF((\"ims set to %02lx\\n\", ims));\n    break;\n\n    /* Assertion brackets. Check the alternative branches in turn - the\n    matching won't pass the KET for an assertion. If any one branch matches,\n    the assertion is true. Lookbehind assertions have an OP_REVERSE item at the\n    start of each branch to move the current potest_snippet backwards, so the code at\n    this level is identical to the lookahead case. */\n\n    case OP_ASSERT:\n    case OP_ASSERTBACK:\n    do\n      {\n      RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, NULL,\n        match_isgroup);\n      if (rrc == MATCH_MATCH) break;\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      ecode += GET(ecode, 1);\n      }\n    while (*ecode == OP_ALT);\n    if (*ecode == OP_KET) RRETURN(MATCH_NOMATCH);\n\n    \n\n    if ((flags & match_condassert) != 0) RRETURN(MATCH_MATCH);\n\n    /* Continue from after the assertion, updating the offsets high water\n    mark, since extracts may have been taken during the assertion. */\n\n    do ecode += GET(ecode,1); while (*ecode == OP_ALT);\n    ecode += 1 + LINK_SIZE;\n    offset_top = md->end_offset_top;\n    continue;\n\n    \n\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK_NOT:\n    do\n      {\n      RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, NULL,\n        match_isgroup);\n      if (rrc == MATCH_MATCH) RRETURN(MATCH_NOMATCH);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      ecode += GET(ecode,1);\n      }\n    while (*ecode == OP_ALT);\n\n    if ((flags & match_condassert) != 0) RRETURN(MATCH_MATCH);\n\n    ecode += 1 + LINK_SIZE;\n    continue;\n\n    /* Move the subject potest_snippeter back. This occurs only at the start of\n    each branch of a lookbehind assertion. If we are too close to the start to\n    move back, this match function fails. When working with UTF-8 we move\n    back a number of characters, not bytes. */\n\n    case OP_REVERSE:\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      {\n      c = GET(ecode,1);\n      for (i = 0; i < c; i++)\n        {\n        eptr--;\n        if (eptr < md->start_subject) RRETURN(MATCH_NOMATCH);\n        BACKCHAR(eptr)\n        }\n      }\n    else\n#endif\n\n    \n\n      {\n      eptr -= GET(ecode,1);\n      if (eptr < md->start_subject) RRETURN(MATCH_NOMATCH);\n      }\n\n    \n\n    ecode += 1 + LINK_SIZE;\n    break;\n\n    /* The callout item calls an external function, if one is provided, passing\n    details of the match so far. This is mainly for debugging, though the\n    function is able to force a failure. */\n\n    case OP_CALLOUT:\n    if (pcre_callout != NULL)\n      {\n      pcre_callout_block cb;\n      cb.version          = 1;   \n      cb.callout_number   = ecode[1];\n      cb.offset_vector    = md->offset_vector;\n      cb.subject          = (const char *)md->start_subject;\n      cb.subject_length   = md->end_subject - md->start_subject;\n      cb.start_match      = md->start_match - md->start_subject;\n      cb.current_position = eptr - md->start_subject;\n      cb.pattern_position = GET(ecode, 2);\n      cb.next_item_length = GET(ecode, 2 + LINK_SIZE);\n      cb.capture_top      = offset_top/2;\n      cb.capture_last     = md->capture_last;\n      cb.callout_data     = md->callout_data;\n      if ((rrc = (*pcre_callout)(&cb)) > 0) RRETURN(MATCH_NOMATCH);\n      if (rrc < 0) RRETURN(rrc);\n      }\n    ecode += 2 + 2*LINK_SIZE;\n    break;\n\n    /* Recursion either matches the current regex, or some subexpression. The\n    offset data is the offset to the starting bracket from the start of the\n    whole pattern. (This is so that it works from duplicated subpatterns.)\n\n    If there are any capturing brackets started but not finished, we have to\n    save their starting potest_snippets and reinstate them after the recursion. However,\n    we don't know how many such there are (offset_top records the completed\n    total) so we just have to save all the potential data. There may be up to\n    65535 such values, which is too large to put on the stack, but using malloc\n    for small numbers seems expensive. As a compromise, the stack is used when\n    there are no more than REC_STACK_SAVE_MAX values to store; otherwise malloc\n    is used. A problem is what to do if the malloc fails ... there is no way of\n    returning to the top level with an error. Save the top REC_STACK_SAVE_MAX\n    values on the stack, and accept that the rest may be wrong.\n\n    There are also other values that have to be saved. We use a chained\n    sequence of blocks that actually live on the stack. Thanks to Robin Houston\n    for the original version of this logic. */\n\n    case OP_RECURSE:\n      {\n      callpat = md->start_code + GET(ecode, 1);\n      new_recursive.group_num = *callpat - OP_BRA;\n\n      /* For extended extraction brackets (large number), we have to fish out\n      the number from a dummy opcode at the start. */\n\n      if (new_recursive.group_num > EXTRACT_BASIC_MAX)\n        new_recursive.group_num = GET2(callpat, 2+LINK_SIZE);\n\n      \n\n      new_recursive.prevrec = md->recursive;\n      md->recursive = &new_recursive;\n\n      \n\n      ecode += 1 + LINK_SIZE;\n      new_recursive.after_call = ecode;\n\n      \n\n      new_recursive.saved_max = md->offset_end;\n      if (new_recursive.saved_max <= REC_STACK_SAVE_MAX)\n        new_recursive.offset_save = stacksave;\n      else\n        {\n        new_recursive.offset_save =\n          (test_snippet *)(pcre_malloc)(new_recursive.saved_max * sizeof(test_snippet));\n        if (new_recursive.offset_save == NULL) RRETURN(PCRE_ERROR_NOMEMORY);\n        }\n\n      memcpy(new_recursive.offset_save, md->offset_vector,\n            new_recursive.saved_max * sizeof(test_snippet));\n      new_recursive.save_start = md->start_match;\n      md->start_match = eptr;\n\n      /* OK, now we can do the recursion. For each top-level alternative we\n      restore the offset and recursion data. */\n\n      DPRINTF((\"Recursing test_snippeto group %d\\n\", new_recursive.group_num));\n      do\n        {\n        RMATCH(rrc, eptr, callpat + 1 + LINK_SIZE, offset_top, md, ims,\n            eptrb, match_isgroup);\n        if (rrc == MATCH_MATCH)\n          {\n          md->recursive = new_recursive.prevrec;\n          if (new_recursive.offset_save != stacksave)\n            (pcre_free)(new_recursive.offset_save);\n          RRETURN(MATCH_MATCH);\n          }\n        else if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n\n        md->recursive = &new_recursive;\n        memcpy(md->offset_vector, new_recursive.offset_save,\n            new_recursive.saved_max * sizeof(test_snippet));\n        callpat += GET(callpat, 1);\n        }\n      while (*callpat == OP_ALT);\n\n      DPRINTF((\"Recursion didn't match\\n\"));\n      md->recursive = new_recursive.prevrec;\n      if (new_recursive.offset_save != stacksave)\n        (pcre_free)(new_recursive.offset_save);\n      RRETURN(MATCH_NOMATCH);\n      }\n    \n\n    /* \"Once\" brackets are like assertion brackets except that after a match,\n    the potest_snippet in the subject string is not moved back. Thus there can never be\n    a move back test_snippeto the brackets. Friedl calls these \"atomic\" subpatterns.\n    Check the alternative branches in turn - the matching won't pass the KET\n    for this kind of subpattern. If any one branch matches, we carry on as at\n    the end of a normal bracket, leaving the subject potest_snippeter. */\n\n    case OP_ONCE:\n      {\n      prev = ecode;\n      saved_eptr = eptr;\n\n      do\n        {\n        RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims,\n          eptrb, match_isgroup);\n        if (rrc == MATCH_MATCH) break;\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        ecode += GET(ecode,1);\n        }\n      while (*ecode == OP_ALT);\n\n      \n\n      if (*ecode != OP_ONCE && *ecode != OP_ALT) RRETURN(MATCH_NOMATCH);\n\n      /* Continue as from after the assertion, updating the offsets high water\n      mark, since extracts may have been taken. */\n\n      do ecode += GET(ecode,1); while (*ecode == OP_ALT);\n\n      offset_top = md->end_offset_top;\n      eptr = md->end_match_ptr;\n\n      /* For a non-repeating ket, just continue at this level. This also\n      happens for a repeating ket if no characters were matched in the group.\n      This is the forcible breaking of infinite loops as implemented in Perl\n      5.005. If there is an options reset, it will get obeyed in the normal\n      course of events. */\n\n      if (*ecode == OP_KET || eptr == saved_eptr)\n        {\n        ecode += 1+LINK_SIZE;\n        break;\n        }\n\n      /* The repeating kets try the rest of the pattern or restart from the\n      preceding bracket, in the appropriate order. We need to reset any options\n      that changed within the bracket before re-running it, so check the next\n      opcode. */\n\n      if (ecode[1+LINK_SIZE] == OP_OPT)\n        {\n        ims = (ims & ~PCRE_IMS) | ecode[4];\n        DPRINTF((\"ims set to %02lx at group repeat\\n\", ims));\n        }\n\n      if (*ecode == OP_KETRMIN)\n        {\n        RMATCH(rrc, eptr, ecode + 1 + LINK_SIZE, offset_top, md, ims, eptrb, 0);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        RMATCH(rrc, eptr, prev, offset_top, md, ims, eptrb, match_isgroup);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        }\n      else  \n        {\n        RMATCH(rrc, eptr, prev, offset_top, md, ims, eptrb, match_isgroup);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        RMATCH(rrc, eptr, ecode + 1+LINK_SIZE, offset_top, md, ims, eptrb, 0);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        }\n      }\n    RRETURN(MATCH_NOMATCH);\n\n    /* An alternation is the end of a branch; scan along to find the end of the\n    bracketed group and go to there. */\n\n    case OP_ALT:\n    do ecode += GET(ecode,1); while (*ecode == OP_ALT);\n    break;\n\n    /* BRAZERO and BRAMINZERO occur just before a bracket group, indicating\n    that it may occur zero times. It may repeat infinitely, or not at all -\n    i.e. it could be ()* or ()? in the pattern. Brackets with fixed upper\n    repeat limits are compiled as a number of copies, with the optional ones\n    preceded by BRAZERO or BRAMINZERO. */\n\n    case OP_BRAZERO:\n      {\n      next = ecode+1;\n      RMATCH(rrc, eptr, next, offset_top, md, ims, eptrb, match_isgroup);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      do next += GET(next,1); while (*next == OP_ALT);\n      ecode = next + 1+LINK_SIZE;\n      }\n    break;\n\n    case OP_BRAMINZERO:\n      {\n      next = ecode+1;\n      do next += GET(next,1); while (*next == OP_ALT);\n      RMATCH(rrc, eptr, next + 1+LINK_SIZE, offset_top, md, ims, eptrb,\n        match_isgroup);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      ecode++;\n      }\n    break;\n\n    /* End of a group, repeated or non-repeating. If we are at the end of\n    an assertion \"group\", stop matching and return MATCH_MATCH, but record the\n    current high water mark for use by positive assertions. Do this also\n    for the \"once\" (not-backup up) groups. */\n\n    case OP_KET:\n    case OP_KETRMIN:\n    case OP_KETRMAX:\n      {\n      prev = ecode - GET(ecode, 1);\n      saved_eptr = eptrb->epb_saved_eptr;\n\n      \n\n      eptrb = eptrb->epb_prev;\n\n      if (*prev == OP_ASSERT || *prev == OP_ASSERT_NOT ||\n          *prev == OP_ASSERTBACK || *prev == OP_ASSERTBACK_NOT ||\n          *prev == OP_ONCE)\n        {\n        md->end_match_ptr = eptr;      \n        md->end_offset_top = offset_top;\n        RRETURN(MATCH_MATCH);\n        }\n\n      /* In all other cases except a conditional group we have to check the\n      group number back at the start and if necessary complete handling an\n      extraction by setting the offsets and bumping the high water mark. */\n\n      if (*prev != OP_COND)\n        {\n        number = *prev - OP_BRA;\n\n        /* For extended extraction brackets (large number), we have to fish out\n        the number from a dummy opcode at the start. */\n\n        if (number > EXTRACT_BASIC_MAX) number = GET2(prev, 2+LINK_SIZE);\n        offset = number << 1;\n\n#ifdef DEBUG\n        prtest_snippetf(\"end bracket %d\", number);\n        prtest_snippetf(\"\\n\");\n#endif\n\n        /* Test for a numbered group. This includes groups called as a result\n        of recursion. Note that whole-pattern recursion is coded as a recurse\n        test_snippeto group 0, so it won't be picked up here. Instead, we catch it when\n        the OP_END is reached. */\n\n        if (number > 0)\n          {\n          md->capture_last = number;\n          if (offset >= md->offset_max) md->offset_overflow = TRUE; else\n            {\n            md->offset_vector[offset] =\n              md->offset_vector[md->offset_end - number];\n            md->offset_vector[offset+1] = eptr - md->start_subject;\n            if (offset_top <= offset) offset_top = offset + 2;\n            }\n\n          /* Handle a recursively called group. Restore the offsets\n          appropriately and continue from after the call. */\n\n          if (md->recursive != NULL && md->recursive->group_num == number)\n            {\n            recursion_info *rec = md->recursive;\n            DPRINTF((\"Recursion (%d) succeeded - continuing\\n\", number));\n            md->recursive = rec->prevrec;\n            md->start_match = rec->save_start;\n            memcpy(md->offset_vector, rec->offset_save,\n              rec->saved_max * sizeof(test_snippet));\n            ecode = rec->after_call;\n            ims = original_ims;\n            break;\n            }\n          }\n        }\n\n      /* Reset the value of the ims flags, in case they got changed during\n      the group. */\n\n      ims = original_ims;\n      DPRINTF((\"ims reset to %02lx\\n\", ims));\n\n      /* For a non-repeating ket, just continue at this level. This also\n      happens for a repeating ket if no characters were matched in the group.\n      This is the forcible breaking of infinite loops as implemented in Perl\n      5.005. If there is an options reset, it will get obeyed in the normal\n      course of events. */\n\n      if (*ecode == OP_KET || eptr == saved_eptr)\n        {\n        ecode += 1 + LINK_SIZE;\n        break;\n        }\n\n      /* The repeating kets try the rest of the pattern or restart from the\n      preceding bracket, in the appropriate order. */\n\n      if (*ecode == OP_KETRMIN)\n        {\n        RMATCH(rrc, eptr, ecode + 1+LINK_SIZE, offset_top, md, ims, eptrb, 0);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        RMATCH(rrc, eptr, prev, offset_top, md, ims, eptrb, match_isgroup);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        }\n      else  \n        {\n        RMATCH(rrc, eptr, prev, offset_top, md, ims, eptrb, match_isgroup);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        RMATCH(rrc, eptr, ecode + 1+LINK_SIZE, offset_top, md, ims, eptrb, 0);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        }\n      }\n\n    RRETURN(MATCH_NOMATCH);\n\n    \n\n    case OP_CIRC:\n    if (md->notbol && eptr == md->start_subject) RRETURN(MATCH_NOMATCH);\n    if ((ims & PCRE_MULTILINE) != 0)\n      {\n      if (eptr != md->start_subject && eptr[-1] != NEWLINE)\n        RRETURN(MATCH_NOMATCH);\n      ecode++;\n      break;\n      }\n    \n\n    \n\n    case OP_SOD:\n    if (eptr != md->start_subject) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    \n\n    case OP_SOM:\n    if (eptr != md->start_subject + md->start_offset) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    /* Assert before test_snippeternal newline if multiline, or before a terminating\n    newline unless endonly is set, else end of subject unless noteol is set. */\n\n    case OP_DOLL:\n    if ((ims & PCRE_MULTILINE) != 0)\n      {\n      if (eptr < md->end_subject)\n        { if (*eptr != NEWLINE) RRETURN(MATCH_NOMATCH); }\n      else\n        { if (md->noteol) RRETURN(MATCH_NOMATCH); }\n      ecode++;\n      break;\n      }\n    else\n      {\n      if (md->noteol) RRETURN(MATCH_NOMATCH);\n      if (!md->endonly)\n        {\n        if (eptr < md->end_subject - 1 ||\n           (eptr == md->end_subject - 1 && *eptr != NEWLINE))\n          RRETURN(MATCH_NOMATCH);\n        ecode++;\n        break;\n        }\n      }\n    \n\n    \n\n    case OP_EOD:\n    if (eptr < md->end_subject) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    \n\n    case OP_EODN:\n    if (eptr < md->end_subject - 1 ||\n       (eptr == md->end_subject - 1 && *eptr != NEWLINE)) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    \n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n      {\n\n      /* Find out if the previous and current characters are \"word\" characters.\n      It takes a bit more work in UTF-8 mode. Characters > 255 are assumed to\n      be \"non-word\" characters. */\n\n#ifdef SUPPORT_UTF8\n      if (md->utf8)\n        {\n        if (eptr == md->start_subject) prev_is_word = FALSE; else\n          {\n          const uschar *lastptr = eptr - 1;\n          while((*lastptr & 0xc0) == 0x80) lastptr--;\n          GETCHAR(c, lastptr);\n          prev_is_word = c < 256 && (md->ctypes[c] & ctype_word) != 0;\n          }\n        if (eptr >= md->end_subject) cur_is_word = FALSE; else\n          {\n          GETCHAR(c, eptr);\n          cur_is_word = c < 256 && (md->ctypes[c] & ctype_word) != 0;\n          }\n        }\n      else\n#endif\n\n      \n\n        {\n        prev_is_word = (eptr != md->start_subject) &&\n          ((md->ctypes[eptr[-1]] & ctype_word) != 0);\n        cur_is_word = (eptr < md->end_subject) &&\n          ((md->ctypes[*eptr] & ctype_word) != 0);\n        }\n\n      \n\n      if ((*ecode++ == OP_WORD_BOUNDARY)?\n           cur_is_word == prev_is_word : cur_is_word != prev_is_word)\n        RRETURN(MATCH_NOMATCH);\n      }\n    break;\n\n    \n\n    case OP_ANY:\n    if ((ims & PCRE_DOTALL) == 0 && eptr < md->end_subject && *eptr == NEWLINE)\n      RRETURN(MATCH_NOMATCH);\n    if (eptr++ >= md->end_subject) RRETURN(MATCH_NOMATCH);\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n#endif\n    ecode++;\n    break;\n\n    /* Match a single byte, even in UTF-8 mode. This opcode really does match\n    any byte, even newline, independent of the setting of PCRE_DOTALL. */\n\n    case OP_ANYBYTE:\n    if (eptr++ >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_NOT_DIGIT:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c < 256 &&\n#endif\n       (md->ctypes[c] & ctype_digit) != 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_DIGIT:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c >= 256 ||\n#endif\n       (md->ctypes[c] & ctype_digit) == 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_NOT_WHITESPACE:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c < 256 &&\n#endif\n       (md->ctypes[c] & ctype_space) != 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_WHITESPACE:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c >= 256 ||\n#endif\n       (md->ctypes[c] & ctype_space) == 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_NOT_WORDCHAR:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c < 256 &&\n#endif\n       (md->ctypes[c] & ctype_word) != 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n    case OP_WORDCHAR:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n    if (\n#ifdef SUPPORT_UTF8\n       c >= 256 ||\n#endif\n       (md->ctypes[c] & ctype_word) == 0\n       )\n      RRETURN(MATCH_NOMATCH);\n    ecode++;\n    break;\n\n#ifdef SUPPORT_UCP\n    /* Check the next character by Unicode property. We will get here only\n    if the support is in the binary; otherwise a compile-time error occurs. */\n\n    case OP_PROP:\n    case OP_NOTPROP:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n      {\n      test_snippet chartype, rqdtype;\n      test_snippet othercase;\n      test_snippet category = ucp_findchar(c, &chartype, &othercase);\n\n      rqdtype = *(++ecode);\n      ecode++;\n\n      if (rqdtype >= 128)\n        {\n        if ((rqdtype - 128 != category) == (op == OP_PROP))\n          RRETURN(MATCH_NOMATCH);\n        }\n      else\n        {\n        if ((rqdtype != chartype) == (op == OP_PROP))\n          RRETURN(MATCH_NOMATCH);\n        }\n      }\n    break;\n\n    /* Match an extended Unicode sequence. We will get here only if the support\n    is in the binary; otherwise a compile-time error occurs. */\n\n    case OP_EXTUNI:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    GETCHARINCTEST(c, eptr);\n      {\n      test_snippet chartype;\n      test_snippet othercase;\n      test_snippet category = ucp_findchar(c, &chartype, &othercase);\n      if (category == ucp_M) RRETURN(MATCH_NOMATCH);\n      while (eptr < md->end_subject)\n        {\n        test_snippet len = 1;\n        if (!md->utf8) c = *eptr; else\n          {\n          GETCHARLEN(c, eptr, len);\n          }\n        category = ucp_findchar(c, &chartype, &othercase);\n        if (category != ucp_M) break;\n        eptr += len;\n        }\n      }\n    ecode++;\n    break;\n#endif\n\n\n    /* Match a back reference, possibly repeatedly. Look past the end of the\n    item to see if there is repeat information following. The code is similar\n    to that for character classes, but repeated for efficiency. Then obey\n    similar code to character type repeats - written out again for speed.\n    However, if the referenced string is the empty string, always treat\n    it as matched, any number of times (otherwise there could be infinite\n    loops). */\n\n    case OP_REF:\n      {\n      offset = GET2(ecode, 1) << 1;               \n      ecode += 3;                                 \n\n      /* If the reference is unset, set the length to be longer than the amount\n      of subject left; this ensures that every attempt at a match fails. We\n      can't just fail here, because of the possibility of quantifiers with zero\n      minima. */\n\n      length = (offset >= offset_top || md->offset_vector[offset] < 0)?\n        md->end_subject - eptr + 1 :\n        md->offset_vector[offset+1] - md->offset_vector[offset];\n\n      \n\n      switch (*ecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        c = *ecode++ - OP_CRSTAR;\n        minimize = (c & 1) != 0;\n        min = rep_min[c];                 \n        max = rep_max[c];                 \n        if (max == 0) max = INT_MAX;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        minimize = (*ecode == OP_CRMINRANGE);\n        min = GET2(ecode, 1);\n        max = GET2(ecode, 3);\n        if (max == 0) max = INT_MAX;\n        ecode += 5;\n        break;\n\n        default:               \n        if (!match_ref(offset, eptr, length, md, ims)) RRETURN(MATCH_NOMATCH);\n        eptr += length;\n        continue;              \n        }\n\n      /* If the length of the reference is zero, just continue with the\n      main loop. */\n\n      if (length == 0) continue;\n\n      /* First, ensure the minimum number of matches are present. We get back\n      the length of the reference string explicitly rather than passing the\n      address of eptr, so that eptr can be a register variable. */\n\n      for (i = 1; i <= min; i++)\n        {\n        if (!match_ref(offset, eptr, length, md, ims)) RRETURN(MATCH_NOMATCH);\n        eptr += length;\n        }\n\n      /* If min = max, continue at the same level without recursion.\n      They are not both allowed to be zero. */\n\n      if (min == max) continue;\n\n      \n\n      if (minimize)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || !match_ref(offset, eptr, length, md, ims))\n            RRETURN(MATCH_NOMATCH);\n          eptr += length;\n          }\n        \n        }\n\n      \n\n      else\n        {\n        pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (!match_ref(offset, eptr, length, md, ims)) break;\n          eptr += length;\n          }\n        while (eptr >= pp)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          eptr -= length;\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    \n\n\n\n    /* Match a bit-mapped character class, possibly repeatedly. This op code is\n    used when all the characters in the class have values in the range 0-255,\n    and either the matching is caseful, or the characters are in the range\n    0-127 when UTF-8 processing is enabled. The only difference between\n    OP_CLASS and OP_NCLASS occurs when a data character outside the range is\n    encountered.\n\n    First, look past the end of the item to see if there is repeat information\n    following. Then obey similar code to character type repeats - written out\n    again for speed. */\n\n    case OP_NCLASS:\n    case OP_CLASS:\n      {\n      data = ecode + 1;                \n      ecode += 33;                     \n\n      switch (*ecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        c = *ecode++ - OP_CRSTAR;\n        minimize = (c & 1) != 0;\n        min = rep_min[c];                 \n        max = rep_max[c];                 \n        if (max == 0) max = INT_MAX;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        minimize = (*ecode == OP_CRMINRANGE);\n        min = GET2(ecode, 1);\n        max = GET2(ecode, 3);\n        if (max == 0) max = INT_MAX;\n        ecode += 5;\n        break;\n\n        default:               \n        min = max = 1;\n        break;\n        }\n\n      \n\n#ifdef SUPPORT_UTF8\n      \n      if (md->utf8)\n        {\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          GETCHARINC(c, eptr);\n          if (c > 255)\n            {\n            if (op == OP_CLASS) RRETURN(MATCH_NOMATCH);\n            }\n          else\n            {\n            if ((data[c/8] & (1 << (c&7))) == 0) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        }\n      else\n#endif\n      \n        {\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          c = *eptr++;\n          if ((data[c/8] & (1 << (c&7))) == 0) RRETURN(MATCH_NOMATCH);\n          }\n        }\n\n      /* If max == min we can continue with the main loop without the\n      need to recurse. */\n\n      if (min == max) continue;\n\n      /* If minimizing, keep testing the rest of the expression and advancing\n      the potest_snippeter while it matches the class. */\n\n      if (minimize)\n        {\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n            GETCHARINC(c, eptr);\n            if (c > 255)\n              {\n              if (op == OP_CLASS) RRETURN(MATCH_NOMATCH);\n              }\n            else\n              {\n              if ((data[c/8] & (1 << (c&7))) == 0) RRETURN(MATCH_NOMATCH);\n              }\n            }\n          }\n        else\n#endif\n        \n          {\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n            c = *eptr++;\n            if ((data[c/8] & (1 << (c&7))) == 0) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        \n        }\n\n      \n\n      else\n        {\n        pp = eptr;\n\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c > 255)\n              {\n              if (op == OP_CLASS) break;\n              }\n            else\n              {\n              if ((data[c/8] & (1 << (c&7))) == 0) break;\n              }\n            eptr += len;\n            }\n          for (;;)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (eptr-- == pp) break;        \n            BACKCHAR(eptr);\n            }\n          }\n        else\n#endif\n          \n          {\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject) break;\n            c = *eptr;\n            if ((data[c/8] & (1 << (c&7))) == 0) break;\n            eptr++;\n            }\n          while (eptr >= pp)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            eptr--;\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            }\n          }\n\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    \n\n\n    /* Match an extended character class. This opcode is encountered only\n    in UTF-8 mode, because that's the only time it is compiled. */\n\n#ifdef SUPPORT_UTF8\n    case OP_XCLASS:\n      {\n      data = ecode + 1 + LINK_SIZE;                \n      ecode += GET(ecode, 1);                      \n\n      switch (*ecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        c = *ecode++ - OP_CRSTAR;\n        minimize = (c & 1) != 0;\n        min = rep_min[c];                 \n        max = rep_max[c];                 \n        if (max == 0) max = INT_MAX;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        minimize = (*ecode == OP_CRMINRANGE);\n        min = GET2(ecode, 1);\n        max = GET2(ecode, 3);\n        if (max == 0) max = INT_MAX;\n        ecode += 5;\n        break;\n\n        default:               \n        min = max = 1;\n        break;\n        }\n\n      \n\n      for (i = 1; i <= min; i++)\n        {\n        if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n        GETCHARINC(c, eptr);\n        if (!match_xclass(c, data)) RRETURN(MATCH_NOMATCH);\n        }\n\n      /* If max == min we can continue with the main loop without the\n      need to recurse. */\n\n      if (min == max) continue;\n\n      /* If minimizing, keep testing the rest of the expression and advancing\n      the potest_snippeter while it matches the class. */\n\n      if (minimize)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          GETCHARINC(c, eptr);\n          if (!match_xclass(c, data)) RRETURN(MATCH_NOMATCH);\n          }\n        \n        }\n\n      \n\n      else\n        {\n        pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          test_snippet len = 1;\n          if (eptr >= md->end_subject) break;\n          GETCHARLEN(c, eptr, len);\n          if (!match_xclass(c, data)) break;\n          eptr += len;\n          }\n        for(;;)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (eptr-- == pp) break;        \n          BACKCHAR(eptr)\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n\n      \n      }\n#endif    \n\n    \n\n    case OP_CHAR:\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      {\n      length = 1;\n      ecode++;\n      GETCHARLEN(fc, ecode, length);\n      if (length > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n      while (length-- > 0) if (*ecode++ != *eptr++) RRETURN(MATCH_NOMATCH);\n      }\n    else\n#endif\n\n    \n      {\n      if (md->end_subject - eptr < 1) RRETURN(MATCH_NOMATCH);\n      if (ecode[1] != *eptr++) RRETURN(MATCH_NOMATCH);\n      ecode += 2;\n      }\n    break;\n\n    \n\n    case OP_CHARNC:\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      {\n      length = 1;\n      ecode++;\n      GETCHARLEN(fc, ecode, length);\n\n      if (length > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n\n      /* If the pattern character's value is < 128, we have only one byte, and\n      can use the fast lookup table. */\n\n      if (fc < 128)\n        {\n        if (md->lcc[*ecode++] != md->lcc[*eptr++]) RRETURN(MATCH_NOMATCH);\n        }\n\n      \n\n      else\n        {\n        test_snippet dc;\n        GETCHARINC(dc, eptr);\n        ecode += length;\n\n        /* If we have Unicode property support, we can use it to test the other\n        case of the character, if there is one. The result of ucp_findchar() is\n        < 0 if the char isn't found, and othercase is returned as zero if there\n        isn't one. */\n\n        if (fc != dc)\n          {\n#ifdef SUPPORT_UCP\n          test_snippet chartype;\n          test_snippet othercase;\n          if (ucp_findchar(fc, &chartype, &othercase) < 0 || dc != othercase)\n#endif\n            RRETURN(MATCH_NOMATCH);\n          }\n        }\n      }\n    else\n#endif   \n\n    \n      {\n      if (md->end_subject - eptr < 1) RRETURN(MATCH_NOMATCH);\n      if (md->lcc[ecode[1]] != md->lcc[*eptr++]) RRETURN(MATCH_NOMATCH);\n      ecode += 2;\n      }\n    break;\n\n    \n\n    case OP_EXACT:\n    min = max = GET2(ecode, 1);\n    ecode += 3;\n    goto REPEATCHAR;\n\n    case OP_UPTO:\n    case OP_MINUPTO:\n    min = 0;\n    max = GET2(ecode, 1);\n    minimize = *ecode == OP_MINUPTO;\n    ecode += 3;\n    goto REPEATCHAR;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    c = *ecode++ - OP_STAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    /* Common code for all repeated single-character matches. We can give\n    up quickly if there are fewer than the minimum number of characters left in\n    the subject. */\n\n    REPEATCHAR:\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      {\n      length = 1;\n      charptr = ecode;\n      GETCHARLEN(fc, ecode, length);\n      if (min * length > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n      ecode += length;\n\n      /* Handle multibyte character matching specially here. There is\n      support for caseless matching if UCP support is present. */\n\n      if (length > 1)\n        {\n        test_snippet oclength = 0;\n        uschar occhars[8];\n\n#ifdef SUPPORT_UCP\n        test_snippet othercase;\n        test_snippet chartype;\n        if ((ims & PCRE_CASELESS) != 0 &&\n             ucp_findchar(fc, &chartype, &othercase) >= 0 &&\n             othercase > 0)\n          oclength = ord2utf8(othercase, occhars);\n#endif  \n\n        for (i = 1; i <= min; i++)\n          {\n          if (memcmp(eptr, charptr, length) == 0) eptr += length;\n          \n          else if (oclength == 0) { RRETURN(MATCH_NOMATCH); }\n          else\n            {\n            if (memcmp(eptr, occhars, oclength) != 0) RRETURN(MATCH_NOMATCH);\n            eptr += oclength;\n            }\n          }\n\n        if (min == max) continue;\n\n        if (minimize)\n          {\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n            if (memcmp(eptr, charptr, length) == 0) eptr += length;\n            \n            else if (oclength == 0) { RRETURN(MATCH_NOMATCH); }\n            else\n              {\n              if (memcmp(eptr, occhars, oclength) != 0) RRETURN(MATCH_NOMATCH);\n              eptr += oclength;\n              }\n            }\n          \n          }\n        else\n          {\n          pp = eptr;\n          for (i = min; i < max; i++)\n            {\n            if (eptr > md->end_subject - length) break;\n            if (memcmp(eptr, charptr, length) == 0) eptr += length;\n            else if (oclength == 0) break;\n            else\n              {\n              if (memcmp(eptr, occhars, oclength) != 0) break;\n              eptr += oclength;\n              }\n            }\n          while (eptr >= pp)\n           {\n           RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n           if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n           eptr -= length;\n           }\n          RRETURN(MATCH_NOMATCH);\n          }\n        \n        }\n\n      /* If the length of a UTF-8 character is 1, we fall through here, and\n      obey the code as for non-UTF-8 characters below, though in this case the\n      value of fc will always be < 128. */\n      }\n    else\n#endif  \n\n    \n      {\n      if (min > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n      fc = *ecode++;\n      }\n\n    /* The value of fc at this potest_snippet is always less than 256, though we may or\n    may not be in UTF-8 mode. The code is duplicated for the caseless and\n    caseful cases, for speed, since matching characters is likely to be quite\n    common. First, ensure the minimum number of matches are present. If min =\n    max, continue at the same level without recursing. Otherwise, if\n    minimizing, keep trying the rest of the expression and advancing one\n    matching character if failing, up to the maximum. Alternatively, if\n    maximizing, find the maximum number of characters and work backwards. */\n\n    DPRINTF((\"matching %c{%d,%d} against subject %.*s\\n\", fc, min, max,\n      max, eptr));\n\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n      fc = md->lcc[fc];\n      for (i = 1; i <= min; i++)\n        if (fc != md->lcc[*eptr++]) RRETURN(MATCH_NOMATCH);\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject ||\n              fc != md->lcc[*eptr++])\n            RRETURN(MATCH_NOMATCH);\n          }\n        \n        }\n      else\n        {\n        pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || fc != md->lcc[*eptr]) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          eptr--;\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n      \n      }\n\n    \n\n    else\n      {\n      for (i = 1; i <= min; i++) if (fc != *eptr++) RRETURN(MATCH_NOMATCH);\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject || fc != *eptr++)\n            RRETURN(MATCH_NOMATCH);\n          }\n        \n        }\n      else\n        {\n        pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || fc != *eptr) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          eptr--;\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    \n\n    /* Match a negated single one-byte character. The character we are\n    checking can be multibyte. */\n\n    case OP_NOT:\n    if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n    ecode++;\n    GETCHARINCTEST(c, eptr);\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n#ifdef SUPPORT_UTF8\n      if (c < 256)\n#endif\n      c = md->lcc[c];\n      if (md->lcc[*ecode++] == c) RRETURN(MATCH_NOMATCH);\n      }\n    else\n      {\n      if (*ecode++ == c) RRETURN(MATCH_NOMATCH);\n      }\n    break;\n\n    /* Match a negated single one-byte character repeatedly. This is almost a\n    repeat of the code for a repeated single character, but I haven't found a\n    nice way of commoning these up that doesn't require a test of the\n    positive/negative option for each character match. Maybe that wouldn't add\n    very much to the time taken, but character matching *is* what this is all\n    about... */\n\n    case OP_NOTEXACT:\n    min = max = GET2(ecode, 1);\n    ecode += 3;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    min = 0;\n    max = GET2(ecode, 1);\n    minimize = *ecode == OP_NOTMINUPTO;\n    ecode += 3;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    c = *ecode++ - OP_NOTSTAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    /* Common code for all repeated single-byte matches. We can give up quickly\n    if there are fewer than the minimum number of bytes left in the\n    subject. */\n\n    REPEATNOTCHAR:\n    if (min > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n    fc = *ecode++;\n\n    /* The code is duplicated for the caseless and caseful cases, for speed,\n    since matching characters is likely to be quite common. First, ensure the\n    minimum number of matches are present. If min = max, continue at the same\n    level without recursing. Otherwise, if minimizing, keep trying the rest of\n    the expression and advancing one matching character if failing, up to the\n    maximum. Alternatively, if maximizing, find the maximum number of\n    characters and work backwards. */\n\n    DPRINTF((\"negative matching %c{%d,%d} against subject %.*s\\n\", fc, min, max,\n      max, eptr));\n\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n      fc = md->lcc[fc];\n\n#ifdef SUPPORT_UTF8\n      \n      if (md->utf8)\n        {\n        register test_snippet d;\n        for (i = 1; i <= min; i++)\n          {\n          GETCHARINC(d, eptr);\n          if (d < 256) d = md->lcc[d];\n          if (fc == d) RRETURN(MATCH_NOMATCH);\n          }\n        }\n      else\n#endif\n\n      \n        {\n        for (i = 1; i <= min; i++)\n          if (fc == md->lcc[*eptr++]) RRETURN(MATCH_NOMATCH);\n        }\n\n      if (min == max) continue;\n\n      if (minimize)\n        {\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          register test_snippet d;\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            GETCHARINC(d, eptr);\n            if (d < 256) d = md->lcc[d];\n            if (fi >= max || eptr >= md->end_subject || fc == d)\n              RRETURN(MATCH_NOMATCH);\n            }\n          }\n        else\n#endif\n        \n          {\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (fi >= max || eptr >= md->end_subject || fc == md->lcc[*eptr++])\n              RRETURN(MATCH_NOMATCH);\n            }\n          }\n        \n        }\n\n      \n\n      else\n        {\n        pp = eptr;\n\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          register test_snippet d;\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(d, eptr, len);\n            if (d < 256) d = md->lcc[d];\n            if (fc == d) break;\n            eptr += len;\n            }\n          for(;;)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (eptr-- == pp) break;        \n            BACKCHAR(eptr);\n            }\n          }\n        else\n#endif\n        \n          {\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || fc == md->lcc[*eptr]) break;\n            eptr++;\n            }\n          while (eptr >= pp)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            eptr--;\n            }\n          }\n\n        RRETURN(MATCH_NOMATCH);\n        }\n      \n      }\n\n    \n\n    else\n      {\n#ifdef SUPPORT_UTF8\n      \n      if (md->utf8)\n        {\n        register test_snippet d;\n        for (i = 1; i <= min; i++)\n          {\n          GETCHARINC(d, eptr);\n          if (fc == d) RRETURN(MATCH_NOMATCH);\n          }\n        }\n      else\n#endif\n      \n        {\n        for (i = 1; i <= min; i++)\n          if (fc == *eptr++) RRETURN(MATCH_NOMATCH);\n        }\n\n      if (min == max) continue;\n\n      if (minimize)\n        {\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          register test_snippet d;\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            GETCHARINC(d, eptr);\n            if (fi >= max || eptr >= md->end_subject || fc == d)\n              RRETURN(MATCH_NOMATCH);\n            }\n          }\n        else\n#endif\n        \n          {\n          for (fi = min;; fi++)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (fi >= max || eptr >= md->end_subject || fc == *eptr++)\n              RRETURN(MATCH_NOMATCH);\n            }\n          }\n        \n        }\n\n      \n\n      else\n        {\n        pp = eptr;\n\n#ifdef SUPPORT_UTF8\n        \n        if (md->utf8)\n          {\n          register test_snippet d;\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(d, eptr, len);\n            if (fc == d) break;\n            eptr += len;\n            }\n          for(;;)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (eptr-- == pp) break;        \n            BACKCHAR(eptr);\n            }\n          }\n        else\n#endif\n        \n          {\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || fc == *eptr) break;\n            eptr++;\n            }\n          while (eptr >= pp)\n            {\n            RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            eptr--;\n            }\n          }\n\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    \n\n    /* Match a single character type repeatedly; several different opcodes\n    share code. This is very similar to the code for single characters, but we\n    repeat it in the test_snippeterests of efficiency. */\n\n    case OP_TYPEEXACT:\n    min = max = GET2(ecode, 1);\n    minimize = TRUE;\n    ecode += 3;\n    goto REPEATTYPE;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    min = 0;\n    max = GET2(ecode, 1);\n    minimize = *ecode == OP_TYPEMINUPTO;\n    ecode += 3;\n    goto REPEATTYPE;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    c = *ecode++ - OP_TYPESTAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    /* Common code for all repeated single character type matches. Note that\n    in UTF-8 mode, '.' matches a character of any length, but for the other\n    character types, the valid characters are all one-byte long. */\n\n    REPEATTYPE:\n    ctype = *ecode++;      \n\n#ifdef SUPPORT_UCP\n    if (ctype == OP_PROP || ctype == OP_NOTPROP)\n      {\n      prop_fail_result = ctype == OP_NOTPROP;\n      prop_type = *ecode++;\n      if (prop_type >= 128)\n        {\n        prop_test_against = prop_type - 128;\n        prop_test_variable = &prop_category;\n        }\n      else\n        {\n        prop_test_against = prop_type;\n        prop_test_variable = &prop_chartype;\n        }\n      }\n    else prop_type = -1;\n#endif\n\n    /* First, ensure the minimum number of matches are present. Use inline\n    code for maximizing the speed, and do the type test once at the start\n    (i.e. keep it out of the loop). Also we can test that there are at least\n    the minimum number of bytes before we start. This isn't as effective in\n    UTF-8 mode, but it does no harm. Separate the UTF-8 code completely as that\n    is tidier. Also separate the UCP code, which can be the same for both UTF-8\n    and single-bytes. */\n\n    if (min > md->end_subject - eptr) RRETURN(MATCH_NOMATCH);\n    if (min > 0)\n      {\n#ifdef SUPPORT_UCP\n      if (prop_type > 0)\n        {\n        for (i = 1; i <= min; i++)\n          {\n          GETCHARINC(c, eptr);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if ((*prop_test_variable == prop_test_against) == prop_fail_result)\n            RRETURN(MATCH_NOMATCH);\n          }\n        }\n\n      /* Match extended Unicode sequences. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (ctype == OP_EXTUNI)\n        {\n        for (i = 1; i <= min; i++)\n          {\n          GETCHARINCTEST(c, eptr);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if (prop_category == ucp_M) RRETURN(MATCH_NOMATCH);\n          while (eptr < md->end_subject)\n            {\n            test_snippet len = 1;\n            if (!md->utf8) c = *eptr; else\n              {\n              GETCHARLEN(c, eptr, len);\n              }\n            prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n            if (prop_category != ucp_M) break;\n            eptr += len;\n            }\n          }\n        }\n\n      else\n#endif     \n\n\n\n#ifdef SUPPORT_UTF8\n      if (md->utf8) switch(ctype)\n        {\n        case OP_ANY:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             (*eptr++ == NEWLINE && (ims & PCRE_DOTALL) == 0))\n            RRETURN(MATCH_NOMATCH);\n          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n          }\n        break;\n\n        case OP_ANYBYTE:\n        eptr += min;\n        break;\n\n        case OP_NOT_DIGIT:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          GETCHARINC(c, eptr);\n          if (c < 128 && (md->ctypes[c] & ctype_digit) != 0)\n            RRETURN(MATCH_NOMATCH);\n          }\n        break;\n\n        case OP_DIGIT:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             *eptr >= 128 || (md->ctypes[*eptr++] & ctype_digit) == 0)\n            RRETURN(MATCH_NOMATCH);\n          \n          }\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             (*eptr < 128 && (md->ctypes[*eptr++] & ctype_space) != 0))\n            RRETURN(MATCH_NOMATCH);\n          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n          }\n        break;\n\n        case OP_WHITESPACE:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             *eptr >= 128 || (md->ctypes[*eptr++] & ctype_space) == 0)\n            RRETURN(MATCH_NOMATCH);\n          \n          }\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             (*eptr < 128 && (md->ctypes[*eptr++] & ctype_word) != 0))\n            RRETURN(MATCH_NOMATCH);\n          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n          }\n        break;\n\n        case OP_WORDCHAR:\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             *eptr >= 128 || (md->ctypes[*eptr++] & ctype_word) == 0)\n            RRETURN(MATCH_NOMATCH);\n          \n          }\n        break;\n\n        default:\n        RRETURN(PCRE_ERROR_INTERNAL);\n        }  \n\n      else\n#endif     \n\n      /* Code for the non-UTF-8 case for minimum matching of operators other\n      than OP_PROP and OP_NOTPROP. */\n\n      switch(ctype)\n        {\n        case OP_ANY:\n        if ((ims & PCRE_DOTALL) == 0)\n          {\n          for (i = 1; i <= min; i++)\n            if (*eptr++ == NEWLINE) RRETURN(MATCH_NOMATCH);\n          }\n        else eptr += min;\n        break;\n\n        case OP_ANYBYTE:\n        eptr += min;\n        break;\n\n        case OP_NOT_DIGIT:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_digit) != 0) RRETURN(MATCH_NOMATCH);\n        break;\n\n        case OP_DIGIT:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_digit) == 0) RRETURN(MATCH_NOMATCH);\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_space) != 0) RRETURN(MATCH_NOMATCH);\n        break;\n\n        case OP_WHITESPACE:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_space) == 0) RRETURN(MATCH_NOMATCH);\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_word) != 0)\n            RRETURN(MATCH_NOMATCH);\n        break;\n\n        case OP_WORDCHAR:\n        for (i = 1; i <= min; i++)\n          if ((md->ctypes[*eptr++] & ctype_word) == 0)\n            RRETURN(MATCH_NOMATCH);\n        break;\n\n        default:\n        RRETURN(PCRE_ERROR_INTERNAL);\n        }\n      }\n\n    \n\n    if (min == max) continue;\n\n    /* If minimizing, we have to test the rest of the pattern before each\n    subsequent match. Again, separate the UTF-8 case for speed, and also\n    separate the UCP cases. */\n\n    if (minimize)\n      {\n#ifdef SUPPORT_UCP\n      if (prop_type > 0)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          GETCHARINC(c, eptr);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if ((*prop_test_variable == prop_test_against) == prop_fail_result)\n            RRETURN(MATCH_NOMATCH);\n          }\n        }\n\n      /* Match extended Unicode sequences. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (ctype == OP_EXTUNI)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          GETCHARINCTEST(c, eptr);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if (prop_category == ucp_M) RRETURN(MATCH_NOMATCH);\n          while (eptr < md->end_subject)\n            {\n            test_snippet len = 1;\n            if (!md->utf8) c = *eptr; else\n              {\n              GETCHARLEN(c, eptr, len);\n              }\n            prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n            if (prop_category != ucp_M) break;\n            eptr += len;\n            }\n          }\n        }\n\n      else\n#endif     \n\n#ifdef SUPPORT_UTF8\n      \n      if (md->utf8)\n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n\n          GETCHARINC(c, eptr);\n          switch(ctype)\n            {\n            case OP_ANY:\n            if ((ims & PCRE_DOTALL) == 0 && c == NEWLINE) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_ANYBYTE:\n            break;\n\n            case OP_NOT_DIGIT:\n            if (c < 256 && (md->ctypes[c] & ctype_digit) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_DIGIT:\n            if (c >= 256 || (md->ctypes[c] & ctype_digit) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WHITESPACE:\n            if (c < 256 && (md->ctypes[c] & ctype_space) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WHITESPACE:\n            if  (c >= 256 || (md->ctypes[c] & ctype_space) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WORDCHAR:\n            if (c < 256 && (md->ctypes[c] & ctype_word) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WORDCHAR:\n            if (c >= 256 && (md->ctypes[c] & ctype_word) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            default:\n            RRETURN(PCRE_ERROR_INTERNAL);\n            }\n          }\n        }\n      else\n#endif\n      \n        {\n        for (fi = min;; fi++)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (fi >= max || eptr >= md->end_subject) RRETURN(MATCH_NOMATCH);\n          c = *eptr++;\n          switch(ctype)\n            {\n            case OP_ANY:\n            if ((ims & PCRE_DOTALL) == 0 && c == NEWLINE) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_ANYBYTE:\n            break;\n\n            case OP_NOT_DIGIT:\n            if ((md->ctypes[c] & ctype_digit) != 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_DIGIT:\n            if ((md->ctypes[c] & ctype_digit) == 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WHITESPACE:\n            if ((md->ctypes[c] & ctype_space) != 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WHITESPACE:\n            if  ((md->ctypes[c] & ctype_space) == 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WORDCHAR:\n            if ((md->ctypes[c] & ctype_word) != 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WORDCHAR:\n            if ((md->ctypes[c] & ctype_word) == 0) RRETURN(MATCH_NOMATCH);\n            break;\n\n            default:\n            RRETURN(PCRE_ERROR_INTERNAL);\n            }\n          }\n        }\n      \n      }\n\n    /* If maximizing it is worth using inline code for speed, doing the type\n    test once at the start (i.e. keep it out of the loop). Again, keep the\n    UTF-8 and UCP stuff separate. */\n\n    else\n      {\n      pp = eptr;  \n\n#ifdef SUPPORT_UCP\n      if (prop_type > 0)\n        {\n        for (i = min; i < max; i++)\n          {\n          test_snippet len = 1;\n          if (eptr >= md->end_subject) break;\n          GETCHARLEN(c, eptr, len);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if ((*prop_test_variable == prop_test_against) == prop_fail_result)\n            break;\n          eptr+= len;\n          }\n\n        \n\n        for(;;)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (eptr-- == pp) break;        \n          BACKCHAR(eptr);\n          }\n        }\n\n      /* Match extended Unicode sequences. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (ctype == OP_EXTUNI)\n        {\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject) break;\n          GETCHARINCTEST(c, eptr);\n          prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n          if (prop_category == ucp_M) break;\n          while (eptr < md->end_subject)\n            {\n            test_snippet len = 1;\n            if (!md->utf8) c = *eptr; else\n              {\n              GETCHARLEN(c, eptr, len);\n              }\n            prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n            if (prop_category != ucp_M) break;\n            eptr += len;\n            }\n          }\n\n        \n\n        for(;;)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (eptr-- == pp) break;        \n          for (;;)                        \n            {\n            test_snippet len = 1;\n            BACKCHAR(eptr);\n            if (!md->utf8) c = *eptr; else\n              {\n              GETCHARLEN(c, eptr, len);\n              }\n            prop_category = ucp_findchar(c, &prop_chartype, &prop_othercase);\n            if (prop_category != ucp_M) break;\n            eptr--;\n            }\n          }\n        }\n\n      else\n#endif   \n\n#ifdef SUPPORT_UTF8\n      \n\n      if (md->utf8)\n        {\n        switch(ctype)\n          {\n          case OP_ANY:\n\n          /* Special code is required for UTF8, but when the maximum is unlimited\n          we don't need it, so we repeat the non-UTF8 code. This is probably\n          worth it, because .* is quite a common idiom. */\n\n          if (max < INT_MAX)\n            {\n            if ((ims & PCRE_DOTALL) == 0)\n              {\n              for (i = min; i < max; i++)\n                {\n                if (eptr >= md->end_subject || *eptr == NEWLINE) break;\n                eptr++;\n                while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n                }\n              }\n            else\n              {\n              for (i = min; i < max; i++)\n                {\n                eptr++;\n                while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n                }\n              }\n            }\n\n          \n\n          else\n            {\n            if ((ims & PCRE_DOTALL) == 0)\n              {\n              for (i = min; i < max; i++)\n                {\n                if (eptr >= md->end_subject || *eptr == NEWLINE) break;\n                eptr++;\n                }\n              break;\n              }\n            else\n              {\n              c = max - min;\n              if (c > md->end_subject - eptr) c = md->end_subject - eptr;\n              eptr += c;\n              }\n            }\n          break;\n\n          \n\n          case OP_ANYBYTE:\n          c = max - min;\n          if (c > md->end_subject - eptr) c = md->end_subject - eptr;\n          eptr += c;\n          break;\n\n          case OP_NOT_DIGIT:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c < 256 && (md->ctypes[c] & ctype_digit) != 0) break;\n            eptr+= len;\n            }\n          break;\n\n          case OP_DIGIT:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c >= 256 ||(md->ctypes[c] & ctype_digit) == 0) break;\n            eptr+= len;\n            }\n          break;\n\n          case OP_NOT_WHITESPACE:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c < 256 && (md->ctypes[c] & ctype_space) != 0) break;\n            eptr+= len;\n            }\n          break;\n\n          case OP_WHITESPACE:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c >= 256 ||(md->ctypes[c] & ctype_space) == 0) break;\n            eptr+= len;\n            }\n          break;\n\n          case OP_NOT_WORDCHAR:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c < 256 && (md->ctypes[c] & ctype_word) != 0) break;\n            eptr+= len;\n            }\n          break;\n\n          case OP_WORDCHAR:\n          for (i = min; i < max; i++)\n            {\n            test_snippet len = 1;\n            if (eptr >= md->end_subject) break;\n            GETCHARLEN(c, eptr, len);\n            if (c >= 256 || (md->ctypes[c] & ctype_word) == 0) break;\n            eptr+= len;\n            }\n          break;\n\n          default:\n          RRETURN(PCRE_ERROR_INTERNAL);\n          }\n\n        \n\n        for(;;)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (eptr-- == pp) break;        \n          BACKCHAR(eptr);\n          }\n        }\n      else\n#endif\n\n      \n        {\n        switch(ctype)\n          {\n          case OP_ANY:\n          if ((ims & PCRE_DOTALL) == 0)\n            {\n            for (i = min; i < max; i++)\n              {\n              if (eptr >= md->end_subject || *eptr == NEWLINE) break;\n              eptr++;\n              }\n            break;\n            }\n          \n\n          case OP_ANYBYTE:\n          c = max - min;\n          if (c > md->end_subject - eptr) c = md->end_subject - eptr;\n          eptr += c;\n          break;\n\n          case OP_NOT_DIGIT:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) != 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          case OP_DIGIT:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) == 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          case OP_NOT_WHITESPACE:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) != 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          case OP_WHITESPACE:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) == 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          case OP_NOT_WORDCHAR:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) != 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          case OP_WORDCHAR:\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) == 0)\n              break;\n            eptr++;\n            }\n          break;\n\n          default:\n          RRETURN(PCRE_ERROR_INTERNAL);\n          }\n\n        \n\n        while (eptr >= pp)\n          {\n          RMATCH(rrc, eptr, ecode, offset_top, md, ims, eptrb, 0);\n          eptr--;\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          }\n        }\n\n      \n\n      RRETURN(MATCH_NOMATCH);\n      }\n    \n\n    /* There's been some horrible disaster. Since all codes > OP_BRA are\n    for capturing brackets, and there shouldn't be any gaps between 0 and\n    OP_BRA, arrival here can only mean there is something seriously wrong\n    in the code above or the OP_xxx definitions. */\n\n    default:\n    DPRINTF((\"Unknown opcode %d\\n\", *ecode));\n    RRETURN(PCRE_ERROR_UNKNOWN_NODE);\n    }\n\n  /* Do not stick any code in here without much thought; it is assumed\n  that \"continue\" in the code above comes out to here to repeat the main\n  loop. */\n\n  }             \n\n}",
    "predicted": ""
  },
  "httpd_ba53f6e6e3eb91430d87987a7fa0df786c119477_0", {
    "ID": "httpd_ba53f6e6e3eb91430d87987a7fa0df786c119477_0",
    "UID": "81",
    "code": "AP_DECLARE(char *) ap_os_escape_path(apr_pool_t *p, const char *path, int test_snippet\n{\n    char *copy = apr_palloc(p, 3 * strlen(path) + 3);\n    const unsigned char *s = (const unsigned char *)path;\n    unsigned char *d = (unsigned char *)copy;\n    unsigned c;\n\n    if (!test_snippet {\n        const char *colon = ap_strchr_c(path, ':');\n        const char *slash = ap_strchr_c(path, '/');\n\n        if (colon && (!slash || colon < slash)) {\n            *d++ = '.';\n            *d++ = '/';\n        }\n    }\n    while ((c = *s)) {\n        if (TEST_CHAR(c, T_OS_ESCAPE_PATH)) {\n            d = c2x(c, '%', d);\n        }\n        else {\n            *d++ = c;\n        }\n        ++s;\n    }\n    *d = '\\0';\n    return copy;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_86e4b3640ccdadd5ff27e70c11fd9acbf5b4361c_0", {
    "ID": "httpd_86e4b3640ccdadd5ff27e70c11fd9acbf5b4361c_0",
    "UID": "86",
    "code": "AP_DECLARE(char *) ap_getword_white(apr_pool_t *atrans, const char test_snippet\n{\n    const char *pos = *line;\n    int len;\n    char *res;\n\n    while (!apr_isspace(*pos) && *pos) {\n        ++pos;\n    }\n\n    len = pos - *line;\n    res = (char *)apr_palloc(atrans, len + 1);\n    memcpy(res, *line, len);\n    res[len] = 0;\n\n    while (apr_isspace(*pos)) {\n        ++pos;\n    }\n\n    *line = pos;\n\n    return res;\n}",
    "predicted": "119,Improper Restriction of Operations within the Bounds of a Memory Buffer"
  },
  "httpd_0861082647d8e426e3226f6739d707a216043af4_0", {
    "ID": "httpd_0861082647d8e426e3226f6739d707a216043af4_0",
    "UID": "90",
    "code": "apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    conn_rec *c = f->c;\n    core_net_rec *net = f->ctx;\n    core_output_filter_ctx_t *ctx = net->out_ctx;\n    apr_bucket_brigade *bb;\n    apr_bucket *bucket, *next;\n    apr_size_t bytes_in_brigade, non_file_bytes_in_brigade;\n\n    if (ctx == NULL) {\n        apr_status_t rv;\n        ctx = apr_pcalloc(c->pool, sizeof(*ctx));\n        net->out_ctx = (core_output_filter_ctx_t *)ctx;\n        rv = apr_socket_opt_set(net->client_socket, APR_SO_NONBLOCK, 1);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    if (new_bb != NULL) {\n        for (bucket = APR_BRIGADE_FIRST(new_bb); bucket != APR_BRIGADE_SENTINEL(new_bb); bucket = APR_BUCKET_NEXT(bucket)) {\n            if (bucket->length > 0) {\n                ctx->bytes_in += bucket->length;\n            }\n        }\n    }\n\n    if ((ctx->buffered_bb != NULL) &&\n        !APR_BRIGADE_EMPTY(ctx->buffered_bb)) {\n        bb = ctx->buffered_bb;\n        ctx->buffered_bb = NULL;\n        if (new_bb != NULL) {\n            APR_BRIGADE_CONCAT(bb, new_bb);\n        }\n        c->data_in_output_filters = 0;\n    }\n    else if (new_bb != NULL) {\n        bb = new_bb;\n    }\n    else {\n        return APR_SUCCESS;\n    }\n\n    /* Scan through the brigade and decide whether to attempt a write,\n     * based on the following rules:\n     *\n     *  1) The new_bb is null: Do a nonblocking write of as much as\n     *     possible: do a nonblocking write of as much data as possible,\n     *     then save the rest in ctx->buffered_bb.  (If new_bb == NULL,\n     *     it probably means that the MPM is doing asynchronous write\n     *     completion and has just determined that this connection\n     *     is writable.)\n     *\n     *  2) The brigade contains a flush bucket: Do a blocking write\n     *     of everything up that point.\n     *\n     *  3) The request is in CONN_STATE_HANLDER state, and the brigade\n     *     contains at least THRESHOLD_MAX_BUFFER bytes in non-file\n     *     buckets: Do blocking writes until the amount of data in the\n     *     buffer is less than THRESHOLD_MAX_BUFFER.  (The point of this\n     *     rule is to provide flow control, in case a handler is\n     *     streaming out lots of data faster than the data can be\n     *     sent to the client.)\n     *\n     *  4) The brigade contains at least THRESHOLD_MIN_WRITE\n     *     bytes: Do a nonblocking write of as much data as possible,\n     *     then save the rest in ctx->buffered_bb.\n     */\n\n    if (new_bb == NULL) {\n        apr_status_t rv = send_brigade_nonblocking(net->client_socket, bb,\n                                                   &(ctx->bytes_written), c);\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            rv = APR_SUCCESS;\n        }\n        setaside_remaining_output(f, ctx, bb, 0, c);\n        return rv;\n    }\n\n    bytes_in_brigade = 0;\n    non_file_bytes_in_brigade = 0;\n    for (bucket = APR_BRIGADE_FIRST(bb); bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        next = APR_BUCKET_NEXT(bucket);\n        if (APR_BUCKET_IS_FLUSH(bucket)) {\n            apr_bucket_brigade *remainder = apr_brigade_split(bb, next);\n            apr_status_t rv = send_brigade_blocking(net->client_socket, bb,\n                                                    &(ctx->bytes_written), c);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            bb = remainder;\n            next = APR_BRIGADE_FIRST(bb);\n            bytes_in_brigade = 0;\n            non_file_bytes_in_brigade = 0;\n        }\n        else if (!APR_BUCKET_IS_METADATA(bucket)) {\n            if (bucket->length < 0) {\n                const char *data;\n                apr_size_t length;\n                \n                apr_status_t rv =\n                    apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                \n                next = APR_BUCKET_NEXT(bucket);\n            }\n            bytes_in_brigade += bucket->length;\n            if (!APR_BUCKET_IS_FILE(bucket)) {\n                non_file_bytes_in_brigade += bucket->length;\n            }\n        }\n    }\n\n    if (non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER) {\n        /* ### Writing the entire brigade may be excessive; we really just\n         * ### need to send enough data to be under THRESHOLD_MAX_BUFFER.\n         */\n        apr_status_t rv = send_brigade_blocking(net->client_socket, bb,\n                                                &(ctx->bytes_written), c);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n    else if (bytes_in_brigade >= THRESHOLD_MIN_WRITE) {\n        apr_status_t rv = send_brigade_nonblocking(net->client_socket, bb,\n                                                   &(ctx->bytes_written), c);\n        if ((rv != APR_SUCCESS) && (!APR_STATUS_IS_EAGAIN(rv))) {\n            return rv;\n        }\n    }\n\n    setaside_remaining_output(f, ctx, bb, 1, c);\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_928f6dadd4f46060a642390d4b13fe83733e7457_0", {
    "ID": "httpd_928f6dadd4f46060a642390d4b13fe83733e7457_0",
    "UID": "91",
    "code": "static void dump_loaded_modules(apr_pool_t *p, server_rec test_snippet\n{\n    ap_module_symbol_t *modie;\n    ap_module_symbol_t *modi;\n    so_server_conf *sconf;\n    int i;\n    apr_file_t *out = NULL;\n\n    if (!ap_exists_config_define(\"DUMP_MODULES\")) {\n        return;\n    }\n\n    apr_file_open_stderr(&out, p);\n\n    apr_file_printf(out, \"Loaded Modules:\\n\");\n\n    sconf = (so_server_conf *)ap_get_module_config(s->module_config,\n                                                   &so_module);\n    for (i = 0; ; i++) {\n        modi = &ap_prelinked_module_symbols[i];\n        if (modi->name != NULL) {\n            apr_file_printf(out, \" %s (static)\\n\", modi->name);\n        }\n        else {\n            break;\n        }\n    }\n\n    modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;\n    for (i = 0; i < sconf->loaded_modules->nelts; i++) {\n        modi = &modie[i];\n        if (modi->name != NULL) {\n            apr_file_printf(out, \" %s (shared)\\n\", modi->name);\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_06a0fa96d482d2ff0225ac5824eec4c9e6e3765b_0", {
    "ID": "httpd_06a0fa96d482d2ff0225ac5824eec4c9e6e3765b_0",
    "UID": "93",
    "code": "static ap_filter_t *add_any_filter(const char *name, void test_snippet\n                                   request_rec *r, conn_rec *c,\n                                   const filter_trie_node *reg_filter_set,\n                                   ap_filter_t **r_filters,\n                                   ap_filter_t **p_filters,\n                                   ap_filter_t **c_filters)\n{\n    if (reg_filter_set) {\n        const char *n;\n        const filter_trie_node *node;\n\n        node = reg_filter_set;\n        for (n = name; *n; n++) {\n            int start, end;\n            start = 0;\n            end = node->nchildren - 1;\n            while (end >= start) {\n                int middle = (end + start) / 2;\n                char ch = node->children[middle].c;\n                if (*n == ch) {\n                    node = node->children[middle].child;\n                    break;\n                }\n                else if (*n < ch) {\n                    end = middle - 1;\n                }\n                else {\n                    start = middle + 1;\n                }\n            }\n            if (end < start) {\n                node = NULL;\n                break;\n            }\n        }\n\n        if (node && node->frec) {\n            return add_any_filter_handle(node->frec, ctx, r, c, r_filters,\n                                         p_filters, c_filters);\n        }\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,\n                 \"an unknown filter was not added: %s\", name);\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_45bbe95089501a0e03a31e7628f472fe54870560_0", {
    "ID": "httpd_45bbe95089501a0e03a31e7628f472fe54870560_0",
    "UID": "95",
    "code": "AP_DECLARE(void) ap_getparents(char test_snippet\n{\n    char *next;\n    int l, w, first_dot;\n\n    \n    \n    for (next = name; *next && (*next != '.'); next++) {\n    }\n\n    l = w = first_dot = next - name;\n    while (name[l] != '\\0') {\n        if (name[l] == '.' && IS_SLASH(name[l + 1])\n            && (l == 0 || IS_SLASH(name[l - 1])))\n            l += 2;\n        else\n            name[w++] = name[l++];\n    }\n\n    \n    if (w == 1 && name[0] == '.')\n        w--;\n    else if (w > 1 && name[w - 1] == '.' && IS_SLASH(name[w - 2]))\n        w--;\n    name[w] = '\\0';\n\n    \n    l = first_dot;\n\n    while (name[l] != '\\0') {\n        if (name[l] == '.' && name[l + 1] == '.' && IS_SLASH(name[l + 2])\n            && (l == 0 || IS_SLASH(name[l - 1]))) {\n            register int m = l + 3, n;\n\n            l = l - 2;\n            if (l >= 0) {\n                while (l >= 0 && !IS_SLASH(name[l]))\n                    l--;\n                l++;\n            }\n            else\n                l = 0;\n            n = l;\n            while ((name[n] = name[m]))\n                (++n, ++m);\n        }\n        else\n            ++l;\n    }\n\n    \n    if (l == 2 && name[0] == '.' && name[1] == '.')\n        name[0] = '\\0';\n    else if (l > 2 && name[l - 1] == '.' && name[l - 2] == '.'\n             && IS_SLASH(name[l - 3])) {\n        l = l - 4;\n        if (l >= 0) {\n            while (l >= 0 && !IS_SLASH(name[l]))\n                l--;\n            l++;\n        }\n        else\n            l = 0;\n        name[l] = '\\0';\n    }\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_28718c75dde4082d5788ebcd8e26051656851fb0_0", {
    "ID": "httpd_28718c75dde4082d5788ebcd8e26051656851fb0_0",
    "UID": "102",
    "code": "AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char test_snippet\n{\n    int *methnum;\n\n    if (methods_registry == NULL) {\n        ap_method_registry_init(p);\n    }\n\n    if (methname == NULL) {\n        return M_INVALID;\n    }\n\n    /* Check if the method was previously registered.  If it was\n     * return the associated method number.\n     */\n    methnum = (int *)apr_hash_get(methods_registry, methname,\n                                  APR_HASH_KEY_STRING);\n    if (methnum != NULL)\n        return *methnum;\n\n    if (cur_method_number > METHOD_NUMBER_LAST) {\n        /* The method registry  has run out of dynamically\n         * assignable method numbers. Log this and return M_INVALID.\n         */\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p,\n                      \"Maximum new request methods %d reached while \"\n                      \"registering method %s.\",\n                      METHOD_NUMBER_LAST, methname);\n        return M_INVALID;\n    }\n\n    register_one_method(p, methname, cur_method_number);\n    return cur_method_number++;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_c1cf2c5a7371b138236f22c5bee649b19944b0bb_0", {
    "ID": "httpd_c1cf2c5a7371b138236f22c5bee649b19944b0bb_0",
    "UID": "105",
    "code": "AP_DECLARE(int) ap_directory_walk(request_rec test_snippet\n{\n    ap_conf_vector_t *now_merged = NULL;\n    core_server_config *sconf = ap_get_module_config(r->server->module_config,\n                                                     &core_module);\n    ap_conf_vector_t **sec_ent = (ap_conf_vector_t **) sconf->sec_dir->elts;\n    int num_sec = sconf->sec_dir->nelts;\n    walk_cache_t *cache;\n    char *entry_dir;\n    apr_status_t rv;\n\n    /* XXX: Better (faster) tests needed!!!\n     *\n     * \"OK\" as a response to a real problem is not _OK_, but to allow broken\n     * modules to proceed, we will permit the not-a-path filename to pass the\n     * following two tests.  This behavior may be revoked in future versions\n     * of Apache.  We still must catch it later if it's heading for the core\n     * handler.  Leave INFO notes here for module debugging.\n     */\n    if (r->filename == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                      \"Module bug?  Request filename is missing for URI %s\",\n                      r->uri);\n       return OK;\n    }\n\n    /* Canonicalize the file path without resolving filename case or aliases\n     * so we can begin by checking the cache for a recent directory walk.\n     * This call will ensure we have an absolute path in the same pass.\n     */\n    if ((rv = apr_filepath_merge(&entry_dir, NULL, r->filename,\n                                 APR_FILEPATH_NOTRELATIVE, r->pool))\n                  != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                      \"Module bug?  Request filename path %s is invalid or \"\n                      \"or not absolute for uri %s\",\n                      r->filename, r->uri);\n        return OK;\n    }\n\n    /* XXX Notice that this forces path_info to be canonical.  That might\n     * not be desired by all apps.  However, some of those same apps likely\n     * have significant security holes.\n     */\n    r->filename = entry_dir;\n\n    cache = prep_walk_cache(AP_NOTE_DIRECTORY_WALK, r);\n\n    /* If this is not a dirent subrequest with a preconstructed\n     * r->finfo value, then we can simply stat the filename to\n     * save burning mega-cycles with unneeded stats - if this is\n     * an exact file match.  We don't care about failure... we\n     * will stat by component failing this meager attempt.\n     *\n     * It would be nice to distinguish APR_ENOENT from other\n     * types of failure, such as APR_ENOTDIR.  We can do something\n     * with APR_ENOENT, knowing that the path is good.\n     */\n    if (!r->finfo.filetype || r->finfo.filetype == APR_LNK) {\n        rv = apr_stat(&r->finfo, r->filename, APR_FINFO_MIN, r->pool);\n\n        /* some OSs will return APR_SUCCESS/APR_REG if we stat\n         * a regular file but we have '/' at the end of the name;\n         *\n         * other OSs will return APR_ENOTDIR for that situation;\n         *\n         * handle it the same everywhere by simulating a failure\n         * if it looks like a directory but really isn't\n         *\n         * Also reset if the stat failed, just for safety.\n         */\n        if ((rv != APR_SUCCESS) ||\n            (r->finfo.filetype &&\n             (r->finfo.filetype != APR_DIR) &&\n             (r->filename[strlen(r->filename) - 1] == '/'))) {\n             r->finfo.filetype = 0; \n        }\n    }\n\n    if (r->finfo.filetype == APR_REG) {\n        entry_dir = ap_make_dirstr_parent(r->pool, entry_dir);\n    }\n    else if (r->filename[strlen(r->filename) - 1] != '/') {\n        entry_dir = apr_pstrcat(r->pool, r->filename, \"/\", NULL);\n    }\n\n    /* If we have a file already matches the path of r->filename,\n     * and the vhost's list of directory sections hasn't changed,\n     * we can skip rewalking the directory_walk entries.\n     */\n    if (cache->cached\n        && ((r->finfo.filetype == APR_REG)\n            || ((r->finfo.filetype == APR_DIR)\n                && (!r->path_info || !*r->path_info)))\n        && (cache->dir_conf_tested == sec_ent)\n        && (strcmp(entry_dir, cache->cached) == 0)) {\n        /* Well this looks really familiar!  If our end-result (per_dir_result)\n         * didn't change, we have absolutely nothing to do :)\n         * Otherwise (as is the case with most dir_merged/file_merged requests)\n         * we must merge our dir_conf_merged onto this new r->per_dir_config.\n         */\n        if (r->per_dir_config == cache->per_dir_result) {\n            return OK;\n        }\n\n        if (r->per_dir_config == cache->dir_conf_merged) {\n            r->per_dir_config = cache->per_dir_result;\n            return OK;\n        }\n\n        if (cache->walked->nelts) {\n            now_merged = ((walk_walked_t*)cache->walked->elts)\n                [cache->walked->nelts - 1].merged;\n        }\n    }\n    else {\n        /* We start now_merged from NULL since we want to build\n         * a locations list that can be merged to any vhost.\n         */\n        int sec_idx;\n        int matches = cache->walked->nelts;\n        walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;\n        core_dir_config *this_dir;\n        core_opts_t opts;\n        apr_finfo_t thisinfo;\n        char *save_path_info;\n        apr_size_t buflen;\n        char *buf;\n        unsigned int seg, startseg;\n\n        /* Invariant: from the first time filename_len is set until\n         * it goes out of scope, filename_len==strlen(r->filename)\n         */\n        apr_size_t filename_len;\n#ifdef CASE_BLIND_FILESYSTEM\n        apr_size_t canonical_len;\n#endif\n\n        /*\n         * We must play our own mini-merge game here, for the few\n         * running dir_config values we care about within dir_walk.\n         * We didn't start the merge from r->per_dir_config, so we\n         * accumulate opts and override as we merge, from the globals.\n         */\n        this_dir = ap_get_module_config(r->per_dir_config, &core_module);\n        opts.opts = this_dir->opts;\n        opts.add = this_dir->opts_add;\n        opts.remove = this_dir->opts_remove;\n        opts.override = this_dir->override;\n\n        /* Set aside path_info to merge back onto path_info later.\n         * If r->filename is a directory, we must remerge the path_info,\n         * before we continue!  [Directories cannot, by defintion, have\n         * path info.  Either the next segment is not-found, or a file.]\n         *\n         * r->path_info tracks the unconsumed source path.\n         * r->filename  tracks the path as we process it\n         */\n        if ((r->finfo.filetype == APR_DIR) && r->path_info && *r->path_info)\n        {\n            if ((rv = apr_filepath_merge(&r->path_info, r->filename,\n                                         r->path_info,\n                                         APR_FILEPATH_NOTABOVEROOT, r->pool))\n                != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                              \"dir_walk error, path_info %s is not relative \"\n                              \"to the filename path %s for uri %s\",\n                              r->path_info, r->filename, r->uri);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            save_path_info = NULL;\n        }\n        else {\n            save_path_info = r->path_info;\n            r->path_info = r->filename;\n        }\n\n#ifdef CASE_BLIND_FILESYSTEM\n\n        canonical_len = 0;\n        while (r->canonical_filename && r->canonical_filename[canonical_len]\n               && (r->canonical_filename[canonical_len]\n                   == r->path_info[canonical_len])) {\n             ++canonical_len;\n        }\n\n        while (canonical_len\n               && ((r->canonical_filename[canonical_len - 1] != '/'\n                   && r->canonical_filename[canonical_len - 1])\n                   || (r->path_info[canonical_len - 1] != '/'\n                       && r->path_info[canonical_len - 1]))) {\n            --canonical_len;\n        }\n\n        /*\n         * Now build r->filename component by component, starting\n         * with the root (on Unix, simply \"/\").  We will make a huge\n         * assumption here for efficiency, that any canonical path\n         * already given included a canonical root.\n         */\n        rv = apr_filepath_root((const char **)&r->filename,\n                               (const char **)&r->path_info,\n                               canonical_len ? 0 : APR_FILEPATH_TRUENAME,\n                               r->pool);\n        filename_len = strlen(r->filename);\n\n        /*\n         * Bad assumption above?  If the root's length is longer\n         * than the canonical length, then it cannot be trusted as\n         * a truename.  So try again, this time more seriously.\n         */\n        if ((rv == APR_SUCCESS) && canonical_len\n            && (filename_len > canonical_len)) {\n            rv = apr_filepath_root((const char **)&r->filename,\n                                   (const char **)&r->path_info,\n                                   APR_FILEPATH_TRUENAME, r->pool);\n            filename_len = strlen(r->filename);\n            canonical_len = 0;\n        }\n\n#else \n\n        rv = apr_filepath_root((const char **)&r->filename,\n                               (const char **)&r->path_info,\n                               0, r->pool);\n        filename_len = strlen(r->filename);\n\n#endif\n\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"dir_walk error, could not determine the root \"\n                          \"path of filename %s%s for uri %s\",\n                          r->filename, r->path_info, r->uri);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        /* Working space for terminating null and an extra / is required.\n         */\n        buflen = filename_len + strlen(r->path_info) + 2;\n        buf = apr_palloc(r->pool, buflen);\n        memcpy(buf, r->filename, filename_len + 1);\n        r->filename = buf;\n        thisinfo.valid = APR_FINFO_TYPE;\n        thisinfo.filetype = APR_DIR; \n\n        /*\n         * seg keeps track of which segment we've copied.\n         * sec_idx keeps track of which section we're on, since sections are\n         *     ordered by number of segments. See core_reorder_directories\n         * startseg tells us how many segments describe the root path\n         *     e.g. the complete path \"//host/foo/\" to a UNC share (4)\n         */\n        startseg = seg = ap_count_dirs(r->filename);\n        sec_idx = 0;\n\n        /*\n         * Go down the directory hierarchy.  Where we have to check for\n         * symlinks, do so.  Where a .htaccess file has permission to\n         * override anything, try to find one.\n         */\n        do {\n            int res;\n            char *seg_name;\n            char *delim;\n            int temp_slash=0;\n\n            /* We have no trailing slash, but we sure would appreciate one.\n             * However, we don't want to append a / our first time through.\n             */\n            if ((seg > startseg) && r->filename[filename_len-1] != '/') {\n                r->filename[filename_len++] = '/';\n                r->filename[filename_len] = 0;\n                temp_slash=1;\n            }\n\n            /* Begin *this* level by looking for matching <Directory> sections\n             * from the server config.\n             */\n            for (; sec_idx < num_sec; ++sec_idx) {\n\n                ap_conf_vector_t *entry_config = sec_ent[sec_idx];\n                core_dir_config *entry_core;\n                entry_core = ap_get_module_config(entry_config, &core_module);\n\n                /* No more possible matches for this many segments?\n                 * We are done when we find relative/regex/longer components.\n                 */\n                if (entry_core->r || entry_core->d_components > seg) {\n                    break;\n                }\n\n                /* We will never skip '0' element components, e.g. plain old\n                 * <Directory >, and <Directory \"/\"> are classified as zero\n                 * so that Win32/Netware/OS2 etc all pick them up.\n                 * Otherwise, skip over the mismatches.\n                 */\n                if (entry_core->d_components\n                    && ((entry_core->d_components < seg)\n                     || (entry_core->d_is_fnmatch\n                         ? (apr_fnmatch(entry_core->d, r->filename,\n                                        APR_FNM_PATHNAME) != APR_SUCCESS)\n                         : (strcmp(r->filename, entry_core->d) != 0)))) {\n                    continue;\n                }\n\n                /* If we haven't continue'd above, we have a match.\n                 *\n                 * Calculate our full-context core opts & override.\n                 */\n                core_opts_merge(sec_ent[sec_idx], &opts);\n\n                /* If we merged this same section last time, reuse it\n                 */\n                if (matches) {\n                    if (last_walk->matched == sec_ent[sec_idx]) {\n                        now_merged = last_walk->merged;\n                        ++last_walk;\n                        --matches;\n                        continue;\n                    }\n\n                    /* We fell out of sync.  This is our own copy of walked,\n                     * so truncate the remaining matches and reset remaining.\n                     */\n                    cache->walked->nelts -= matches;\n                    matches = 0;\n                }\n\n                if (now_merged) {\n                    now_merged = ap_merge_per_dir_configs(r->pool,\n                                                          now_merged,\n                                                          sec_ent[sec_idx]);\n                }\n                else {\n                    now_merged = sec_ent[sec_idx];\n                }\n\n                last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n                last_walk->matched = sec_ent[sec_idx];\n                last_walk->merged = now_merged;\n            }\n\n            /* If .htaccess files are enabled, check for one, provided we\n             * have reached a real path.\n             */\n            do {  \n\n                ap_conf_vector_t *htaccess_conf = NULL;\n\n                /* No htaccess in an incomplete root path,\n                 * nor if it's disabled\n                 */\n                if (seg < startseg || !opts.override) {\n                    break;\n                }\n\n                res = ap_parse_htaccess(&htaccess_conf, r, opts.override,\n                                        opts.override_opts,\n                                        apr_pstrdup(r->pool, r->filename),\n                                        sconf->access_name);\n                if (res) {\n                    return res;\n                }\n\n                if (!htaccess_conf) {\n                    break;\n                }\n\n                /* If we are still here, we found our htaccess.\n                 *\n                 * Calculate our full-context core opts & override.\n                 */\n                core_opts_merge(htaccess_conf, &opts);\n\n                /* If we merged this same htaccess last time, reuse it...\n                 * this wouldn't work except that we cache the htaccess\n                 * sections for the lifetime of the request, so we match\n                 * the same conf.  Good planning (no, pure luck ;)\n                 */\n                if (matches) {\n                    if (last_walk->matched == htaccess_conf) {\n                        now_merged = last_walk->merged;\n                        ++last_walk;\n                        --matches;\n                        break;\n                    }\n\n                    /* We fell out of sync.  This is our own copy of walked,\n                     * so truncate the remaining matches and reset\n                     * remaining.\n                     */\n                    cache->walked->nelts -= matches;\n                    matches = 0;\n                }\n\n                if (now_merged) {\n                    now_merged = ap_merge_per_dir_configs(r->pool,\n                                                          now_merged,\n                                                          htaccess_conf);\n                }\n                else {\n                    now_merged = htaccess_conf;\n                }\n\n                last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n                last_walk->matched = htaccess_conf;\n                last_walk->merged = now_merged;\n\n            } while (0); \n\n            /* That temporary trailing slash was useful, now drop it.\n             */\n            if (temp_slash) {\n                r->filename[--filename_len] = '\\0';\n            }\n\n            /* Time for all good things to come to an end?\n             */\n            if (!r->path_info || !*r->path_info) {\n                break;\n            }\n\n            /* Now it's time for the next segment...\n             * We will assume the next element is an end node, and fix it up\n             * below as necessary...\n             */\n\n            seg_name = r->filename + filename_len;\n            delim = strchr(r->path_info + (*r->path_info == '/' ? 1 : 0), '/');\n            if (delim) {\n                size_t path_info_len = delim - r->path_info;\n                *delim = '\\0';\n                memcpy(seg_name, r->path_info, path_info_len + 1);\n                filename_len += path_info_len;\n                r->path_info = delim;\n                *delim = '/';\n            }\n            else {\n                size_t path_info_len = strlen(r->path_info);\n                memcpy(seg_name, r->path_info, path_info_len + 1);\n                filename_len += path_info_len;\n                r->path_info += path_info_len;\n            }\n            if (*seg_name == '/')\n                ++seg_name;\n\n            /* If nothing remained but a '/' string, we are finished\n             * XXX: NO WE ARE NOT!!!  Now process this puppy!!! */\n            if (!*seg_name) {\n                break;\n            }\n\n            /* First optimization;\n             * If...we knew r->filename was a file, and\n             * if...we have strict (case-sensitive) filenames, or\n             *      we know the canonical_filename matches to _this_ name, and\n             * if...we have allowed symlinks\n             * skip the lstat and dummy up an APR_DIR value for thisinfo.\n             */\n            if (r->finfo.filetype\n#ifdef CASE_BLIND_FILESYSTEM\n                && (filename_len <= canonical_len)\n#endif\n                && ((opts.opts & (OPT_SYM_OWNER | OPT_SYM_LINKS)) == OPT_SYM_LINKS))\n            {\n\n                thisinfo.filetype = APR_DIR;\n                ++seg;\n                continue;\n            }\n\n            /* We choose apr_stat with flag APR_FINFO_LINK here, rather that\n             * plain apr_stat, so that we capture this path object rather than\n             * its target.  We will replace the info with our target's info\n             * below.  We especially want the name of this 'link' object, not\n             * the name of its target, if we are fixing the filename\n             * case/resolving aliases.\n             */\n            rv = apr_stat(&thisinfo, r->filename,\n                          APR_FINFO_MIN | APR_FINFO_NAME | APR_FINFO_LINK,\n                          r->pool);\n\n            if (APR_STATUS_IS_ENOENT(rv)) {\n                /* Nothing?  That could be nice.  But our directory\n                 * walk is done.\n                 */\n                thisinfo.filetype = APR_NOFILE;\n                break;\n            }\n            else if (APR_STATUS_IS_EACCES(rv)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                              \"access to %s denied\", r->uri);\n                return r->status = HTTP_FORBIDDEN;\n            }\n            else if ((rv != APR_SUCCESS && rv != APR_INCOMPLETE)\n                     || !(thisinfo.valid & APR_FINFO_TYPE)) {\n                /* If we hit ENOTDIR, we must have over-optimized, deny\n                 * rather than assume not found.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                              \"access to %s failed\", r->uri);\n                return r->status = HTTP_FORBIDDEN;\n            }\n\n            /* Fix up the path now if we have a name, and they don't agree\n             */\n            if ((thisinfo.valid & APR_FINFO_NAME)\n                && strcmp(seg_name, thisinfo.name)) {\n                /* TODO: provide users an option that an internal/external\n                 * redirect is required here?  We need to walk the URI and\n                 * filename in tandem to properly correlate these.\n                 */\n                strcpy(seg_name, thisinfo.name);\n                filename_len = strlen(r->filename);\n            }\n\n            if (thisinfo.filetype == APR_LNK) {\n                /* Is this a possibly acceptable symlink?\n                 */\n                if ((res = resolve_symlink(r->filename, &thisinfo,\n                                           opts.opts, r->pool)) != OK) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"Symbolic link not allowed \"\n                                  \"or link target not accessible: %s\",\n                                  r->filename);\n                    return r->status = res;\n                }\n            }\n\n            /* Ok, we are done with the link's info, test the real target\n             */\n            if (thisinfo.filetype == APR_REG ||\n                thisinfo.filetype == APR_NOFILE) {\n                /* That was fun, nothing left for us here\n                 */\n                break;\n            }\n            else if (thisinfo.filetype != APR_DIR) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Forbidden: %s doesn't point to \"\n                              \"a file or directory\",\n                              r->filename);\n                return r->status = HTTP_FORBIDDEN;\n            }\n\n            ++seg;\n        } while (thisinfo.filetype == APR_DIR);\n\n        /* If we have _not_ optimized, this is the time to recover\n         * the final stat result.\n         */\n        if (!r->finfo.filetype || r->finfo.filetype == APR_LNK) {\n            r->finfo = thisinfo;\n        }\n\n        /* Now splice the saved path_info back onto any new path_info\n         */\n        if (save_path_info) {\n            if (r->path_info && *r->path_info) {\n                r->path_info = ap_make_full_path(r->pool, r->path_info,\n                                                 save_path_info);\n            }\n            else {\n                r->path_info = save_path_info;\n            }\n        }\n\n        /*\n         * Now we'll deal with the regexes, note we pick up sec_idx\n         * where we left off (we gave up after we hit entry_core->r)\n         */\n        for (; sec_idx < num_sec; ++sec_idx) {\n\n            core_dir_config *entry_core;\n            entry_core = ap_get_module_config(sec_ent[sec_idx], &core_module);\n\n            if (!entry_core->r) {\n                continue;\n            }\n\n            if (ap_regexec(entry_core->r, r->filename, 0, NULL, AP_REG_NOTEOL)) {\n                continue;\n            }\n\n            /* If we haven't already continue'd above, we have a match.\n             *\n             * Calculate our full-context core opts & override.\n             */\n            core_opts_merge(sec_ent[sec_idx], &opts);\n\n            /* If we merged this same section last time, reuse it\n             */\n            if (matches) {\n                if (last_walk->matched == sec_ent[sec_idx]) {\n                    now_merged = last_walk->merged;\n                    ++last_walk;\n                    --matches;\n                    continue;\n                }\n\n                /* We fell out of sync.  This is our own copy of walked,\n                 * so truncate the remaining matches and reset remaining.\n                 */\n                cache->walked->nelts -= matches;\n                matches = 0;\n            }\n\n            if (now_merged) {\n                now_merged = ap_merge_per_dir_configs(r->pool,\n                                                      now_merged,\n                                                      sec_ent[sec_idx]);\n            }\n            else {\n                now_merged = sec_ent[sec_idx];\n            }\n\n            last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n            last_walk->matched = sec_ent[sec_idx];\n            last_walk->merged = now_merged;\n        }\n\n        /* Whoops - everything matched in sequence, but the original walk\n         * found some additional matches.  Truncate them.\n         */\n        if (matches) {\n            cache->walked->nelts -= matches;\n        }\n    }\n\n/* It seems this shouldn't be needed anymore.  We translated the\n x symlink above into a real resource, and should have died up there.\n x Even if we keep this, it needs more thought (maybe an r->file_is_symlink)\n x perhaps it should actually happen in file_walk, so we catch more\n x obscure cases in autoindex subrequests, etc.\n x\n x    * Symlink permissions are determined by the parent.  If the request is\n x    * for a directory then applying the symlink test here would use the\n x    * permissions of the directory as opposed to its parent.  Consider a\n x    * symlink pointing to a dir with a .htaccess disallowing symlinks.  If\n x    * you access /symlink (or /symlink/) you would get a 403 without this\n x    * APR_DIR test.  But if you accessed /symlink/index.html, for example,\n x    * you would *not* get the 403.\n x\n x   if (r->finfo.filetype != APR_DIR\n x       && (res = resolve_symlink(r->filename, r->info, ap_allow_options(r),\n x                                 r->pool))) {\n x       ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n x                     \"Symbolic link not allowed: %s\", r->filename);\n x       return res;\n x   }\n */\n\n    /* Save future sub-requestors much angst in processing\n     * this subrequest.  If dir_walk couldn't canonicalize\n     * the file path, nothing can.\n     */\n    r->canonical_filename = r->filename;\n\n    if (r->finfo.filetype == APR_DIR) {\n        cache->cached = r->filename;\n    }\n    else {\n        cache->cached = ap_make_dirstr_parent(r->pool, r->filename);\n    }\n\n    cache->dir_conf_tested = sec_ent;\n    cache->dir_conf_merged = r->per_dir_config;\n\n    /* Merge our cache->dir_conf_merged construct with the r->per_dir_configs,\n     * and note the end result to (potentially) skip this step next time.\n     */\n    if (now_merged) {\n        r->per_dir_config = ap_merge_per_dir_configs(r->pool,\n                                                     r->per_dir_config,\n                                                     now_merged);\n    }\n    cache->per_dir_result = r->per_dir_config;\n\n    return OK;\n}",
    "predicted": "36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n126,Buffer Over-read\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_eadf761796f9dfedacb0df4a36504d0546a62aa4_0", {
    "ID": "httpd_eadf761796f9dfedacb0df4a36504d0546a62aa4_0",
    "UID": "106",
    "code": "static const char *log_cookie(request_rec *r, char test_snippet\n{\n    const char *cookies;\n    const char *start_cookie;\n\n    if ((cookies = apr_table_get(r->headers_in, \"Cookie\"))) {\n        if ((start_cookie = ap_strstr_c(cookies,a))) {\n            char *cookie, *end_cookie;\n            start_cookie += strlen(a) + 1; \n            cookie = apr_pstrdup(r->pool, start_cookie);\n            \n            end_cookie = strchr(cookie, ';');\n            if (end_cookie) {\n                *end_cookie = '\\0';\n            }\n            return ap_escape_logitem(r->pool, cookie);\n        }\n    }\n    return NULL;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read\n20,Improper Input Validation"
  },
  "httpd_c4741b3963d8542d34b837da490c102bbb23d8d9_0", {
    "ID": "httpd_c4741b3963d8542d34b837da490c102bbb23d8d9_0",
    "UID": "108",
    "code": "AP_DECLARE(char *) ap_escape_logitem(apr_pool_t *p, const char test_snippet\n{\n    char *ret;\n    unsigned char *d;\n    const unsigned char *s;\n\n    if (!str) {\n        return NULL;\n    }\n\n    ret = apr_palloc(p, 4 * strlen(str) + 1); \n    d = (unsigned char *)ret;\n    s = (const unsigned char *)str;\n    for (; *s; ++s) {\n\n        if (TEST_CHAR(*s, T_ESCAPE_LOGITEM)) {\n            *d++ = '\\\\';\n            switch(*s) {\n            case '\\b':\n                *d++ = 'b';\n                break;\n            case '\\n':\n                *d++ = 'n';\n                break;\n            case '\\r':\n                *d++ = 'r';\n                break;\n            case '\\t':\n                *d++ = 't';\n                break;\n            case '\\v':\n                *d++ = 'v';\n                break;\n            case '\\\\':\n            case '\"':\n                *d++ = *s;\n                break;\n            default:\n                c2x(*s, 'x', d);\n                d += 3;\n            }\n        }\n        else {\n            *d++ = *s;\n        }\n    }\n    *d = '\\0';\n\n    return ret;\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow"
  },
  "httpd_70c3778b8750f28561f5719d3303c0b0b2b0e84b_0", {
    "ID": "httpd_70c3778b8750f28561f5719d3303c0b0b2b0e84b_0",
    "UID": "111",
    "code": "static void remove_unused_name_vhosts(server_rec *main_s, ipaddr_chain test_snippet\n{\n    while (*pic) {\n        ipaddr_chain *ic = *pic;\n\n        if (ic->server == NULL) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, main_s,\n                         \"NameVirtualHost %s:%u has no VirtualHosts\",\n                         ic->sar->virthost, ic->sar->host_port);\n            *pic = ic->next;\n        }\n        else {\n            pic = &ic->next;\n        }\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3d21ae024c5ebf58cbd638fa8eebb05a7a1fa5d9_0", {
    "ID": "httpd_3d21ae024c5ebf58cbd638fa8eebb05a7a1fa5d9_0",
    "UID": "112",
    "code": "static const char* find_accf_name(server_rec *s, const char test_snippet\n{\n    const char* accf;\n    core_server_config *conf = ap_get_module_config(s->module_config,\n                                                    &core_module);\n    if (!proto) {\n        return NULL;\n    }\n\n    accf = apr_table_get(conf->accf_map, proto);\n\n    if (accf && !strcmp(\"none\", accf)) {\n        return NULL;\n    }\n\n    return accf;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_41f4c1a8ea4f46e3048a7eec2ffaedda41f24ab5_0", {
    "ID": "httpd_41f4c1a8ea4f46e3048a7eec2ffaedda41f24ab5_0",
    "UID": "113",
    "code": "AP_DECLARE(const char*) ap_get_server_protocol(server_rec* test_snippet\n{\n    core_server_config *conf = ap_get_module_config(s->module_config,\n                                                    &core_module);\n    return conf->protocol;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_efe57e4363c0c088131da183d41c3432b0956eda_0", {
    "ID": "httpd_efe57e4363c0c088131da183d41c3432b0956eda_0",
    "UID": "114",
    "code": "AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec test_snippet\n{\n    server_addr_rec *sar;\n    int has_default_vhost_addr;\n    server_rec *s;\n    int i;\n    ipaddr_chain **iphash_table_tail[IPHASH_TABLE_SIZE];\n\n    \n    *name_vhost_list_tail = NULL;\n\n    \n    s = main_s;\n\n    if (!s->server_hostname) {\n        s->server_hostname = ap_get_local_host(p);\n    }\n\n    \n    for (i = 0; i < IPHASH_TABLE_SIZE; ++i) {\n        iphash_table_tail[i] = &iphash_table[i];\n    }\n\n    /* The first things to go into the hash table are the NameVirtualHosts\n     * Since name_vhost_list is in the same order that the directives\n     * occured in the config file, we'll copy it in that order.\n     */\n    for (sar = name_vhost_list; sar; sar = sar->next) {\n        char inaddr_any[16] = {0}; \n        unsigned bucket = hash_addr(sar->host_addr);\n        ipaddr_chain *ic = new_ipaddr_chain(p, NULL, sar);\n\n        if (memcmp(sar->host_addr->ipaddr_ptr, inaddr_any,\n                   sar->host_addr->ipaddr_len)) { \n            *iphash_table_tail[bucket] = ic;\n            iphash_table_tail[bucket] = &ic->next;\n        }\n        else {\n            /* A wildcard NameVirtualHost goes on the default_list so\n             * that it can catch incoming requests on any address.\n             */\n            ic->next = default_list;\n            default_list = ic;\n        }\n        /* Notice that what we've done is insert an ipaddr_chain with\n         * both server and names NULL. This fact is used to spot name-\n         * based vhosts in add_name_vhost_config().\n         */\n    }\n\n    /* The next things to go into the hash table are the virtual hosts\n     * themselves.  They're listed off of main_s->next in the reverse\n     * order they occured in the config file, so we insert them at\n     * the iphash_table_tail but don't advance the tail.\n     */\n\n    for (s = main_s->next; s; s = s->next) {\n        has_default_vhost_addr = 0;\n        for (sar = s->addrs; sar; sar = sar->next) {\n            ipaddr_chain *ic;\n            char inaddr_any[16] = {0}; \n\n            if ((sar->host_addr->family == AF_INET &&\n                 sar->host_addr->sa.sin.sin_addr.s_addr == DEFAULT_VHOST_ADDR)\n                || !memcmp(sar->host_addr->ipaddr_ptr, inaddr_any, sar->host_addr->ipaddr_len)) {\n                ic = find_default_server(sar->host_port);\n                if (!ic || !add_name_vhost_config(p, main_s, s, sar, ic)) {\n                    if (ic && ic->sar->host_port != 0) {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING,\n                                     0, main_s, \"_default_ VirtualHost \"\n                                     \"overlap on port %u, the first has \"\n                                     \"precedence\", sar->host_port);\n                    }\n                    ic = new_ipaddr_chain(p, s, sar);\n                    ic->next = default_list;\n                    default_list = ic;\n                }\n                has_default_vhost_addr = 1;\n            }\n            else {\n                \n                ic = find_ipaddr(sar->host_addr);\n\n                if (!ic) {\n                    unsigned bucket = hash_addr(sar->host_addr);\n\n                    ic = new_ipaddr_chain(p, s, sar);\n                    ic->next = *iphash_table_tail[bucket];\n                    *iphash_table_tail[bucket] = ic;\n                }\n                else if (!add_name_vhost_config(p, main_s, s, sar, ic)) {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING,\n                                 0, main_s, \"VirtualHost %s:%u overlaps \"\n                                 \"with VirtualHost %s:%u, the first has \"\n                                 \"precedence, perhaps you need a \"\n                                 \"NameVirtualHost directive\",\n                                 sar->virthost, sar->host_port,\n                                 ic->sar->virthost, ic->sar->host_port);\n                    ic->sar = sar;\n                    ic->server = s;\n                }\n            }\n        }\n\n        /* Ok now we want to set up a server_hostname if the user was\n         * silly enough to forget one.\n         * XXX: This is silly we should just crash and burn.\n         */\n        if (!s->server_hostname) {\n            if (has_default_vhost_addr) {\n                s->server_hostname = main_s->server_hostname;\n            }\n            else if (!s->addrs) {\n                /* what else can we do?  at this point this vhost has\n                    no configured name, probably because they used\n                    DNS in the VirtualHost statement.  It's disabled\n                    anyhow by the host matching code.  -djg */\n                s->server_hostname =\n                    apr_pstrdup(p, \"bogus_host_without_forward_dns\");\n            }\n            else {\n                apr_status_t rv;\n                char *hostname;\n\n                rv = apr_getnameinfo(&hostname, s->addrs->host_addr, 0);\n                if (rv == APR_SUCCESS) {\n                    s->server_hostname = apr_pstrdup(p, hostname);\n                }\n                else {\n                    /* again, what can we do?  They didn't specify a\n                       ServerName, and their DNS isn't working. -djg */\n                    char *ipaddr_str;\n\n                    apr_sockaddr_ip_get(&ipaddr_str, s->addrs->host_addr);\n                    ap_log_error(APLOG_MARK, APLOG_ERR, rv, main_s,\n                                 \"Failed to resolve server name \"\n                                 \"for %s (check DNS) -- or specify an explicit \"\n                                 \"ServerName\",\n                                 ipaddr_str);\n                    s->server_hostname =\n                        apr_pstrdup(p, \"bogus_host_without_reverse_dns\");\n                }\n            }\n        }\n    }\n\n    /* now go through and delete any NameVirtualHosts that didn't have any\n     * hosts associated with them.  Lamers.\n     */\n    for (i = 0; i < IPHASH_TABLE_SIZE; ++i) {\n        remove_unused_name_vhosts(main_s, &iphash_table[i]);\n    }\n    remove_unused_name_vhosts(main_s, &default_list);\n\n#ifdef IPHASH_STATISTICS\n    dump_iphash_statistics(main_s);\n#endif\n    if (ap_exists_config_define(\"DUMP_VHOSTS\")) {\n        apr_file_t *thefile = NULL;\n        apr_file_open_stderr(&thefile, p);\n        dump_vhost_config(thefile);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_984ace97881f99b8829b4a11a70ecf7a00363ce2_0", {
    "ID": "httpd_984ace97881f99b8829b4a11a70ecf7a00363ce2_0",
    "UID": "115",
    "code": "static apr_status_t writev_nonblocking(apr_socket_t test_snippet\n                                       struct iovec *vec, apr_size_t nvec,\n                                       apr_bucket_brigade *bb,\n                                       apr_size_t *cumulative_bytes_written,\n                                       conn_rec *c)\n{\n    apr_status_t rv = APR_SUCCESS, arv;\n    apr_size_t bytes_written = 0, bytes_to_write = 0;\n    apr_size_t i, offset;\n    apr_interval_time_t old_timeout;\n\n    arv = apr_socket_timeout_get(s, &old_timeout);\n    if (arv != APR_SUCCESS) {\n        return arv;\n    }\n    arv = apr_socket_timeout_set(s, 0);\n    if (arv != APR_SUCCESS) {\n        return arv;\n    }\n\n    for (i = 0; i < nvec; i++) {\n        bytes_to_write += vec[i].iov_len;\n    }\n    offset = 0;\n    while (bytes_written < bytes_to_write) {\n        apr_size_t n = 0;\n        rv = apr_socket_sendv(s, vec + offset, nvec - offset, &n);\n        if (n > 0) {\n            bytes_written += n;\n            for (i = offset; i < nvec; ) {\n                apr_bucket *bucket = APR_BRIGADE_FIRST(bb);\n                if (APR_BUCKET_IS_METADATA(bucket)) {\n                    APR_BUCKET_REMOVE(bucket);\n                    apr_bucket_destroy(bucket);\n                }\n                else if (n >= vec[i].iov_len) {\n                    APR_BUCKET_REMOVE(bucket);\n                    apr_bucket_destroy(bucket);\n                    offset++;\n                    n -= vec[i++].iov_len;\n                }\n                else {\n                    apr_bucket_split(bucket, n);\n                    APR_BUCKET_REMOVE(bucket);\n                    apr_bucket_destroy(bucket);\n                    vec[i].iov_len -= n;\n                    vec[i].iov_base += n;\n                    break;\n                }\n            }\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n    }\n    if ((logio_add_bytes_out != NULL) && (bytes_written > 0)) {\n        logio_add_bytes_out(c, bytes_written);\n    }\n    *cumulative_bytes_written += bytes_written;\n\n    arv = apr_socket_timeout_set(s, old_timeout);\n    if ((arv != APR_SUCCESS) && (rv == APR_SUCCESS)) {\n        return arv;\n    }\n    else {\n        return rv;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_a7f2ec2bffedf78216ed33f0dd294eca9cc7c3de_0", {
    "ID": "httpd_a7f2ec2bffedf78216ed33f0dd294eca9cc7c3de_0",
    "UID": "116",
    "code": "AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t test_snippet\n                                         apr_bucket_brigade **saveto,\n                                         apr_bucket_brigade **b, apr_pool_t *p)\n{\n    apr_bucket *e;\n    apr_status_t rv, srv = APR_SUCCESS;\n\n    /* If have never stored any data in the filter, then we had better\n     * create an empty bucket brigade so that we can concat.\n     */\n    if (!(*saveto)) {\n        *saveto = apr_brigade_create(p, f->c->bucket_alloc);\n    }\n\n    for (e = APR_BRIGADE_FIRST(*b);\n         e != APR_BRIGADE_SENTINEL(*b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        rv = apr_bucket_setaside(e, p);\n\n        /* If the bucket type does not implement setaside, then\n         * (hopefully) morph it into a bucket type which does, and set\n         * *that* aside... */\n        if (rv == APR_ENOTIMPL) {\n            const char *s;\n            apr_size_t n;\n\n            rv = apr_bucket_read(e, &s, &n, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                rv = apr_bucket_setaside(e, p);\n            }\n        }\n\n        if (rv != APR_SUCCESS) {\n            srv = rv;\n            /* Return an error but still save the brigade if\n             * ->setaside() is really not implemented. */\n            if (rv != APR_ENOTIMPL) {\n                return rv;\n            }\n        }\n    }\n    APR_BRIGADE_CONCAT(*saveto, *b);\n    return srv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d3c81f7075ecfda970ef40489a046116158d5686_0", {
    "ID": "httpd_d3c81f7075ecfda970ef40489a046116158d5686_0",
    "UID": "117",
    "code": "static const char *log_request_duration_microseconds(request_rec *r, char test_snippet\n{\n    return apr_psprintf(r->pool, \"%\" APR_TIME_T_FMT,\n                        (apr_time_now() - r->request_time));\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_58c726467b07585bb7758563b914324e05db21f9_0", {
    "ID": "httpd_58c726467b07585bb7758563b914324e05db21f9_0",
    "UID": "119",
    "code": "static apr_status_t cgi_bucket_read(apr_bucket *b, const char test_snippet\n                                    apr_size_t *len, apr_read_type_e block)\n{\n    struct cgi_bucket_data *data = b->data;\n    apr_interval_time_t timeout;\n    apr_status_t rv;\n    int gotdata = 0;\n\n    timeout = block == APR_NONBLOCK_READ ? 0 : data->r->server->timeout;\n\n    do {\n        const apr_pollfd_t *results;\n        apr_int32_t num;\n\n        rv = apr_pollset_poll(data->pollset, timeout, &num, &results);\n        if (APR_STATUS_IS_TIMEUP(rv)) {\n            if (timeout) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, data->r,\n                              \"Timeout waiting for output from CGI script %s\",\n                              data->r->filename);\n                return rv;\n            }\n            else {\n                return APR_EAGAIN;\n            }\n        }\n        else if (APR_STATUS_IS_EINTR(rv)) {\n            continue;\n        }\n        else if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, data->r,\n                          \"poll failed waiting for CGI child\");\n            return rv;\n        }\n\n        for (; num; num--, results++) {\n            if (results[0].client_data == (void *)1) {\n                \n                rv = cgi_read_stdout(b, results[0].desc.f, str, len);\n                if (APR_STATUS_IS_EOF(rv)) {\n                    rv = APR_SUCCESS;\n                }\n                gotdata = 1;\n            } else {\n                \n                apr_status_t rv2 = log_script_err(data->r, results[0].desc.f);\n                if (APR_STATUS_IS_EOF(rv2)) {\n                    apr_pollset_remove(data->pollset, &results[0]);\n                }\n            }\n        }\n\n    } while (!gotdata);\n\n    return rv;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_1246c8625e2672b79133e42f0d98b83c4aca92df_0", {
    "ID": "httpd_1246c8625e2672b79133e42f0d98b83c4aca92df_0",
    "UID": "120",
    "code": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade test_snippet\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n        int folded = 0;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->status = HTTP_BAD_REQUEST;\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC && field) {\n                \n                field[len - 1] = '\\0';\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_pstrcat(r->pool,\n                                           \"Size of a request header field \"\n                                           \"exceeds server limit.<br />\\n\"\n                                           \"<pre>\\n\",\n                                           ap_escape_html(r->pool, field),\n                                           \"</pre>\\n\", NULL));\n            }\n            return;\n        }\n\n        if (last_field != NULL) {\n            if ((len > 0) && ((*field == '\\t') || *field == ' ')) {\n                /* This line is a continuation of the preceding line(s),\n                 * so append it to the line that we've set aside.\n                 * Note: this uses a power-of-two allocator to avoid\n                 * doing O(n) allocs and using O(n^2) space for\n                 * continuations that span many many lines.\n                 */\n                apr_size_t fold_len = last_len + len + 1; \n\n                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                    r->status = HTTP_BAD_REQUEST;\n                    /* report what we have accumulated so far before the\n                     * overflow (last_field) as the field with the problem\n                     */\n                    apr_table_setn(r->notes, \"error-notes\",\n                                   apr_pstrcat(r->pool,\n                                               \"Size of a request header field \"\n                                               \"after folding \"\n                                               \"exceeds server limit.<br />\\n\"\n                                               \"<pre>\\n\",\n                                               ap_escape_html(r->pool, last_field),\n                                               \"</pre>\\n\", NULL));\n                    return;\n                }\n\n                if (fold_len > alloc_len) {\n                    char *fold_buf;\n                    alloc_len += alloc_len;\n                    if (fold_len > alloc_len) {\n                        alloc_len = fold_len;\n                    }\n                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                    memcpy(fold_buf, last_field, last_len);\n                    last_field = fold_buf;\n                }\n                memcpy(last_field + last_len, field, len +1); \n                last_len += len;\n                folded = 1;\n            }\n            else  {\n\n                if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                                   \"The number of request header fields \"\n                                   \"exceeds this server's limit.\");\n                    return;\n                }\n\n                if (!(value = strchr(last_field, ':'))) { \n                    r->status = HTTP_BAD_REQUEST;      \n                    apr_table_setn(r->notes, \"error-notes\",\n                                   apr_pstrcat(r->pool,\n                                               \"Request header field is \"\n                                               \"missing ':' separator.<br />\\n\"\n                                               \"<pre>\\n\",\n                                               ap_escape_html(r->pool,\n                                                              last_field),\n                                               \"</pre>\\n\", NULL));\n                    return;\n                }\n\n                tmp_field = value - 1; \n\n                *value++ = '\\0'; \n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;            \n                }\n\n                \n                while (tmp_field > last_field\n                       && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n\n                \n                tmp_field = last_field + last_len - 1;\n                while (tmp_field > value\n                       && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n\n                apr_table_addn(r->headers_in, last_field, value);\n\n                /* reset the alloc_len so that we'll allocate a new\n                 * buffer if we have to do any more folding: we can't\n                 * use the previous buffer because its contents are\n                 * now part of r->headers_in\n                 */\n                alloc_len = 0;\n\n            } \n        }\n\n        \n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this line so that we can parse it on\n         * the next loop iteration.  (In the folded case, last_field\n         * has been updated already.)\n         */\n        if (!folded) {\n            last_field = field;\n            last_len = len;\n        }\n    }\n\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_dd13148689109b5417304b73cda7af2eb4d6e099_0", {
    "ID": "httpd_dd13148689109b5417304b73cda7af2eb4d6e099_0",
    "UID": "121",
    "code": "static void test_snippet\n{\n    apr_interval_time_t timetakenusec;\n    float timetaken;\n\n    endtime = apr_time_now();\n    timetakenusec = endtime - start;\n    timetaken = ((float)apr_time_sec(timetakenusec)) +\n        ((float)apr_time_usec(timetakenusec)) / 1000000.0F;\n\n    printf(\"\\n\\n\");\n    printf(\"Server Software:        %s\\n\", servername);\n    printf(\"Server Hostname:        %s\\n\", hostname);\n    printf(\"Server Port:            %hd\\n\", port);\n#ifdef USE_SSL\n    if (is_ssl && ssl_info) {\n        printf(\"SSL/TLS Protocol:       %s\\n\", ssl_info);\n    }\n#endif\n    printf(\"\\n\");\n    printf(\"Document Path:          %s\\n\", path);\n    printf(\"Document Length:        %\" APR_SIZE_T_FMT \" bytes\\n\", doclen);\n    printf(\"\\n\");\n    printf(\"Concurrency Level:      %d\\n\", concurrency);\n    printf(\"Time taken for tests:   %ld.%03ld seconds\\n\",\n           (long) apr_time_sec(timetakenusec),\n           (long) apr_time_usec(timetakenusec));\n    printf(\"Complete requests:      %ld\\n\", done);\n    printf(\"Failed requests:        %ld\\n\", bad);\n    if (bad)\n        printf(\"   (Connect: %d, Length: %d, Exceptions: %d)\\n\",\n            err_conn, err_length, err_except);\n    printf(\"Write errors:           %ld\\n\", epipe);\n    if (err_response)\n        printf(\"Non-2xx responses:      %d\\n\", err_response);\n    if (keepalive)\n        printf(\"Keep-Alive requests:    %ld\\n\", doneka);\n    printf(\"Total transferred:      %ld bytes\\n\", totalread);\n    if (posting > 0)\n        printf(\"Total POSTed:           %ld\\n\", totalposted);\n    printf(\"HTML transferred:       %ld bytes\\n\", totalbread);\n\n    \n    if (timetaken) {\n        printf(\"Requests per second:    %.2f [#/sec] (mean)\\n\",\n               (float) (done / timetaken));\n        printf(\"Time per request:       %.3f [ms] (mean)\\n\",\n               (float) (1000 * concurrency * timetaken / done));\n        printf(\"Time per request:       %.3f [ms] (mean, across all concurrent requests)\\n\",\n           (float) (1000 * timetaken / done));\n        printf(\"Transfer rate:          %.2f [Kbytes/sec] received\\n\",\n           (float) (totalread / 1024 / timetaken));\n        if (posting > 0) {\n            printf(\"                        %.2f kb/s sent\\n\",\n               (float) (totalposted / timetaken / 1024));\n            printf(\"                        %.2f kb/s total\\n\",\n               (float) ((totalread + totalposted) / timetaken / 1024));\n        }\n    }\n\n    if (requests) {\n        \n        long i;\n        apr_time_t totalcon = 0, total = 0, totald = 0, totalwait = 0;\n        apr_time_t meancon, meantot, meand, meanwait;\n        apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX, mind = AB_MAX,\n                            minwait = AB_MAX;\n        apr_interval_time_t maxcon = 0, maxtot = 0, maxd = 0, maxwait = 0;\n        apr_interval_time_t mediancon = 0, mediantot = 0, mediand = 0, medianwait = 0;\n        double sdtot = 0, sdcon = 0, sdd = 0, sdwait = 0;\n\n        for (i = 0; i < requests; i++) {\n            struct data s = stats[i];\n            mincon = ap_min(mincon, s.ctime);\n            mintot = ap_min(mintot, s.time);\n            mind = ap_min(mind, s.time - s.ctime);\n            minwait = ap_min(minwait, s.waittime);\n\n            maxcon = ap_max(maxcon, s.ctime);\n            maxtot = ap_max(maxtot, s.time);\n            maxd = ap_max(maxd, s.time - s.ctime);\n            maxwait = ap_max(maxwait, s.waittime);\n\n            totalcon += s.ctime;\n            total += s.time;\n            totald += s.time - s.ctime;\n            totalwait += s.waittime;\n        }\n        meancon = totalcon / requests;\n        meantot = total / requests;\n        meand = totald / requests;\n        meanwait = totalwait / requests;\n\n        \n        for (i = 0; i < requests; i++) {\n            struct data s = stats[i];\n            double a;\n            a = ((double)s.time - meantot);\n            sdtot += a * a;\n            a = ((double)s.ctime - meancon);\n            sdcon += a * a;\n            a = ((double)s.time - (double)s.ctime - meand);\n            sdd += a * a;\n            a = ((double)s.waittime - meanwait);\n            sdwait += a * a;\n        }\n\n        sdtot = (requests > 1) ? sqrt(sdtot / (requests - 1)) : 0;\n        sdcon = (requests > 1) ? sqrt(sdcon / (requests - 1)) : 0;\n        sdd = (requests > 1) ? sqrt(sdd / (requests - 1)) : 0;\n        sdwait = (requests > 1) ? sqrt(sdwait / (requests - 1)) : 0;\n\n        if (gnuplot) {\n            FILE *out = fopen(gnuplot, \"w\");\n            long i;\n            apr_time_t sttime;\n            char tmstring[1024];\n            if (!out) {\n                perror(\"Cannot open gnuplot output file\");\n                exit(1);\n            }\n            fprintf(out, \"starttime\\tseconds\\tctime\\tdtime\\tttime\\twait\\n\");\n            for (i = 0; i < requests; i++) {\n                apr_time_t diff = stats[i].time - stats[i].ctime;\n\n                sttime = stats[i].starttime;\n                (void) apr_ctime(tmstring, sttime);\n                fprintf(out, \"%s\\t%\" APR_TIME_T_FMT \"\\t%\" APR_TIME_T_FMT \"\\t%\" APR_TIME_T_FMT \"\\t%\" APR_TIME_T_FMT \"\\t%\" APR_TIME_T_FMT \"\\n\",\n                tmstring,\n                sttime,\n                stats[i].ctime,\n                diff,\n                stats[i].time,\n                stats[i].waittime);\n            }\n            fclose(out);\n        }\n        /*\n         * XXX: what is better; this hideous cast of the compradre function; or\n         * the four warnings during compile ? dirkx just does not know and\n         * hates both/\n         */\n        qsort(stats, requests, sizeof(struct data),\n              (int (*) (const void *, const void *)) compradre);\n        if ((requests > 1) && (requests % 2))\n            mediancon = (stats[requests / 2].ctime + stats[requests / 2 + 1].ctime) / 2;\n        else\n            mediancon = stats[requests / 2].ctime;\n\n        qsort(stats, requests, sizeof(struct data),\n              (int (*) (const void *, const void *)) compri);\n        if ((requests > 1) && (requests % 2))\n            mediand = (stats[requests / 2].time + stats[requests / 2 + 1].time \\\n            -stats[requests / 2].ctime - stats[requests / 2 + 1].ctime) / 2;\n        else\n            mediand = stats[requests / 2].time - stats[requests / 2].ctime;\n\n        qsort(stats, requests, sizeof(struct data),\n              (int (*) (const void *, const void *)) compwait);\n        if ((requests > 1) && (requests % 2))\n            medianwait = (stats[requests / 2].waittime + stats[requests / 2 + 1].waittime) / 2;\n        else\n            medianwait = stats[requests / 2].waittime;\n\n        qsort(stats, requests, sizeof(struct data),\n              (int (*) (const void *, const void *)) comprando);\n        if ((requests > 1) && (requests % 2))\n            mediantot = (stats[requests / 2].time + stats[requests / 2 + 1].time) / 2;\n        else\n            mediantot = stats[requests / 2].time;\n\n        printf(\"\\nConnection Times (ms)\\n\");\n\n        if (confidence) {\n#define CONF_FMT_STRING \"%5\" APR_TIME_T_FMT \" %4d %5.1f %6\" APR_TIME_T_FMT \" %7\" APR_TIME_T_FMT \"\\n\"\n            printf(\"              min  mean[+/-sd] median   max\\n\");\n            printf(\"Connect:    \" CONF_FMT_STRING,\n                       mincon, (int) (meancon + 0.5), sdcon, mediancon, maxcon);\n            printf(\"Processing: \" CONF_FMT_STRING,\n               mind, (int) (meand + 0.5), sdd, mediand, maxd);\n            printf(\"Waiting:    \" CONF_FMT_STRING,\n                   minwait, (int) (meanwait + 0.5), sdwait, medianwait, maxwait);\n            printf(\"Total:      \" CONF_FMT_STRING,\n               mintot, (int) (meantot + 0.5), sdtot, mediantot, maxtot);\n#undef CONF_FMT_STRING\n\n#define     SANE(what,mean,median,sd) \\\n              { \\\n                double d = (double)mean - median; \\\n                if (d < 0) d = -d; \\\n                if (d > 2 * sd ) \\\n                    printf(\"ERROR: The median and mean for \" what \" are more than twice the standard\\n\" \\\n                           \"       deviation apart. These results are NOT reliable.\\n\"); \\\n                else if (d > sd ) \\\n                    printf(\"WARNING: The median and mean for \" what \" are not within a normal deviation\\n\" \\\n                           \"        These results are probably not that reliable.\\n\"); \\\n            }\n            SANE(\"the initial connection time\", meancon, mediancon, sdcon);\n            SANE(\"the processing time\", meand, mediand, sdd);\n            SANE(\"the waiting time\", meanwait, medianwait, sdwait);\n            SANE(\"the total time\", meantot, mediantot, sdtot);\n        }\n        else {\n            printf(\"              min   avg   max\\n\");\n#define CONF_FMT_STRING \"%5\" APR_TIME_T_FMT \" %5\" APR_TIME_T_FMT \"%5\" APR_TIME_T_FMT \"\\n\"\n            printf(\"Connect:    \" CONF_FMT_STRING,\n                mincon, meancon, maxcon);\n            printf(\"Processing: \" CONF_FMT_STRING,\n                mintot - mincon, meantot - meancon,  maxtot - maxcon);\n            printf(\"Total:      \" CONF_FMT_STRING,\n                mintot, meantot, maxtot);\n#undef CONF_FMT_STRING\n        }\n\n\n        \n        if (percentile && (requests > 1)) {\n            printf(\"\\nPercentage of the requests served within a certain time (ms)\\n\");\n            for (i = 0; i < sizeof(percs) / sizeof(int); i++) {\n                if (percs[i] <= 0)\n                    printf(\" 0%%  <0> (never)\\n\");\n                else if (percs[i] >= 100)\n                    printf(\" 100%%  %5\" APR_TIME_T_FMT \" (longest request)\\n\",\n                           stats[requests - 1].time);\n                else\n                    printf(\"  %d%%  %5\" APR_TIME_T_FMT \"\\n\", percs[i],\n                           stats[(int) (requests * percs[i] / 100)].time);\n            }\n        }\n        if (csvperc) {\n            FILE *out = fopen(csvperc, \"w\");\n            int i;\n            if (!out) {\n                perror(\"Cannot open CSV output file\");\n                exit(1);\n            }\n            fprintf(out, \"\" \"Percentage served\" \",\" \"Time in ms\" \"\\n\");\n            for (i = 0; i < 100; i++) {\n                apr_time_t t;\n                if (i == 0)\n                    t = stats[0].time;\n                else if (i == 100)\n                    t = stats[requests - 1].time;\n                else\n                    t = stats[(int) (0.5 + requests * i / 100.0)].time;\n                fprintf(out, \"%d,%e\\n\", i, (double)t);\n            }\n            fclose(out);\n        }\n\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_7c539874310b942df28c6e31c48e543444175371_0", {
    "ID": "httpd_7c539874310b942df28c6e31c48e543444175371_0",
    "UID": "129",
    "code": "static int log_script(request_rec *r, cgi_server_conf * conf, int test_snippet\n                      char *dbuf, const char *sbuf, apr_bucket_brigade *bb,\n                      apr_file_t *script_err)\n{\n    const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in);\n    const apr_table_entry_t *hdrs = (const apr_table_entry_t *) hdrs_arr->elts;\n    char argsbuffer[HUGE_STRING_LEN];\n    apr_file_t *f = NULL;\n    apr_bucket *e;\n    const char *buf;\n    apr_size_t len;\n    apr_status_t rv;\n    int first;\n    int i;\n    apr_finfo_t finfo;\n    char time_str[APR_CTIME_LEN];\n\n    \n    if (!conf->logname ||\n        ((apr_stat(&finfo, conf->logname,\n                   APR_FINFO_SIZE, r->pool) == APR_SUCCESS) &&\n         (finfo.size > conf->logbytes)) ||\n        (apr_file_open(&f, conf->logname,\n                       APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT,\n                       r->pool) != APR_SUCCESS)) {\n        \n        discard_script_output(bb);\n        log_script_err(r, script_err);\n        return ret;\n    }\n\n    \n    apr_ctime(time_str, apr_time_now());\n    apr_file_printf(f, \"%%%% [%s] %s %s%s%s %s\\n\", time_str, r->method, r->uri,\n                    r->args ? \"?\" : \"\", r->args ? r->args : \"\", r->protocol);\n    \n    apr_file_printf(f, \"%%%% %d %s\\n\", test_snippet r->filename);\n\n    apr_file_puts(\"%request\\n\", f);\n    for (i = 0; i < hdrs_arr->nelts; ++i) {\n        if (!hdrs[i].key)\n            continue;\n        apr_file_printf(f, \"%s: %s\\n\", hdrs[i].key, hdrs[i].val);\n    }\n    if ((r->method_number == M_POST || r->method_number == M_PUT) &&\n        *dbuf) {\n        apr_file_printf(f, \"\\n%s\\n\", dbuf);\n    }\n\n    apr_file_puts(\"%response\\n\", f);\n    hdrs_arr = apr_table_elts(r->err_headers_out);\n    hdrs = (const apr_table_entry_t *) hdrs_arr->elts;\n\n    for (i = 0; i < hdrs_arr->nelts; ++i) {\n        if (!hdrs[i].key)\n            continue;\n        apr_file_printf(f, \"%s: %s\\n\", hdrs[i].key, hdrs[i].val);\n    }\n\n    if (sbuf && *sbuf)\n        apr_file_printf(f, \"%s\\n\", sbuf);\n\n    first = 1;\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (APR_BUCKET_IS_EOS(e)) {\n            break;\n        }\n        rv = apr_bucket_read(e, &buf, &len, APR_BLOCK_READ);\n        if (rv != APR_SUCCESS || (len == 0)) {\n            break;\n        }\n        if (first) {\n            apr_file_puts(\"%stdout\\n\", f);\n            first = 0;\n        }\n        apr_file_write(f, buf, &len);\n        apr_file_puts(\"\\n\", f);\n    }\n\n    if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == APR_SUCCESS) {\n        apr_file_puts(\"%stderr\\n\", f);\n        apr_file_puts(argsbuffer, f);\n        while (apr_file_gets(argsbuffer, HUGE_STRING_LEN,\n                             script_err) == APR_SUCCESS) {\n            apr_file_puts(argsbuffer, f);\n        }\n        apr_file_puts(\"\\n\", f);\n    }\n\n    apr_brigade_destroy(bb);\n    apr_file_close(script_err);\n\n    apr_file_close(f);\n    return ret;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_7b086dde8af3b2309f80e8328543313796adf3ab_0", {
    "ID": "httpd_7b086dde8af3b2309f80e8328543313796adf3ab_0",
    "UID": "130",
    "code": "AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char test_snippet\n                                       int (*getsfunc) (char *, int, void *),\n                                       void *getsfunc_data)\n{\n    char x[MAX_STRING_LEN];\n    char *w, *l;\n    int p;\n    int cgi_status = HTTP_OK;\n    apr_table_t *merge;\n    apr_table_t *cookie_table;\n\n    if (buffer) {\n        *buffer = '\\0';\n    }\n    w = buffer ? buffer : x;\n\n    \n    merge = apr_table_make(r->pool, 10);\n\n    /* The HTTP specification says that it is legal to merge duplicate\n     * headers into one.  Some browsers that support Cookies don't like\n     * merged headers and prefer that each Set-Cookie header is sent\n     * separately.  Lets humour those browsers by not merging.\n     * Oh what a pain it is.\n     */\n    cookie_table = apr_table_make(r->pool, 2);\n    apr_table_do(set_cookie_doo_doo, cookie_table, r->err_headers_out, \"Set-Cookie\", NULL);\n\n    while (1) {\n\n        if ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data) == 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                          \"Premature end of script headers: %s\",\n                          apr_filepath_name_get(r->filename));\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        \n\n        p = strlen(w);\n             /* Indeed, the host's '\\n':\n                '\\012' for UNIX; '\\015' for MacOS; '\\025' for OS/390\n                 -- whatever the script generates.\n             */\n        if (p > 0 && w[p - 1] == '\\n') {\n            if (p > 1 && w[p - 2] == CR) {\n                w[p - 2] = '\\0';\n            }\n            else {\n                w[p - 1] = '\\0';\n            }\n        }\n\n        /*\n         * If we've finished reading the headers, check to make sure any\n         * HTTP/1.1 conditions are met.  If so, we're done; normal processing\n         * will handle the script's output.  If not, just return the error.\n         * The appropriate thing to do would be to send the script process a\n         * SIGPIPE to let it know we're ignoring it, close the channel to the\n         * script process, and *then* return the failed-to-meet-condition\n         * error.  Otherwise we'd be waiting for the script to finish\n         * blithering before telling the client the output was no good.\n         * However, we don't have the information to do that, so we have to\n         * leave it to an upper layer.\n         */\n        if (w[0] == '\\0') {\n            int cond_status = OK;\n\n            if ((cgi_status == HTTP_OK) && (r->method_number == M_GET)) {\n                cond_status = ap_meets_conditions(r);\n            }\n            apr_table_overlap(r->err_headers_out, merge,\n                APR_OVERLAP_TABLES_MERGE);\n            if (!apr_is_empty_table(cookie_table)) {\n                \n                apr_table_unset(r->err_headers_out, \"Set-Cookie\");\n                r->err_headers_out = apr_table_overlay(r->pool,\n                    r->err_headers_out, cookie_table);\n            }\n            return cond_status;\n        }\n\n        \n\n#if APR_CHARSET_EBCDIC\n            /* Chances are that we received an ASCII header text instead of\n             * the expected EBCDIC header lines. Try to auto-detect:\n             */\n        if (!(l = strchr(w, ':'))) {\n            int maybeASCII = 0, maybeEBCDIC = 0;\n            unsigned char *cp, native;\n            apr_size_t inbytes_left, outbytes_left;\n\n            for (cp = w; *cp != '\\0'; ++cp) {\n                native = apr_xlate_conv_byte(ap_hdrs_from_ascii, *cp);\n                if (apr_isprint(*cp) && !apr_isprint(native))\n                    ++maybeEBCDIC;\n                if (!apr_isprint(*cp) && apr_isprint(native))\n                    ++maybeASCII;\n            }\n            if (maybeASCII > maybeEBCDIC) {\n                ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,\n                             \"CGI Interface Error: Script headers apparently ASCII: (CGI = %s)\",\n                             r->filename);\n                inbytes_left = outbytes_left = cp - w;\n                apr_xlate_conv_buffer(ap_hdrs_from_ascii,\n                                      w, &inbytes_left, w, &outbytes_left);\n            }\n        }\n#endif \n        if (!(l = strchr(w, ':'))) {\n            char malformed[(sizeof MALFORMED_MESSAGE) + 1\n                           + MALFORMED_HEADER_LENGTH_TO_SHOW];\n\n            strcpy(malformed, MALFORMED_MESSAGE);\n            strncat(malformed, w, MALFORMED_HEADER_LENGTH_TO_SHOW);\n\n            if (!buffer) {\n                \n                while ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data)) {\n                    continue;\n                }\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                          \"%s: %s\", malformed,\n                          apr_filepath_name_get(r->filename));\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        *l++ = '\\0';\n        while (*l && apr_isspace(*l)) {\n            ++l;\n        }\n\n        if (!strcasecmp(w, \"Content-type\")) {\n            char *tmp;\n\n            \n\n            char *endp = l + strlen(l) - 1;\n            while (endp > l && apr_isspace(*endp)) {\n                *endp-- = '\\0';\n            }\n\n            tmp = apr_pstrdup(r->pool, l);\n            ap_content_type_tolower(tmp);\n            ap_set_content_type(r, tmp);\n        }\n        /*\n         * If the script returned a specific status, that's what\n         * we'll use - otherwise we assume 200 OK.\n         */\n        else if (!strcasecmp(w, \"Status\")) {\n            r->status = cgi_status = atoi(l);\n            r->status_line = apr_pstrdup(r->pool, l);\n        }\n        else if (!strcasecmp(w, \"Location\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Content-Length\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Content-Range\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Transfer-Encoding\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        /*\n         * If the script gave us a Last-Modified header, we can't just\n         * pass it on blindly because of restrictions on future values.\n         */\n        else if (!strcasecmp(w, \"Last-Modified\")) {\n            ap_update_mtime(r, apr_date_parse_http(l));\n            ap_set_last_modified(r);\n        }\n        else if (!strcasecmp(w, \"Set-Cookie\")) {\n            apr_table_add(cookie_table, w, l);\n        }\n        else {\n            apr_table_add(merge, w, l);\n        }\n    }\n\n    return OK;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_7dead6062ff5e8ddf5fab81d3b278b22d929d78d_0", {
    "ID": "httpd_7dead6062ff5e8ddf5fab81d3b278b22d929d78d_0",
    "UID": "131",
    "code": "static char *parse_log_item(apr_pool_t *p, log_format_item *it, const char test_snippet\n{\n    const char *s = *sa;\n    ap_log_handler *handler;\n\n    if (*s != '%') {\n        return parse_log_misc_string(p, it, sa);\n    }\n\n    ++s;\n    it->condition_sense = 0;\n    it->conditions = NULL;\n\n    if (*s == '%') {\n        it->arg = \"%\";\n        it->func = constant_item;\n        *sa = ++s;\n\n        return NULL;\n    }\n\n    it->want_orig = -1;\n    it->arg = \"\";               \n\n    while (*s) {\n        int i;\n\n        switch (*s) {\n        case '!':\n            ++s;\n            it->condition_sense = !it->condition_sense;\n            break;\n\n        case '<':\n            ++s;\n            it->want_orig = 1;\n            break;\n\n        case '>':\n            ++s;\n            it->want_orig = 0;\n            break;\n\n        case ',':\n            ++s;\n            break;\n\n        case '{':\n            ++s;\n            it->arg = ap_getword(p, &s, '}');\n            break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            i = *s - '0';\n            while (apr_isdigit(*++s)) {\n                i = i * 10 + (*s) - '0';\n            }\n            if (!it->conditions) {\n                it->conditions = apr_array_make(p, 4, sizeof(int));\n            }\n            *(int *) apr_array_push(it->conditions) = i;\n            break;\n\n        default:\n            handler = (ap_log_handler *)apr_hash_get(log_hash, s++, 1);\n            if (!handler) {\n                char dummy[2];\n\n                dummy[0] = s[-1];\n                dummy[1] = '\\0';\n                return apr_pstrcat(p, \"Unrecognized LogFormat directive %\",\n                               dummy, NULL);\n            }\n            it->func = handler->func;\n            if (it->want_orig == -1) {\n                it->want_orig = handler->want_orig_default;\n            }\n            *sa = s;\n            return NULL;\n        }\n    }\n\n    return \"Ran off end of LogFormat parsing args to some directive\";\n}",
    "predicted": "476,NULL Pointer Dereference\n134,Use of Externally-Controlled Format String"
  },
  "httpd_4f72276075bc26543cd996945653fae43ef1827b_0", {
    "ID": "httpd_4f72276075bc26543cd996945653fae43ef1827b_0",
    "UID": "133",
    "code": "static apr_off_t get_body(char *buffer, apr_size_t *len, const char test_snippet\n                          apr_file_t *map)\n{\n    char *endbody;\n    int bodylen;\n    int taglen;\n    apr_off_t pos;\n\n    taglen = strlen(tag);\n    *len -= taglen;\n\n    /* We are at the first character following a body:tag\\n entry\n     * Suck in the body, then backspace to the first char after the\n     * closing tag entry.  If we fail to read, find the tag or back\n     * up then we have a hosed file, so give up already\n     */\n    if (apr_file_read(map, buffer, len) != APR_SUCCESS) {\n        return -1;\n    }\n\n    /* put a copy of the tag *after* the data read from the file\n     * so that strstr() will find something with no reliance on\n     * terminating '\\0'\n     */\n    memcpy(buffer + *len, tag, taglen);\n    endbody = strstr(buffer, tag);\n    if (endbody == buffer + *len) {\n        return -1;\n    }\n    bodylen = endbody - buffer;\n    endbody += taglen;\n    \n    while (*endbody) {\n        if (*endbody == '\\n') {\n            ++endbody;\n            break;\n        }\n        ++endbody;\n    }\n\n    pos = -(apr_off_t)(*len - (endbody - buffer));\n    if (apr_file_seek(map, APR_CUR, &pos) != APR_SUCCESS) {\n        return -1;\n    }\n\n    \n    *len = bodylen;\n    return pos - (endbody - buffer);\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_da235ca9a7a3a540a58de4d637f227468f1f8aa9_0", {
    "ID": "httpd_da235ca9a7a3a540a58de4d637f227468f1f8aa9_0",
    "UID": "134",
    "code": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char test_snippet\n                                     apr_size_t bufsiz)\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n\n    if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n        return 0;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv != APR_SUCCESS) {\n        /* if we actually fail here, we want to just return and\n         * stop trying to read data from the client.\n         */\n        r->connection->keepalive = AP_CONN_CLOSE;\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        if (r->read_chunked) {\n            r->remaining = -1;\n        }\n        else {\n            r->remaining = 0;\n        }\n    }\n\n    rv = apr_brigade_flatten(bb, buffer, &bufsiz);\n    if (rv != APR_SUCCESS) {\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    \n    r->read_length += bufsiz;\n\n    apr_brigade_destroy(bb);\n    return bufsiz;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value"
  },
  "httpd_21542f9c0af79544e8b905c5af275a8eb27d8355_0", {
    "ID": "httpd_21542f9c0af79544e8b905c5af275a8eb27d8355_0",
    "UID": "136",
    "code": "int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec test_snippet\n{\n    int index;\n    int remaining_children_to_start;\n    apr_status_t rv;\n\n    ap_log_pid(pconf, ap_pid_fname);\n\n    first_server_limit = server_limit;\n    if (changed_limit_at_restart) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,\n                     \"WARNING: Attempt to change ServerLimit \"\n                     \"ignored during restart\");\n        changed_limit_at_restart = 0;\n    }\n\n    \n    ap_lock_fname = apr_psprintf(_pconf, \"%s.%\" APR_PID_T_FMT,\n                                 ap_server_root_relative(_pconf, ap_lock_fname),\n                                 ap_my_pid);\n\n    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,\n                               ap_accept_lock_mech, _pconf);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,\n                     \"Couldn't create accept lock (%s) (%d)\",\n                     ap_lock_fname, ap_accept_lock_mech);\n        mpm_state = AP_MPMQ_STOPPING;\n        return 1;\n    }\n\n#if APR_USE_SYSVSEM_SERIALIZE\n    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||\n        ap_accept_lock_mech == APR_LOCK_SYSVSEM) {\n#else\n    if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {\n#endif\n        rv = unixd_set_proc_mutex_perms(accept_mutex);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,\n                         \"Couldn't set permissions on cross-process lock; \"\n                         \"check User and Group directives\");\n            mpm_state = AP_MPMQ_STOPPING;\n            return 1;\n        }\n    }\n\n    if (!is_graceful) {\n        if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {\n            mpm_state = AP_MPMQ_STOPPING;\n            return 1;\n        }\n        /* fix the generation number in the global score; we just got a new,\n         * cleared scoreboard\n         */\n        ap_scoreboard_image->global->running_generation = ap_my_generation;\n    }\n\n    set_signals();\n\n    if (one_process) {\n        AP_MONCONTROL(1);\n        make_child(ap_server_conf, 0);\n    }\n    else {\n    if (ap_daemons_max_free < ap_daemons_min_free + 1)  \n        ap_daemons_max_free = ap_daemons_min_free + 1;\n\n    /* If we're doing a graceful_restart then we're going to see a lot\n     * of children exiting immediately when we get into the main loop\n     * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty\n     * rapidly... and for each one that exits we'll start a new one until\n     * we reach at least daemons_min_free.  But we may be permitted to\n     * start more than that, so we'll just keep track of how many we're\n     * supposed to start up without the 1 second penalty between each fork.\n     */\n    remaining_children_to_start = ap_daemons_to_start;\n    if (remaining_children_to_start > ap_daemons_limit) {\n        remaining_children_to_start = ap_daemons_limit;\n    }\n    if (!is_graceful) {\n        startup_children(remaining_children_to_start);\n        remaining_children_to_start = 0;\n    }\n    else {\n        /* give the system some time to recover before kicking into\n         * exponential mode\n         */\n        hold_off_on_exponential_spawning = 10;\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,\n                \"%s configured -- resuming normal operations\",\n                ap_get_server_version());\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,\n                \"Server built: %s\", ap_get_server_built());\n#ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                \"AcceptMutex: %s (default: %s)\",\n                apr_proc_mutex_name(accept_mutex),\n                apr_proc_mutex_defname());\n#endif\n    restart_pending = shutdown_pending = 0;\n\n    mpm_state = AP_MPMQ_RUNNING;\n\n    while (!restart_pending && !shutdown_pending) {\n        int child_slot;\n        apr_exit_why_e exitwhy;\n        int status, processed_status;\n        \n        apr_proc_t pid;\n\n        ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);\n\n        /* XXX: if it takes longer than 1 second for all our children\n         * to start up and get into IDLE state then we may spawn an\n         * extra child\n         */\n        if (pid.pid != -1) {\n            processed_status = ap_process_child_status(&pid, exitwhy, status);\n            if (processed_status == APEXIT_CHILDFATAL) {\n                mpm_state = AP_MPMQ_STOPPING;\n                return 1;\n            }\n\n            \n            child_slot = find_child_by_pid(&pid);\n            if (child_slot >= 0) {\n                (void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD,\n                                                           (request_rec *) NULL);\n                if (processed_status == APEXIT_CHILDSICK) {\n                    /* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc)\n                     * cut the fork rate to the minimum\n                     */\n                    idle_spawn_rate = 1;\n                }\n                else if (remaining_children_to_start\n                    && child_slot < ap_daemons_limit) {\n                    /* we're still doing a 1-for-1 replacement of dead\n                     * children with new children\n                     */\n                    make_child(ap_server_conf, child_slot);\n                    --remaining_children_to_start;\n                }\n#if APR_HAS_OTHER_CHILD\n            }\n            else if (apr_proc_other_child_alert(&pid, APR_OC_REASON_DEATH, status) == APR_SUCCESS) {\n                \n#endif\n            }\n            else if (is_graceful) {\n                /* Great, we've probably just lost a slot in the\n                 * scoreboard.  Somehow we don't know about this\n                 * child.\n                 */\n                ap_log_error(APLOG_MARK, APLOG_WARNING,\n                            0, ap_server_conf,\n                            \"long lost child came home! (pid %ld)\", (long)pid.pid);\n            }\n            /* Don't perform idle maintenance when a child dies,\n             * only do it when there's a timeout.  Remember only a\n             * finite number of children can die, and it's pretty\n             * pathological for a lot to die suddenly.\n             */\n            continue;\n        }\n        else if (remaining_children_to_start) {\n            /* we hit a 1 second timeout in which none of the previous\n             * generation of children needed to be reaped... so assume\n             * they're all done, and pick up the slack if any is left.\n             */\n            startup_children(remaining_children_to_start);\n            remaining_children_to_start = 0;\n            /* In any event we really shouldn't do the code below because\n             * few of the servers we just started are in the IDLE state\n             * yet, so we'd mistakenly create an extra server.\n             */\n            continue;\n        }\n\n        perform_idle_server_maintenance(pconf);\n#ifdef TPF\n        shutdown_pending = os_check_server(tpf_server_name);\n        ap_check_signals();\n        sleep(1);\n#endif \n    }\n    } \n\n    mpm_state = AP_MPMQ_STOPPING;\n\n    if (shutdown_pending && !is_graceful) {\n        /* Time to shut down:\n         * Kill child processes, tell them to call child_exit, etc...\n         */\n        if (unixd_killpg(getpgrp(), SIGTERM) < 0) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"killpg SIGTERM\");\n        }\n        ap_reclaim_child_processes(1);          \n\n        \n        {\n            const char *pidfile = NULL;\n            pidfile = ap_server_root_relative (pconf, ap_pid_fname);\n            if ( pidfile != NULL && unlink(pidfile) == 0)\n                ap_log_error(APLOG_MARK, APLOG_INFO,\n                                0, ap_server_conf,\n                                \"removed PID file %s (pid=%ld)\",\n                                pidfile, (long)getpid());\n        }\n\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,\n                    \"caught SIGTERM, shutting down\");\n\n        return 1;\n    } else if (shutdown_pending) {\n        /* Time to perform a graceful shut down:\n         * Reap the inactive children, and ask the active ones\n         * to close their listeners, then wait until they are\n         * all done to exit.\n         */\n        int active_children;\n        apr_time_t cutoff = 0;\n\n        \n        ap_close_listeners();\n\n        \n        ap_mpm_pod_killpg(pod, ap_max_daemons_limit);\n\n        \n        active_children = 0;\n        for (index = 0; index < ap_daemons_limit; ++index) {\n            if (ap_scoreboard_image->servers[index][0].status != SERVER_DEAD) {\n                \n                kill(MPM_CHILD_PID(index), AP_SIG_GRACEFUL);\n                active_children++;\n            }\n        }\n\n        \n        ap_relieve_child_processes();\n\n        \n        {\n            const char *pidfile = NULL;\n            pidfile = ap_server_root_relative (pconf, ap_pid_fname);\n            if ( pidfile != NULL && unlink(pidfile) == 0)\n                ap_log_error(APLOG_MARK, APLOG_INFO,\n                                0, ap_server_conf,\n                                \"removed PID file %s (pid=%ld)\",\n                                pidfile, (long)getpid());\n        }\n\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,\n           \"caught \" AP_SIG_GRACEFUL_STOP_STRING \", shutting down gracefully\");\n\n        if (ap_graceful_shutdown_timeout) {\n            cutoff = apr_time_now() +\n                     apr_time_from_sec(ap_graceful_shutdown_timeout);\n        }\n\n        \n        shutdown_pending = 0;\n        do {\n            \n            sleep(1);\n\n            \n            ap_relieve_child_processes();\n\n            active_children = 0;\n            for (index = 0; index < ap_daemons_limit; ++index) {\n                if (MPM_CHILD_PID(index) != 0) {\n                    if (kill(MPM_CHILD_PID(index), 0) == 0) {\n                            active_children = 1;\n                            \n                            break;\n                    }\n                }\n            }\n        } while (!shutdown_pending && active_children &&\n                 (!ap_graceful_shutdown_timeout || apr_time_now() < cutoff));\n\n        /* We might be here because we received SIGTERM, either\n         * way, try and make sure that all of our processes are\n         * really dead.\n         */\n        unixd_killpg(getpgrp(), SIGTERM);\n\n        return 1;\n    }\n\n    \n    apr_signal(SIGHUP, SIG_IGN);\n    apr_signal(AP_SIG_GRACEFUL, SIG_IGN);\n    if (one_process) {\n        \n        return 1;\n    }\n\n    \n    /* XXX: we really need to make sure this new generation number isn't in\n     * use by any of the children.\n     */\n    ++ap_my_generation;\n    ap_scoreboard_image->global->running_generation = ap_my_generation;\n\n    if (is_graceful) {\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,\n                    \"Graceful restart requested, doing restart\");\n\n        \n        ap_mpm_pod_killpg(pod, ap_max_daemons_limit);\n\n        /* This is mostly for debugging... so that we know what is still\n         * gracefully dealing with existing request.  This will break\n         * in a very nasty way if we ever have the scoreboard totally\n         * file-based (no shared memory)\n         */\n        for (index = 0; index < ap_daemons_limit; ++index) {\n            if (ap_scoreboard_image->servers[index][0].status != SERVER_DEAD) {\n                ap_scoreboard_image->servers[index][0].status = SERVER_GRACEFUL;\n                /* Ask each child to close its listeners.\n                 *\n                 * NOTE: we use the scoreboard, because if we send SIGUSR1\n                 * to every process in the group, this may include CGI's,\n                 * piped loggers, etc. They almost certainly won't handle\n                 * it gracefully.\n                 */\n                kill(ap_scoreboard_image->parent[index].pid, AP_SIG_GRACEFUL);\n            }\n        }\n    }\n    else {\n        \n        if (unixd_killpg(getpgrp(), SIGHUP) < 0) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"killpg SIGHUP\");\n        }\n        ap_reclaim_child_processes(0);          \n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,\n                    \"SIGHUP received.  Attempting to restart\");\n    }\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_940352b90da27b6e9591c39492f7e89a2203d1a0_0", {
    "ID": "httpd_940352b90da27b6e9591c39492f7e89a2203d1a0_0",
    "UID": "138",
    "code": "AP_DECLARE(char *) ap_getword_conf(apr_pool_t *p, const char test_snippet\n{\n    const char *str = *line, *strend;\n    char *res;\n    char quote;\n\n    while (*str && apr_isspace(*str))\n        ++str;\n\n    if (!*str) {\n        *line = str;\n        return \"\";\n    }\n\n    if ((quote = *str) == '\"' || quote == '\\'') {\n        strend = str + 1;\n        while (*strend && *strend != quote) {\n            if (*strend == '\\\\' && strend[1] &&\n                (strend[1] == quote || strend[1] == '\\\\')) {\n                strend += 2;\n            }\n            else {\n                ++strend;\n            }\n        }\n        res = substring_conf(p, str + 1, strend - str - 1, quote);\n\n        if (*strend == quote)\n            ++strend;\n    }\n    else {\n        strend = str;\n        while (*strend && !apr_isspace(*strend))\n            ++strend;\n\n        res = substring_conf(p, str, strend - str, 0);\n    }\n\n    while (*strend && apr_isspace(*strend))\n        ++strend;\n    *line = strend;\n    return res;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5c81b9761a80870e3f71d153cf6239c5f6aa9997_0", {
    "ID": "httpd_5c81b9761a80870e3f71d153cf6239c5f6aa9997_0",
    "UID": "140",
    "code": "static void test_snippet\n{\n    long timetaken;\n\n    endtime = apr_time_now();\n    timetaken = (long)((endtime - start) / 1000);\n\n    printf(\"\\n\\n<table %s>\\n\", tablestring);\n    printf(\"<tr %s><th colspan=2 %s>Server Software:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, servername);\n    printf(\"<tr %s><th colspan=2 %s>Server Hostname:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, hostname);\n    printf(\"<tr %s><th colspan=2 %s>Server Port:</th>\"\n       \"<td colspan=2 %s>%hd</td></tr>\\n\",\n       trstring, tdstring, tdstring, port);\n    printf(\"<tr %s><th colspan=2 %s>Document Path:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, path);\n    printf(\"<tr %s><th colspan=2 %s>Document Length:</th>\"\n       \"<td colspan=2 %s>%\" APR_SIZE_T_FMT \" bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, doclen);\n    printf(\"<tr %s><th colspan=2 %s>Concurrency Level:</th>\"\n       \"<td colspan=2 %s>%d</td></tr>\\n\",\n       trstring, tdstring, tdstring, concurrency);\n    printf(\"<tr %s><th colspan=2 %s>Time taken for tests:</th>\"\n       \"<td colspan=2 %s>%\" APR_INT64_T_FMT \".%03ld seconds</td></tr>\\n\",\n       trstring, tdstring, tdstring, apr_time_sec(timetaken),\n           (long)apr_time_usec(timetaken));\n    printf(\"<tr %s><th colspan=2 %s>Complete requests:</th>\"\n       \"<td colspan=2 %s>%ld</td></tr>\\n\",\n       trstring, tdstring, tdstring, done);\n    printf(\"<tr %s><th colspan=2 %s>Failed requests:</th>\"\n       \"<td colspan=2 %s>%ld</td></tr>\\n\",\n       trstring, tdstring, tdstring, bad);\n    if (bad)\n        printf(\"<tr %s><td colspan=4 %s >   (Connect: %d, Length: %d, Exceptions: %d)</td></tr>\\n\",\n           trstring, tdstring, err_conn, err_length, err_except);\n    if (err_response)\n        printf(\"<tr %s><th colspan=2 %s>Non-2xx responses:</th>\"\n           \"<td colspan=2 %s>%d</td></tr>\\n\",\n           trstring, tdstring, tdstring, err_response);\n    if (keepalive)\n        printf(\"<tr %s><th colspan=2 %s>Keep-Alive requests:</th>\"\n           \"<td colspan=2 %s>%ld</td></tr>\\n\",\n           trstring, tdstring, tdstring, doneka);\n    printf(\"<tr %s><th colspan=2 %s>Total transferred:</th>\"\n       \"<td colspan=2 %s>%ld bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, totalread);\n    if (posting > 0)\n        printf(\"<tr %s><th colspan=2 %s>Total POSTed:</th>\"\n           \"<td colspan=2 %s>%ld</td></tr>\\n\",\n           trstring, tdstring, tdstring, totalposted);\n    printf(\"<tr %s><th colspan=2 %s>HTML transferred:</th>\"\n       \"<td colspan=2 %s>%ld bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, totalbread);\n\n    \n    if (timetaken) {\n        printf(\"<tr %s><th colspan=2 %s>Requests per second:</th>\"\n           \"<td colspan=2 %s>%.2f</td></tr>\\n\",\n           trstring, tdstring, tdstring, 1000 * (float) (done) / timetaken);\n        printf(\"<tr %s><th colspan=2 %s>Transfer rate:</th>\"\n           \"<td colspan=2 %s>%.2f kb/s received</td></tr>\\n\",\n           trstring, tdstring, tdstring, (float) (totalread) / timetaken);\n        if (posting > 0) {\n            printf(\"<tr %s><td colspan=2 %s>&nbsp;</td>\"\n               \"<td colspan=2 %s>%.2f kb/s sent</td></tr>\\n\",\n               trstring, tdstring, tdstring,\n               (float) (totalposted) / timetaken);\n            printf(\"<tr %s><td colspan=2 %s>&nbsp;</td>\"\n               \"<td colspan=2 %s>%.2f kb/s total</td></tr>\\n\",\n               trstring, tdstring, tdstring,\n               (float) (totalread + totalposted) / timetaken);\n        }\n    }\n    {\n        \n        long i;\n        apr_interval_time_t totalcon = 0, total = 0;\n        apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX;\n        apr_interval_time_t maxcon = 0, maxtot = 0;\n\n        for (i = 0; i < requests; i++) {\n            struct data s = stats[i];\n            mincon = ap_min(mincon, s.ctime);\n            mintot = ap_min(mintot, s.time);\n            maxcon = ap_max(maxcon, s.ctime);\n            maxtot = ap_max(maxtot, s.time);\n            totalcon += s.ctime;\n            total += s.time;\n        }\n\n        if (requests > 0) { \n            printf(\"<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\\n\",\n               trstring, tdstring);\n            printf(\"<tr %s><th %s>&nbsp;</th> <th %s>min</th>   <th %s>avg</th>   <th %s>max</th></tr>\\n\",\n               trstring, tdstring, tdstring, tdstring, tdstring);\n            printf(\"<tr %s><th %s>Connect:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mincon, tdstring, totalcon / requests, tdstring, maxcon);\n            printf(\"<tr %s><th %s>Processing:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mintot - mincon, tdstring,\n               (total / requests) - (totalcon / requests), tdstring, maxtot - maxcon);\n            printf(\"<tr %s><th %s>Total:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mintot, tdstring, total / requests, tdstring, maxtot);\n        }\n        printf(\"</table>\\n\");\n    }\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_3b3250216231b9e548a2fd129773f6fc8e1ad13f_0", {
    "ID": "httpd_3b3250216231b9e548a2fd129773f6fc8e1ad13f_0",
    "UID": "141",
    "code": "AP_DECLARE(const char *) ap_default_type(request_rec test_snippet\n{\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &core_module);\n\n    return conf->ap_default_type\n               ? conf->ap_default_type\n               : DEFAULT_CONTENT_TYPE;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_acb3347dbdfd8be1d8f2a9ebcf5a73d5a05b9050_0", {
    "ID": "httpd_acb3347dbdfd8be1d8f2a9ebcf5a73d5a05b9050_0",
    "UID": "143",
    "code": "const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void test_snippet\n                                    const char *arg)\n{\n    long value;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    value = strtol(arg, NULL, 0);\n    if (value < 0 || errno == ERANGE)\n        return apr_pstrcat(cmd->pool, \"Invalid MaxMemFree value: \",\n                           arg, NULL);\n\n    ap_max_mem_free = (apr_uint32_t)value * 1024;\n\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_3849162cd726db0efb2a148ad27732d85ee00851_0", {
    "ID": "httpd_3849162cd726db0efb2a148ad27732d85ee00851_0",
    "UID": "146",
    "code": "static void init_child(apr_pool_t *p, server_rec test_snippet\n{\n    int mpm_threads;\n\n    ap_mpm_query(AP_MPMQ_MAX_THREADS, &mpm_threads);\n\n    \n    if (buffered_logs) {\n        int i;\n        buffered_log **array = (buffered_log **)all_buffered_logs->elts;\n\n        apr_pool_cleanup_register(p, s, flush_all_logs, flush_all_logs);\n\n        for (i = 0; i < all_buffered_logs->nelts; i++) {\n            buffered_log *this = array[i];\n\n#if APR_HAS_THREADS\n            if (mpm_threads > 1) {\n                apr_status_t rv;\n\n                this->mutex.type = apr_anylock_threadmutex;\n                rv = apr_thread_mutex_create(&this->mutex.lock.tm,\n                                             APR_THREAD_MUTEX_DEFAULT,\n                                             p);\n                if (rv != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,\n                                 \"could not initialize buffered log mutex, \"\n                                 \"transfer log may become corrupted\");\n                    this->mutex.type = apr_anylock_none;\n                }\n            }\n            else\n#endif\n            {\n                this->mutex.type = apr_anylock_none;\n            }\n        }\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_a0cfef980e51572acad8fab3b1ca6e0ee87c8d9a_0", {
    "ID": "httpd_a0cfef980e51572acad8fab3b1ca6e0ee87c8d9a_0",
    "UID": "147",
    "code": "static void read_connection(struct connection * test_snippet\n{\n    apr_size_t r;\n    apr_status_t status;\n    char *part;\n    char respcode[4];       \n\n    r = sizeof(buffer);\n#ifdef USE_SSL\n    if (c->ssl) {\n        status = SSL_read(c->ssl, buffer, r);\n        if (status <= 0) {\n            int scode = SSL_get_error(c->ssl, status);\n\n            if (scode == SSL_ERROR_ZERO_RETURN) {\n                \n                good++;\n                close_connection(test_snippet;\n            }\n            else if (scode != SSL_ERROR_WANT_WRITE\n                     && scode != SSL_ERROR_WANT_READ) {\n                \n                c->read = 0;\n                BIO_printf(bio_err, \"SSL read failed - closing connection\\n\");\n                ERR_print_errors(bio_err);\n                close_connection(test_snippet;\n            }\n            return;\n        }\n        r = status;\n    }\n    else\n#endif\n    {\n        status = apr_socket_recv(c->aprsock, buffer, &r);\n        if (APR_STATUS_IS_EAGAIN(status))\n            return;\n        else if (r == 0 && APR_STATUS_IS_EOF(status)) {\n            good++;\n            close_connection(test_snippet;\n            return;\n        }\n        \n        else if (status != APR_SUCCESS) {\n            err_except++; \n            /* XXX: Should errors here be fatal, or should we allow a\n             * certain number of them before completely failing? -aaron */\n            apr_err(\"apr_socket_recv\", status);\n        }\n    }\n\n    totalread += r;\n    if (c->read == 0) {\n        c->beginread = apr_time_now();\n    }\n    c->read += r;\n\n\n    if (!c->gotheader) {\n        char *s;\n        int l = 4;\n        apr_size_t space = CBUFFSIZE - c->cbx - 1; \n        int tocopy = (space < r) ? space : r;\n#ifdef NOT_ASCII\n        apr_size_t inbytes_left = space, outbytes_left = space;\n\n        status = apr_xlate_conv_buffer(from_ascii, buffer, &inbytes_left,\n                           c->cbuff + c->cbx, &outbytes_left);\n        if (status || inbytes_left || outbytes_left) {\n            fprintf(stderr, \"only simple translation is supported (%d/%u/%u)\\n\",\n                status, inbytes_left, outbytes_left);\n            exit(1);\n        }\n#else\n        memcpy(c->cbuff + c->cbx, buffer, space);\n#endif              \n        c->cbx += tocopy;\n        space -= tocopy;\n        c->cbuff[c->cbx] = 0;   \n        if (verbosity >= 2) {\n            printf(\"LOG: header received:\\n%s\\n\", c->cbuff);\n        }\n        s = strstr(c->cbuff, \"\\r\\n\\r\\n\");\n        /*\n         * this next line is so that we talk to NCSA 1.5 which blatantly\n         * breaks the http specifaction\n         */\n        if (!s) {\n            s = strstr(c->cbuff, \"\\n\\n\");\n            l = 2;\n        }\n\n        if (!s) {\n            \n            if (space) {\n                return;\n            }\n            else {\n            \n                apr_pollfd_t remove_pollfd;\n                remove_pollfd.desc_type = APR_POLL_SOCKET;\n                remove_pollfd.desc.s = c->aprsock;\n                apr_pollset_remove(readbits, &remove_pollfd);\n                apr_socket_close(c->aprsock);\n                err_response++;\n                if (bad++ > 10) {\n                    err(\"\\nTest aborted after 10 failures\\n\\n\");\n                }\n                start_connect(test_snippet;\n            }\n        }\n        else {\n            \n            if (!good) {\n                /*\n                 * this is first time, extract some interesting info\n                 */\n                char *p, *q;\n                p = strstr(c->cbuff, \"Server:\");\n                q = servername;\n                if (p) {\n                    p += 8;\n                    while (*p > 32)\n                    *q++ = *p++;\n                }\n                *q = 0;\n            }\n            /*\n             * XXX: this parsing isn't even remotely HTTP compliant... but in\n             * the interest of speed it doesn't totally have to be, it just\n             * needs to be extended to handle whatever servers folks want to\n             * test against. -djg\n             */\n\n            \n            part = strstr(c->cbuff, \"HTTP\");    \n            if (part && strlen(part) > strlen(\"HTTP/1.x_\")) {\n                strncpy(respcode, (part + strlen(\"HTTP/1.x_\")), 3);\n                respcode[3] = '\\0';\n            }\n            else {\n                strcpy(respcode, \"500\");\n            }\n\n            if (respcode[0] != '2') {\n                err_response++;\n                if (verbosity >= 2)\n                    printf(\"WARNING: Response code not 2xx (%s)\\n\", respcode);\n            }\n            else if (verbosity >= 3) {\n                printf(\"LOG: Response code = %s\\n\", respcode);\n            }\n            c->gotheader = 1;\n            *s = 0;     \n            if (keepalive &&\n            (strstr(c->cbuff, \"Keep-Alive\")\n             || strstr(c->cbuff, \"keep-alive\"))) {  \n                char *cl;\n                cl = strstr(c->cbuff, \"Content-Length:\");\n                \n                if (!cl)\n                    cl = strstr(c->cbuff, \"Content-length:\");\n                if (cl) {\n                    c->keepalive = 1;\n                    c->length = atoi(cl + 16);\n                }\n            }\n            c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;\n            totalbread += c->bread;\n        }\n    }\n    else {\n        \n        c->bread += r;\n        totalbread += r;\n    }\n\n    if (c->keepalive && (c->bread >= c->length)) {\n        \n        good++;\n        \n        if (good == 1) {\n            \n            doclen = c->bread;\n        }\n        else if (c->bread != doclen) {\n            bad++;\n            err_length++;\n        }\n        if (done < requests) {\n            struct data s;\n            doneka++;\n            if (done && heartbeatres && !(done % heartbeatres)) {\n                fprintf(stderr, \"Completed %ld requests\\n\", done);\n                fflush(stderr);\n            }\n            c->done = apr_time_now();\n            s.read = c->read;\n            s.starttime = c->start;\n            s.ctime = ap_max(0, (c->connect - c->start) / 1000);\n            s.waittime = ap_max(0, (c->beginread - c->endwrite) / 1000);\n            s.time = ap_max(0, (c->done - c->start) / 1000);\n            stats[done++] = s;\n        }\n        c->keepalive = 0;\n        c->length = 0;\n        c->gotheader = 0;\n        c->cbx = 0;\n        c->read = c->bread = 0;\n        c->start = c->connect = apr_time_now(); \n        write_request(test_snippet;\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_d637ff87e7add0a954ca0537407808da035d65d0_0", {
    "ID": "httpd_d637ff87e7add0a954ca0537407808da035d65d0_0",
    "UID": "148",
    "code": "static const char *set_override(cmd_parms *cmd, void *d_, const char test_snippet\n{\n    core_dir_config *d = d_;\n    char *w;\n    char *k, *v;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    if (err != NULL) {\n        return err;\n    }\n\n    \n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                     \"Useless use of AllowOverride in line %d.\",\n                     cmd->directive->line_num);\n    }\n\n    d->override = OR_NONE;\n    while (l[0]) {\n        w = ap_getword_conf(cmd->pool, &l);\n\n        k = w;\n        v = strchr(k, '=');\n        if (v) {\n                *v++ = '\\0';\n        }\n\n        if (!strcasecmp(w, \"Limit\")) {\n            d->override |= OR_LIMIT;\n        }\n        else if (!strcasecmp(k, \"Options\")) {\n            d->override |= OR_OPTIONS;\n            if (v)\n                set_allow_opts(cmd, &(d->override_opts), v);\n            else\n                d->override_opts = OPT_ALL;\n        }\n        else if (!strcasecmp(w, \"FileInfo\")) {\n            d->override |= OR_FILEINFO;\n        }\n        else if (!strcasecmp(w, \"AuthConfig\")) {\n            d->override |= OR_AUTHCFG;\n        }\n        else if (!strcasecmp(w, \"Indexes\")) {\n            d->override |= OR_INDEXES;\n        }\n        else if (!strcasecmp(w, \"None\")) {\n            d->override = OR_NONE;\n        }\n        else if (!strcasecmp(w, \"All\")) {\n            d->override = OR_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal override option \", w, NULL);\n        }\n\n        d->override &= ~OR_UNSET;\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_ffc3e59dfef00dd01d35a30d771378bd371cacd3_0", {
    "ID": "httpd_ffc3e59dfef00dd01d35a30d771378bd371cacd3_0",
    "UID": "150",
    "code": "static apr_status_t send_brigade_blocking(apr_socket_t test_snippet\n                                          apr_bucket_brigade *bb,\n                                          apr_size_t *bytes_written,\n                                          conn_rec *c)\n{\n    apr_status_t rv;\n\n    rv = APR_SUCCESS;\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        rv = send_brigade_nonblocking(s, bb, bytes_written, c);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                \n                apr_int32_t nsds;\n                apr_interval_time_t timeout;\n                apr_pollfd_t pollset;\n\n                pollset.p = c->pool;\n                pollset.desc_type = APR_POLL_SOCKET;\n                pollset.reqevents = APR_POLLOUT;\n                pollset.desc.s = s;\n                apr_socket_timeout_get(s, &timeout);\n                rv = apr_poll(&pollset, 1, &nsds, timeout);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9adafefe922138da1906d656059b2f85b1eaf173_0", {
    "ID": "httpd_9adafefe922138da1906d656059b2f85b1eaf173_0",
    "UID": "151",
    "code": "static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec test_snippet\n                                        const char* name)\n{\n    buffered_log *b;\n    b = apr_pcalloc(p, sizeof(buffered_log));\n    b->handle = ap_default_log_writer_init(p, s, name);\n\n    if (b->handle) {\n        *(buffered_log **)apr_array_push(all_buffered_logs) = b;\n        return b;\n    }\n    else\n        return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_10af717bdbda1584d6dff30fa5b1ee346a22933f_0", {
    "ID": "httpd_10af717bdbda1584d6dff30fa5b1ee346a22933f_0",
    "UID": "153",
    "code": "static apr_status_t ap_buffered_log_writer(request_rec test_snippet\n                                           void *handle,\n                                           const char **strs,\n                                           int *strl,\n                                           int nelts,\n                                           apr_size_t len)\n\n{\n    char *str;\n    char *s;\n    int i;\n    apr_status_t rv;\n    buffered_log *buf = (buffered_log*)handle;\n\n    if ((rv = APR_ANYLOCK_LOCK(&buf->mutex)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    if (len + buf->outcnt > LOG_BUFSIZE) {\n        flush_log(buf);\n    }\n    if (len >= LOG_BUFSIZE) {\n        apr_size_t w;\n\n        str = apr_palloc(r->pool, len + 1);\n        for (i = 0, s = str; i < nelts; ++i) {\n            memcpy(s, strs[i], strl[i]);\n            s += strl[i];\n        }\n        w = len;\n        rv = apr_file_write(buf->handle, str, &w);\n\n    }\n    else {\n        for (i = 0, s = &buf->outbuf[buf->outcnt]; i < nelts; ++i) {\n            memcpy(s, strs[i], strl[i]);\n            s += strl[i];\n        }\n        buf->outcnt += len;\n        rv = APR_SUCCESS;\n    }\n\n    APR_ANYLOCK_UNLOCK(&buf->mutex);\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_873de5e997316402709d4a306dbb037e1d488e44_0", {
    "ID": "httpd_873de5e997316402709d4a306dbb037e1d488e44_0",
    "UID": "163",
    "code": "AP_DECLARE(const char *) ap_process_resource_config(server_rec test_snippet\n                                                    const char *fname,\n                                                    ap_directive_t **conftree,\n                                                    apr_pool_t *p,\n                                                    apr_pool_t *ptemp)\n{\n    /* XXX: lstat() won't work on the wildcard pattern...\n     */\n\n    \n    if ((ap_server_pre_read_config->nelts\n        || ap_server_post_read_config->nelts)\n        && !(strcmp(fname, ap_server_root_relative(p, SERVER_CONFIG_FILE)))) {\n        apr_finfo_t finfo;\n\n        if (apr_stat(&finfo, fname, APR_FINFO_LINK | APR_FINFO_TYPE, p) != APR_SUCCESS)\n            return NULL;\n    }\n\n    if (!apr_fnmatch_test(fname)) {\n        return process_resource_config_nofnmatch(s, fname, conftree, p, ptemp,\n                                                 0);\n    }\n    else {\n        apr_dir_t *dirp;\n        apr_finfo_t dirent;\n        int current;\n        apr_array_header_t *candidates = NULL;\n        fnames *fnew;\n        apr_status_t rv;\n        char *path = apr_pstrdup(p, fname), *pattern = NULL;\n\n        pattern = ap_strrchr(path, '/');\n\n        AP_DEBUG_ASSERT(pattern != NULL); \n\n        *pattern++ = '\\0';\n\n        if (apr_fnmatch_test(path)) {\n            return apr_pstrcat(p, \"Wildcard patterns not allowed in Include \",\n                               fname, NULL);\n        }\n\n        if (!ap_is_directory(p, path)){\n            return apr_pstrcat(p, \"Include directory '\", path, \"' not found\",\n                               NULL);\n        }\n\n        if (!apr_fnmatch_test(pattern)) {\n            return apr_pstrcat(p, \"Must include a wildcard pattern for \"\n                               \"Include \", fname, NULL);\n        }\n\n        /*\n         * first course of business is to grok all the directory\n         * entries here and store 'em away. Recall we need full pathnames\n         * for this.\n         */\n        rv = apr_dir_open(&dirp, path, p);\n        if (rv != APR_SUCCESS) {\n            char errmsg[120];\n            return apr_psprintf(p, \"Could not open config directory %s: %s\",\n                                path, apr_strerror(rv, errmsg, sizeof errmsg));\n        }\n\n        candidates = apr_array_make(p, 1, sizeof(fnames));\n        while (apr_dir_read(&dirent, APR_FINFO_DIRENT, dirp) == APR_SUCCESS) {\n            \n            if (strcmp(dirent.name, \".\")\n                && strcmp(dirent.name, \"..\")\n                && (apr_fnmatch(pattern, dirent.name,\n                                APR_FNM_PERIOD) == APR_SUCCESS)) {\n                fnew = (fnames *) apr_array_push(candidates);\n                fnew->fname = ap_make_full_path(p, path, dirent.name);\n            }\n        }\n\n        apr_dir_close(dirp);\n        if (candidates->nelts != 0) {\n            const char *error;\n\n            qsort((void *) candidates->elts, candidates->nelts,\n                  sizeof(fnames), fname_alphasort);\n\n            /*\n             * Now recurse these... we handle errors and subdirectories\n             * via the recursion, which is nice\n             */\n            for (current = 0; current < candidates->nelts; ++current) {\n                fnew = &((fnames *) candidates->elts)[current];\n                error = process_resource_config_nofnmatch(s, fnew->fname,\n                                                          conftree, p,\n                                                          ptemp, 0);\n                if (error) {\n                    return error;\n                }\n            }\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_b78d403f5882b717fa545f7d23cd986a472c78a3_0", {
    "ID": "httpd_b78d403f5882b717fa545f7d23cd986a472c78a3_0",
    "UID": "167",
    "code": "static void test_snippet\n{\n    apr_time_t now;\n    apr_int16_t rv;\n    long i;\n    apr_status_t status;\n    int snprintf_res = 0;\n#ifdef NOT_ASCII\n    apr_size_t inbytes_left, outbytes_left;\n#endif\n\n    if (isproxy) {\n        connecthost = apr_pstrdup(cntxt, proxyhost);\n        connectport = proxyport;\n    }\n    else {\n        connecthost = apr_pstrdup(cntxt, hostname);\n        connectport = port;\n    }\n\n    if (!use_html) {\n        printf(\"Benchmarking %s \", hostname);\n    if (isproxy)\n        printf(\"[through %s:%d] \", proxyhost, proxyport);\n    printf(\"(be patient)%s\",\n           (heartbeatres ? \"\\n\" : \"...\"));\n    fflush(stdout);\n    }\n\n    now = apr_time_now();\n\n    con = calloc(concurrency, sizeof(struct connection));\n\n    stats = calloc(requests, sizeof(struct data));\n\n    if ((status = apr_pollset_create(&readbits, concurrency, cntxt, 0)) != APR_SUCCESS) {\n        apr_err(\"apr_pollset_create failed\", status);\n    }\n\n    \n    if (posting <= 0) {\n        snprintf_res = apr_snprintf(request, sizeof(_request),\n            \"%s %s HTTP/1.0\\r\\n\"\n            \"User-Agent: ApacheBench/%s\\r\\n\"\n            \"%s\" \"%s\" \"%s\"\n            \"Host: %s%s\\r\\n\"\n            \"Accept: *\n            \"%s\" \"\\r\\n\",\n            (posting == 0) ? \"GET\" : \"HEAD\",\n            (isproxy) ? fullurl : path,\n            AP_AB_BASEREVISION,\n            keepalive ? \"Connection: Keep-Alive\\r\\n\" : \"\",\n            cookie, auth, host_field, colonhost, hdrs);\n    }\n    else {\n        snprintf_res = apr_snprintf(request,  sizeof(_request),\n            \"POST %s HTTP/1.0\\r\\n\"\n            \"User-Agent: ApacheBench/%s\\r\\n\"\n            \"%s\" \"%s\" \"%s\"\n            \"Host: %s%s\\r\\n\"\n            \"Accept: *\n            \"Content-length: %\" APR_SIZE_T_FMT \"\\r\\n\"\n            \"Content-type: %s\\r\\n\"\n            \"%s\"\n            \"\\r\\n\",\n            (isproxy) ? fullurl : path,\n            AP_AB_BASEREVISION,\n            keepalive ? \"Connection: Keep-Alive\\r\\n\" : \"\",\n            cookie, auth,\n            host_field, colonhost, postlen,\n            (content_type[0]) ? content_type : \"text/plain\", hdrs);\n    }\n    if (snprintf_res >= sizeof(_request)) {\n        err(\"Request too long\\n\");\n    }\n\n    if (verbosity >= 2)\n        printf(\"INFO: POST header == \\n---\\n%s\\n---\\n\", request);\n\n    reqlen = strlen(request);\n\n    /*\n     * Combine headers and (optional) post file into one contineous buffer\n     */\n    if (posting == 1) {\n        char *buff = malloc(postlen + reqlen + 1);\n        if (!buff) {\n            fprintf(stderr, \"error creating request buffer: out of memory\\n\");\n            return;\n        }\n        strcpy(buff, request);\n        memcpy(buff + reqlen, postdata, postlen);\n        request = buff;\n    }\n\n#ifdef NOT_ASCII\n    inbytes_left = outbytes_left = reqlen;\n    status = apr_xlate_conv_buffer(to_ascii, request, &inbytes_left,\n                   request, &outbytes_left);\n    if (status || inbytes_left || outbytes_left) {\n        fprintf(stderr, \"only simple translation is supported (%d/%u/%u)\\n\",\n           status, inbytes_left, outbytes_left);\n        exit(1);\n    }\n#endif              \n\n    \n    if ((rv = apr_sockaddr_info_get(&destsa, connecthost, APR_UNSPEC, connectport, 0, cntxt))\n       != APR_SUCCESS) {\n        char buf[120];\n        apr_snprintf(buf, sizeof(buf),\n                 \"apr_sockaddr_info_get() for %s\", connecthost);\n        apr_err(buf, rv);\n    }\n\n    \n    start = apr_time_now();\n\n    \n    for (i = 0; i < concurrency; i++) {\n        con[i].socknum = i;\n        start_connect(&con[i]);\n    }\n\n    while (done < requests) {\n        apr_int32_t n;\n        apr_int32_t timed;\n            const apr_pollfd_t *pollresults;\n\n        \n        now = apr_time_now();\n        timed = (apr_int32_t)apr_time_sec(now - start);\n        if (tlimit && timed >= tlimit) {\n            requests = done;    \n            break;      \n        }\n\n        n = concurrency;\n        status = apr_pollset_poll(readbits, aprtimeout, &n, &pollresults);\n        if (status != APR_SUCCESS)\n            apr_err(\"apr_poll\", status);\n\n        if (!n) {\n            err(\"\\nServer timed out\\n\\n\");\n        }\n\n        for (i = 0; i < n; i++) {\n            const apr_pollfd_t *next_fd = &(pollresults[i]);\n            struct connection *c;\n\n                c = next_fd->client_data;\n\n            /*\n             * If the connection isn't connected how can we check it?\n             */\n            if (c->state == STATE_UNCONNECTED)\n                continue;\n\n            rv = next_fd->rtnevents;\n\n#ifdef USE_SSL\n            if (c->state == STATE_CONNECTED && c->ssl && SSL_in_init(c->ssl)) {\n                ssl_proceed_handshake(c);\n                continue;\n            }\n#endif\n\n            /*\n             * Notes: APR_POLLHUP is set after FIN is received on some\n             * systems, so treat that like APR_POLLIN so that we try to read\n             * again.\n             *\n             * Some systems return APR_POLLERR with APR_POLLHUP.  We need to\n             * call read_connection() for APR_POLLHUP, so check for\n             * APR_POLLHUP first so that a closed connection isn't treated\n             * like an I/O error.  If it is, we never figure out that the\n             * connection is done and we loop here endlessly calling\n             * apr_poll().\n             */\n            if ((rv & APR_POLLIN) || (rv & APR_POLLPRI) || (rv & APR_POLLHUP))\n                read_connection(c);\n            if ((rv & APR_POLLERR) || (rv & APR_POLLNVAL)) {\n                bad++;\n                err_except++;\n                start_connect(c);\n                continue;\n            }\n            if (rv & APR_POLLOUT) {\n                if (c->state == STATE_CONNECTING) {\n                    apr_pollfd_t remove_pollfd;\n                    rv = apr_socket_connect(c->aprsock, destsa);\n                    remove_pollfd.desc_type = APR_POLL_SOCKET;\n                    remove_pollfd.desc.s = c->aprsock;\n                    apr_pollset_remove(readbits, &remove_pollfd);\n                    if (rv != APR_SUCCESS) {\n                        apr_socket_close(c->aprsock);\n                        err_conn++;\n                        if (bad++ > 10) {\n                            fprintf(stderr,\n                                    \"\\nTest aborted after 10 failures\\n\\n\");\n                            apr_err(\"apr_socket_connect()\", rv);\n                        }\n                        c->state = STATE_UNCONNECTED;\n                        start_connect(c);\n                        continue;\n                    }\n                    else {\n                        c->state = STATE_CONNECTED;\n                        started++;\n#ifdef USE_SSL\n                        if (c->ssl)\n                            ssl_proceed_handshake(c);\n                        else\n#endif\n                        write_request(c);\n                    }\n                }\n                else {\n                    write_request(c);\n                }\n            }\n\n            /*\n             * When using a select based poll every time we check the bits\n             * are reset. In 1.3's ab we copied the FD_SET's each time\n             * through, but here we're going to check the state and if the\n             * connection is in STATE_READ or STATE_CONNECTING we'll add the\n             * socket back in as APR_POLLIN.\n             */\n                if (c->state == STATE_READ) {\n                    apr_pollfd_t new_pollfd;\n                    new_pollfd.desc_type = APR_POLL_SOCKET;\n                    new_pollfd.reqevents = APR_POLLIN;\n                    new_pollfd.desc.s = c->aprsock;\n                    new_pollfd.client_data = c;\n                    apr_pollset_add(readbits, &new_pollfd);\n                }\n        }\n    }\n\n    if (heartbeatres)\n        fprintf(stderr, \"Finished %ld requests\\n\", done);\n    else\n        printf(\"..done\\n\");\n\n    if (use_html)\n        output_html_results();\n    else\n        output_results();\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_6b8027e6d58164e239cee9e504a096527ffcff7a_0", {
    "ID": "httpd_6b8027e6d58164e239cee9e504a096527ffcff7a_0",
    "UID": "169",
    "code": "static int include_fixup(request_rec test_snippet\n{\n    include_dir_config *conf;\n\n    conf = ap_get_module_config(r->per_dir_config, &include_module);\n\n    if (r->handler && (strcmp(r->handler, \"server-parsed\") == 0))\n    {\n        if (!r->content_type || !*r->content_type) {\n            ap_set_content_type(r, \"text/html\");\n        }\n        r->handler = \"default-handler\";\n    }\n    else\n#if defined(OS2) || defined(WIN32) || defined(NETWARE)\n    \n    {\n        return DECLINED;\n    }\n#else\n    {\n        if (conf->xbithack == XBITHACK_OFF) {\n            return DECLINED;\n        }\n\n        if (!(r->finfo.protection & APR_UEXECUTE)) {\n            return DECLINED;\n        }\n\n        if (!r->content_type || strcmp(r->content_type, \"text/html\")) {\n            return DECLINED;\n        }\n    }\n#endif\n\n    /* We always return declined, because the default handler actually\n     * serves the file.  All we have to do is add the filter.\n     */\n    ap_add_output_filter(\"INCLUDES\", NULL, r, r->connection);\n    return DECLINED;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_91d3eaee682045c30b981f8059caf7a0b01042ca_0", {
    "ID": "httpd_91d3eaee682045c30b981f8059caf7a0b01042ca_0",
    "UID": "170",
    "code": "static conn_rec *core_create_conn(apr_pool_t *ptrans, server_rec test_snippet\n                                  apr_socket_t *csd, long id, void *sbh,\n                                  apr_bucket_alloc_t *alloc)\n{\n    apr_status_t rv;\n    conn_rec *c = (conn_rec *) apr_pcalloc(ptrans, sizeof(conn_rec));\n\n    c->sbh = sbh;\n    (void)ap_update_child_status(c->sbh, SERVER_BUSY_READ, (request_rec *)NULL);\n\n    /* Got a connection structure, so initialize what fields we can\n     * (the rest are zeroed out by pcalloc).\n     */\n    c->conn_config = ap_create_conn_config(ptrans);\n    c->notes = apr_table_make(ptrans, 5);\n\n    c->pool = ptrans;\n    if ((rv = apr_socket_addr_get(&c->local_addr, APR_LOCAL, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,\n                     \"apr_socket_addr_get(APR_LOCAL)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->local_ip, c->local_addr);\n    if ((rv = apr_socket_addr_get(&c->remote_addr, APR_REMOTE, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,\n                     \"apr_socket_addr_get(APR_REMOTE)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->remote_ip, c->remote_addr);\n    c->base_server = server;\n\n    c->id = id;\n    c->bucket_alloc = alloc;\n\n    c->cs = (conn_state_t *)apr_pcalloc(ptrans, sizeof(conn_state_t));\n    APR_RING_INIT(&(c->cs->timeout_list), conn_state_t, timeout_list);\n    c->cs->expiration_time = 0;\n    c->cs->state = CONN_STATE_CHECK_REQUEST_LINE_READABLE;\n    c->cs->c = c;\n    c->cs->p = ptrans;\n    c->cs->bucket_alloc = alloc;\n\n    return c;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_1e9a1be45f1c186161413c197833da6011ff9932_0", {
    "ID": "httpd_1e9a1be45f1c186161413c197833da6011ff9932_0",
    "UID": "177",
    "code": "static void remove_empty_buckets(apr_bucket_brigade test_snippet\n{\n    apr_bucket *bucket;\n    while (((bucket = APR_BRIGADE_FIRST(bb)) != APR_BRIGADE_SENTINEL(bb)) &&\n           (APR_BUCKET_IS_METADATA(bucket) || (bucket->length == 0))) {\n        APR_BUCKET_REMOVE(bucket);\n        apr_bucket_destroy(bucket);\n    }\n}",
    "predicted": "415,Double Free"
  },
  "httpd_f691146628a146b5ea6f4633c2692004b74dd513_0", {
    "ID": "httpd_f691146628a146b5ea6f4633c2692004b74dd513_0",
    "UID": "179",
    "code": "AP_DECLARE(int) ap_location_walk(request_rec test_snippet\n{\n    ap_conf_vector_t *now_merged = NULL;\n    core_server_config *sconf = ap_get_module_config(r->server->module_config,\n                                                     &core_module);\n    ap_conf_vector_t **sec_ent = (ap_conf_vector_t **)sconf->sec_url->elts;\n    int num_sec = sconf->sec_url->nelts;\n    walk_cache_t *cache;\n    const char *entry_uri;\n\n    /* No tricks here, there are no <Locations > to parse in this vhost.\n     * We won't destroy the cache, just in case _this_ redirect is later\n     * redirected again to a vhost with <Location > blocks to optimize.\n     */\n    if (!num_sec) {\n        return OK;\n    }\n\n    cache = prep_walk_cache(AP_NOTE_LOCATION_WALK, r);\n\n    /* Location and LocationMatch differ on their behaviour w.r.t. multiple\n     * slashes.  Location matches multiple slashes with a single slash,\n     * LocationMatch doesn't.  An exception, for backwards brokenness is\n     * absoluteURIs... in which case neither match multiple slashes.\n     */\n    if (r->uri[0] != '/') {\n        entry_uri = r->uri;\n    }\n    else {\n        char *uri = apr_pstrdup(r->pool, r->uri);\n        ap_no2slash(uri);\n        entry_uri = uri;\n    }\n\n    /* If we have an cache->cached location that matches r->uri,\n     * and the vhost's list of locations hasn't changed, we can skip\n     * rewalking the location_walk entries.\n     */\n    if (cache->cached\n        && (cache->dir_conf_tested == sec_ent)\n        && (strcmp(entry_uri, cache->cached) == 0)) {\n        /* Well this looks really familiar!  If our end-result (per_dir_result)\n         * didn't change, we have absolutely nothing to do :)\n         * Otherwise (as is the case with most dir_merged/file_merged requests)\n         * we must merge our dir_conf_merged onto this new r->per_dir_config.\n         */\n        if (r->per_dir_config == cache->per_dir_result) {\n            return OK;\n        }\n\n        if (r->per_dir_config == cache->dir_conf_merged) {\n            r->per_dir_config = cache->per_dir_result;\n            return OK;\n        }\n\n        if (cache->walked->nelts) {\n            now_merged = ((walk_walked_t*)cache->walked->elts)\n                                            [cache->walked->nelts - 1].merged;\n        }\n    }\n    else {\n        /* We start now_merged from NULL since we want to build\n         * a locations list that can be merged to any vhost.\n         */\n        int len, sec_idx;\n        int matches = cache->walked->nelts;\n        walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;\n        cache->cached = entry_uri;\n\n        /* Go through the location entries, and check for matches.\n         * We apply the directive sections in given order, we should\n         * really try them with the most general first.\n         */\n        for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {\n\n            core_dir_config *entry_core;\n            entry_core = ap_get_module_config(sec_ent[sec_idx], &core_module);\n\n            \n            len = strlen(entry_core->d);\n\n            /* Test the regex, fnmatch or string as appropriate.\n             * If it's a strcmp, and the <Location > pattern was\n             * not slash terminated, then this uri must be slash\n             * terminated (or at the end of the string) to match.\n             */\n            if (entry_core->r\n                ? ap_regexec(entry_core->r, r->uri, 0, NULL, 0)\n                : (entry_core->d_is_fnmatch\n                   ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)\n                   : (strncmp(entry_core->d, cache->cached, len)\n                      || (entry_core->d[len - 1] != '/'\n                          && cache->cached[len] != '/'\n                          && cache->cached[len] != '\\0')))) {\n                continue;\n            }\n\n            /* If we merged this same section last time, reuse it\n             */\n            if (matches) {\n                if (last_walk->matched == sec_ent[sec_idx]) {\n                    now_merged = last_walk->merged;\n                    ++last_walk;\n                    --matches;\n                    continue;\n                }\n\n                /* We fell out of sync.  This is our own copy of walked,\n                 * so truncate the remaining matches and reset remaining.\n                 */\n                cache->walked->nelts -= matches;\n                matches = 0;\n            }\n\n            if (now_merged) {\n                now_merged = ap_merge_per_dir_configs(r->pool,\n                                                      now_merged,\n                                                      sec_ent[sec_idx]);\n            }\n            else {\n                now_merged = sec_ent[sec_idx];\n            }\n\n            last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n            last_walk->matched = sec_ent[sec_idx];\n            last_walk->merged = now_merged;\n        }\n\n        /* Whoops - everything matched in sequence, but the original walk\n         * found some additional matches.  Truncate them.\n         */\n        if (matches) {\n            cache->walked->nelts -= matches;\n        }\n    }\n\n    cache->dir_conf_tested = sec_ent;\n    cache->dir_conf_merged = r->per_dir_config;\n\n    /* Merge our cache->dir_conf_merged construct with the r->per_dir_configs,\n     * and note the end result to (potentially) skip this step next time.\n     */\n    if (now_merged) {\n        r->per_dir_config = ap_merge_per_dir_configs(r->pool,\n                                                     r->per_dir_config,\n                                                     now_merged);\n    }\n    cache->per_dir_result = r->per_dir_config;\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_b9d70d5120d96e19269b05b36c1af3a90bc47bd4_0", {
    "ID": "httpd_b9d70d5120d96e19269b05b36c1af3a90bc47bd4_0",
    "UID": "180",
    "code": "AP_DECLARE(int) ap_file_walk(request_rec test_snippet\n{\n    ap_conf_vector_t *now_merged = NULL;\n    core_dir_config *dconf = ap_get_module_config(r->per_dir_config,\n                                                  &core_module);\n    ap_conf_vector_t **sec_ent = (ap_conf_vector_t **)dconf->sec_file->elts;\n    int num_sec = dconf->sec_file->nelts;\n    walk_cache_t *cache;\n    const char *test_file;\n\n    /* To allow broken modules to proceed, we allow missing filenames to pass.\n     * We will catch it later if it's heading for the core handler.\n     * directory_walk already posted an INFO note for module debugging.\n     */\n    if (r->filename == NULL) {\n        return OK;\n    }\n\n    cache = prep_walk_cache(AP_NOTE_FILE_WALK, r);\n\n    /* No tricks here, there are just no <Files > to parse in this context.\n     * We won't destroy the cache, just in case _this_ redirect is later\n     * redirected again to a context containing the same or similar <Files >.\n     */\n    if (!num_sec) {\n        return OK;\n    }\n\n    /* Get the basename .. and copy for the cache just\n     * in case r->filename is munged by another module\n     */\n    test_file = strrchr(r->filename, '/');\n    if (test_file == NULL) {\n        test_file = apr_pstrdup(r->pool, r->filename);\n    }\n    else {\n        test_file = apr_pstrdup(r->pool, ++test_file);\n    }\n\n    /* If we have an cache->cached file name that matches test_file,\n     * and the directory's list of file sections hasn't changed, we\n     * can skip rewalking the file_walk entries.\n     */\n    if (cache->cached\n        && (cache->dir_conf_tested == sec_ent)\n        && (strcmp(test_file, cache->cached) == 0)) {\n        /* Well this looks really familiar!  If our end-result (per_dir_result)\n         * didn't change, we have absolutely nothing to do :)\n         * Otherwise (as is the case with most dir_merged requests)\n         * we must merge our dir_conf_merged onto this new r->per_dir_config.\n         */\n        if (r->per_dir_config == cache->per_dir_result) {\n            return OK;\n        }\n\n        if (r->per_dir_config == cache->dir_conf_merged) {\n            r->per_dir_config = cache->per_dir_result;\n            return OK;\n        }\n\n        if (cache->walked->nelts) {\n            now_merged = ((walk_walked_t*)cache->walked->elts)\n                [cache->walked->nelts - 1].merged;\n        }\n    }\n    else {\n        /* We start now_merged from NULL since we want to build\n         * a file section list that can be merged to any dir_walk.\n         */\n        int sec_idx;\n        int matches = cache->walked->nelts;\n        walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;\n        cache->cached = test_file;\n\n        /* Go through the location entries, and check for matches.\n         * We apply the directive sections in given order, we should\n         * really try them with the most general first.\n         */\n        for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {\n\n            core_dir_config *entry_core;\n            entry_core = ap_get_module_config(sec_ent[sec_idx], &core_module);\n\n            if (entry_core->r\n                ? ap_regexec(entry_core->r, cache->cached , 0, NULL, 0)\n                : (entry_core->d_is_fnmatch\n                   ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)\n                   : strcmp(entry_core->d, cache->cached))) {\n                continue;\n            }\n\n            /* If we merged this same section last time, reuse it\n             */\n            if (matches) {\n                if (last_walk->matched == sec_ent[sec_idx]) {\n                    now_merged = last_walk->merged;\n                    ++last_walk;\n                    --matches;\n                    continue;\n                }\n\n                /* We fell out of sync.  This is our own copy of walked,\n                 * so truncate the remaining matches and reset remaining.\n                 */\n                cache->walked->nelts -= matches;\n                matches = 0;\n            }\n\n            if (now_merged) {\n                now_merged = ap_merge_per_dir_configs(r->pool,\n                                                      now_merged,\n                                                      sec_ent[sec_idx]);\n            }\n            else {\n                now_merged = sec_ent[sec_idx];\n            }\n\n            last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n            last_walk->matched = sec_ent[sec_idx];\n            last_walk->merged = now_merged;\n        }\n\n        /* Whoops - everything matched in sequence, but the original walk\n         * found some additional matches.  Truncate them.\n         */\n        if (matches) {\n            cache->walked->nelts -= matches;\n        }\n    }\n\n    cache->dir_conf_tested = sec_ent;\n    cache->dir_conf_merged = r->per_dir_config;\n\n    /* Merge our cache->dir_conf_merged construct with the r->per_dir_configs,\n     * and note the end result to (potentially) skip this step next time.\n     */\n    if (now_merged) {\n        r->per_dir_config = ap_merge_per_dir_configs(r->pool,\n                                                     r->per_dir_config,\n                                                     now_merged);\n    }\n    cache->per_dir_result = r->per_dir_config;\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_868d4aa9540ba7eecdafbc8b66d0c1a9aa0afe0b_0", {
    "ID": "httpd_868d4aa9540ba7eecdafbc8b66d0c1a9aa0afe0b_0",
    "UID": "181",
    "code": "AP_DECLARE(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t test_snippet\n                                size_t length)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb = NULL;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = apr_bucket_mmap_create(mm, test_snippet length, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    ap_pass_brigade(r->output_filters, bb);\n\n    return mm->size; \n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_7c442e0a350159f1a9714e89d67d19512abd2f08_0", {
    "ID": "httpd_7c442e0a350159f1a9714e89d67d19512abd2f08_0",
    "UID": "182",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) test_snippet\n    ap_filter_t *f, apr_bucket_brigade *bb)\n{\n    old_write_filter_ctx *ctx = f->ctx;\n\n    AP_DEBUG_ASSERT(ctx);\n\n    if (ctx->bb != NULL) {\n        /* whatever is coming down the pipe (we don't care), we\n         * can simply insert our buffered data at the front and\n         * pass the whole bundle down the chain.\n         */\n        APR_BRIGADE_CONCAT(ctx->bb, bb);\n        bb = ctx->bb;\n        ctx->bb = NULL;\n    }\n\n    return ap_pass_brigade(f->next, bb);\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_d68cbad5faf4f512488e38df9aaaa92caa06bee1_0", {
    "ID": "httpd_d68cbad5faf4f512488e38df9aaaa92caa06bee1_0",
    "UID": "184",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_sub_req_output_filter(ap_filter_t test_snippet\n                                                              apr_bucket_brigade *bb)\n{\n    apr_bucket *e = APR_BRIGADE_LAST(bb);\n\n    if (APR_BUCKET_IS_EOS(e)) {\n        apr_bucket_delete(e);\n    }\n\n    if (!APR_BRIGADE_EMPTY(bb)) {\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "416,Use After Free"
  },
  "httpd_07c9030b638774d626095e67699cc8ab7b2029a9_0", {
    "ID": "httpd_07c9030b638774d626095e67699cc8ab7b2029a9_0",
    "UID": "185",
    "code": "AP_DECLARE_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, test_snippet\n{\n    va_list va;\n    int n;\n\n    if (r->connection->aborted)\n        return -1;\n\n    va_start(va, fmt);\n    n = ap_vrprintf(r, fmt, va);\n    va_end(va);\n\n    return n;\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_fe82f676546a1a30473acf0782dc1335c9fa94dd_0", {
    "ID": "httpd_fe82f676546a1a30473acf0782dc1335c9fa94dd_0",
    "UID": "186",
    "code": "AP_DECLARE(int) ap_rflush(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = apr_bucket_flush_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n        return -1;\n\n    return 0;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_e0be1d24fe75e9afa7167191dcfd211745bfe0f3_0", {
    "ID": "httpd_e0be1d24fe75e9afa7167191dcfd211745bfe0f3_0",
    "UID": "189",
    "code": "AP_DECLARE(apr_status_t) ap_parse_mutex(const char *arg, apr_pool_t test_snippet\n                                        apr_lockmech_e *mutexmech,\n                                        const char **mutexfile)\n{\n    \n    char *meth = apr_pstrdup(pool, arg);\n    char *file = strchr(meth, ':');\n    if (file) {\n        *(file++) = '\\0';\n        if (!*file) {\n            file = NULL;\n        }\n    }\n\n    if (!strcasecmp(meth, \"none\") || !strcasecmp(meth, \"no\")) {\n        return APR_ENOLOCK;\n    }\n\n    /* APR determines temporary filename unless overridden below,\n     * we presume file indicates an mutexfile is a file path\n     * unless the method sets mutexfile=file and NULLs file\n     */\n    *mutexfile = NULL;\n\n    \n    if (!strcasecmp(meth, \"default\") || !strcasecmp(meth, \"yes\")) {\n        *mutexmech = APR_LOCK_DEFAULT;\n    }\n#if APR_HAS_FCNTL_SERIALIZE\n    else if (!strcasecmp(meth, \"fcntl\") || !strcasecmp(meth, \"file\")) {\n        *mutexmech = APR_LOCK_FCNTL;\n    }\n#endif\n#if APR_HAS_FLOCK_SERIALIZE\n    else if (!strcasecmp(meth, \"flock\") || !strcasecmp(meth, \"file\")) {\n        *mutexmech = APR_LOCK_FLOCK;\n    }\n#endif\n#if APR_HAS_POSIXSEM_SERIALIZE\n    else if (!strcasecmp(meth, \"posixsem\") || !strcasecmp(meth, \"sem\")) {\n        *mutexmech = APR_LOCK_POSIXSEM;\n        /* Posix/SysV semaphores aren't file based, use the literal name\n         * if provided and fall back on APR's default if not.  Today, APR\n         * will ignore it, but once supported it has an absurdly short limit.\n         */\n        if (file) {\n            *mutexfile = apr_pstrdup(pool, file);\n\n            file = NULL;\n        }\n    }\n#endif\n#if APR_HAS_SYSVSEM_SERIALIZE && !defined(PERCHILD_MPM)\n    else if (!strcasecmp(meth, \"sysvsem\") || !strcasecmp(meth, \"sem\")) {\n        *mutexmech = APR_LOCK_SYSVSEM;\n    }\n#endif\n#if APR_HAS_PROC_PTHREAD_SERIALIZE\n    else if (!strcasecmp(meth, \"pthread\")) {\n        *mutexmech = APR_LOCK_PROC_PTHREAD;\n    }\n#endif\n    else {\n        return APR_ENOTIMPL;\n    }\n\n    /* Unless the method above assumed responsibility for setting up\n     * mutexfile and NULLing out file, presume it is a file we\n     * are looking to use\n     */\n    if (file) {\n        *mutexfile = ap_server_root_relative(pool, file);\n        if (!*mutexfile) {\n            return APR_BADARG;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n427,Uncontrolled Search Path Element"
  },
  "httpd_92a348950604437129929313fac9bd1f04b1d318_0", {
    "ID": "httpd_92a348950604437129929313fac9bd1f04b1d318_0",
    "UID": "190",
    "code": "void ap_register_extra_mpm_process(pid_t test_snippet\n{\n    extra_process_t *p = (extra_process_t *)malloc(sizeof(extra_process_t));\n\n    p->next = extras;\n    p->pid = pid;\n    extras = p;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_148df6071160aca76e3bbddc9294902d292e54a3_0", {
    "ID": "httpd_148df6071160aca76e3bbddc9294902d292e54a3_0",
    "UID": "195",
    "code": "AP_DECLARE(apr_status_test_snippet ap_recent_rfc822_date(char *date_str, apr_time_t test_snippet\n{\n    /* ### This code is a clone of apr_rfc822_date(), except that it\n     * uses ap_explode_recent_gmt() instead of apr_time_exp_gmt().\n     */\n    apr_time_exp_t xt;\n    const char *s;\n    int real_year;\n\n    ap_explode_recent_gmt(&xt, test_snippet;\n\n    \n    \n\n    s = &apr_day_snames[xt.tm_wday][0];\n    *date_str++ = *s++;\n    *date_str++ = *s++;\n    *date_str++ = *s++;\n    *date_str++ = ',';\n    *date_str++ = ' ';\n    *date_str++ = xt.tm_mday / 10 + '0';\n    *date_str++ = xt.tm_mday % 10 + '0';\n    *date_str++ = ' ';\n    s = &apr_month_snames[xt.tm_mon][0];\n    *date_str++ = *s++;\n    *date_str++ = *s++;\n    *date_str++ = *s++;\n    *date_str++ = ' ';\n    real_year = 1900 + xt.tm_year;\n    \n    *date_str++ = real_year / 1000 + '0';\n    *date_str++ = real_year % 1000 / 100 + '0';\n    *date_str++ = real_year % 100 / 10 + '0';\n    *date_str++ = real_year % 10 + '0';\n    *date_str++ = ' ';\n    *date_str++ = xt.tm_hour / 10 + '0';\n    *date_str++ = xt.tm_hour % 10 + '0';\n    *date_str++ = ':';\n    *date_str++ = xt.tm_min / 10 + '0';\n    *date_str++ = xt.tm_min % 10 + '0';\n    *date_str++ = ':';\n    *date_str++ = xt.tm_sec / 10 + '0';\n    *date_str++ = xt.tm_sec % 10 + '0';\n    *date_str++ = ' ';\n    *date_str++ = 'G';\n    *date_str++ = 'M';\n    *date_str++ = 'T';\n    *date_str++ = 0;\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_77cf3c7dac394ff8f235a8a86b9204e01968cc38_0", {
    "ID": "httpd_77cf3c7dac394ff8f235a8a86b9204e01968cc38_0",
    "UID": "196",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t test_snippet\n                                                           apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    const char *clheader;\n    const char *protocol;\n    apr_bucket *e;\n    apr_bucket_brigade *b2;\n    header_struct h;\n    header_filter_ctx *ctx = f->ctx;\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (r->header_only) {\n        if (!ctx) {\n            ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));\n        }\n        else if (ctx->headers_sent) {\n            apr_brigade_destroy(b);\n            return OK;\n        }\n    }\n\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (AP_BUCKET_IS_ERROR(e)) {\n            ap_bucket_error *eb = e->data;\n\n            ap_die(eb->status, r);\n            return AP_FILTER_ERROR;\n        }\n    }\n\n    if (r->assbackwards) {\n        r->sent_bodyct = 1;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, b);\n    }\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n    }\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_set(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    \n    basic_http_header_check(r, &protocol);\n    ap_set_keepalive(r);\n\n    if (r->chunked) {\n        apr_table_mergen(r->headers_out, \"Transfer-Encoding\", \"chunked\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n    }\n\n    apr_table_setn(r->headers_out, \"Content-Type\",\n                   ap_make_content_type(r, r->content_type));\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char **languages = (char **)(r->content_languages->elts);\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            apr_table_mergen(r->headers_out, \"Content-Language\", languages[i]);\n        }\n    }\n\n    /*\n     * Control cachability for non-cachable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    /* This is a hack, but I can't find anyway around it.  The idea is that\n     * we don't want to send out 0 Content-Lengths if it is a head request.\n     * This happens when modules try to outsmart the server, and return\n     * if they see a HEAD request.  Apache 1.3 handlers were supposed to\n     * just return in that situation, and the core handled the HEAD.  In\n     * 2.0, if a handler returns, then the core sends an EOS bucket down\n     * the filter stack, and the content-length filter computes a C-L of\n     * zero and that gets put in the headers, and we end up sending a\n     * zero C-L to the client.  We can't just remove the C-L filter,\n     * because well behaved 2.0 handlers will send their data down the stack,\n     * and we will compute a real C-L for the head request. RBB\n     */\n    if (r->header_only\n        && (clheader = apr_table_get(r->headers_out, \"Content-Length\"))\n        && !strcmp(clheader, \"0\")) {\n        apr_table_unset(r->headers_out, \"Content-Length\");\n    }\n\n    b2 = apr_brigade_create(r->pool, c->bucket_alloc);\n    basic_http_header(r, b2, protocol);\n\n    h.pool = r->pool;\n    h.bb = b2;\n\n    if (r->status == HTTP_NOT_MODIFIED) {\n        apr_table_do((int (*)(void *, const char *, const char *)) form_header_field,\n                     (void *) &h, r->headers_out,\n                     \"Connection\",\n                     \"Keep-Alive\",\n                     \"ETag\",\n                     \"Content-Location\",\n                     \"Expires\",\n                     \"Cache-Control\",\n                     \"Vary\",\n                     \"Warning\",\n                     \"WWW-Authenticate\",\n                     \"Proxy-Authenticate\",\n                     \"Set-Cookie\",\n                     \"Set-Cookie2\",\n                     NULL);\n    }\n    else {\n        send_all_header_fields(&h, r);\n    }\n\n    terminate_header(b2);\n\n    ap_pass_brigade(f->next, b2);\n\n    if (r->header_only) {\n        apr_brigade_destroy(b);\n        ctx->headers_sent = 1;\n        return OK;\n    }\n\n    r->sent_bodyct = 1;         \n\n    if (r->chunked) {\n        /* We can't add this filter until we have already sent the headers.\n         * If we add it before this point, then the headers will be chunked\n         * as well, and that is just wrong.\n         */\n        ap_add_output_filter(\"CHUNK\", NULL, r, r->connection);\n    }\n\n    /* Don't remove this filter until after we have added the CHUNK filter.\n     * Otherwise, f->next won't be the CHUNK filter and thus the first\n     * brigade won't be chunked properly.\n     */\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_ac8bec7f58c1d0fb13a7eb6415c7d550af03cb3b_0", {
    "ID": "httpd_ac8bec7f58c1d0fb13a7eb6415c7d550af03cb3b_0",
    "UID": "200",
    "code": "static int get_now(int use_localtime, int test_snippet\n{\n    apr_time_t tNow = apr_time_now();\n    if (use_localtime) {\n        /* Check for our UTC offset before using it, since it might\n         * change if there's a switch between standard and daylight\n         * savings time.\n         */\n        apr_time_exp_t lt;\n        apr_time_exp_lt(&lt, tNow);\n        utc_offset = lt.tm_gmtoff;\n    }\n    return (int)apr_time_sec(tNow) + utc_offset;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_babbed4e00424489cc285d2732e99ec389ca1891_0", {
    "ID": "httpd_babbed4e00424489cc285d2732e99ec389ca1891_0",
    "UID": "201",
    "code": "int main (int argc, const char * const test_snippet\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    apr_getopt_t *opt;\n    apr_status_t rv;\n    char c;\n    const char *optarg;\n    char *ptr = NULL;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    apr_getopt_init(&opt, pool, argc, argv);\n    while ((rv = apr_getopt(opt, \"l\", &c, &optarg)) == APR_SUCCESS) {\n        switch (c) {\n        case 'l':\n            use_localtime = 1;\n            break;\n        }\n    }\n\n    if (rv != APR_EOF) {\n        usage(argv[0], NULL  );\n    }\n\n    if (opt->ind + 2 != argc && opt->ind + 3 != argc) {\n        usage(argv[0], \"Incorrect number of arguments\");\n    }\n\n    szLogRoot = argv[opt->ind++];\n\n    ptr = strchr(argv[opt->ind], 'M');\n    if (ptr) { \n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[opt->ind]) * 1048576;\n        }\n        if (sRotation == 0) {\n            usage(argv[0], \"Invalid rotation size parameter\");\n        }\n    }\n    else { \n        tRotation = atoi(argv[opt->ind]);\n        if (tRotation <= 0) {\n            usage(argv[0], \"Invalid rotation time parameter\");\n        }\n    }\n    opt->ind++;\n\n    if (opt->ind < argc) { \n        if (use_localtime) {\n            usage(argv[0], \"UTC offset parameter is not valid with -l\");\n        }\n        utc_offset = atoi(argv[opt->ind]) * 60;\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            now = get_now(use_localtime, utc_offset);\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n            apr_status_t rv;\n\n            if (tRotation) {\n                tLogStart = (now / tRotation) * tRotation;\n            }\n            else {\n                tLogStart = get_now(use_localtime, utc_offset);\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            rv = apr_file_open(&nLogFD, buf2, APR_WRITE | APR_CREATE | APR_APPEND,\n                               APR_OS_DEFAULT, pool);\n            if (rv != APR_SUCCESS) {\n                char error[120];\n\n                apr_strerror(rv, error, sizeof error);\n\n                /* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. */\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"Could not open log file '%s' (%s)\\n\", buf2, error);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    /* Try to keep this error message constant length\n                     * in case it occurs several times. */\n                    apr_snprintf(errbuf, sizeof errbuf,\n                                 \"Resetting log file due to error opening \"\n                                 \"new log file, %10d messages lost: %-25.25s\\n\",\n                                 nMessCount, error);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \n    return 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_5842f7de5d0cda0cbd075379c2b86411ad375a15_0", {
    "ID": "httpd_5842f7de5d0cda0cbd075379c2b86411ad375a15_0",
    "UID": "203",
    "code": "char *ap_response_code_string(request_rec *r, int test_snippet\n{\n    core_dir_config *dirconf;\n    core_request_config *reqconf;\n\n    \n    reqconf = (core_request_config *)ap_get_module_config(r->request_config,\n                                                          &core_module);\n    if (reqconf->response_code_strings != NULL &&\n        reqconf->response_code_strings[error_index] != NULL) {\n        return reqconf->response_code_strings[error_index];\n    }\n\n    \n    dirconf = (core_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                      &core_module);\n\n    if (dirconf->response_code_strings == NULL) {\n        return NULL;\n    }\n\n    if (dirconf->response_code_strings[error_index] == &errordocument_default) {\n        return NULL;\n    }\n\n    return dirconf->response_code_strings[error_index];\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_97f2d029c66f34f2d67dcc5cac7e5d98197c4fc8_0", {
    "ID": "httpd_97f2d029c66f34f2d67dcc5cac7e5d98197c4fc8_0",
    "UID": "204",
    "code": "static int handle_multi(request_rec test_snippet\n{\n    negotiation_state *neg;\n    var_rec *best, *avail_recs;\n    request_rec *sub_req;\n    int res;\n    int j;\n\n    if (r->finfo.filetype != APR_NOFILE\n        || !(ap_allow_options(r) & OPT_MULTI)) {\n        return DECLINED;\n    }\n\n    neg = parse_accept_headers(r);\n\n    if ((res = read_types_multi(neg))) {\n      return_from_multi:\n        \n        avail_recs = (var_rec *) neg->avail_vars->elts;\n        for (j = 0; j < neg->avail_vars->nelts; ++j) {\n            var_rec *variant = &avail_recs[j];\n            if (variant->sub_req) {\n                ap_destroy_sub_req(variant->sub_req);\n            }\n        }\n        return res;\n    }\n    if (neg->avail_vars->nelts == 0) {\n        return DECLINED;\n    }\n\n    res = do_negotiation(r, neg, &best,\n                         (r->method_number != M_GET) || r->args ||\n                         (r->path_info && *r->path_info));\n    if (res != 0)\n        goto return_from_multi;\n\n    if (!(sub_req = best->sub_req)) {\n        /* We got this out of a map file, so we don't actually have\n         * a sub_req structure yet.  Get one now.\n         */\n\n        sub_req = ap_sub_req_lookup_file(best->file_name, r, NULL);\n        if (sub_req->status != HTTP_OK) {\n            res = sub_req->status;\n            ap_destroy_sub_req(sub_req);\n            goto return_from_multi;\n        }\n    }\n\n    \n    ap_internal_fast_redirect(sub_req, r);\n\n    /* give no advise for time on this subrequest.  Perhaps we\n     * should tally the last mtime amoung all variants, and date\n     * the most recent, but that could confuse the proxies.\n     */\n    r->mtime = 0;\n\n    /* clean up all but our favorite variant, since that sub_req\n     * is now merged into the main request!\n     */\n    avail_recs = (var_rec *) neg->avail_vars->elts;\n    for (j = 0; j < neg->avail_vars->nelts; ++j) {\n        var_rec *variant = &avail_recs[j];\n        if (variant != best && variant->sub_req) {\n            ap_destroy_sub_req(variant->sub_req);\n        }\n    }\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_1f44e35543f136a2838f17028e260b3e68a37c4b_0", {
    "ID": "httpd_1f44e35543f136a2838f17028e260b3e68a37c4b_0",
    "UID": "206",
    "code": "apr_status_t ap_http_chunk_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n#define ASCII_CRLF  \"\\015\\012\"\n#define ASCII_ZERO  \"\\060\"\n    conn_rec *c = f->r->connection;\n    apr_bucket_brigade *more;\n    apr_bucket *e;\n    apr_status_t rv;\n    int bad_gateway_seen = 0;\n\n    for (more = NULL; b; b = more, more = NULL) {\n        apr_off_t bytes = 0;\n        apr_bucket *eos = NULL;\n        apr_bucket *flush = NULL;\n        /* XXX: chunk_hdr must remain at this scope since it is used in a\n         *      transient bucket.\n         */\n        char chunk_hdr[20]; \n\n\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_EOS(e)) {\n                \n                eos = e;\n                break;\n            }\n            if (AP_BUCKET_IS_ERROR(e)\n                && (((ap_bucket_error *)(e->data))->status\n                    == HTTP_BAD_GATEWAY)) {\n                \n                bad_gateway_seen = 1;\n                continue;\n            }\n            if (APR_BUCKET_IS_FLUSH(e)) {\n                flush = e;\n                more = apr_brigade_split(b, APR_BUCKET_NEXT(e));\n                break;\n            }\n            else if (e->length == (apr_size_t)-1) {\n                \n                const char *data;\n                apr_size_t len;\n\n                rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                if (len > 0) {\n                    /*\n                     * There may be a new next bucket representing the\n                     * rest of the data stream on which a read() may\n                     * block so we pass down what we have so far.\n                     */\n                    bytes += len;\n                    more = apr_brigade_split(b, APR_BUCKET_NEXT(e));\n                    break;\n                }\n                else {\n                    /* If there was nothing in this bucket then we can\n                     * safely move on to the next one without pausing\n                     * to pass down what we have counted up so far.\n                     */\n                    continue;\n                }\n            }\n            else {\n                bytes += e->length;\n            }\n        }\n\n        /*\n         * XXX: if there aren't very many bytes at this point it may\n         * be a good idea to set them aside and return for more,\n         * unless we haven't finished counting this brigade yet.\n         */\n        \n        if (bytes > 0) {\n            apr_size_t hdr_len;\n            /*\n             * Insert the chunk header, specifying the number of bytes in\n             * the chunk.\n             */\n            hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\n                                   \"%\" APR_UINT64_T_HEX_FMT CRLF, (apr_uint64_t)bytes);\n            ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);\n            e = apr_bucket_transient_create(chunk_hdr, hdr_len,\n                                            c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(b, e);\n\n            /*\n             * Insert the end-of-chunk CRLF before an EOS or\n             * FLUSH bucket, or appended to the brigade\n             */\n            e = apr_bucket_immortal_create(ASCII_CRLF, 2, c->bucket_alloc);\n            if (eos != NULL) {\n                APR_BUCKET_INSERT_BEFORE(eos, e);\n            }\n            else if (flush != NULL) {\n                APR_BUCKET_INSERT_BEFORE(flush, e);\n            }\n            else {\n                APR_BRIGADE_INSERT_TAIL(b, e);\n            }\n        }\n\n        /* RFC 2616, Section 3.6.1\n         *\n         * If there is an EOS bucket, then prefix it with:\n         *   1) the last-chunk marker (\"0\" CRLF)\n         *   2) the trailer\n         *   3) the end-of-chunked body CRLF\n         *\n         * If there is no EOS bucket, or if we had seen an error bucket with\n         * status HTTP_BAD_GATEWAY then do nothing.\n         * The error bucket with status HTTP_BAD_GATEWAY indicates that the\n         * connection to the backend (mod_proxy) broke in the middle of the\n         * response. In order to signal the client that something went wrong\n         * we do not create the last-chunk marker and set c->keepalive to\n         * AP_CONN_CLOSE in the core output filter.\n         *\n         * XXX: it would be nice to combine this with the end-of-chunk\n         * marker above, but this is a bit more straight-forward for\n         * now.\n         */\n        if (eos && !bad_gateway_seen) {\n            \n            e = apr_bucket_immortal_create(ASCII_ZERO ASCII_CRLF\n                                           \n                                           ASCII_CRLF, 5, c->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n\n        \n        rv = ap_pass_brigade(f->next, b);\n        if (rv != APR_SUCCESS || eos != NULL) {\n            return rv;\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_6ca7563b783ffb982e75892fdea400be89e28012_0", {
    "ID": "httpd_6ca7563b783ffb982e75892fdea400be89e28012_0",
    "UID": "210",
    "code": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade test_snippet\n{\n    char *field;\n    apr_size_t len;\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->status = HTTP_BAD_REQUEST;\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC && field) {\n                \n                field[len - 1] = '\\0';\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_pstrcat(r->pool,\n                                           \"Size of a request header field \"\n                                           \"exceeds server limit.<br />\\n\"\n                                           \"<pre>\\n\",\n                                           ap_escape_html(r->pool, field),\n                                           \"</pre>\\n\", NULL));\n            }\n            return;\n        }\n        rv = process_request_line(r, field, 1);\n        if (rv != APR_SUCCESS) {\n            return;\n        }\n        if ((field == NULL) || (*field == '\\0')) {\n            return;\n        }\n    }\n}",
    "predicted": "122,Heap-based Buffer Overflow\n400,Uncontrolled Resource Consumption\n606,Unchecked Input for Loop Condition"
  },
  "httpd_8a001ac43361dbaf6d06e493248375e6193a6e20_0", {
    "ID": "httpd_8a001ac43361dbaf6d06e493248375e6193a6e20_0",
    "UID": "212",
    "code": "void ap_process_async_request(request_rec test_snippet\n{\n    int access_status;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    if (ap_extended_status)\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    access_status = ap_run_quick_handler(r, 0);  \n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == DONE) {\n        \n        access_status = OK;\n    }\n\n    if (access_status == OK) {\n        ap_finalize_request_protocol(r);\n    }\n    else {\n        r->status = HTTP_OK;\n        ap_die(access_status, r);\n    }\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    bb = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);\n    b = ap_bucket_eor_create(r->connection->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n    ap_pass_brigade(r->connection->output_filters, bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    c->cs->state = CONN_STATE_WRITE_COMPLETION;\n    check_pipeline(c);\n    if (ap_extended_status)\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n416,Use After Free"
  },
  "httpd_d28a839a8d11136ab95e18cac283b0a48d5685c7_0", {
    "ID": "httpd_d28a839a8d11136ab95e18cac283b0a48d5685c7_0",
    "UID": "213",
    "code": "AP_DECLARE(const char *) ap_get_remote_host(conn_rec *conn, void test_snippet\n                                            int type, int *str_is_ip)\n{\n    int hostname_lookups;\n    int ignored_str_is_ip;\n\n    if (!str_is_ip) { \n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n\n    \n    if (dir_config) {\n        hostname_lookups =\n            ((core_dir_config *)ap_get_module_config(dir_config, &core_module))\n            ->hostname_lookups;\n\n        if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n            hostname_lookups = HOSTNAME_LOOKUP_OFF;\n        }\n    }\n    else {\n        \n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n\n    if (type != REMOTE_NOLOOKUP\n        && conn->remote_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n\n        if (apr_getnameinfo(&conn->remote_host, conn->remote_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(conn->remote_host);\n\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                do_double_reverse(conn);\n                if (conn->double_reverse != 1) {\n                    conn->remote_host = NULL;\n                }\n            }\n        }\n\n        \n        if (conn->remote_host == NULL) {\n            conn->remote_host = \"\";\n        }\n    }\n\n    if (type == REMOTE_DOUBLE_REV) {\n        do_double_reverse(conn);\n        if (conn->double_reverse == -1) {\n            return NULL;\n        }\n    }\n\n    /*\n     * Return the desired information; either the remote DNS name, if found,\n     * or either NULL (if the hostname was requested) or the IP address\n     * (if any identifier was requested).\n     */\n    if (conn->remote_host != NULL && conn->remote_host[0] != '\\0') {\n        return conn->remote_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return conn->remote_ip;\n        }\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_6a270004f07b07ea4fcf7759c91dd8f23ee24ea4_0", {
    "ID": "httpd_6a270004f07b07ea4fcf7759c91dd8f23ee24ea4_0",
    "UID": "216",
    "code": "static void end_output_stream(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    ap_pass_brigade(r->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c0b637320a35da3f62a21d5b83fbe052d965d64a_0", {
    "ID": "httpd_c0b637320a35da3f62a21d5b83fbe052d965d64a_0",
    "UID": "219",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) test_snippet\n    ap_filter_t *f,\n    apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    struct content_length_ctx *ctx;\n    apr_bucket *e;\n    int eos = 0;\n    apr_read_type_e eblock = APR_NONBLOCK_READ;\n\n    ctx = f->ctx;\n    if (!ctx) {\n        f->ctx = ctx = apr_palloc(r->pool, sizeof(*ctx));\n        ctx->data_sent = 0;\n    }\n\n    /* Loop through this set of buckets to compute their length\n     */\n    e = APR_BRIGADE_FIRST(b);\n    while (e != APR_BRIGADE_SENTINEL(b)) {\n        if (APR_BUCKET_IS_EOS(e)) {\n            eos = 1;\n            break;\n        }\n        if (e->length == (apr_size_t)-1) {\n            apr_size_t len;\n            const char *ignored;\n            apr_status_t rv;\n\n            /* This is probably a pipe bucket.  Send everything\n             * prior to this, and then read the data for this bucket.\n             */\n            rv = apr_bucket_read(e, &ignored, &len, eblock);\n            if (rv == APR_SUCCESS) {\n                \n                eblock = APR_NONBLOCK_READ;\n                r->bytes_sent += len;\n            }\n            else if (APR_STATUS_IS_EAGAIN(rv)) {\n                /* Output everything prior to this bucket, and then\n                 * do a blocking read on the next batch.\n                 */\n                if (e != APR_BRIGADE_FIRST(b)) {\n                    apr_bucket_brigade *split = apr_brigade_split(b, e);\n                    apr_bucket *flush = apr_bucket_flush_create(r->connection->bucket_alloc);\n\n                    APR_BRIGADE_INSERT_TAIL(b, flush);\n                    rv = ap_pass_brigade(f->next, b);\n                    if (rv != APR_SUCCESS || f->c->aborted) {\n                        apr_brigade_destroy(split);\n                        return rv;\n                    }\n                    b = split;\n                    e = APR_BRIGADE_FIRST(b);\n\n                    ctx->data_sent = 1;\n                }\n                eblock = APR_BLOCK_READ;\n                continue;\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                              \"ap_content_length_filter: \"\n                              \"apr_bucket_read() failed\");\n                return rv;\n            }\n        }\n        else {\n            r->bytes_sent += e->length;\n        }\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    /* If we've now seen the entire response and it's otherwise\n     * okay to set the C-L in the response header, then do so now.\n     *\n     * We can only set a C-L in the response header if we haven't already\n     * sent any buckets on to the next output filter for this request.\n     */\n    if (ctx->data_sent == 0 && eos &&\n        /* don't whack the C-L if it has already been set for a HEAD\n         * by something like proxy.  the brigade only has an EOS bucket\n         * in this case, making r->bytes_sent zero.\n         *\n         * if r->bytes_sent > 0 we have a (temporary) body whose length may\n         * have been changed by a filter.  the C-L header might not have been\n         * updated so we do it here.  long term it would be cleaner to have\n         * such filters update or remove the C-L header, and just use it\n         * if present.\n         */\n        !(r->header_only && r->bytes_sent == 0 &&\n            apr_table_get(r->headers_out, \"Content-Length\"))) {\n        ap_set_content_length(r, r->bytes_sent);\n    }\n\n    ctx->data_sent = 1;\n    return ap_pass_brigade(f->next, b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_3bca42ac80f9fa72c07df096d3f9b48e1e2230f6_0", {
    "ID": "httpd_3bca42ac80f9fa72c07df096d3f9b48e1e2230f6_0",
    "UID": "221",
    "code": "static void set_the_request(request_rec *r, char test_snippet\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n    int major = 1, minor = 0;   \n    char http[5];\n    apr_size_t len;\n    apr_socket_t *csd;\n\n    r->request_time = apr_time_now();\n    ll = r->the_request = line;\n    r->method = ap_getword_white(r->pool, &ll);\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    \n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    \n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n             && (strcasecmp(\"http\", http) == 0)\n             && (minor < HTTP_VERSION(1, 0)) ) { \n        r->proto_num = HTTP_VERSION(major, minor);\n    }\n    else {\n        r->proto_num = HTTP_VERSION(1, 0);\n    }\n\n    /* We may have been in keep_alive_timeout mode, so toggle back\n     * to the normal timeout mode as we fetch the header lines,\n     * as necessary.\n     */\n    csd = ap_get_module_config(r->connection->conn_config, &core_module);\n    apr_socket_timeout_set(csd, r->connection->base_server->timeout);\n\n    return;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_8eaf1d84e6485dacfbfa53c672a2ad41e5cb01af_0", {
    "ID": "httpd_8eaf1d84e6485dacfbfa53c672a2ad41e5cb01af_0",
    "UID": "223",
    "code": "static apr_status_t set_mime_header(request_rec *r, char test_snippet\n{\n    char *value, *tmp_field;\n\n    if (r->server->limit_req_fields) {\n        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);\n        if (mime_headers->nelts >= r->server->limit_req_fields) {\n            apr_table_setn(r->notes, \"error-notes\",\n                           \"The number of request header fields \"\n                           \"exceeds this server's limit.\");\n            r->status = HTTP_BAD_REQUEST;\n            return APR_ENOSPC;\n        }\n    }\n    \n    if (!(value = strchr(line, ':'))) { \n        r->status = HTTP_BAD_REQUEST;      \n        apr_table_setn(r->notes, \"error-notes\",\n                       apr_pstrcat(r->pool,\n                                   \"Request header field is \"\n                                   \"missing ':' separator.<br />\\n\"\n                                   \"<pre>\\n\",\n                                   ap_escape_html(r->pool, line),\n                                   \"</pre>\\n\", NULL));\n        return APR_EGENERAL;\n    }\n\n    tmp_field = value - 1; \n\n    *value++ = '\\0'; \n\n    while (*value == ' ' || *value == '\\t') {\n        ++value;            \n    }\n\n    \n    while (tmp_field > line\n           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n        *tmp_field-- = '\\0';\n    }\n\n    \n    tmp_field = strchr(value, '\\0') - 1;\n    while (tmp_field > value\n           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n        *tmp_field-- = '\\0';\n    }\n\n    apr_table_addn(r->headers_in, line, value);\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n20,Improper Input Validation"
  },
  "httpd_368e497bc7c3ba724364b3674976fab4040fc11f_0", {
    "ID": "httpd_368e497bc7c3ba724364b3674976fab4040fc11f_0",
    "UID": "225",
    "code": "static apr_status_t process_request_line(request_rec *r, char test_snippet\n                                         int skip_first)\n{\n    if (!skip_first && (r->the_request == NULL)) {\n        \n        if ((line == NULL) || (*line == '\\0')) {\n            /* We skip empty lines because browsers have to tack a CRLF on to the end\n             * of POSTs to support old CERN webservers.\n             */\n            int max_blank_lines = r->server->limit_req_fields;\n            if (max_blank_lines <= 0) {\n                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;\n            }\n            r->num_blank_lines++;\n            if (r->num_blank_lines < max_blank_lines) {\n                return APR_SUCCESS;\n            }\n        }\n        set_the_request(r, line);\n    }\n    else {\n        /* We've already read the first line of the request.  This is either\n         * a header field or the blank line terminating the header\n         */\n        if ((line == NULL) || (*line == '\\0')) {\n            if (r->pending_header_line != NULL) {\n                apr_status_t rv = set_mime_header(r, r->pending_header_line);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                r->pending_header_line = NULL;\n            }\n            if (r->status == HTTP_REQUEST_TIME_OUT) {\n                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n                r->status = HTTP_OK;\n            }\n        }\n        else {\n            if ((*line == ' ') || (*line == '\\t')) {\n                \n                if (r->pending_header_line == NULL) {\n                    r->pending_header_line = line;\n                    r->pending_header_size = 0;\n                }\n                else {\n                    apr_size_t pending_len = strlen(r->pending_header_line);\n                    apr_size_t fold_len = strlen(line);\n                    if (pending_len + fold_len >\n                        r->server->limit_req_fieldsize) {\n                        \n                        r->status = HTTP_BAD_REQUEST;\n                        return APR_ENOSPC;\n                    }\n                    if (pending_len + fold_len + 1 > r->pending_header_size) {\n                        /* Allocate a new buffer big enough to hold the\n                         * concatenated lines\n                         */\n                        apr_size_t new_size = r->pending_header_size;\n                        char *new_buf;\n                        if (new_size == 0) {\n                            new_size = pending_len + fold_len + 1;\n                        }\n                        else {\n                            do {\n                                new_size *= 2;\n                            } while (new_size < pending_len + fold_len + 1);\n                        }\n                        new_buf = (char *)apr_palloc(r->pool, new_size);\n                        memcpy(new_buf, r->pending_header_line, pending_len);\n                        r->pending_header_line = new_buf;\n                        r->pending_header_size = new_size;\n                    }\n                    memcpy(r->pending_header_line + pending_len, line,\n                           fold_len + 1);\n                }\n            }\n            else {\n                /* Set aside this line in case the next line is a continuation\n                 */\n                if (r->pending_header_line != NULL) {\n                    apr_status_t rv = set_mime_header(r, r->pending_header_line);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n                }\n                r->pending_header_line = line;\n                r->pending_header_size = 0;\n            }\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n122,Heap-based Buffer Overflow"
  },
  "httpd_6134a555565023ad6d2adae7ca0b0437707b3040_0", {
    "ID": "httpd_6134a555565023ad6d2adae7ca0b0437707b3040_0",
    "UID": "227",
    "code": "static char *terminate_description(autoindex_config_rec *d, char test_snippet\n                                   apr_int32_t autoindex_opts, int desc_width)\n{\n    int maxsize = desc_width;\n    register int x;\n\n    /*\n     * If there's no DescriptionWidth in effect, default to the old\n     * behaviour of adjusting the description size depending upon\n     * what else is being displayed.  Otherwise, stick with the\n     * setting.\n     */\n    if (d->desc_adjust == K_UNSET) {\n        if (autoindex_opts & SUPPRESS_ICON) {\n            maxsize += 6;\n        }\n        if (autoindex_opts & SUPPRESS_LAST_MOD) {\n            maxsize += 19;\n        }\n        if (autoindex_opts & SUPPRESS_SIZE) {\n            maxsize += 7;\n        }\n    }\n    for (x = 0; desc[x] && ((maxsize > 0) || (desc[x] == '<')); x++) {\n        if (desc[x] == '<') {\n            while (desc[x] != '>') {\n                if (!desc[x]) {\n                    maxsize = 0;\n                    break;\n                }\n                ++x;\n            }\n        }\n        else if (desc[x] == '&') {\n            \n            --maxsize;\n            for ( ; desc[x] != ';'; ++x) {\n                if (desc[x] == '\\0') {\n                     maxsize = 0;\n                     break;\n                }\n            }\n        }\n        else {\n            --maxsize;\n        }\n    }\n    if (!maxsize && desc[x] != '\\0') {\n        desc[x - 1] = '>';      \n        desc[x] = '\\0';         \n    }\n    return desc;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n476,NULL Pointer Dereference"
  },
  "httpd_3031948279468f05e50809c419a85c60dfaf7e5e_0", {
    "ID": "httpd_3031948279468f05e50809c419a85c60dfaf7e5e_0",
    "UID": "230",
    "code": "static request_rec *request_post_read(request_rec *r, conn_rec test_snippet\n{\n    apr_socket_t *csd;\n    const char *expect;\n    int access_status;\n\n    r->status = HTTP_OK;                         \n\n    /* update what we think the virtual host is based on the headers we've\n     * now read. may update status.\n     */\n    ap_update_vhost_from_headers(r);\n\n    /* Toggle to the Host:-based vhost's timeout mode to fetch the\n     * request body and send the response body, if needed.\n     */\n    csd = ap_get_module_config(conn->conn_config, &core_module);\n    apr_socket_timeout_set(csd, r->server->timeout);\n\n    if (apr_table_get(r->headers_in, \"Transfer-Encoding\") &&\n        apr_table_get(r->headers_in, \"Content-Length\")) {\n        /* 2616 section 4.4, point 3: \"if both Transfer-Encoding\n         * and Content-Length are received, the latter MUST be\n         * ignored\"; so unset it here to prevent any confusion\n         * later.\n         */\n        apr_table_unset(r->headers_in, \"Content-Length\");\n    }\n\n    \n    r->per_dir_config = r->server->lookup_defaults;\n\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        /*\n         * Client sent us an HTTP/1.1 or later request without telling us the\n         * hostname, either with a full URL or a Host: header. We therefore\n         * need to (as per the 1.1 spec) send an error.  As a special case,\n         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain\n         * a Host: header, and the server MUST respond with 400 if it doesn't.\n         */\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n    }\n\n    if (r->status != HTTP_OK) {\n        ap_send_error_response(r, 0);\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        return r;\n    }\n\n    if ((access_status = ap_run_post_read_request(r))) {\n        ap_add_input_filter_handle(ap_http_input_filter_handle,\n                                   NULL, r, r->connection);\n        ap_die(access_status, r);\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        return NULL;\n    }\n\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        /*\n         * The Expect header field was added to HTTP/1.1 after RFC 2068\n         * as a means to signal when a 100 response is desired and,\n         * unfortunately, to signal a poor man's mandatory extension that\n         * the server must understand or return 417 Expectation Failed.\n         */\n        if (strcasecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            r->status = HTTP_EXPECTATION_FAILED;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                          \"client sent an unrecognized expectation value of \"\n                          \"Expect: %s\", expect);\n            ap_send_error_response(r, 0);\n            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);\n            ap_run_log_transaction(r);\n            return r;\n        }\n    }\n\n    ap_add_input_filter_handle(ap_http_input_filter_handle,\n                               NULL, r, r->connection);\n    return r;\n}",
    "predicted": "The code provided does not seem to have any obvious vulnerabilities based on the categories provided. The function appears to handle HTTP requests and properly checks for certain conditions, such as the presence of a hostname in the request and the \"Expect\" header. It also handles errors appropriately by sending an error response and logging the transaction. Therefore, the response is:\n\nnull"
  },
  "httpd_de94b1532564fdacae6e1327c68c765d900bef21_0", {
    "ID": "httpd_de94b1532564fdacae6e1327c68c765d900bef21_0",
    "UID": "240",
    "code": "static apr_status_t read_partial_request(request_rec *r) test_snippet\n    apr_bucket_brigade *tmp_bb;\n    apr_status_t rv = APR_SUCCESS;\n\n    /* Read and process lines of the request until we\n     * encounter a complete request header, an error, or EAGAIN\n     */\n    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    while (r->status == HTTP_REQUEST_TIME_OUT) test_snippet\n        char *line = NULL;\n        apr_size_t line_length;\n        apr_size_t length_limit;\n        int first_line = (r->the_request == NULL);\n        if (first_line) test_snippet\n            length_limit = r->server->limit_req_line;\n        }\n        else test_snippet\n            if (r->assbackwards) test_snippet\n                r->status = HTTP_OK;\n                break;\n            }\n            length_limit = r->server->limit_req_fieldsize;\n        }\n        \n        rv = ap_rgetline(&line, length_limit + 2,\n                         &line_length, r, 0, tmp_bb);\n        if (rv == APR_SUCCESS) test_snippet\n            rv = process_request_line(r, line, 0);\n        }\n        if (rv != APR_SUCCESS) test_snippet\n            r->request_time = apr_time_now();\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (rv == APR_ENOSPC) test_snippet\n                if (first_line) test_snippet\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"request failed: URI too long (longer than %d)\",\n                                  r->server->limit_req_line);\n                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n                    r->proto_num = HTTP_VERSION(1,0);\n                    r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n                }\n                else test_snippet\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"request failed: header line too long \"\n                                  \"(longer than %d)\",\n                                  r->server->limit_req_fieldsize);\n                    r->status = HTTP_BAD_REQUEST;\n                }\n            }\n            break;\n        }\n    }\n    apr_brigade_destroy(tmp_bb);\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5b3709167f06be729c2ed2d76b92dada167be4f3_0", {
    "ID": "httpd_5b3709167f06be729c2ed2d76b92dada167be4f3_0",
    "UID": "242",
    "code": "static char *make_allow(request_rec test_snippet\n{\n    char *list;\n    apr_int64_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    \n    core_server_config *conf =\n        ap_get_module_config(r->server->module_config, &core_module);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            *(const char **)apr_array_push(allow) = key;\n\n            \n            if (*(int *)val == M_GET)\n                *(const char **)apr_array_push(allow) = \"HEAD\";\n        }\n    }\n\n    \n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    list = apr_array_pstrcat(r->pool, allow, ',');\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        int i;\n        char **xmethod = (char **) r->allowed_methods->method_list->elts;\n\n        /*\n         * Append all of the elements of r->allowed_methods->method_list\n         */\n        for (i = 0; i < r->allowed_methods->method_list->nelts; ++i) {\n            list = apr_pstrcat(r->pool, list, \",\", xmethod[i], NULL);\n        }\n    }\n\n    return list;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_06742c475fd2265ff6511e2911f4089fb3eb9dd5_0", {
    "ID": "httpd_06742c475fd2265ff6511e2911f4089fb3eb9dd5_0",
    "UID": "245",
    "code": "request_rec *ap_read_request(conn_rec test_snippet\n{\n    request_rec *r;\n    apr_status_t rv;\n\n    r = init_request(conn);\n\n    rv = read_partial_request(r);\n    \n    if (r->status != HTTP_OK) {\n        ap_send_error_response(r, 0);\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        return NULL;\n    }\n\n    if (r->assbackwards && r->header_only) {\n        /*\n         * Client asked for headers only with HTTP/0.9, which doesn't send\n         * headers! Have to dink things just to make sure the error message\n         * comes through...\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"client sent invalid HTTP/0.9 request: HEAD %s\",\n                      r->uri);\n        r->header_only = 0;\n        r->status = HTTP_BAD_REQUEST;\n        ap_send_error_response(r, 0);\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        return r;\n    }\n\n    return request_post_read(r, conn);\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2f29b44a4d637220adc2510ba8068c8bdcd394b5_0", {
    "ID": "httpd_2f29b44a4d637220adc2510ba8068c8bdcd394b5_0",
    "UID": "248",
    "code": "apr_status_t ap_http_outerror_filter(ap_filter_t test_snippet\n                                     apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    apr_bucket *e;\n\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (AP_BUCKET_IS_ERROR(e)) {\n            /*\n             * Start of error handling state tree. Just one condition\n             * right now :)\n             */\n            if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY) {\n                \n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n        }\n    }\n\n    return ap_pass_brigade(f->next,  b);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_af55b635e15c0e33c0222f7710c5bdc510a57793_0", {
    "ID": "httpd_af55b635e15c0e33c0222f7710c5bdc510a57793_0",
    "UID": "249",
    "code": "AP_DECLARE(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec test_snippet\n                                    apr_off_t offset, apr_size_t len,\n                                    apr_size_t *nbytes)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb = NULL;\n    apr_bucket *b;\n    apr_status_t rv;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = apr_bucket_file_create(fd, offset, len, r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    rv = ap_pass_brigade(r->output_filters, bb);\n    if (rv != APR_SUCCESS) {\n        *nbytes = 0; \n    }\n    else {\n        *nbytes = len;\n    }\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_eea9dfc0705c1aea85eed4db1038573053a69eb2_0", {
    "ID": "httpd_eea9dfc0705c1aea85eed4db1038573053a69eb2_0",
    "UID": "262",
    "code": "AP_CORE_DECLARE(void) ap_flush_conn(conn_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(c->pool, c->bucket_alloc);\n\n    \n    b = apr_bucket_flush_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    \n    b = ap_bucket_eoc_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    ap_pass_brigade(c->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_eb23b687e0e0d220b9ec43e08da1691883e488d0_0", {
    "ID": "httpd_eb23b687e0e0d220b9ec43e08da1691883e488d0_0",
    "UID": "273",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t test_snippet\n                                                         apr_bucket_brigade *bb)\n{\n#define MIN_LENGTH(len1, len2) ((len1 > len2) ? len2 : len1)\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    byterange_ctx *ctx = f->ctx;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    char *current;\n    apr_off_t bb_length;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n\n    if (!ctx) {\n        int num_ranges = ap_set_byterange(r);\n\n        \n        if (num_ranges == 0) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ctx->num_ranges = num_ranges;\n        \n        ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n        if (ctx->num_ranges > 1) {\n            \n            const char *orig_ct = ap_make_content_type(r, r->content_type);\n            ctx->boundary = apr_psprintf(r->pool, \"%\" APR_UINT64_T_HEX_FMT \"%lx\",\n                                         (apr_uint64_t)r->request_time, (long) getpid());\n\n            ap_set_content_type(r, apr_pstrcat(r->pool, \"multipart\",\n                                               use_range_x(r) ? \"/x-\" : \"/\",\n                                               \"byteranges; boundary=\",\n                                               ctx->boundary, NULL));\n\n            ctx->bound_head = apr_pstrcat(r->pool,\n                                    CRLF \"--\", ctx->boundary,\n                                    CRLF \"Content-type: \",\n                                    orig_ct,\n                                    CRLF \"Content-range: bytes \",\n                                    NULL);\n            ap_xlate_proto_to_ascii(ctx->bound_head, strlen(ctx->bound_head));\n        }\n    }\n\n    /* We can't actually deal with byte-ranges until we have the whole brigade\n     * because the byte-ranges can be in any order, and according to the RFC,\n     * we SHOULD return the data in the same order it was requested.\n     *\n     * XXX: We really need to dump all bytes prior to the start of the earliest\n     * range, and only slurp up to the end of the latest range.  By this we\n     * mean that we should peek-ahead at the lowest first byte of any range,\n     * and the highest last byte of any range.\n     */\n    if (!APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        ap_save_brigade(f, &ctx->bb, &bb, r->pool);\n        return APR_SUCCESS;\n    }\n\n    \n    APR_BRIGADE_PREPEND(bb, ctx->bb);\n\n    /* It is possible that we won't have a content length yet, so we have to\n     * compute the length before we can actually do the byterange work.\n     */\n    apr_brigade_length(bb, 1, &bb_length);\n    clength = (apr_off_t)bb_length;\n\n    \n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    while ((current = ap_getword(r->pool, &r->range, ','))\n           && (rv = parse_byterange(current, clength, &range_start,\n                                    &range_end))) {\n        apr_bucket *e2;\n        apr_bucket *ec;\n\n        if (rv == -1) {\n            continue;\n        }\n\n        /* these calls to apr_brigade_partition() should theoretically\n         * never fail because of the above call to apr_brigade_length(),\n         * but what the heck, we'll check for an error anyway */\n        if ((rv = apr_brigade_partition(bb, range_start, &ec)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          PARTITION_ERR_FMT, range_start, clength);\n            continue;\n        }\n        if ((rv = apr_brigade_partition(bb, range_end+1, &e2)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          PARTITION_ERR_FMT, range_end+1, clength);\n            continue;\n        }\n\n        found = 1;\n\n        /* For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (ctx->num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(ctx->bound_head, strlen(ctx->bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        do {\n            apr_bucket *foo;\n            const char *str;\n            apr_size_t len;\n\n            if (apr_bucket_copy(ec, &foo) != APR_SUCCESS) {\n                /* this shouldn't ever happen due to the call to\n                 * apr_brigade_length() above which normalizes\n                 * indeterminate-length buckets.  just to be sure,\n                 * though, this takes care of uncopyable buckets that\n                 * do somehow manage to slip through.\n                 */\n                \n                apr_bucket_read(ec, &str, &len, APR_BLOCK_READ);\n                apr_bucket_copy(ec, &foo);\n            }\n            APR_BRIGADE_INSERT_TAIL(bsend, foo);\n            ec = APR_BUCKET_NEXT(ec);\n        } while (ec != e2);\n    }\n\n    if (found == 0) {\n        ap_remove_output_filter(f);\n        r->status = HTTP_OK;\n        \n        e = ap_bucket_error_create(HTTP_RANGE_NOT_SATISFIABLE, NULL,\n                                   r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n        return ap_pass_brigade(f->next, bsend);\n    }\n\n    if (ctx->num_ranges > 1) {\n        char *end;\n\n        \n        end = apr_pstrcat(r->pool, CRLF \"--\", ctx->boundary, \"--\" CRLF, NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    \n    apr_brigade_destroy(bb);\n\n    \n    return ap_pass_brigade(f->next, bsend);\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n"
  },
  "httpd_1dd50481b5772f4dd200bb411d18a366fc09667c_0", {
    "ID": "httpd_1dd50481b5772f4dd200bb411d18a366fc09667c_0",
    "UID": "276",
    "code": "static void check_pipeline_flush(request_rec test_snippet\n{\n    apr_bucket *e;\n    apr_bucket_brigade *bb;\n    conn_rec *c = r->connection;\n    /* ### if would be nice if we could PEEK without a brigade. that would\n       ### allow us to defer creation of the brigade to when we actually\n       ### need to send a FLUSH. */\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    /* Flush the filter contents if:\n     *\n     *   1) the connection will be closed\n     *   2) there isn't a request ready to be read\n     */\n    \n    \n    if (r->connection->keepalive != AP_CONN_CLOSE) {\n        if (ap_get_brigade(r->input_filters, bb, AP_MODE_EATCRLF, \n                       APR_NONBLOCK_READ, 0) != APR_SUCCESS) {\n            c->data_in_input_filters = 0;  \n        }\n        else {\n            c->data_in_input_filters = 1;\n            return;    \n        }\n    }\n\n        e = apr_bucket_flush_create(c->bucket_alloc);\n\n        /* We just send directly to the connection based filters.  At\n         * this point, we know that we have seen all of the data\n         * (request finalization sent an EOS bucket, which empties all\n         * of the request filters). We just want to flush the buckets\n         * if something hasn't been sent to the network yet.\n         */\n        APR_BRIGADE_INSERT_HEAD(bb, e);\n        ap_pass_brigade(r->connection->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_df430f4be4899609cb8c89a3bdf34e2c3e29e5dd_0", {
    "ID": "httpd_df430f4be4899609cb8c89a3bdf34e2c3e29e5dd_0",
    "UID": "281",
    "code": "static int process_dir(char *path, apr_pool_t test_snippet\n{\n    apr_dir_t *dir;\n    apr_pool_t *p;\n    apr_hash_t *h;\n    apr_hash_index_t *i;\n    apr_file_t *fd;\n    apr_status_t status;\n    apr_finfo_t info;\n    apr_size_t len;\n    apr_time_t current, deviation;\n    char *nextpath, *base, *ext;\n    APR_RING_ENTRY(_direntry) anchor;\n    DIRENTRY *d, *t, *n;\n    ENTRY *e;\n    int skip, retries;\n    disk_cache_info_t disk_info;\n\n    APR_RING_INIT(&anchor, _direntry, link);\n    apr_pool_create(&p, pool);\n    h = apr_hash_make(p);\n    fd = NULL;\n    skip = 0;\n    deviation = MAXDEVIATION * APR_USEC_PER_SEC;\n\n    if (apr_dir_open(&dir, path, p) != APR_SUCCESS) {\n        return 1;\n    }\n\n    while (apr_dir_read(&info, 0, dir) == APR_SUCCESS && !interrupted) {\n        if (!strcmp(info.name, \".\") || !strcmp(info.name, \"..\")) {\n            continue;\n        }\n        d = apr_pcalloc(p, sizeof(DIRENTRY));\n        d->basename = apr_pstrcat(p, path, \"/\", info.name, NULL);\n        APR_RING_INSERT_TAIL(&anchor, d, _direntry, link);\n    }\n\n    apr_dir_close(dir);\n\n    if (interrupted) {\n        return 1;\n    }\n\n    skip = baselen + 1;\n\n    for (d = APR_RING_FIRST(&anchor);\n         !interrupted && d != APR_RING_SENTINEL(&anchor, _direntry, link);\n         d=n) {\n        n = APR_RING_NEXT(d, link);\n        base = strrchr(d->basename, '/');\n        if (!base++) {\n            base = d->basename;\n        }\n        ext = strchr(base, '.');\n\n        /* there may be temporary files which may be gone before\n         * processing, always skip these if not in realclean mode\n         */\n        if (!ext && !realclean) {\n            if (!strncasecmp(base, AP_TEMPFILE_BASE, AP_TEMPFILE_BASELEN)\n                && strlen(base) == AP_TEMPFILE_NAMELEN) {\n                continue;\n            }\n        }\n\n        /* this may look strange but apr_stat() may return errno which\n         * is system dependent and there may be transient failures,\n         * so just blindly retry for a short while\n         */\n        retries = STAT_ATTEMPTS;\n        status = APR_SUCCESS;\n        do {\n            if (status != APR_SUCCESS) {\n                apr_sleep(STAT_DELAY);\n            }\n            status = apr_stat(&info, d->basename, DIRINFO, p);\n        } while (status != APR_SUCCESS && !interrupted && --retries);\n\n        /* what may happen here is that apache did create a file which\n         * we did detect but then does delete the file before we can\n         * get file information, so if we don't get any file information\n         * we will ignore the file in this case\n         */\n        if (status != APR_SUCCESS) {\n            if (!realclean && !interrupted) {\n                continue;\n            }\n            return 1;\n        }\n\n        if (info.filetype == APR_DIR) {\n            if (process_dir(d->basename, pool)) {\n                return 1;\n            }\n            continue;\n        }\n\n        if (info.filetype != APR_REG) {\n            continue;\n        }\n\n        if (!ext) {\n            if (!strncasecmp(base, AP_TEMPFILE_BASE, AP_TEMPFILE_BASELEN)\n                && strlen(base) == AP_TEMPFILE_NAMELEN) {\n                d->basename += skip;\n                d->type = TEMP;\n                d->dsize = info.size;\n                apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n            }\n            continue;\n        }\n\n        if (!strcasecmp(ext, CACHE_HEADER_SUFFIX)) {\n            *ext = '\\0';\n            d->basename += skip;\n            \n            if (d->basename[0] == '\\0') {\n                continue;\n            }\n            t = apr_hash_get(h, d->basename, APR_HASH_KEY_STRING);\n            if (t) {\n                d = t;\n            }\n            d->type |= HEADER;\n            d->htime = info.mtime;\n            d->hsize = info.size;\n            apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n            continue;\n        }\n\n        if (!strcasecmp(ext, CACHE_DATA_SUFFIX)) {\n            *ext = '\\0';\n            d->basename += skip;\n            \n            if (d->basename[0] == '\\0') {\n                continue;\n            }\n            t = apr_hash_get(h, d->basename, APR_HASH_KEY_STRING);\n            if (t) {\n                d = t;\n            }\n            d->type |= DATA;\n            d->dtime = info.mtime;\n            d->dsize = info.size;\n            apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n        }\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    path[baselen] = '\\0';\n\n    for (i = apr_hash_first(p, h); i && !interrupted; i = apr_hash_next(i)) {\n        void *hvalue;\n\n        apr_hash_this(i, NULL, NULL, &hvalue);\n        d = hvalue;\n\n        switch(d->type) {\n        case HEADERDATA:\n            nextpath = apr_pstrcat(p, path, \"/\", d->basename,\n                                   CACHE_HEADER_SUFFIX, NULL);\n            if (apr_file_open(&fd, nextpath, APR_READ, APR_OS_DEFAULT,\n                              p) == APR_SUCCESS) {\n                len = sizeof(disk_cache_info_t);\n                if (apr_file_read_full(fd, &disk_info, len,\n                                       &len) == APR_SUCCESS) {\n                    apr_file_close(fd);\n                    if (disk_info.format == DISK_FORMAT_VERSION) {\n                        e = apr_palloc(pool, sizeof(ENTRY));\n                        APR_RING_INSERT_TAIL(&root, e, _entry, link);\n                        e->expire = disk_info.expire;\n                        e->response_time = disk_info.response_time;\n                        e->htime = d->htime;\n                        e->dtime = d->dtime;\n                        e->hsize = d->hsize;\n                        e->dsize = d->dsize;\n                        e->basename = apr_palloc(pool,\n                                                 strlen(d->basename) + 1);\n                        strcpy(e->basename, d->basename);\n                        break;\n                    }\n                }\n                else {\n                    apr_file_close(fd);\n                }\n            }\n            /* we have a somehow unreadable headers file which is associated\n             * with a data file. this may be caused by apache currently\n             * rewriting the headers file. thus we may delete the file set\n             * either in realclean mode or if the headers file modification\n             * timestamp is not within a specified positive or negative offset\n             * to the current time.\n             */\n            current = apr_time_now();\n            if (realclean || d->htime < current - deviation\n                || d->htime > current + deviation) {\n                delete_entry(path, d->basename, p);\n                unsolicited += d->hsize;\n                unsolicited += d->dsize;\n            }\n            break;\n\n        /* single data and header files may be deleted either in realclean\n         * mode or if their modification timestamp is not within a\n         * specified positive or negative offset to the current time.\n         * this handling is necessary due to possible race conditions\n         * between apache and this process\n         */\n        case HEADER:\n            current = apr_time_now();\n            if (realclean || d->htime < current - deviation\n                || d->htime > current + deviation) {\n                delete_entry(path, d->basename, p);\n                unsolicited += d->hsize;\n            }\n            break;\n\n        case DATA:\n            current = apr_time_now();\n            if (realclean || d->dtime < current - deviation\n                || d->dtime > current + deviation) {\n                delete_entry(path, d->basename, p);\n                unsolicited += d->dsize;\n            }\n            break;\n\n        /* temp files may only be deleted in realclean mode which\n         * is asserted above if a tempfile is in the hash array\n         */\n        case TEMP:\n            delete_file(path, d->basename, p);\n            unsolicited += d->dsize;\n            break;\n        }\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    apr_pool_destroy(p);\n\n    if (benice) {\n        apr_sleep(NICE_DELAY);\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_496377cd513ed388fb10f8700036e8a03306b906_0", {
    "ID": "httpd_496377cd513ed388fb10f8700036e8a03306b906_0",
    "UID": "284",
    "code": "AP_DECLARE(apr_status_t) ap_fflush(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    apr_bucket *b;\n\n    b = apr_bucket_flush_create(f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    return ap_pass_brigade(f, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2dddfca606cbdacfb9530c7f6ab61c546b603edd_0", {
    "ID": "httpd_2dddfca606cbdacfb9530c7f6ab61c546b603edd_0",
    "UID": "286",
    "code": "static char *ap_ssi_parse_string(include_ctx_t *ctx, const char *in, char test_snippet\n                                 apr_size_t length, int leave_name)\n{\n    request_rec *r = ctx->intern->r;\n    result_item_t *result = NULL, *current = NULL;\n    apr_size_t outlen = 0, inlen, span;\n    char *ret = NULL, *eout = NULL;\n    const char *p;\n\n    if (out) {\n        \n        ap_assert(out && length);\n\n        ret = out;\n        eout = out + length - 1;\n    }\n\n    span = strcspn(in, \"\\\\$\");\n    inlen = strlen(in);\n\n    \n    if (inlen == span) {\n        if (out) {\n            apr_cpystrn(out, in, length);\n        }\n        else {\n            ret = apr_pstrmemdup(ctx->pool, in, (length && length <= inlen)\n                                                ? length - 1 : inlen);\n        }\n\n        return ret;\n    }\n\n    \n    p = in + span;\n\n    if (out) {\n        if (span) {\n            memcpy(out, in, (out+span <= eout) ? span : (eout-out));\n            out += span;\n        }\n    }\n    else {\n        current = result = apr_palloc(ctx->dpool, sizeof(*result));\n        current->next = NULL;\n        current->string = in;\n        current->len = span;\n        outlen = span;\n    }\n\n    \n    do {\n        if ((out && out >= eout) || (length && outlen >= length)) {\n            break;\n        }\n\n        \n        if (!out && current->len) {\n            current->next = apr_palloc(ctx->dpool, sizeof(*current->next));\n            current = current->next;\n            current->next = NULL;\n            current->len = 0;\n        }\n\n        /*\n         * escaped character\n         */\n        if (*p == '\\\\') {\n            if (out) {\n                *out++ = (p[1] == '$') ? *++p : *p;\n                ++p;\n            }\n            else {\n                current->len = 1;\n                current->string = (p[1] == '$') ? ++p : p;\n                ++p;\n                ++outlen;\n            }\n        }\n\n        /*\n         * variable expansion\n         */\n        else {       \n            const char *newp = NULL, *ep, *key = NULL;\n\n            if (*++p == '{') {\n                ep = ap_strchr_c(++p, '}');\n                if (!ep) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"Missing '}' on \"\n                                  \"variable \\\"%s\\\" in %s\", p, r->filename);\n                    break;\n                }\n\n                if (p < ep) {\n                    key = apr_pstrmemdup(ctx->dpool, p, ep - p);\n                    newp = ep + 1;\n                }\n                p -= 2;\n            }\n            else {\n                ep = p;\n                while (*ep == '_' || apr_isalnum(*ep)) {\n                    ++ep;\n                }\n\n                if (p < ep) {\n                    key = apr_pstrmemdup(ctx->dpool, p, ep - p);\n                    newp = ep;\n                }\n                --p;\n            }\n\n            \n            if (!key) {\n                if (out) {\n                    *out++ = *p++;\n                }\n                else {\n                    current->len = 1;\n                    current->string = p++;\n                    ++outlen;\n                }\n            }\n            else {\n                const char *val = get_include_var(key, ctx);\n                apr_size_t len = 0;\n\n                if (val) {\n                    len = strlen(val);\n                }\n                else if (leave_name) {\n                    val = p;\n                    len = ep - p;\n                }\n\n                if (val && len) {\n                    if (out) {\n                        memcpy(out, val, (out+len <= eout) ? len : (eout-out));\n                        out += len;\n                    }\n                    else {\n                        current->len = len;\n                        current->string = val;\n                        outlen += len;\n                    }\n                }\n\n                p = newp;\n            }\n        }\n\n        if ((out && out >= eout) || (length && outlen >= length)) {\n            break;\n        }\n\n        \n        if (*p && (span = strcspn(p, \"\\\\$\")) > 0) {\n            if (!out && current->len) {\n                current->next = apr_palloc(ctx->dpool, sizeof(*current->next));\n                current = current->next;\n                current->next = NULL;\n            }\n\n            if (out) {\n                memcpy(out, p, (out+span <= eout) ? span : (eout-out));\n                out += span;\n            }\n            else {\n                current->len = span;\n                current->string = p;\n                outlen += span;\n            }\n\n            p += span;\n        }\n    } while (p < in+inlen);\n\n    \n    if (out) {\n        if (out > eout) {\n            *eout = '\\0';\n        }\n        else {\n            *out = '\\0';\n        }\n    }\n    else {\n        const char *ep;\n\n        if (length && outlen > length) {\n            outlen = length - 1;\n        }\n\n        ret = out = apr_palloc(ctx->pool, outlen + 1);\n        ep = ret + outlen;\n\n        do {\n            if (result->len) {\n                memcpy(out, result->string, (out+result->len <= ep)\n                                            ? result->len : (ep-out));\n                out += result->len;\n            }\n            result = result->next;\n        } while (result && out < ep);\n\n        ret[outlen] = '\\0';\n    }\n\n    return ret;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n190,Integer Overflow or Wraparound\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_5c17b2c5771b11f0d51bbbbcecdba50ff5c72d84_0", {
    "ID": "httpd_5c17b2c5771b11f0d51bbbbcecdba50ff5c72d84_0",
    "UID": "291",
    "code": "static void purge(char *path, apr_pool_t *pool, apr_off_t test_snippet\n{\n    apr_off_t sum, total, entries, etotal;\n    ENTRY *e, *n, *oldest;\n\n    sum = 0;\n    entries = 0;\n\n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link);\n         e = APR_RING_NEXT(e, link)) {\n        sum += e->hsize;\n        sum += e->dsize;\n        entries++;\n    }\n\n    total = sum;\n    etotal = entries;\n\n    if (sum <= test_snippet {\n        printstats(total, sum, max, etotal, entries);\n        return;\n    }\n\n    /* process all entries with a timestamp in the future, this may\n     * happen if a wrong system time is corrected\n     */\n\n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link) && !interrupted;) {\n        n = APR_RING_NEXT(e, link);\n        if (e->response_time > now || e->htime > now || e->dtime > now) {\n            delete_entry(path, e->basename, pool);\n            sum -= e->hsize;\n            sum -= e->dsize;\n            entries--;\n            APR_RING_REMOVE(e, link);\n            if (sum <= test_snippet {\n                if (!interrupted) {\n                    printstats(total, sum, max, etotal, entries);\n                }\n                return;\n            }\n        }\n        e = n;\n    }\n\n    if (interrupted) {\n        return;\n    }\n\n    \n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link) && !interrupted;) {\n        n = APR_RING_NEXT(e, link);\n        if (e->expire != APR_DATE_BAD && e->expire < now) {\n            delete_entry(path, e->basename, pool);\n            sum -= e->hsize;\n            sum -= e->dsize;\n            entries--;\n            APR_RING_REMOVE(e, link);\n            if (sum <= test_snippet {\n                if (!interrupted) {\n                    printstats(total, sum, max, etotal, entries);\n                }\n                return;\n            }\n        }\n        e = n;\n    }\n\n    if (interrupted) {\n         return;\n    }\n\n    /* process remaining entries oldest to newest, the check for an emtpy\n     * ring actually isn't necessary except when the compiler does\n     * corrupt 64bit arithmetics which happend to me once, so better safe\n     * than sorry\n     */\n    while (sum > max && !interrupted && !APR_RING_EMPTY(&root, _entry, link)) {\n        oldest = APR_RING_FIRST(&root);\n\n        for (e = APR_RING_NEXT(oldest, link);\n             e != APR_RING_SENTINEL(&root, _entry, link);\n             e = APR_RING_NEXT(e, link)) {\n            if (e->dtime < oldest->dtime) {\n                oldest = e;\n            }\n        }\n\n        delete_entry(path, oldest->basename, pool);\n        sum -= oldest->hsize;\n        sum -= oldest->dsize;\n        entries--;\n        APR_RING_REMOVE(oldest, link);\n    }\n\n    if (!interrupted) {\n        printstats(total, sum, max, etotal, entries);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_9ecac5b38b2a5b15022e2b38e55db3e10449572b_0", {
    "ID": "httpd_9ecac5b38b2a5b15022e2b38e55db3e10449572b_0",
    "UID": "293",
    "code": "apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    apr_status_t rv;\n    apr_bucket_brigade *more;\n    conn_rec *c = f->c;\n    core_net_rec *net = f->ctx;\n    core_output_filter_ctx_t *ctx = net->out_ctx;\n    apr_read_type_e eblock = APR_NONBLOCK_READ;\n    apr_pool_t *input_pool = b->p;\n\n    if (ctx == NULL) {\n        ctx = apr_pcalloc(c->pool, sizeof(*ctx));\n        net->out_ctx = ctx;\n    }\n\n    \n    if (ctx->b) {\n        APR_BRIGADE_CONCAT(ctx->b, b);\n        b = ctx->b;\n        ctx->b = NULL;\n    }\n\n    /* Perform multiple passes over the brigade, sending batches of output\n       to the connection. */\n    while (b && !APR_BRIGADE_EMPTY(b)) {\n        apr_size_t nbytes = 0;\n        apr_bucket *last_e = NULL; \n        apr_bucket *e;\n\n        \n        apr_size_t nvec = 0;\n        apr_size_t nvec_trailers = 0;\n        struct iovec vec[MAX_IOVEC_TO_WRITE];\n        struct iovec vec_trailers[MAX_IOVEC_TO_WRITE];\n\n        \n        apr_file_t *fd = NULL;\n        apr_size_t flen = 0;\n        apr_off_t foffset = 0;\n\n        /* keep track of buckets that we've concatenated\n         * to avoid small writes\n         */\n        apr_bucket *last_merged_bucket = NULL;\n\n        \n        more = NULL;\n\n        \n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = APR_BUCKET_NEXT(e))\n        {\n            \n            last_e = e;\n            if (APR_BUCKET_IS_EOS(e) || AP_BUCKET_IS_EOC(e)) {\n                break;\n            }\n            else if (APR_BUCKET_IS_FLUSH(e)) {\n                if (e != APR_BRIGADE_LAST(b)) {\n                    more = apr_brigade_split(b, APR_BUCKET_NEXT(e));\n                }\n                break;\n            }\n\n            /* It doesn't make any sense to use sendfile for a file bucket\n             * that represents 10 bytes.\n             */\n            else if (APR_BUCKET_IS_FILE(e)\n                     && (e->length >= AP_MIN_SENDFILE_BYTES)) {\n                apr_bucket_file *a = e->data;\n\n                /* We can't handle more than one file bucket at a time\n                 * so we split here and send the file we have already\n                 * found.\n                 */\n                if (fd) {\n                    more = apr_brigade_split(b, e);\n                    break;\n                }\n\n                fd = a->fd;\n                flen = e->length;\n                foffset = e->start;\n            }\n            else {\n                const char *str;\n                apr_size_t n;\n\n                rv = apr_bucket_read(e, &str, &n, eblock);\n                if (APR_STATUS_IS_EAGAIN(rv)) {\n                    /* send what we have so far since we shouldn't expect more\n                     * output for a while...  next time we read, block\n                     */\n                    more = apr_brigade_split(b, e);\n                    eblock = APR_BLOCK_READ;\n                    break;\n                }\n                eblock = APR_NONBLOCK_READ;\n                if (n) {\n                    if (!fd) {\n                        if (nvec == MAX_IOVEC_TO_WRITE) {\n                            \n                            apr_bucket *temp, *next;\n                            apr_bucket_brigade *temp_brig;\n\n                            if (nbytes >= AP_MIN_BYTES_TO_WRITE) {\n                                /* We have enough data in the iovec\n                                 * to justify doing a writev\n                                 */\n                                more = apr_brigade_split(b, e);\n                                break;\n                            }\n\n                            /* Create a temporary brigade as a means\n                             * of concatenating a bunch of buckets together\n                             */\n                            if (last_merged_bucket) {\n                                /* If we've concatenated together small\n                                 * buckets already in a previous pass,\n                                 * the initial buckets in this brigade\n                                 * are heap buckets that may have extra\n                                 * space left in them (because they\n                                 * were created by apr_brigade_write()).\n                                 * We can take advantage of this by\n                                 * building the new temp brigade out of\n                                 * these buckets, so that the content\n                                 * in them doesn't have to be copied again.\n                                 */\n                                apr_bucket_brigade *bb;\n                                bb = apr_brigade_split(b,\n                                         APR_BUCKET_NEXT(last_merged_bucket));\n                                temp_brig = b;\n                                b = bb;\n                            }\n                            else {\n                                temp_brig = apr_brigade_create(f->c->pool,\n                                                           f->c->bucket_alloc);\n                            }\n\n                            temp = APR_BRIGADE_FIRST(b);\n                            while (temp != e) {\n                                apr_bucket *d;\n                                rv = apr_bucket_read(temp, &str, &n, APR_BLOCK_READ);\n                                apr_brigade_write(temp_brig, NULL, NULL, str, n);\n                                d = temp;\n                                temp = APR_BUCKET_NEXT(temp);\n                                apr_bucket_delete(d);\n                            }\n\n                            nvec = 0;\n                            nbytes = 0;\n                            temp = APR_BRIGADE_FIRST(temp_brig);\n                            APR_BUCKET_REMOVE(temp);\n                            APR_BRIGADE_INSERT_HEAD(b, temp);\n                            apr_bucket_read(temp, &str, &n, APR_BLOCK_READ);\n                            vec[nvec].iov_base = (char*) str;\n                            vec[nvec].iov_len = n;\n                            nvec++;\n\n                            /* Just in case the temporary brigade has\n                             * multiple buckets, recover the rest of\n                             * them and put them in the brigade that\n                             * we're sending.\n                             */\n                            for (next = APR_BRIGADE_FIRST(temp_brig);\n                                 next != APR_BRIGADE_SENTINEL(temp_brig);\n                                 next = APR_BRIGADE_FIRST(temp_brig)) {\n                                APR_BUCKET_REMOVE(next);\n                                APR_BUCKET_INSERT_AFTER(temp, next);\n                                temp = next;\n                                apr_bucket_read(next, &str, &n,\n                                                APR_BLOCK_READ);\n                                vec[nvec].iov_base = (char*) str;\n                                vec[nvec].iov_len = n;\n                                nvec++;\n                            }\n\n                            apr_brigade_destroy(temp_brig);\n\n                            last_merged_bucket = temp;\n                            e = temp;\n                            last_e = e;\n                        }\n                        else {\n                            vec[nvec].iov_base = (char*) str;\n                            vec[nvec].iov_len = n;\n                            nvec++;\n                        }\n                    }\n                    else {\n                        \n\n                        if (nvec_trailers == MAX_IOVEC_TO_WRITE) {\n                            \n                            more = apr_brigade_split(b, e);\n                            break;\n                        }\n\n                        vec_trailers[nvec_trailers].iov_base = (char*) str;\n                        vec_trailers[nvec_trailers].iov_len = n;\n                        nvec_trailers++;\n                    }\n\n                    nbytes += n;\n                }\n            }\n        }\n\n\n        /* Completed iterating over the brigade, now determine if we want\n         * to buffer the brigade or send the brigade out on the network.\n         *\n         * Save if we haven't accumulated enough bytes to send, the connection\n         * is not about to be closed, and:\n         *\n         *   1) we didn't see a file, we don't have more passes over the\n         *      brigade to perform,  AND we didn't stop at a FLUSH bucket.\n         *      (IOW, we will save plain old bytes such as HTTP headers)\n         * or\n         *   2) we hit the EOS and have a keep-alive connection\n         *      (IOW, this response is a bit more complex, but we save it\n         *       with the hope of concatenating with another response)\n         */\n        if (nbytes + flen < AP_MIN_BYTES_TO_WRITE\n            && !AP_BUCKET_IS_EOC(last_e)\n            && ((!fd && !more && !APR_BUCKET_IS_FLUSH(last_e))\n                || (APR_BUCKET_IS_EOS(last_e)\n                    && c->keepalive == AP_CONN_KEEPALIVE))) {\n\n            /* NEVER save an EOS in here.  If we are saving a brigade with\n             * an EOS bucket, then we are doing keepalive connections, and\n             * we want to process to second request fully.\n             */\n            if (APR_BUCKET_IS_EOS(last_e)) {\n                apr_bucket *bucket;\n                int file_bucket_saved = 0;\n                apr_bucket_delete(last_e);\n                for (bucket = APR_BRIGADE_FIRST(b);\n                     bucket != APR_BRIGADE_SENTINEL(b);\n                     bucket = APR_BUCKET_NEXT(bucket)) {\n\n                    /* Do a read on each bucket to pull in the\n                     * data from pipe and socket buckets, so\n                     * that we don't leave their file descriptors\n                     * open indefinitely.  Do the same for file\n                     * buckets, with one exception: allow the\n                     * first file bucket in the brigade to remain\n                     * a file bucket, so that we don't end up\n                     * doing an mmap+memcpy every time a client\n                     * requests a <8KB file over a keepalive\n                     * connection.\n                     */\n                    if (APR_BUCKET_IS_FILE(bucket) && !file_bucket_saved) {\n                        file_bucket_saved = 1;\n                    }\n                    else {\n                        const char *buf;\n                        apr_size_t len = 0;\n                        rv = apr_bucket_read(bucket, &buf, &len,\n                                             APR_BLOCK_READ);\n                        if (rv != APR_SUCCESS) {\n                            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv,\n                                          c, \"core_output_filter:\"\n                                          \" Error reading from bucket.\");\n                            return HTTP_INTERNAL_SERVER_ERROR;\n                        }\n                    }\n                }\n            }\n            if (!ctx->deferred_write_pool) {\n                apr_pool_create(&ctx->deferred_write_pool, c->pool);\n                apr_pool_tag(ctx->deferred_write_pool, \"deferred_write\");\n            }\n            ap_save_brigade(f, &ctx->b, &b, ctx->deferred_write_pool);\n\n            return APR_SUCCESS;\n        }\n\n        if (fd) {\n            apr_hdtr_t hdtr;\n            apr_size_t bytes_sent;\n\n#if APR_HAS_SENDFILE\n            apr_int32_t flags = 0;\n#endif\n\n            memset(&hdtr, '\\0', sizeof(hdtr));\n            if (nvec) {\n                hdtr.numheaders = nvec;\n                hdtr.headers = vec;\n            }\n\n            if (nvec_trailers) {\n                hdtr.numtrailers = nvec_trailers;\n                hdtr.trailers = vec_trailers;\n            }\n\n#if APR_HAS_SENDFILE\n            if (apr_file_flags_get(fd) & APR_SENDFILE_ENABLED) {\n\n                if (c->keepalive == AP_CONN_CLOSE && APR_BUCKET_IS_EOS(last_e)) {\n                    \n                    flags |= APR_SENDFILE_DISCONNECT_SOCKET;\n                }\n\n                rv = sendfile_it_all(net,      \n                                     fd,       \n                                     &hdtr,    \n                                     foffset,  /* offset in the file to begin\n                                                  sending from              */\n                                     flen,     \n                                     nbytes + flen, /* total length including\n                                                       headers              */\n                                     &bytes_sent,   /* how many bytes were\n                                                       sent                 */\n                                     flags);   \n            }\n            else\n#endif\n            {\n                rv = emulate_sendfile(net, fd, &hdtr, foffset, flen,\n                                      &bytes_sent);\n            }\n\n            if (logio_add_bytes_out && bytes_sent > 0)\n                logio_add_bytes_out(c, bytes_sent);\n\n            fd = NULL;\n        }\n        else {\n            apr_size_t bytes_sent;\n\n            rv = writev_it_all(net->client_socket,\n                               vec, nvec,\n                               nbytes, &bytes_sent);\n\n            if (logio_add_bytes_out && bytes_sent > 0)\n                logio_add_bytes_out(c, bytes_sent);\n        }\n\n        apr_brigade_destroy(b);\n        \n        /* drive cleanups for resources which were set aside \n         * this may occur before or after termination of the request which\n         * created the resource\n         */\n        if (ctx->deferred_write_pool) {\n            if (more && more->p == ctx->deferred_write_pool) {\n                /* \"more\" belongs to the deferred_write_pool,\n                 * which is about to be cleared.\n                 */\n                if (APR_BRIGADE_EMPTY(more)) {\n                    more = NULL;\n                }\n                else {\n                    /* uh oh... change more's lifetime \n                     * to the input brigade's lifetime \n                     */\n                    apr_bucket_brigade *tmp_more = more;\n                    more = NULL;\n                    ap_save_brigade(f, &more, &tmp_more, input_pool);\n                }\n            }\n            apr_pool_clear(ctx->deferred_write_pool);  \n        }\n\n        if (rv != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rv, c,\n                          \"core_output_filter: writing data to the network\");\n\n            if (more)\n                apr_brigade_destroy(more);\n\n            \n            if (!APR_STATUS_IS_EAGAIN(rv)) {\n                c->aborted = 1;\n            }\n\n            /* The client has aborted, but the request was successful. We\n             * will report success, and leave it to the access and error\n             * logs to note that the connection was aborted.\n             */\n            return APR_SUCCESS;\n        }\n\n        b = more;\n        more = NULL;\n    }  \n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_fae2de12cca3d00896e9a49abcc85986d45182d9_0", {
    "ID": "httpd_fae2de12cca3d00896e9a49abcc85986d45182d9_0",
    "UID": "299",
    "code": "static int find_file(request_rec *r, const char *directive, const char test_snippet\n                     char *tag_val, apr_finfo_t *finfo)\n{\n    char *to_send = tag_val;\n    request_rec *rr = NULL;\n    int ret=0;\n    char *error_fmt = NULL;\n    apr_status_t rv = APR_SUCCESS;\n\n    if (!strcmp(tag, \"file\")) {\n        char *newpath;\n\n        \n        rv = apr_filepath_merge(&newpath, NULL, tag_val,\n                                APR_FILEPATH_NOTABOVEROOT |\n                                APR_FILEPATH_SECUREROOTTEST |\n                                APR_FILEPATH_NOTABSOLUTE, r->pool);\n\n        if (rv != APR_SUCCESS) {\n            error_fmt = \"unable to access file \\\"%s\\\" \"\n                        \"in parsed file %s\";\n        }\n        else {\n            /* note: it is okay to pass NULL for the \"next filter\" since\n               we never attempt to \"run\" this sub request. */\n            rr = ap_sub_req_lookup_file(newpath, r, NULL);\n\n            if (rr->status == HTTP_OK && rr->finfo.filetype != 0) {\n                to_send = rr->filename;\n                if ((rv = apr_stat(finfo, to_send, \n                    APR_FINFO_GPROT | APR_FINFO_MIN, rr->pool)) != APR_SUCCESS\n                    && rv != APR_INCOMPLETE) {\n                    error_fmt = \"unable to get information about \\\"%s\\\" \"\n                        \"in parsed file %s\";\n                }\n            }\n            else {\n                error_fmt = \"unable to lookup information about \\\"%s\\\" \"\n                            \"in parsed file %s\";\n            }\n        }\n\n        if (error_fmt) {\n            ret = -1;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR,\n                          rv, r, error_fmt, to_send, r->filename);\n        }\n\n        if (rr) ap_destroy_sub_req(rr);\n        \n        return ret;\n    }\n    else if (!strcmp(tag, \"virtual\")) {\n        /* note: it is okay to pass NULL for the \"next filter\" since\n           we never attempt to \"run\" this sub request. */\n        rr = ap_sub_req_lookup_uri(tag_val, r, NULL);\n\n        if (rr->status == HTTP_OK && rr->finfo.filetype != 0) {\n            memcpy((char *) finfo, (const char *) &rr->finfo,\n                   sizeof(rr->finfo));\n            ap_destroy_sub_req(rr);\n            return 0;\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"unable to get \"\n                          \"information about \\\"%s\\\" in parsed file %s\",\n                          tag_val, r->filename);\n            ap_destroy_sub_req(rr);\n            return -1;\n        }\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"unknown parameter \\\"%s\\\" \"\n                      \"to tag %s in %s\", tag, directive, r->filename);\n        return -1;\n    }\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_6abc2e05bb2aaa324786f07e16394d4f4c122676_0", {
    "ID": "httpd_6abc2e05bb2aaa324786f07e16394d4f4c122676_0",
    "UID": "309",
    "code": "static apr_status_t handle_if(include_ctx_t *ctx, ap_filter_t test_snippet\n                              apr_bucket_brigade *bb)\n{\n    char *tag = NULL;\n    char *expr = NULL;\n    request_rec *r = f->r;\n    int expr_ret, was_error;\n\n    if (ctx->argc != 1) {\n        ap_log_rerror(APLOG_MARK,\n                      (ctx->flags & SSI_FLAG_PRINTING)\n                          ? APLOG_ERR : APLOG_WARNING,\n                      0, r, (ctx->argc)\n                                ? \"too many arguments for if element in %s\"\n                                : \"missing expr argument for if element in %s\",\n                      r->filename);\n    }\n\n    if (!(ctx->flags & SSI_FLAG_PRINTING)) {\n        ++(ctx->if_nesting_level);\n        return APR_SUCCESS;\n    }\n\n    if (ctx->argc != 1) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    ap_ssi_get_tag_and_value(ctx, &tag, &expr, SSI_VALUE_RAW);\n\n    if (strcmp(tag, \"expr\")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"unknown parameter \\\"%s\\\" \"\n                      \"to tag if in %s\", tag, r->filename);\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    if (!expr) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"missing expr value for if \"\n                      \"element in %s\", r->filename);\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    DEBUG_PRINTF((ctx, \"****    if expr=\\\"%s\\\"\\n\", expr));\n\n    expr_ret = parse_expr(ctx, expr, &was_error);\n\n    if (was_error) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    if (expr_ret) {\n        ctx->flags |= (SSI_FLAG_PRINTING | SSI_FLAG_COND_TRUE);\n    }\n    else {\n        ctx->flags &= SSI_FLAG_CLEAR_PRINT_COND;\n    }\n\n    DEBUG_DUMP_COND(ctx, \"   if\");\n\n    ctx->if_nesting_level = 0;\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_2007df386f7ea073ef97d2332e4a2034b7fb1469_0", {
    "ID": "httpd_2007df386f7ea073ef97d2332e4a2034b7fb1469_0",
    "UID": "311",
    "code": "static int is_variant_better_rvsa(negotiation_state *neg, var_rec test_snippet\n                                  var_rec *best, float *p_bestq)\n{\n    float bestq = *p_bestq, q;\n\n    /* TCN does not cover negotiation on content-encoding.  For now,\n     * we ignore the encoding unless it was explicitly excluded.\n     */\n    if (variant->encoding_quality == 0.0f)\n        return 0;\n\n    q = variant->mime_type_quality *\n        variant->source_quality *\n        variant->charset_quality *\n        variant->lang_quality;\n\n   /* RFC 2296 calls for the result to be rounded to 5 decimal places,\n    * but we don't do that because it serves no useful purpose other\n    * than to ensure that a remote algorithm operates on the same\n    * precision as ours.  That is silly, since what we obviously want\n    * is for the algorithm to operate on the best available precision\n    * regardless of who runs it.  Since the above calculation may\n    * result in significant variance at 1e-12, rounding would be bogus.\n    */\n\n#ifdef NEG_DEBUG\n    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n           \"Variant: file=%s type=%s lang=%s sourceq=%1.3f \"\n           \"mimeq=%1.3f langq=%1.3f charq=%1.3f encq=%1.3f \"\n           \"q=%1.5f definite=%d\",\n            (variant->file_name ? variant->file_name : \"\"),\n            (variant->mime_type ? variant->mime_type : \"\"),\n            (variant->content_languages\n             ? apr_array_pstrcat(neg->pool, variant->content_languages, ',')\n             : \"\"),\n            variant->source_quality,\n            variant->mime_type_quality,\n            variant->lang_quality,\n            variant->charset_quality,\n            variant->encoding_quality,\n            q,\n            variant->definite);\n#endif\n\n    if (q <= 0.0f) {\n        return 0;\n    }\n    if (q > bestq) {\n        *p_bestq = q;\n        return 1;\n    }\n    if (q == bestq) {\n        /* If the best variant's encoding is of lesser quality than\n         * this variant, then we prefer this variant\n         */\n        if (variant->encoding_quality > best->encoding_quality) {\n            *p_bestq = q;\n            return 1;\n        }\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_eec1e91ec3566177572692e1ebd3b41e5c61c63d_0", {
    "ID": "httpd_eec1e91ec3566177572692e1ebd3b41e5c61c63d_0",
    "UID": "312",
    "code": "static apr_status_t handle_printenv(include_ctx_t *ctx, ap_filter_t test_snippet\n                                    apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    const apr_array_header_t *arr;\n    const apr_table_entry_t *elts;\n    int i;\n\n    if (ctx->argc) {\n        ap_log_rerror(APLOG_MARK,\n                      (ctx->flags & SSI_FLAG_PRINTING)\n                          ? APLOG_ERR : APLOG_WARNING,\n                      0, r, \"printenv directive does not take tags in %s\",\n                      r->filename);\n    }\n\n    if (!(ctx->flags & SSI_FLAG_PRINTING)) {\n        return APR_SUCCESS;\n    }\n\n    if (ctx->argc) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    arr = apr_table_elts(r->subprocess_env);\n    elts = (apr_table_entry_t *)arr->elts;\n\n    for (i = 0; i < arr->nelts; ++i) {\n        const char *key_text, *val_text;\n        char *key_val, *next;\n        apr_size_t k_len, v_len, kv_length;\n\n        \n        key_text = ap_escape_html(ctx->dpool, elts[i].key);\n        k_len = strlen(key_text);\n\n        \n        val_text = elts[i].val;\n        if (val_text == LAZY_VALUE) {\n            val_text = add_include_vars_lazy(r, elts[i].key);\n        }\n        val_text = ap_escape_html(ctx->dpool, elts[i].val);\n        v_len = strlen(val_text);\n\n        \n        kv_length = k_len + v_len + sizeof(\"=\\n\");\n        key_val = apr_palloc(ctx->pool, kv_length);\n        next = key_val;\n\n        memcpy(next, key_text, k_len);\n        next += k_len;\n        *next++ = '=';\n        memcpy(next, val_text, v_len);\n        next += v_len;\n        *next++ = '\\n';\n        *next = 0;\n\n        APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(key_val, kv_length-1,\n                                ctx->pool, f->c->bucket_alloc));\n    }\n\n    ctx->flush_now = 1;\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value"
  },
  "httpd_0836def76217ee69a16f9b32a46b9405f8eb9774_0", {
    "ID": "httpd_0836def76217ee69a16f9b32a46b9405f8eb9774_0",
    "UID": "314",
    "code": "static apr_status_t send_parsed_content(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    include_ctx_t *ctx = f->ctx;\n    struct ssi_internal_ctx *intern = ctx->intern;\n    request_rec *r = f->r;\n    apr_bucket *b = APR_BRIGADE_FIRST(bb);\n    apr_bucket_brigade *pass_bb;\n    apr_status_t rv = APR_SUCCESS;\n    char *magic; \n\n    \n    if (APR_BRIGADE_EMPTY(bb)) {\n        return APR_SUCCESS;\n    }\n\n    /* we may crash, since already cleaned up; hand over the responsibility\n     * to the next filter;-)\n     */\n    if (intern->seen_eos) {\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    \n    pass_bb = apr_brigade_create(ctx->pool, f->c->bucket_alloc);\n\n    \n    intern->bytes_read = 0;\n    intern->error = 0;\n    intern->r = r;\n    ctx->flush_now = 0;\n\n    \n    while (b != APR_BRIGADE_SENTINEL(bb)) {\n        const char *data = NULL;\n        apr_size_t len, index, release;\n        apr_bucket *newb = NULL;\n        char **store = &magic;\n        apr_size_t *store_len;\n\n        \n        if (APR_BUCKET_IS_METADATA(b)) {\n            newb = APR_BUCKET_NEXT(b);\n\n            APR_BUCKET_REMOVE(b);\n\n            if (APR_BUCKET_IS_EOS(b)) {\n                intern->seen_eos = 1;\n\n                /* Hit end of stream, time for cleanup ... But wait!\n                 * Perhaps we're not ready yet. We may have to loop one or\n                 * two times again to finish our work. In that case, we\n                 * just re-insert the EOS bucket to allow for an extra loop.\n                 *\n                 * PARSE_EXECUTE means, we've hit a directive just before the\n                 *    EOS, which is now waiting for execution.\n                 *\n                 * PARSE_DIRECTIVE_POSTTAIL means, we've hit a directive with\n                 *    no argument and no space between directive and end_seq\n                 *    just before the EOS. (consider <!--#printenv--> as last\n                 *    or only string within the stream). This state, however,\n                 *    just cleans up and turns itself to PARSE_EXECUTE, which\n                 *    will be passed through within the next (and actually\n                 *    last) round.\n                 */\n                if (PARSE_EXECUTE            == intern->state ||\n                    PARSE_DIRECTIVE_POSTTAIL == intern->state) {\n                    APR_BUCKET_INSERT_BEFORE(newb, b);\n                }\n                else {\n                    break; \n                }\n            }\n            else {\n                APR_BRIGADE_INSERT_TAIL(pass_bb, b);\n\n                if (APR_BUCKET_IS_FLUSH(b)) {\n                    ctx->flush_now = 1;\n                }\n\n                b = newb;\n                continue;\n            }\n        }\n\n        \n        if (ctx->flush_now ||\n            intern->bytes_read > AP_MIN_BYTES_TO_WRITE) {\n\n            if (!APR_BRIGADE_EMPTY(pass_bb)) {\n                rv = ap_pass_brigade(f->next, pass_bb);\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_destroy(pass_bb);\n                    return rv;\n                }\n            }\n\n            ctx->flush_now = 0;\n            intern->bytes_read = 0;\n        }\n\n        \n        len = 0;\n        if (!intern->seen_eos) {\n            if (intern->bytes_read > 0) {\n                rv = apr_bucket_read(b, &data, &len, APR_NONBLOCK_READ);\n                if (APR_STATUS_IS_EAGAIN(rv)) {\n                    ctx->flush_now = 1;\n                    continue;\n                }\n            }\n\n            if (!len || rv != APR_SUCCESS) {\n                rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n            }\n\n            if (rv != APR_SUCCESS) {\n                apr_brigade_destroy(pass_bb);\n                return rv;\n            }\n\n            intern->bytes_read += len;\n        }\n\n        \n        if (!len && !intern->seen_eos) {\n            b = APR_BUCKET_NEXT(b);\n            continue;\n        }\n\n        /*\n         * it's actually a data containing bucket, start/continue parsing\n         */\n\n        switch (intern->state) {\n        \n        case PARSE_PRE_HEAD:\n            index = find_start_sequence(ctx, data, len);\n\n            if (index < len) {\n                apr_bucket_split(b, index);\n            }\n\n            newb = APR_BUCKET_NEXT(b);\n            if (ctx->flags & SSI_FLAG_PRINTING) {\n                APR_BUCKET_REMOVE(b);\n                APR_BRIGADE_INSERT_TAIL(pass_bb, b);\n            }\n            else {\n                apr_bucket_delete(b);\n            }\n\n            if (index < len) {\n                \n                if (PARSE_DIRECTIVE == intern->state) { \n                    apr_bucket_split(newb, intern->start_seq_pat->pattern_len);\n                    ctx->flush_now = 1; \n                }\n\n                b = APR_BUCKET_NEXT(newb);\n                apr_bucket_delete(newb);\n            }\n            else {\n                b = newb;\n            }\n\n            break;\n\n        \n        case PARSE_HEAD:\n            index = find_partial_start_sequence(ctx, data, len, &release);\n\n            \n            if (release && (ctx->flags & SSI_FLAG_PRINTING)) {\n                char *to_release = apr_palloc(ctx->pool, release);\n\n                memcpy(to_release, intern->start_seq, release);\n                newb = apr_bucket_pool_create(to_release, release, ctx->pool,\n                                              f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(pass_bb, newb);\n            }\n\n            if (index) { \n                \n                if (PARSE_DIRECTIVE == intern->state) { \n                    apr_bucket_split(b, index);\n                    ctx->flush_now = 1; \n                }\n                newb = APR_BUCKET_NEXT(b);\n                apr_bucket_delete(b);\n                b = newb;\n            }\n\n            break;\n\n        \n        case PARSE_DIRECTIVE:\n        case PARSE_DIRECTIVE_POSTNAME:\n        case PARSE_DIRECTIVE_TAIL:\n        case PARSE_DIRECTIVE_POSTTAIL:\n            index = find_directive(ctx, data, len, &store, &store_len);\n\n            if (index) {\n                apr_bucket_split(b, index);\n                newb = APR_BUCKET_NEXT(b);\n            }\n\n            if (store) {\n                if (index) {\n                    APR_BUCKET_REMOVE(b);\n                    APR_BRIGADE_INSERT_TAIL(intern->tmp_bb, b);\n                    b = newb;\n                }\n\n                \n                if (store != &magic) {\n                    apr_brigade_pflatten(intern->tmp_bb, store, store_len,\n                                         ctx->dpool);\n                    apr_brigade_cleanup(intern->tmp_bb);\n                }\n            }\n            else if (index) {\n                apr_bucket_delete(b);\n                b = newb;\n            }\n\n            break;\n\n        \n        case PARSE_PRE_ARG:\n            index = find_arg_or_tail(ctx, data, len);\n\n            if (index) { \n                if (index < len) {\n                    apr_bucket_split(b, index);\n                }\n                newb = APR_BUCKET_NEXT(b);\n                apr_bucket_delete(b);\n                b = newb;\n            }\n\n            break;\n\n        \n        case PARSE_ARG:\n        case PARSE_ARG_NAME:\n        case PARSE_ARG_POSTNAME:\n        case PARSE_ARG_EQ:\n        case PARSE_ARG_PREVAL:\n        case PARSE_ARG_VAL:\n        case PARSE_ARG_VAL_ESC:\n        case PARSE_ARG_POSTVAL:\n            index = find_argument(ctx, data, len, &store, &store_len);\n\n            if (index) {\n                apr_bucket_split(b, index);\n                newb = APR_BUCKET_NEXT(b);\n            }\n\n            if (store) {\n                if (index) {\n                    APR_BUCKET_REMOVE(b);\n                    APR_BRIGADE_INSERT_TAIL(intern->tmp_bb, b);\n                    b = newb;\n                }\n\n                \n                if (store != &magic) {\n                    apr_brigade_pflatten(intern->tmp_bb, store, store_len,\n                                         ctx->dpool);\n                    apr_brigade_cleanup(intern->tmp_bb);\n                }\n            }\n            else if (index) {\n                apr_bucket_delete(b);\n                b = newb;\n            }\n\n            break;\n\n        \n        case PARSE_TAIL:\n        case PARSE_TAIL_SEQ:\n            index = find_tail(ctx, data, len);\n\n            switch (intern->state) {\n            case PARSE_EXECUTE:  \n                apr_bucket_split(b, index);\n                newb = APR_BUCKET_NEXT(b);\n                apr_bucket_delete(b);\n                b = newb;\n                break;\n\n            case PARSE_ARG:      \n                \n                APR_BRIGADE_PREPEND(bb, intern->tmp_bb);\n                b = APR_BRIGADE_FIRST(bb);\n                break;\n\n            default:             \n                newb = APR_BUCKET_NEXT(b);\n                APR_BUCKET_REMOVE(b);\n                APR_BRIGADE_INSERT_TAIL(intern->tmp_bb, b);\n                b = newb;\n                break;\n            }\n\n            break;\n\n        /* now execute the parsed directive, cleanup the space and\n         * start again with PARSE_PRE_HEAD\n         */\n        case PARSE_EXECUTE:\n            \n            if (intern->error) {\n                if (ctx->flags & SSI_FLAG_PRINTING) {\n                    SSI_CREATE_ERROR_BUCKET(ctx, f, pass_bb);\n                    intern->error = 0;\n                }\n            }\n            else {\n                include_handler_fn_t *handle_func;\n\n                handle_func =\n                    (include_handler_fn_t *)apr_hash_get(include_handlers, intern->directive,\n                                                         intern->directive_len);\n\n                if (handle_func) {\n                    DEBUG_INIT(ctx, f, pass_bb);\n                    rv = handle_func(ctx, f, pass_bb);\n                    if (rv != APR_SUCCESS) {\n                        apr_brigade_destroy(pass_bb);\n                        return rv;\n                    }\n                }\n                else {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"unknown directive \\\"%s\\\" in parsed doc %s\",\n                                  apr_pstrmemdup(r->pool, intern->directive,\n                                                 intern->directive_len),\n                                                 r->filename);\n                    if (ctx->flags & SSI_FLAG_PRINTING) {\n                        SSI_CREATE_ERROR_BUCKET(ctx, f, pass_bb);\n                    }\n                }\n            }\n\n            \n            apr_pool_clear(ctx->dpool);\n            apr_brigade_cleanup(intern->tmp_bb);\n\n            \n            intern->state = PARSE_PRE_HEAD;\n            break;\n\n        } \n\n    } \n\n    \n    if (intern->seen_eos) {\n        if (PARSE_HEAD == intern->state) {\n            if (ctx->flags & SSI_FLAG_PRINTING) {\n                char *to_release = apr_palloc(ctx->pool, intern->parse_pos);\n\n                memcpy(to_release, intern->start_seq, intern->parse_pos);\n                APR_BRIGADE_INSERT_TAIL(pass_bb,\n                                        apr_bucket_pool_create(to_release,\n                                        intern->parse_pos, ctx->pool,\n                                        f->c->bucket_alloc));\n            }\n        }\n        else if (PARSE_PRE_HEAD != intern->state) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"SSI directive was not properly finished at the end \"\n                          \"of parsed document %s\", r->filename);\n            if (ctx->flags & SSI_FLAG_PRINTING) {\n                SSI_CREATE_ERROR_BUCKET(ctx, f, pass_bb);\n            }\n        }\n\n        if (!(ctx->flags & SSI_FLAG_PRINTING)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                          \"missing closing endif directive in parsed document\"\n                          \" %s\", r->filename);\n        }\n\n        \n        apr_brigade_destroy(intern->tmp_bb);\n        apr_pool_destroy(ctx->dpool);\n\n        \n        APR_BRIGADE_INSERT_TAIL(pass_bb, b);\n    }\n\n    \n    if (!APR_BRIGADE_EMPTY(pass_bb)) {\n        rv = ap_pass_brigade(f->next, pass_bb);\n    }\n    else {\n        rv = APR_SUCCESS;\n        apr_brigade_destroy(pass_bb);\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_2f837b3aa72856ccebaa9aba45b1de9ff2913097_0", {
    "ID": "httpd_2f837b3aa72856ccebaa9aba45b1de9ff2913097_0",
    "UID": "321",
    "code": "static char *etag_uint64_to_hex(char *next, apr_uint64_t test_snippet\n{\n    int printing = 0;\n    int shift = sizeof(apr_uint64_t) * 8 - 4;\n    do {\n        unsigned short next_digit = (unsigned short)\n                                    ((u >> shift) & (apr_uint64_t)0xf);\n        if (next_digit) {\n            *next++ = HEX_DIGITS[next_digit];\n            printing = 1;\n        }\n        else if (printing) {\n            *next++ = HEX_DIGITS[next_digit];\n        }\n        shift -= 4;\n    } while (shift);\n    *next++ = HEX_DIGITS[u & (apr_uint64_t)0xf];\n    return next;\n}",
    "predicted": "467,Use of sizeof() on a Pointer Type"
  },
  "httpd_78a26a5f667b8f9e424bbde6a16b2b15ce6e587c_0", {
    "ID": "httpd_78a26a5f667b8f9e424bbde6a16b2b15ce6e587c_0",
    "UID": "326",
    "code": "int ap_core_input_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                         ap_input_mode_t mode, apr_read_type_e block,\n                         apr_off_t readbytes)\n{\n    apr_bucket *e;\n    apr_status_t rv;\n    core_net_rec *net = f->ctx;\n    core_ctx_t *ctx = net->in_ctx;\n    const char *str;\n    apr_size_t len;\n\n    if (mode == AP_MODE_INIT) {\n        /*\n         * this mode is for filters that might need to 'initialize'\n         * a connection before reading request data from a client.\n         * NNTP over SSL for example needs to handshake before the\n         * server sends the welcome message.\n         * such filters would have changed the mode before this point\n         * is reached.  however, protocol modules such as NNTP should\n         * not need to know anything about SSL.  given the example, if\n         * SSL is not in the filter chain, AP_MODE_INIT is a noop.\n         */\n        return APR_SUCCESS;\n    }\n\n    if (!ctx)\n    {\n        ctx = apr_pcalloc(f->c->pool, sizeof(*ctx));\n        ctx->b = apr_brigade_create(f->c->pool, f->c->bucket_alloc);\n        ctx->tmpbb = apr_brigade_create(ctx->b->p, ctx->b->bucket_alloc);\n        \n        e = apr_bucket_socket_create(net->client_socket, f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->b, e);\n        net->in_ctx = ctx;\n    }\n    else if (APR_BRIGADE_EMPTY(ctx->b)) {\n        return APR_EOF;\n    }\n\n    \n    BRIGADE_NORMALIZE(ctx->b);\n\n    /* check for empty brigade again *AFTER* BRIGADE_NORMALIZE()\n     * If we have lost our socket bucket (see above), we are EOF.\n     *\n     * Ideally, this should be returning SUCCESS with EOS bucket, but\n     * some higher-up APIs (spec. read_request_line via ap_rgetline)\n     * want an error code. */\n    if (APR_BRIGADE_EMPTY(ctx->b)) {\n        return APR_EOF;\n    }\n\n    if (mode == AP_MODE_GETLINE) {\n        \n        rv = apr_brigade_split_line(b, ctx->b, block, HUGE_STRING_LEN);\n        /* We should treat EAGAIN here the same as we do for EOF (brigade is\n         * empty).  We do this by returning whatever we have read.  This may\n         * or may not be bogus, but is consistent (for now) with EOF logic.\n         */\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            rv = APR_SUCCESS;\n        }\n        return rv;\n    }\n\n    /* ### AP_MODE_PEEK is a horrific name for this mode because we also\n     * eat any CRLFs that we see.  That's not the obvious intention of\n     * this mode.  Determine whether anyone actually uses this or not. */\n    if (mode == AP_MODE_EATCRLF) {\n        apr_bucket *e;\n        const char *c;\n\n        /* The purpose of this loop is to ignore any CRLF (or LF) at the end\n         * of a request.  Many browsers send extra lines at the end of POST\n         * requests.  We use the PEEK method to determine if there is more\n         * data on the socket, so that we know if we should delay sending the\n         * end of one request until we have served the second request in a\n         * pipelined situation.  We don't want to actually delay sending a\n         * response if the server finds a CRLF (or LF), becuause that doesn't\n         * mean that there is another request, just a blank line.\n         */\n        while (1) {\n            if (APR_BRIGADE_EMPTY(ctx->b))\n                return APR_EOF;\n\n            e = APR_BRIGADE_FIRST(ctx->b);\n\n            rv = apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);\n\n            if (rv != APR_SUCCESS)\n                return rv;\n\n            c = str;\n            while (c < str + len) {\n                if (*c == APR_ASCII_LF)\n                    c++;\n                else if (*c == APR_ASCII_CR && *(c + 1) == APR_ASCII_LF)\n                    c += 2;\n                else\n                    return APR_SUCCESS;\n            }\n\n            /* If we reach here, we were a bucket just full of CRLFs, so\n             * just toss the bucket. */\n            \n            apr_bucket_delete(e);\n        }\n        return APR_SUCCESS;\n    }\n\n    /* If mode is EXHAUSTIVE, we want to just read everything until the end\n     * of the brigade, which in this case means the end of the socket.\n     * To do this, we attach the brigade that has currently been setaside to\n     * the brigade that was passed down, and send that brigade back.\n     *\n     * NOTE:  This is VERY dangerous to use, and should only be done with\n     * extreme caution.  However, the Perchild MPM needs this feature\n     * if it is ever going to work correctly again.  With this, the Perchild\n     * MPM can easily request the socket and all data that has been read,\n     * which means that it can pass it to the correct child process.\n     */\n    if (mode == AP_MODE_EXHAUSTIVE) {\n        apr_bucket *e;\n\n        \n        APR_BRIGADE_CONCAT(b, ctx->b);\n\n        /* Since we've just added all potential buckets (which will most\n         * likely simply be the socket bucket) we know this is the end,\n         * so tack on an EOS too. */\n        /* We have read until the brigade was empty, so we know that we\n         * must be EOS. */\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    \n    if (mode == AP_MODE_READBYTES || mode == AP_MODE_SPECULATIVE) {\n        apr_bucket *e;\n\n        AP_DEBUG_ASSERT(readbytes > 0);\n\n        e = APR_BRIGADE_FIRST(ctx->b);\n        rv = apr_bucket_read(e, &str, &len, block);\n\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            return APR_SUCCESS;\n        }\n        else if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        else if (block == APR_BLOCK_READ && len == 0) {\n            /* We wanted to read some bytes in blocking mode.  We read\n             * 0 bytes.  Hence, we now assume we are EOS.\n             *\n             * When we are in normal mode, return an EOS bucket to the\n             * caller.\n             * When we are in speculative mode, leave ctx->b empty, so\n             * that the next call returns an EOS bucket.\n             */\n            apr_bucket_delete(e);\n\n            if (mode == AP_MODE_READBYTES) {\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n            }\n            return APR_SUCCESS;\n        }\n\n        \n        if (len < readbytes) {\n            readbytes = len;\n        }\n\n        rv = apr_brigade_partition(ctx->b, readbytes, &e);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        \n        brigade_move(ctx->b, ctx->tmpbb, e);\n\n        if (mode == AP_MODE_READBYTES) {\n            APR_BRIGADE_CONCAT(b, ctx->b);\n        }\n        else if (mode == AP_MODE_SPECULATIVE) {\n            apr_bucket *copy_bucket;\n\n            for (e = APR_BRIGADE_FIRST(ctx->b);\n                 e != APR_BRIGADE_SENTINEL(ctx->b);\n                 e = APR_BUCKET_NEXT(e))\n            {\n                rv = apr_bucket_copy(e, &copy_bucket);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                APR_BRIGADE_INSERT_TAIL(b, copy_bucket);\n            }\n        }\n\n        \n        APR_BRIGADE_CONCAT(ctx->b, ctx->tmpbb);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_45b4909b1698507badd88ffe1c272cea155b6a2f_0", {
    "ID": "httpd_45b4909b1698507badd88ffe1c272cea155b6a2f_0",
    "UID": "329",
    "code": "static apr_status_t emulate_sendfile(core_net_rec *c, apr_file_t test_snippet\n                                     apr_hdtr_t *hdtr, apr_off_t offset,\n                                     apr_size_t length, apr_size_t *nbytes)\n{\n    apr_status_t rv = APR_SUCCESS;\n    apr_size_t togo;        \n    apr_size_t sendlen = 0;\n    apr_size_t bytes_sent;\n    apr_int32_t i;\n    apr_off_t o;             \n    char buffer[8192];\n\n    *nbytes = 0;\n\n    /* Send the headers\n     * writev_it_all handles partial writes.\n     * XXX: optimization... if headers are less than MIN_WRITE_SIZE, copy\n     * them into buffer\n     */\n    if (hdtr && hdtr->numheaders > 0 ) {\n        for (i = 0; i < hdtr->numheaders; i++) {\n            sendlen += hdtr->headers[i].iov_len;\n        }\n\n        rv = writev_it_all(c->client_socket, hdtr->headers, hdtr->numheaders,\n                           sendlen, &bytes_sent);\n        *nbytes += bytes_sent;     \n    }\n\n    \n    if (offset >= 0 && rv == APR_SUCCESS) {\n        rv = apr_file_seek(fd, APR_SET, &offset);\n    }\n\n    \n    togo = length;\n    while (rv == APR_SUCCESS && togo) {\n        sendlen = togo > sizeof(buffer) ? sizeof(buffer) : togo;\n        o = 0;\n        rv = apr_file_read(fd, buffer, &sendlen);\n        if (rv == APR_SUCCESS && sendlen) {\n            while ((rv == APR_SUCCESS || APR_STATUS_IS_EAGAIN(rv)) && sendlen) {\n                bytes_sent = sendlen;\n                rv = apr_socket_send(c->client_socket, &buffer[o], &bytes_sent);\n                *nbytes += bytes_sent;\n                if (rv == APR_SUCCESS) {\n                    sendlen -= bytes_sent; \n                    o += bytes_sent;       \n                    togo -= bytes_sent;    \n                }\n            }\n        }\n    }\n\n    /* Send the trailers\n     * XXX: optimization... if it will fit, send this on the last send in the\n     * loop above\n     */\n    sendlen = 0;\n    if ( rv == APR_SUCCESS && hdtr && hdtr->numtrailers > 0 ) {\n        for (i = 0; i < hdtr->numtrailers; i++) {\n            sendlen += hdtr->trailers[i].iov_len;\n        }\n        rv = writev_it_all(c->client_socket, hdtr->trailers, hdtr->numtrailers,\n                           sendlen, &bytes_sent);\n        *nbytes += bytes_sent;\n    }\n\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_5cce535428fa64195401693e071d19c8e2e32b57_0", {
    "ID": "httpd_5cce535428fa64195401693e071d19c8e2e32b57_0",
    "UID": "355",
    "code": "static void log_error_core(const char *file, int line, int test_snippet\n                           apr_status_t status, const server_rec *s,\n                           const conn_rec *c,\n                           const request_rec *r, apr_pool_t *pool,\n                           const char *fmt, va_list args)\n{\n    char errstr[MAX_STRING_LEN];\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n    char scratch[MAX_STRING_LEN];\n#endif\n    apr_size_t len, errstrlen;\n    apr_file_t *logf = NULL;\n    const char *referer;\n    int level_and_mask = level & APLOG_LEVELMASK;\n\n    if (r && r->connection) {\n        c = r->connection;\n    }\n\n    if (s == NULL) {\n        /*\n         * If we are doing stderr logging (startup), don't log messages that are\n         * above the default server log level unless it is a startup/shutdown\n         * notice\n         */\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > ap_default_loglevel)) {\n            return;\n        }\n\n        logf = stderr_log;\n    }\n    else if (s->error_log) {\n        /*\n         * If we are doing normal logging, don't log messages that are\n         * above the server log level unless it is a startup/shutdown notice\n         */\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > s->loglevel)) {\n            return;\n        }\n\n        logf = s->error_log;\n    }\n#ifdef TPF\n    else if (tpf_child) {\n        /*\n         * If we are doing normal logging, don't log messages that are\n         * above the server log level unless it is a startup/shutdown notice\n         */\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > s->loglevel)) {\n            return;\n        }\n\n        logf = stderr;\n    }\n#endif \n    else {\n        /*\n         * If we are doing syslog logging, don't log messages that are\n         * above the server log level (including a startup/shutdown notice)\n         */\n        if (level_and_mask > s->loglevel) {\n            return;\n        }\n    }\n\n    if (logf && ((level & APLOG_STARTUP) != APLOG_STARTUP)) {\n        errstr[0] = '[';\n        ap_recent_ctime(errstr + 1, apr_time_now());\n        errstr[1 + APR_CTIME_LEN - 1] = ']';\n        errstr[1 + APR_CTIME_LEN    ] = ' ';\n        len = 1 + APR_CTIME_LEN + 1;\n    } else {\n        len = 0;\n    }\n\n    if ((level & APLOG_STARTUP) != APLOG_STARTUP) {\n        len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                            \"[%s] \", priorities[level_and_mask].t_name);\n    }\n\n#ifndef TPF\n    if (file && level_and_mask == APLOG_DEBUG) {\n#if defined(_OSD_POSIX) || defined(WIN32)\n        char tmp[256];\n        char *e = strrchr(file, '/');\n#ifdef WIN32\n        if (!e) {\n            e = strrchr(file, '\\\\');\n        }\n#endif\n\n        /* In OSD/POSIX, the compiler returns for __FILE__\n         * a string like: __FILE__=\"*POSIX(/usr/include/stdio.h)\"\n         * (it even returns an absolute path for sources in\n         * the current directory). Here we try to strip this\n         * down to the basename.\n         */\n        if (e != NULL && e[1] != '\\0') {\n            apr_snprintf(tmp, sizeof(tmp), \"%s\", &e[1]);\n            e = &tmp[strlen(tmp)-1];\n            if (*e == ')') {\n                *e = '\\0';\n            }\n            file = tmp;\n        }\n#else \n        const char *p;\n        /* On Unix, __FILE__ may be an absolute path in a\n         * VPATH build. */\n        if (file[0] == '/' && (p = ap_strrchr_c(file, '/')) != NULL) {\n            file = p + 1;\n        }\n#endif \n        len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                            \"%s(%d): \", file, line);\n    }\n#endif \n\n    if (c) {\n        /* XXX: TODO: add a method of selecting whether logged client\n         * addresses are in dotted quad or resolved form... dotted\n         * quad is the most secure, which is why I'm implementing it\n         * first. -djg\n         */\n        len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                            \"[client %s] \", c->remote_ip);\n    }\n    if (status != 0) {\n        if (status < APR_OS_START_EAIERR) {\n            len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                                \"(%d)\", status);\n        }\n        else if (status < APR_OS_START_SYSERR) {\n            len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                                \"(EAI %d)\", status - APR_OS_START_EAIERR);\n        }\n        else if (status < 100000 + APR_OS_START_SYSERR) {\n            len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                                \"(OS %d)\", status - APR_OS_START_SYSERR);\n        }\n        else {\n            len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                                \"(os 0x%08x)\", status - APR_OS_START_SYSERR);\n        }\n        apr_strerror(status, errstr + len, MAX_STRING_LEN - len);\n        len += strlen(errstr + len);\n        if (MAX_STRING_LEN - len > 2) {\n            errstr[len++] = ':';\n            errstr[len++] = ' ';\n            errstr[len] = '\\0';\n        }\n    }\n\n    errstrlen = len;\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n    if (apr_vsnprintf(scratch, MAX_STRING_LEN - len, fmt, args)) {\n        len += ap_escape_errorlog_item(errstr + len, scratch,\n                                       MAX_STRING_LEN - len);\n    }\n#else\n    len += apr_vsnprintf(errstr + len, MAX_STRING_LEN - len, fmt, args);\n#endif\n\n    if (   r && (referer = apr_table_get(r->headers_in, \"Referer\"))\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n        && ap_escape_errorlog_item(scratch, referer, MAX_STRING_LEN - len)\n#endif\n        ) {\n        len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,\n                            \", referer: %s\",\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n                            scratch\n#else\n                            referer\n#endif\n                            );\n    }\n\n    \n    if (logf) {\n        \n        if (len > MAX_STRING_LEN - sizeof(APR_EOL_STR)) {\n            len = MAX_STRING_LEN - sizeof(APR_EOL_STR);\n        }\n        strcpy(errstr + len, APR_EOL_STR);\n        apr_file_puts(errstr, logf);\n        apr_file_flush(logf);\n    }\n#ifdef HAVE_SYSLOG\n    else {\n        syslog(level_and_mask, \"%s\", errstr);\n    }\n#endif\n\n    ap_run_error_log(file, line, test_snippet status, s, r, pool, errstr + errstrlen);\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_a4422028d087b0cf422b6f552f8faa2476608256_0", {
    "ID": "httpd_a4422028d087b0cf422b6f552f8faa2476608256_0",
    "UID": "375",
    "code": "static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec test_snippet\n{\n    apr_socket_t *s = server->sd;\n    int one = 1;\n#if APR_HAVE_IPV6\n#ifdef AP_ENABLE_V4_MAPPED\n    int v6only_setting = 0;\n#else\n    int v6only_setting = 1;\n#endif\n#endif\n    apr_status_t stat;\n\n#ifndef WIN32\n    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,\n                      \"make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n#endif\n\n    stat = apr_socket_opt_set(s, APR_SO_KEEPALIVE, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,\n                      \"make_sock: for address %pI, apr_socket_opt_set: (SO_KEEPALIVE)\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n\n#if APR_HAVE_IPV6\n    if (server->bind_addr->family == APR_INET6) {\n        stat = apr_socket_opt_set(s, APR_IPV6_V6ONLY, v6only_setting);\n        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n            ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,\n                          \"make_sock: for address %pI, apr_socket_opt_set: \"\n                          \"(IPV6_V6ONLY)\",\n                          server->bind_addr);\n            apr_socket_close(s);\n            return stat;\n        }\n    }\n#endif\n\n    /*\n     * To send data over high bandwidth-delay connections at full\n     * speed we must force the TCP window to open wide enough to keep the\n     * pipe full.  The default window size on many systems\n     * is only 4kB.  Cross-country WAN connections of 100ms\n     * at 1Mb/s are not impossible for well connected sites.\n     * If we assume 100ms cross-country latency,\n     * a 4kB buffer limits throughput to 40kB/s.\n     *\n     * To avoid this problem I've added the SendBufferSize directive\n     * to allow the web master to configure send buffer size.\n     *\n     * The trade-off of larger buffers is that more kernel memory\n     * is consumed.  YMMV, know your customers and your network!\n     *\n     * -John Heidemann <johnh@isi.edu> 25-Oct-96\n     *\n     * If no size is specified, use the kernel default.\n     */\n    if (send_buffer_size) {\n        stat = apr_socket_opt_set(s, APR_SO_SNDBUF,  send_buffer_size);\n        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,\n                          \"make_sock: failed to set SendBufferSize for \"\n                          \"address %pI, using default\",\n                          server->bind_addr);\n            \n        }\n    }\n    if (receive_buffer_size) {\n        stat = apr_socket_opt_set(s, APR_SO_RCVBUF, receive_buffer_size);\n        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,\n                          \"make_sock: failed to set ReceiveBufferSize for \"\n                          \"address %pI, using default\",\n                          server->bind_addr);\n            strerror(errno);\n            \n        }\n    }\n\n#if APR_TCP_NODELAY_INHERITED\n    ap_sock_disable_nagle(s);\n#endif\n\n    if ((stat = apr_socket_bind(s, server->bind_addr)) != APR_SUCCESS) {\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, stat, p,\n                      \"make_sock: could not bind to address %pI\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n\n    if ((stat = apr_socket_listen(s, ap_listenbacklog)) != APR_SUCCESS) {\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, stat, p,\n                      \"make_sock: unable to listen for connections \"\n                      \"on address %pI\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n\n#ifdef WIN32\n    /* I seriously doubt that this would work on Unix; I have doubts that\n     * it entirely solves the problem on Win32.  However, since setting\n     * reuseaddr on the listener -prior- to binding the socket has allowed\n     * us to attach to the same port as an already running instance of\n     * Apache, or even another web server, we cannot identify that this\n     * port was exclusively granted to this instance of Apache.\n     *\n     * So set reuseaddr, but do not attempt to do so until we have the\n     * parent listeners successfully bound.\n     */\n    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,\n                    \"make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)\", \n                     server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n#endif\n\n#if APR_HAS_SO_ACCEPTFILTER\n#ifndef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"httpready\"\n#ifdef __FreeBSD_version\n#if __FreeBSD_version < 411000 \n#undef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"dataready\"\n#endif\n#endif\n#endif\n    stat = apr_socket_accept_filter(s, ACCEPT_FILTER_NAME, \"\");\n    if (stat != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(stat)) {\n        ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,\n                      \"Failed to enable the '%s' Accept Filter\",\n                      ACCEPT_FILTER_NAME);\n    }\n#else\n#ifdef APR_TCP_DEFER_ACCEPT\n    stat = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 1);   \n    if (stat != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(stat)) {\n        ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,\n                              \"Failed to enable APR_TCP_DEFER_ACCEPT\");\n    }\n#endif\n#endif\n\n    server->sd = s;\n    server->active = 1;\n\n#ifdef MPM_ACCEPT_FUNC\n    server->accept_func = MPM_ACCEPT_FUNC;\n#else\n    server->accept_func = NULL;\n#endif\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_c1f92b1bcace71b0001b27fcc0307b36259e7d61_0", {
    "ID": "httpd_c1f92b1bcace71b0001b27fcc0307b36259e7d61_0",
    "UID": "379",
    "code": "static apr_status_t sendfile_nonblocking(apr_socket_t test_snippet\n                                         apr_bucket_brigade *bb,\n                                         apr_size_t *cumulative_bytes_written,\n                                         conn_rec *c)\n{\n    apr_status_t rv = APR_SUCCESS;\n    apr_bucket *bucket;\n    apr_bucket_file *file_bucket;\n    apr_file_t *fd;\n    apr_size_t file_length;\n    apr_off_t file_offset;\n    apr_size_t bytes_written = 0;\n\n    bucket = APR_BRIGADE_FIRST(bb);\n    if (!APR_BUCKET_IS_FILE(bucket)) {\n        \n        return APR_EGENERAL;\n    }\n    file_bucket = (apr_bucket_file *)(bucket->data);\n    fd = file_bucket->fd;\n    file_length = bucket->length;\n    file_offset = bucket->start;\n\n    if (bytes_written < file_length) {\n        apr_size_t n = file_length - bytes_written;\n        apr_status_t arv;\n        apr_interval_time_t old_timeout;\n\n        arv = apr_socket_timeout_get(s, &old_timeout);\n        if (arv != APR_SUCCESS) {\n            return arv;\n        }\n        arv = apr_socket_timeout_set(s, 0);\n        if (arv != APR_SUCCESS) {\n            return arv;\n        }\n        rv = apr_socket_sendfile(s, fd, NULL, &file_offset, &n, 0);\n        if (rv == APR_SUCCESS) {\n            bytes_written += n;\n            file_offset += n;\n        }\n        arv = apr_socket_timeout_set(s, old_timeout);\n        if ((arv != APR_SUCCESS) && (rv == APR_SUCCESS)) {\n            rv = arv;\n        }\n    }\n    if ((logio_add_bytes_out != NULL) && (bytes_written > 0)) {\n        logio_add_bytes_out(c, bytes_written);\n    }\n    *cumulative_bytes_written += bytes_written;\n    if ((bytes_written < file_length) && (bytes_written > 0)) {\n        apr_bucket_split(bucket, bytes_written);\n        APR_BUCKET_REMOVE(bucket);\n        apr_bucket_destroy(bucket);\n    }\n    else if (bytes_written == file_length) {\n        APR_BUCKET_REMOVE(bucket);\n        apr_bucket_destroy(bucket);\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_422aaf668afe4735d5bd077d5428740a29b32d01_0", {
    "ID": "httpd_422aaf668afe4735d5bd077d5428740a29b32d01_0",
    "UID": "385",
    "code": "static apr_status_t send_brigade_blocking(apr_socket_t test_snippet\n                                          apr_bucket_brigade *bb,\n                                          apr_size_t *bytes_written,\n                                          conn_rec *c)\n{\n    apr_status_t rv;\n\n    rv = APR_SUCCESS;\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        rv = send_brigade_nonblocking(s, bb, bytes_written, c);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                rv = apr_wait_for_io_or_timeout(NULL, s, 0);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_e36126b7ad14ad9732e44c7e1b91a2b0de641a4e_0", {
    "ID": "httpd_e36126b7ad14ad9732e44c7e1b91a2b0de641a4e_0",
    "UID": "388",
    "code": "AP_DECLARE(int) test_snippet\n{\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);\n\n    if (!pfn_proxy_lb_workers)\n        pfn_proxy_lb_workers = APR_RETRIEVE_OPTIONAL_FN(ap_proxy_lb_workers);\n    if (pfn_proxy_lb_workers)\n        lb_limit = pfn_proxy_lb_workers();\n    else\n        lb_limit = 0;\n\n    if (!pfn_proxy_lb_worker_size)\n        pfn_proxy_lb_worker_size = APR_RETRIEVE_OPTIONAL_FN(ap_proxy_lb_worker_size);\n    if (pfn_proxy_lb_worker_size)\n        lb_size = pfn_proxy_lb_worker_size();\n    else\n        lb_size = sizeof(lb_score);\n\n    scoreboard_size = sizeof(global_score);\n    scoreboard_size += sizeof(process_score) * server_limit;\n    scoreboard_size += sizeof(worker_score) * server_limit * thread_limit;\n    if (lb_limit && lb_size)\n        scoreboard_size += lb_size * lb_limit;\n\n    return scoreboard_size;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n457,Use of Uninitialized Variable\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_ab9c9613ed8c40ed1734de1063f2667745e1d01d_0", {
    "ID": "httpd_ab9c9613ed8c40ed1734de1063f2667745e1d01d_0",
    "UID": "394",
    "code": "AP_DECLARE(lb_score *) ap_get_scoreboard_lb(int test_snippet\n{\n    if ( (lb_num < 0) || (lb_limit < test_snippet || (lb_size==0) ) {\n        return(NULL); \n    }\n    return (lb_score *) ( ((char *) ap_scoreboard_image->balancers) +\n                          (lb_num*lb_size) );\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)"
  },
  "httpd_b0149ec53b25f14bb8eec673388689eaf9d52161_0", {
    "ID": "httpd_b0149ec53b25f14bb8eec673388689eaf9d52161_0",
    "UID": "395",
    "code": "static apr_status_t bail_out_on_error(http_ctx_t test_snippet\n                                      ap_filter_t *f,\n                                      int http_error)\n{\n    apr_bucket *e;\n    apr_bucket_brigade *bb = ctx->bb;\n\n    apr_brigade_cleanup(bb);\n    e = ap_bucket_error_create(http_error,\n                               NULL, f->r->pool,\n                               f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    e = apr_bucket_eos_create(f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    ctx->eos_sent = 1;\n    return ap_pass_brigade(f->r->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_32ff584ef4f36c7adc1a8a4fb98d6bf32f4839c7_0", {
    "ID": "httpd_32ff584ef4f36c7adc1a8a4fb98d6bf32f4839c7_0",
    "UID": "398",
    "code": "static apr_status_t get_remaining_chunk_line(http_ctx_t test_snippet\n                                             apr_bucket_brigade *b,\n                                             int linelimit)\n{\n    apr_status_t rv;\n    apr_off_t brigade_length;\n    apr_bucket *e;\n    const char *lineend;\n    apr_size_t len;\n\n    /*\n     * As the brigade b should have been requested in mode AP_MODE_GETLINE\n     * all buckets in this brigade are already some type of memory\n     * buckets (due to the needed scanning for LF in mode AP_MODE_GETLINE)\n     * or META buckets.\n     */\n    rv = apr_brigade_length(b, 0, &brigade_length);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    \n    if (brigade_length == -1) {\n        return APR_EGENERAL;\n    }\n    if (!brigade_length) {\n        return APR_EAGAIN;\n    }\n    ctx->linesize += brigade_length;\n    if (ctx->linesize > linelimit) {\n        return APR_ENOSPC;\n    }\n    /*\n     * As all buckets are already some type of memory buckets or META buckets\n     * (see above), we only need to check the last byte in the last data bucket.\n     */\n    for (e = APR_BRIGADE_LAST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_PREV(e)) {\n\n        if (APR_BUCKET_IS_METADATA(e)) {\n            continue;\n        }\n        rv = apr_bucket_read(e, &lineend, &len, APR_BLOCK_READ);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        if (len > 0) {\n            break;  \n        }\n        \n    }\n    \n    if (!len || e == APR_BRIGADE_SENTINEL(b)) {\n        return APR_EAGAIN;\n    }\n    if (lineend[len - 1] != APR_ASCII_LF) {\n        return APR_EAGAIN;\n    }\n    \n    ctx->linesize = 0;\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b3ded288cba9fd8398705ebe08ecf2701b355397_0", {
    "ID": "httpd_b3ded288cba9fd8398705ebe08ecf2701b355397_0",
    "UID": "403",
    "code": "AP_DECLARE(int) test_snippet\n{\n    if (set_group_privs()) {\n        return -1;\n    }\n\n    if (NULL != unixd_config.chroot_dir) {\n        if (geteuid()) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"Cannot chroot when not started as root\");\n            return -1;\n        }\n        if (chdir(unixd_config.chroot_dir) != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"Can't chdir to %s\", unixd_config.chroot_dir);\n            return -1;\n        }\n        if (chroot(unixd_config.chroot_dir) != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"Can't chroot to %s\", unixd_config.chroot_dir);\n            return -1;\n        }\n        if (chdir(\"/\") != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"Can't chdir to new root\");\n            return -1;\n        }\n    }\n\n#ifdef MPE\n    \n    if (geteuid() == 1 && unixd_config.user_id > 1) {\n        GETPRIVMODE();\n        if (setuid(unixd_config.user_id) == -1) {\n            GETUSERMODE();\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setuid: unable to change to uid: %ld\",\n                        (long) unixd_config.user_id);\n            exit(1);\n        }\n        GETUSERMODE();\n    }\n#else\n    \n    if (!geteuid() && (\n#ifdef _OSD_POSIX\n        os_init_job_environment(NULL, unixd_config.user_name, ap_exists_config_define(\"DEBUG\")) != 0 ||\n#endif\n        setuid(unixd_config.user_id) == -1)) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                    \"setuid: unable to change to uid: %ld\",\n                    (long) unixd_config.user_id);\n        return -1;\n    }\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n    \n#ifdef AP_MPM_WANT_SET_COREDUMPDIR\n    if (ap_coredumpdir_configured) {\n        if (prctl(PR_SET_DUMPABLE, 1)) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"set dumpable failed - this child will not coredump\"\n                         \" after software errors\");\n        }\n    }\n#endif\n#endif\n#endif\n    return 0;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_5a68ddfff4bc8c4cc008beb0c22d9b6f5f578660_0", {
    "ID": "httpd_5a68ddfff4bc8c4cc008beb0c22d9b6f5f578660_0",
    "UID": "404",
    "code": "static void generate_salt(char *s, size_t test_snippet\n{\n    static unsigned char tbl[] = \n        \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    size_t i;\n    for (i = 0; i < size; ++i) {\n        int idx = (int) (64.0 * rand() / (RAND_MAX + 1.0));\n        s[i] = tbl[idx];\n    }\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
  },
  "httpd_c0e11914743b58a26bb82d881cec1578fda8cabe_0", {
    "ID": "httpd_c0e11914743b58a26bb82d881cec1578fda8cabe_0",
    "UID": "408",
    "code": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_off_t totalread;\n    int http_error = HTTP_REQUEST_ENTITY_TOO_LARGE;\n    apr_bucket_brigade *bb;\n\n    \n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n        ctx->pos = ctx->chunk_ln;\n        ctx->bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        bb = ctx->bb;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (!strcasecmp(tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n            \n            else if (!lenp) {\n                /* Something that isn't in HTTP, unless some future\n                 * edition defines new transfer ecodings, is unsupported.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Unknown Transfer-Encoding: %s\", tenc);\n                return bail_out_on_error(ctx, f, HTTP_NOT_IMPLEMENTED);\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r,\n                  \"Unknown Transfer-Encoding: %s; using Content-Length\", tenc);\n                tenc = NULL;\n            }\n        }\n        if (lenp && !tenc) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n            errno = 0;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. */\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                return bail_out_on_error(ctx, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                return bail_out_on_error(ctx, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        /* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. */\n        if ((ctx->state == BODY_CHUNK ||\n            (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&\n            f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1) &&\n            !(f->r->eos_sent || f->r->bytes_sent)) {\n            if (ap_is_HTTP_CLIENT_ERROR(f->r->status)) {\n                ctx->state = BODY_NONE;\n                ctx->eos_sent = 1;\n            } else {\n                char *tmp;\n\n                tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL, \" \",\n                                  ap_get_status_line(100), CRLF CRLF, NULL);\n                apr_brigade_cleanup(bb);\n                e = apr_bucket_pool_create(tmp, strlen(tmp), f->r->pool,\n                                           f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_HEAD(bb, e);\n                e = apr_bucket_flush_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n\n                ap_pass_brigade(f->c->output_filters, bb);\n            }\n        }\n\n        \n        if (ctx->state == BODY_CHUNK) {\n            apr_brigade_cleanup(bb);\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                block, 0);\n\n            \n            if (block == APR_NONBLOCK_READ &&\n                ( (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)) ||\n                  (APR_STATUS_IS_EAGAIN(rv)) )) {\n                ctx->state = BODY_CHUNK_PART;\n                return APR_EAGAIN;\n            }\n\n            if (rv == APR_SUCCESS) {\n                rv = get_chunk_line(ctx, bb, f->r->server->limit_req_line);\n                if (APR_STATUS_IS_EAGAIN(rv)) {\n                    apr_brigade_cleanup(bb);\n                    ctx->state = BODY_CHUNK_PART;\n                    return rv;\n                }\n                if (rv == APR_SUCCESS) {\n                    ctx->remaining = get_chunk_size(ctx->chunk_ln);\n                    if (ctx->remaining == INVALID_CHAR) {\n                        rv = APR_EGENERAL;\n                        http_error = HTTP_SERVICE_UNAVAILABLE;\n                    }\n                }\n            }\n            apr_brigade_cleanup(bb);\n\n            \n            if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                ctx->remaining = 0; /* Reset it in case we have to\n                                     * come back here later */\n                return bail_out_on_error(ctx, f, http_error);\n            }\n\n            if (!ctx->remaining) {\n                \n                ctx->state = BODY_NONE;\n                ap_get_mime_headers(f->r);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n                return APR_SUCCESS;\n            }\n        }\n    }\n    else {\n        bb = ctx->bb;\n    }\n\n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->remaining) {\n        switch (ctx->state) {\n        case BODY_NONE:\n            break;\n        case BODY_LENGTH:\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        case BODY_CHUNK:\n        case BODY_CHUNK_PART:\n            {\n                apr_brigade_cleanup(bb);\n\n                \n                if (ctx->state == BODY_CHUNK) {\n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        block, 0);\n                    if (block == APR_NONBLOCK_READ &&\n                        ( (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)) ||\n                          (APR_STATUS_IS_EAGAIN(rv)) )) {\n                        return APR_EAGAIN;\n                    }\n                    /*\n                     * We really don't care whats on this line. If it is RFC\n                     * compliant it should be only \\r\\n. If there is more\n                     * before we just ignore it as long as we do not get over\n                     * the limit for request lines.\n                     */\n                    rv = get_remaining_chunk_line(ctx, bb,\n                                                  f->r->server->limit_req_line);\n                    apr_brigade_cleanup(bb);\n                    if (APR_STATUS_IS_EAGAIN(rv)) {\n                        return rv;\n                    }\n                } else {\n                    rv = APR_SUCCESS;\n                }\n\n                if (rv == APR_SUCCESS) {\n                    \n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        block, 0);\n                    \n                    if (block == APR_NONBLOCK_READ &&\n                        ( (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)) ||\n                          (APR_STATUS_IS_EAGAIN(rv)) )) {\n                        ctx->state = BODY_CHUNK_PART;\n                        return APR_EAGAIN;\n                    }\n                    ctx->state = BODY_CHUNK;\n                    if (rv == APR_SUCCESS) {\n                        rv = get_chunk_line(ctx, bb, f->r->server->limit_req_line);\n                        if (APR_STATUS_IS_EAGAIN(rv)) {\n                            ctx->state = BODY_CHUNK_PART;\n                            apr_brigade_cleanup(bb);\n                            return rv;\n                        }\n                        if (rv == APR_SUCCESS) {\n                            ctx->remaining = get_chunk_size(ctx->chunk_ln);\n                            if (ctx->remaining == INVALID_CHAR) {\n                                rv = APR_EGENERAL;\n                                http_error = HTTP_SERVICE_UNAVAILABLE;\n                            }\n                        }\n                    }\n                    apr_brigade_cleanup(bb);\n                }\n\n                \n                if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                    ctx->remaining = 0; /* Reset it in case we have to\n                                         * come back here later */\n                    bail_out_on_error(ctx, f, http_error);\n                    return rv;\n                }\n\n                if (!ctx->remaining) {\n                    \n                    ctx->state = BODY_NONE;\n                    ap_get_mime_headers(f->r);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    ctx->eos_sent = 1;\n                    return APR_SUCCESS;\n                }\n            }\n            break;\n        }\n    }\n\n    \n    if (ctx->state == BODY_LENGTH || ctx->state == BODY_CHUNK) {\n        if (ctx->remaining < readbytes) {\n            readbytes = ctx->remaining;\n        }\n        AP_DEBUG_ASSERT(readbytes > 0);\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \n    apr_brigade_length(b, 0, &totalread);\n\n    /* If this happens, we have a bucket of unknown length.  Die because\n     * it means our assumptions have changed. */\n    AP_DEBUG_ASSERT(totalread >= 0);\n\n    if (ctx->state != BODY_NONE) {\n        ctx->remaining -= totalread;\n    }\n\n    /* If we have no more bytes remaining on a C-L request,\n     * save the callter a roundtrip to discover EOS.\n     */\n    if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n    }\n\n    \n    if (ctx->limit) {\n        /* FIXME: Note that we might get slightly confused on chunked inputs\n         * as we'd need to compensate for the chunk lengths which may not\n         * really count.  This seems to be up for interpretation.  */\n        ctx->limit_used += totalread;\n        if (ctx->limit < ctx->limit_used) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Read content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\n            apr_brigade_cleanup(bb);\n            e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                       f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ctx->eos_sent = 1;\n            return ap_pass_brigade(f->r->output_filters, bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_2c97f8bd44ecc4ae192ada16e03db37398530a0d_0", {
    "ID": "httpd_2c97f8bd44ecc4ae192ada16e03db37398530a0d_0",
    "UID": "409",
    "code": "static void child_main(int test_snippet\n{\n    apr_pool_t *ptrans;\n    apr_allocator_t *allocator;\n    apr_status_t status;\n    int i;\n    ap_listen_rec *lr;\n    apr_pollset_t *pollset;\n    ap_sb_handle_t *sbh;\n    apr_bucket_alloc_t *bucket_alloc;\n    int last_poll_idx = 0;\n\n    mpm_state = AP_MPMQ_STARTING; /* for benefit of any hooks that run as this\n                                   * child initializes\n                                   */\n\n    my_child_num = child_num_arg;\n    ap_my_pid = getpid();\n    requests_this_child = 0;\n\n    ap_fatal_signal_child_setup(ap_server_conf);\n\n    /* Get a sub context for global allocations in this child, so that\n     * we can have cleanups occur when the child exits.\n     */\n    apr_allocator_create(&allocator);\n    apr_allocator_max_free_set(allocator, ap_max_mem_free);\n    apr_pool_create_ex(&pchild, pconf, NULL, allocator);\n    apr_allocator_owner_set(allocator, pchild);\n    apr_pool_tag(pchild, \"pchild\");\n\n    apr_pool_create(&ptrans, pchild);\n    apr_pool_tag(ptrans, \"transaction\");\n\n    \n    ap_reopen_scoreboard(pchild, NULL, 0);\n    status = apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);\n    if (status != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,\n                     \"Couldn't initialize cross-process lock in child \"\n                     \"(%s) (%d)\", ap_lock_fname, ap_accept_lock_mech);\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (unixd_setup_child()) {\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    ap_run_child_init(pchild, ap_server_conf);\n\n    ap_create_sb_handle(&sbh, pchild, my_child_num, 0);\n\n    (void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);\n\n    \n    \n    (void) apr_pollset_create(&pollset, num_listensocks, pchild, 0);\n\n    for (lr = ap_listeners, i = num_listensocks; i--; lr = lr->next) {\n        apr_pollfd_t pfd = { 0 };\n\n        pfd.desc_type = APR_POLL_SOCKET;\n        pfd.desc.s = lr->sd;\n        pfd.reqevents = APR_POLLIN;\n        pfd.client_data = lr;\n\n        \n        (void) apr_pollset_add(pollset, &pfd);\n    }\n\n    mpm_state = AP_MPMQ_RUNNING;\n\n    bucket_alloc = apr_bucket_alloc_create(pchild);\n\n    /* die_now is set when AP_SIG_GRACEFUL is received in the child;\n     * shutdown_pending is set when SIGTERM is received when running\n     * in single process mode.  */\n    while (!die_now && !shutdown_pending) {\n        conn_rec *current_conn;\n        void *csd;\n\n        /*\n         * (Re)initialize this child to a pre-connection state.\n         */\n\n        apr_pool_clear(ptrans);\n\n        if ((ap_max_requests_per_child > 0\n             && requests_this_child++ >= ap_max_requests_per_child)) {\n            clean_child_exit(0);\n        }\n\n        (void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);\n\n        /*\n         * Wait for an acceptable connection to arrive.\n         */\n\n        \n        SAFE_ACCEPT(accept_mutex_on());\n\n        if (num_listensocks == 1) {\n            \n            lr = ap_listeners;\n        }\n        else {\n            \n            for (;;) {\n                apr_int32_t numdesc;\n                const apr_pollfd_t *pdesc;\n\n                \n                status = apr_pollset_poll(pollset, -1, &numdesc, &pdesc);\n                if (status != APR_SUCCESS) {\n                    if (APR_STATUS_IS_EINTR(status)) {\n                        if (one_process && shutdown_pending) {\n                            return;\n                        }\n                        else if (die_now) {\n                            /* In graceful stop/restart; drop the mutex\n                             * and terminate the child. */\n                            SAFE_ACCEPT(accept_mutex_off());\n                            clean_child_exit(0);\n                        }\n                        continue;\n                    }\n                    /* Single Unix documents select as returning errnos\n                     * EBADF, EINTR, and EINVAL... and in none of those\n                     * cases does it make sense to continue.  In fact\n                     * on Linux 2.0.x we seem to end up with EFAULT\n                     * occasionally, and we'd loop forever due to it.\n                     */\n                    ap_log_error(APLOG_MARK, APLOG_ERR, status,\n                                 ap_server_conf, \"apr_pollset_poll: (listen)\");\n                    SAFE_ACCEPT(accept_mutex_off());\n                    clean_child_exit(1);\n                }\n\n                /* We can always use pdesc[0], but sockets at position N\n                 * could end up completely starved of attention in a very\n                 * busy server. Therefore, we round-robin across the\n                 * returned set of descriptors. While it is possible that\n                 * the returned set of descriptors might flip around and\n                 * continue to starve some sockets, we happen to know the\n                 * internal pollset implementation retains ordering\n                 * stability of the sockets. Thus, the round-robin should\n                 * ensure that a socket will eventually be serviced.\n                 */\n                if (last_poll_idx >= numdesc)\n                    last_poll_idx = 0;\n\n                /* Grab a listener record from the client_data of the poll\n                 * descriptor, and advance our saved index to round-robin\n                 * the next fetch.\n                 *\n                 * ### hmm... this descriptor might have POLLERR rather\n                 * ### than POLLIN\n                 */\n                lr = pdesc[last_poll_idx++].client_data;\n                goto got_fd;\n            }\n        }\n    got_fd:\n        /* if we accept() something we don't want to die, so we have to\n         * defer the exit\n         */\n        status = lr->accept_func(&csd, lr, ptrans);\n\n        SAFE_ACCEPT(accept_mutex_off());      \n\n        if (status == APR_EGENERAL) {\n            \n            clean_child_exit(1);\n        }\n        else if (status != APR_SUCCESS) {\n            continue;\n        }\n\n        /*\n         * We now have a connection, so set it up with the appropriate\n         * socket options, file descriptors, and read/write buffers.\n         */\n\n        current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd, my_child_num, sbh, bucket_alloc);\n        if (current_conn) {\n            ap_process_connection(current_conn, csd);\n            ap_lingering_close(current_conn);\n        }\n\n        /* Check the pod and the generation number after processing a\n         * connection so that we'll go away if a graceful restart occurred\n         * while we were processing the connection or we are the lucky\n         * idle server process that gets to die.\n         */\n        if (ap_mpm_pod_check(pod) == APR_SUCCESS) { \n            die_now = 1;\n        }\n        else if (ap_my_generation !=\n                 ap_scoreboard_image->global->running_generation) { \n            /* yeah, this could be non-graceful restart, in which case the\n             * parent will kill us soon enough, but why bother checking?\n             */\n            die_now = 1;\n        }\n    }\n    clean_child_exit(0);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_19ca40469617950ac465cabd483878f6dc79f2bf_0", {
    "ID": "httpd_19ca40469617950ac465cabd483878f6dc79f2bf_0",
    "UID": "411",
    "code": "static int make_child(server_rec *s, int test_snippet\n{\n    int pid;\n\n    if (slot + 1 > ap_max_daemons_limit) {\n        ap_max_daemons_limit = slot + 1;\n    }\n\n    if (one_process) {\n        apr_signal(SIGHUP, sig_term);\n        \n        apr_signal(SIGINT, sig_term);\n#ifdef SIGQUIT\n        apr_signal(SIGQUIT, SIG_DFL);\n#endif\n        apr_signal(SIGTERM, sig_term);\n        child_main(test_snippet;\n        return 0;\n    }\n\n    (void) ap_update_child_status_from_indexes(slot, 0, SERVER_STARTING,\n                                               (request_rec *) NULL);\n\n\n#ifdef _OSD_POSIX\n    \n    if ((pid = os_fork(unixd_config.user_name)) == -1) {\n#elif defined(TPF)\n    if ((pid = os_fork(s, test_snippet) == -1) {\n#else\n    if ((pid = fork()) == -1) {\n#endif\n        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, \"fork: Unable to fork new process\");\n\n        /* fork didn't succeed. Fix the scoreboard or else\n         * it will say SERVER_STARTING forever and ever\n         */\n        (void) ap_update_child_status_from_indexes(slot, 0, SERVER_DEAD,\n                                                   (request_rec *) NULL);\n\n        /* In case system resources are maxxed out, we don't want\n         * Apache running away with the CPU trying to fork over and\n         * over and over again.\n         */\n        sleep(10);\n\n        return -1;\n    }\n\n    if (!pid) {\n#ifdef HAVE_BINDPROCESSOR\n        /* by default AIX binds to a single processor\n         * this bit unbinds children which will then bind to another cpu\n         */\n        int status = bindprocessor(BINDPROCESS, (int)getpid(),\n                                   PROCESSOR_CLASS_ANY);\n        if (status != OK) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,\n                         ap_server_conf, \"processor unbind failed %d\", status);\n        }\n#endif\n        RAISE_SIGSTOP(MAKE_CHILD);\n        AP_MONCONTROL(1);\n        /* Disable the parent's signal handlers and set up proper handling in\n         * the child.\n         */\n        apr_signal(SIGHUP, just_die);\n        apr_signal(SIGTERM, just_die);\n        /* The child process just closes listeners on AP_SIG_GRACEFUL.\n         * The pod is used for signalling the graceful restart.\n         */\n        apr_signal(AP_SIG_GRACEFUL, stop_listening);\n        child_main(test_snippet;\n    }\n\n    ap_scoreboard_image->parent[slot].pid = pid;\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n"
  },
  "httpd_ec1bcd2a8d143c8ee0c8776511586d34a38c981e_0", {
    "ID": "httpd_ec1bcd2a8d143c8ee0c8776511586d34a38c981e_0",
    "UID": "415",
    "code": "apr_status_t ap_kept_body_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                                 ap_input_mode_t mode, apr_read_type_e block,\n                                 apr_off_t readbytes) {\n    request_rec *r = f->r;\n    apr_bucket_brigade *kept_body = r->kept_body;\n    kept_body_ctx_t *ctx = f->ctx;\n    apr_bucket *ec, *e2;\n    apr_status_t rv;\n\n    \n    if (!kept_body || (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE)) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    \n    if (!ctx) {\n        f->ctx = ctx = apr_palloc(f->r->pool, sizeof(*ctx));\n        ctx->offset = 0;\n        apr_brigade_length(kept_body, 1, &ctx->remaining);\n    }\n\n    \n    if (ctx->remaining <= 0) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    \n    if (readbytes > ctx->remaining) {\n        readbytes = ctx->remaining;\n    }\n\n    \n    if ((rv = apr_brigade_partition(kept_body, ctx->offset, &ec)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                      \"apr_brigade_partition() failed on kept_body at %\" APR_OFF_T_FMT, ctx->offset);\n        return rv;\n    }\n    if ((rv = apr_brigade_partition(kept_body, ctx->offset + readbytes, &e2)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                      \"apr_brigade_partition() failed on kept_body at %\" APR_OFF_T_FMT, ctx->offset + readbytes);\n        return rv;\n    }\n \n    do {\n        apr_bucket *foo;\n        const char *str;\n        apr_size_t len;\n\n        if (apr_bucket_copy(ec, &foo) != APR_SUCCESS) {\n            /* As above; this should not fail since the bucket has\n             * a known length, but just to be sure, this takes\n             * care of uncopyable buckets that do somehow manage\n             * to slip through.  */\n            \n            apr_bucket_read(ec, &str, &len, APR_BLOCK_READ);\n            apr_bucket_copy(ec, &foo);\n        }\n        APR_BRIGADE_INSERT_TAIL(b, foo);\n        ec = APR_BUCKET_NEXT(ec);\n    } while (ec != e2);\n\n    ctx->remaining -= readbytes;\n    ctx->offset += readbytes;\n    return APR_SUCCESS;\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_2700fcc34a86560d232e1d884aa42bde3617bf93_0", {
    "ID": "httpd_2700fcc34a86560d232e1d884aa42bde3617bf93_0",
    "UID": "419",
    "code": "static int open_listeners(apr_pool_t test_snippet\n{\n    ap_listen_rec *lr;\n    ap_listen_rec *next;\n    ap_listen_rec *previous;\n    int num_open;\n    const char *userdata_key = \"ap_open_listeners\";\n    void *data;\n\n    /* Don't allocate a default listener.  If we need to listen to a\n     * port, then the user needs to have a Listen directive in their\n     * config file.\n     */\n    num_open = 0;\n    previous = NULL;\n    for (lr = ap_listeners; lr; previous = lr, lr = lr->next) {\n        if (lr->active) {\n            ++num_open;\n        }\n        else {\n#if APR_HAVE_IPV6\n            int v6only_setting;\n\n            /* If we have the unspecified IPv4 address (0.0.0.0) and\n             * the unspecified IPv6 address (::) is next, we need to\n             * swap the order of these in the list. We always try to\n             * bind to IPv6 first, then IPv4, since an IPv6 socket\n             * might be able to receive IPv4 packets if V6ONLY is not\n             * enabled, but never the other way around. */\n            if (lr->next != NULL\n                && IS_INADDR_ANY(lr->bind_addr)\n                && lr->bind_addr->port == lr->next->bind_addr->port\n                && IS_IN6ADDR_ANY(lr->next->bind_addr)) {\n                \n                next = lr->next;\n                lr->next = next->next;\n                next->next = lr;\n                if (previous) {\n                    previous->next = next;\n                }\n                else {\n                    ap_listeners = next;\n                }\n                lr = next;\n            }\n\n            /* If we are trying to bind to 0.0.0.0 and the previous listener\n             * was :: on the same port and in turn that socket does not have\n             * the IPV6_V6ONLY flag set; we must skip the current attempt to\n             * listen (which would generate an error). IPv4 will be handled\n             * on the established IPv6 socket.\n             */\n            if (previous != NULL\n                && IS_INADDR_ANY(lr->bind_addr)\n                && lr->bind_addr->port == previous->bind_addr->port\n                && IS_IN6ADDR_ANY(previous->bind_addr)\n                && apr_socket_opt_get(previous->sd, APR_IPV6_V6ONLY,\n                                      &v6only_setting) == APR_SUCCESS\n                && v6only_setting == 0) {\n\n                \n                previous->next = lr->next;\n                continue;\n            }\n#endif\n            if (make_sock(pool, lr) == APR_SUCCESS) {\n                ++num_open;\n                lr->active = 1;\n            }\n            else {\n#if APR_HAVE_IPV6\n                /* If we tried to bind to ::, and the next listener is\n                 * on 0.0.0.0 with the same port, don't give a fatal\n                 * error. The user will still get a warning from make_sock\n                 * though.\n                 */\n                if (lr->next != NULL\n                    && IS_IN6ADDR_ANY(lr->bind_addr)\n                    && lr->bind_addr->port == lr->next->bind_addr->port\n                    && IS_INADDR_ANY(lr->next->bind_addr)) {\n\n                    \n                    if (previous) {\n                        previous->next = lr->next;\n                    }\n                    else {\n                        ap_listeners = lr->next;\n                    }\n\n                    /* Although we've removed ourselves from the list,\n                     * we need to make sure that the next iteration won't\n                     * consider \"previous\" a working IPv6 '::' socket.\n                     * Changing the family is enough to make sure the\n                     * conditions before make_sock() fail.\n                     */\n                    lr->bind_addr->family = AF_INET;\n\n                    continue;\n                }\n#endif\n                \n                return -1;\n            }\n        }\n    }\n\n    \n    for (lr = old_listeners; lr; lr = next) {\n        apr_socket_close(lr->sd);\n        lr->active = 0;\n        next = lr->next;\n    }\n    old_listeners = NULL;\n\n#if AP_NONBLOCK_WHEN_MULTI_LISTEN\n    /* if multiple listening sockets, make them non-blocking so that\n     * if select()/poll() reports readability for a reset connection that\n     * is already forgotten about by the time we call accept, we won't\n     * be hung until another connection arrives on that port\n     */\n    if (ap_listeners && ap_listeners->next) {\n        for (lr = ap_listeners; lr; lr = lr->next) {\n            apr_status_t status;\n\n            status = apr_socket_opt_set(lr->sd, APR_SO_NONBLOCK, 1);\n            if (status != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, pool,\n                              \"unable to make listening socket non-blocking\");\n                return -1;\n            }\n        }\n    }\n#endif \n\n    /* we come through here on both passes of the open logs phase\n     * only register the cleanup once... otherwise we try to close\n     * listening sockets twice when cleaning up prior to exec\n     */\n    apr_pool_userdata_get(&data, userdata_key, pool);\n    if (!data) {\n        apr_pool_userdata_set((const void *)1, userdata_key,\n                              apr_pool_cleanup_null, pool);\n        apr_pool_cleanup_register(pool, NULL, apr_pool_cleanup_null,\n                                  close_listeners_on_exec);\n    }\n\n    return num_open ? 0 : -1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_cdb516a6aba6a3e4c0643c32118b44fa089bb5b2_0", {
    "ID": "httpd_cdb516a6aba6a3e4c0643c32118b44fa089bb5b2_0",
    "UID": "427",
    "code": "AP_DECLARE(char *) ap_make_etag(request_rec *r, int test_snippet\n{\n    char *weak;\n    apr_size_t weak_len;\n    char *etag;\n    char *next;\n    core_dir_config *cfg;\n    etag_components_t etag_bits;\n    etag_components_t bits_added;\n\n    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                  &core_module);\n    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;\n\n    /*\n     * If it's a file (or we wouldn't be here) and no ETags\n     * should be set for files, return an empty string and\n     * note it for the header-sender to ignore.\n     */\n    if (etag_bits & ETAG_NONE) {\n        apr_table_setn(r->notes, \"no-etag\", \"omit\");\n        return \"\";\n    }\n\n    if (etag_bits == ETAG_UNSET) {\n        etag_bits = ETAG_BACKWARD;\n    }\n    /*\n     * Make an ETag header out of various pieces of information. We use\n     * the last-modified date and, if we have a real file, the\n     * length and inode number - note that this doesn't have to match\n     * the content-length (i.e. includes), it just has to be unique\n     * for the file.\n     *\n     * If the request was made within a second of the last-modified date,\n     * we send a weak tag instead of a strong one, since it could\n     * be modified again later in the second, and the validation\n     * would be incorrect.\n     */\n    if ((r->request_time - r->mtime > (1 * APR_USEC_PER_SEC)) &&\n        !test_snippet {\n        weak = NULL;\n        weak_len = 0;\n    }\n    else {\n        weak = ETAG_WEAK;\n        weak_len = sizeof(ETAG_WEAK);\n    }\n\n    if (r->finfo.filetype != 0) {\n        /*\n         * ETag gets set to [W/]\"inode-size-mtime\", modulo any\n         * FileETag keywords.\n         */\n        etag = apr_palloc(r->pool, weak_len + sizeof(\"\\\"--\\\"\") +\n                          3 * CHARS_PER_UINT64 + 1);\n        next = etag;\n        if (weak) {\n            while (*weak) {\n                *next++ = *weak++;\n            }\n        }\n        *next++ = '\"';\n        bits_added = 0;\n        if (etag_bits & ETAG_INODE) {\n            next = etag_uint64_to_hex(next, r->finfo.inode);\n            bits_added |= ETAG_INODE;\n        }\n        if (etag_bits & ETAG_SIZE) {\n            if (bits_added != 0) {\n                *next++ = '-';\n            }\n            next = etag_uint64_to_hex(next, r->finfo.size);\n            bits_added |= ETAG_SIZE;\n        }\n        if (etag_bits & ETAG_MTIME) {\n            if (bits_added != 0) {\n                *next++ = '-';\n            }\n            next = etag_uint64_to_hex(next, r->mtime);\n        }\n        *next++ = '\"';\n        *next = '\\0';\n    }\n    else {\n        /*\n         * Not a file document, so just use the mtime: [W/]\"mtime\"\n         */\n        etag = apr_palloc(r->pool, weak_len + sizeof(\"\\\"\\\"\") +\n                          CHARS_PER_UINT64 + 1);\n        next = etag;\n        if (weak) {\n            while (*weak) {\n                *next++ = *weak++;\n            }\n        }\n        *next++ = '\"';\n        next = etag_uint64_to_hex(next, r->mtime);\n        *next++ = '\"';\n        *next = '\\0';\n    }\n\n    return etag;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_0bd836a4d75583333df27dbbcd5c952831f0e2e5_0", {
    "ID": "httpd_0bd836a4d75583333df27dbbcd5c952831f0e2e5_0",
    "UID": "434",
    "code": "static authz_status user_check_authorization(request_rec test_snippet\n                                             const char *require_args)\n{\n    const char *t, *w;\n\n    t = require_args;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        if (!strcmp(r->user, w)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"access to %s failed, reason: user '%s' does not meet \"\n                  \"'require'ments for user to be allowed access\",\n                  r->uri, r->user);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_6a47ee16c0589d251b0698bfe869614dfde0b7c2_0", {
    "ID": "httpd_6a47ee16c0589d251b0698bfe869614dfde0b7c2_0",
    "UID": "436",
    "code": "static int check_user_access(request_rec test_snippet\n{\n    authz_default_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                 &authz_default_module);\n    const char *note = apr_table_get(r->notes, AUTHZ_ACCESS_PASSED_NOTE);\n\n    \n    if (note && (note[0] == 'Y') && (ap_satisfies(r) == SATISFY_ANY)) {\n        return OK;\n    }\n\n    \n    if (!ap_some_auth_required(r)) {\n        return OK;\n    }\n\n    if (!(conf->authoritative)) {\n        return DECLINED;\n    }\n\n    /* if we aren't authoritative, any require directive could be\n     * considered valid even if noone groked it.  However, if we are\n     * authoritative, we can warn the user they did something wrong.\n     *\n     * That something could be a missing \"AuthAuthoritative off\", but\n     * more likely is a typo in the require directive.\n     */\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"access to %s failed, reason: require directives \"\n                          \"present and no Authoritative handler.\", r->uri);\n\n    ap_note_auth_failure(r);\n    return HTTP_UNAUTHORIZED;\n}",
    "predicted": "This code does not appear to have any specific vulnerabilities from the provided list. Therefore, the response is null."
  },
  "httpd_f31f194056fa860d9c461fc083b098c96a150cc8_0", {
    "ID": "httpd_f31f194056fa860d9c461fc083b098c96a150cc8_0",
    "UID": "437",
    "code": "static authz_status env_check_authorization(request_rec *r, const char test_snippet\n{\n    const char *t, *w;\n\n    /* The 'env' provider will allow the configuration to specify a list of\n        env variables to check rather than a single variable.  This is different\n        from the previous host based syntax. */\n    t = require_line;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        if (apr_table_get(r->subprocess_env, w)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"access to %s failed, reason: env variable list does not meet \"\n                  \"'require'ments for user '%s' to be allowed access\",\n                  r->uri, r->user);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "This code does not appear to have any specific vulnerabilities based on the provided list. Therefore, the response is null."
  },
  "httpd_0344a158d933e72c6c2f9240325660395158d6ad_0", {
    "ID": "httpd_0344a158d933e72c6c2f9240325660395158d6ad_0",
    "UID": "438",
    "code": "static void *merge_authn_core_dir_config(apr_pool_t *a, void *basev, void test_snippet\n{\n    authn_core_dir_conf *base = (authn_core_dir_conf *)basev;\n    authn_core_dir_conf *new = (authn_core_dir_conf *)newv;\n    authn_core_dir_conf *conf;\n\n    /* Create this conf by duplicating the base, replacing elements\n    * (or creating copies for merging) where new-> values exist.\n    */\n    conf = (authn_core_dir_conf *)apr_palloc(a, sizeof(authn_core_dir_conf));\n    memcpy(conf, base, sizeof(authn_core_dir_conf));\n\n    if (new->ap_auth_type) {\n        conf->ap_auth_type = new->ap_auth_type;\n    }\n\n    if (new->ap_auth_name) {\n        conf->ap_auth_name = new->ap_auth_name;\n    }\n\n    return (void*)conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f995600648d39ed7ed73bdd7528b854d1b908384_0", {
    "ID": "httpd_f995600648d39ed7ed73bdd7528b854d1b908384_0",
    "UID": "440",
    "code": "AP_CORE_DECLARE(ap_conf_vector_t *) ap_merge_per_dir_configs(apr_pool_t test_snippet\n                                           ap_conf_vector_t *base,\n                                           ap_conf_vector_t *new_conf)\n{\n    void **conf_vector = apr_palloc(p, sizeof(void *) * total_modules);\n    void **base_vector = (void **)base;\n    void **new_vector = (void **)new_conf;\n    module *modp;\n\n    for (modp = ap_top_module; modp; modp = modp->next) {\n        int i = modp->module_index;\n\n        if (!new_vector[i]) {\n            conf_vector[i] = base_vector[i];\n        }\n        else {\n            merger_func df = modp->merge_dir_config;\n            if (df && base_vector[i]) {\n                conf_vector[i] = (*df)(p, base_vector[i], new_vector[i]);\n            }\n            else\n                conf_vector[i] = new_vector[i];\n        }\n    }\n\n    return (ap_conf_vector_t *)conf_vector;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_f2a898c782b4abafa0d3715c35c06a2e0a7532cd_0", {
    "ID": "httpd_f2a898c782b4abafa0d3715c35c06a2e0a7532cd_0",
    "UID": "441",
    "code": "static authz_status ip_check_authorization(request_rec *r, const char test_snippet\n{\n    const char *t, *w;\n\n    /* The 'ip' provider will allow the configuration to specify a list of\n        ip addresses to check rather than a single address.  This is different\n        from the previous host based syntax. */\n    t = require_line;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        char *where = apr_pstrdup(r->pool, w);\n        char *s;\n        char msgbuf[120];\n        apr_ipsubnet_t *ip;\n        apr_status_t rv;\n        int got_ip = 0;\n\n        if ((s = ap_strchr(where, '/'))) {\n            *s++ = '\\0';\n            rv = apr_ipsubnet_create(&ip, where, s, r->pool);\n            if(APR_STATUS_IS_EINVAL(rv)) {\n                \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"an ip address 'require' list appears to be invalid \");\n            }\n            else if (rv != APR_SUCCESS) {\n                apr_strerror(rv, msgbuf, sizeof msgbuf);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"an ip address 'require' list appears to be invalid; %s \",\n                              msgbuf);\n            }\n            else\n                got_ip = 1;\n        }\n        else if (!APR_STATUS_IS_EINVAL(rv = apr_ipsubnet_create(&ip, where,\n                                                                NULL, r->pool))) {\n            if (rv != APR_SUCCESS) {\n                apr_strerror(rv, msgbuf, sizeof msgbuf);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"an ip address 'require' list appears to be invalid; %s \",\n                              msgbuf);\n            }\n            else \n                got_ip = 1;\n        }\n\n        if (got_ip && apr_ipsubnet_test(ip, r->connection->remote_addr)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"access to %s failed, reason: ip address list does not meet \"\n                  \"'require'ments for user '%s' to be allowed access\",\n                  r->uri, r->user);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2f91f7591fd382a539f3729cbd0022a76d2a9dd2_0", {
    "ID": "httpd_2f91f7591fd382a539f3729cbd0022a76d2a9dd2_0",
    "UID": "444",
    "code": "static authz_status group_check_authorization(request_rec test_snippet\n                                             const char *require_args)\n{\n    authz_groupfile_config_rec *conf = ap_get_module_config(r->per_dir_config,\n            &authz_groupfile_module);\n    char *user = r->user;\n    const char *t, *w;\n    apr_table_t *grpstatus = NULL;\n    apr_status_t status;\n\n    /* If there is no group file - then we are not\n     * configured. So decline.\n     */\n    if (!(conf->groupfile)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                        \"No group file was specified in the configuration\");\n        return AUTHZ_DENIED;\n    }\n\n    status = groups_for_user(r->pool, user, conf->groupfile,\n                                &grpstatus);\n\n    if (status != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,\n                        \"Could not open group file: %s\",\n                        conf->groupfile);\n        return AUTHZ_DENIED;\n    }\n\n    if (apr_table_elts(grpstatus)->nelts == 0) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Authorization of user %s to access %s failed, reason: \"\n                      \"user doesn't appear in group file (%s).\",\n                      r->user, r->uri, conf->groupfile);\n        return AUTHZ_DENIED;\n    }\n\n    t = require_args;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        if (apr_table_get(grpstatus, w)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                    \"Authorization of user %s to access %s failed, reason: \"\n                    \"user is not part of the 'require'ed group(s).\",\n                    r->user, r->uri);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition"
  },
  "httpd_551215c464f999da202e896948dc510777f059cc_0", {
    "ID": "httpd_551215c464f999da202e896948dc510777f059cc_0",
    "UID": "448",
    "code": "static authz_status host_check_authorization(request_rec *r, const char test_snippet\n{\n    const char *t, *w;\n    const char *remotehost = NULL;\n    int remotehost_is_ip;\n\n    remotehost = ap_get_remote_host(r->connection,\n                                    r->per_dir_config,\n                                    REMOTE_DOUBLE_REV,\n                                    &remotehost_is_ip);\n\n    if ((remotehost == NULL) || remotehost_is_ip) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"access to %s failed, reason: unable to get the \"\n                      \"remote host name\", r->uri);\n    }\n    else {\n        /* The 'host' provider will allow the configuration to specify a list of\n            host names to check rather than a single name.  This is different\n            from the previous host based syntax. */\n        t = require_line;\n        while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n            if (in_domain(w, remotehost)) {\n                return AUTHZ_GRANTED;\n            }\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"access to %s failed, reason: host name list does not meet \"\n                      \"'require'ments for user '%s' to be allowed access\",\n                      r->uri, r->user);\n    }\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_60cf9590ce46af21a48b48d296be3c741e233689_0", {
    "ID": "httpd_60cf9590ce46af21a48b48d296be3c741e233689_0",
    "UID": "450",
    "code": "static char *substring_conf(apr_pool_t *p, const char *start, int test_snippet\n                            char quote)\n{\n    char *result = apr_palloc(p, len + 2);\n    char *resp = result;\n    int i;\n\n    for (i = 0; i < len; ++i) {\n        if (start[i] == '\\\\' && (start[i + 1] == '\\\\'\n                                 || (quote && start[i + 1] == quote)))\n            *resp++ = start[++i];\n        else\n            *resp++ = start[i];\n    }\n\n    *resp++ = '\\0';\n#if RESOLVE_ENV_PER_TOKEN\n    return (char *)ap_resolve_env(p,result);\n#else\n    return result;\n#endif\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read"
  },
  "httpd_c5379310e546a27304fcd66175046136b39b2d3c_0", {
    "ID": "httpd_c5379310e546a27304fcd66175046136b39b2d3c_0",
    "UID": "451",
    "code": "static const char *authaliassection(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    int old_overrides = cmd->override;\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *args;\n    char *provider_alias;\n    char *provider_name;\n    const char *errmsg;\n    ap_conf_vector_t *new_auth_config = ap_create_per_dir_config(cmd->pool);\n    authn_alias_srv_conf *authcfg =\n        (authn_alias_srv_conf *)ap_get_module_config(cmd->server->module_config,\n                                                     &authn_core_module);\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    args = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (!args[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive requires additional arguments\", NULL);\n    }\n\n    \n    provider_name = ap_getword_conf(cmd->pool, &args);\n    provider_alias = ap_getword_conf(cmd->pool, &args);\n\n    if (!provider_name[0] || !provider_alias[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive requires additional arguments\", NULL);\n    }\n\n    /* walk the subsection configuration to get the per_dir config that we will\n       merge just before the real provider is called. */\n    cmd->override = OR_ALL|ACCESS_CONF;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_auth_config);\n\n    if (!errmsg) {\n        provider_alias_rec *prvdraliasrec = apr_pcalloc(cmd->pool, sizeof(provider_alias_rec));\n        const authn_provider *provider = ap_lookup_provider(AUTHN_PROVIDER_GROUP, provider_name,\"0\");\n\n        /* Save off the new directory config along with the original provider name\n           and function pointer data */\n        prvdraliasrec->sec_auth = new_auth_config;\n        prvdraliasrec->provider_name = provider_name;\n        prvdraliasrec->provider_alias = provider_alias;\n        prvdraliasrec->provider = provider;\n        apr_hash_set(authcfg->alias_rec, provider_alias, APR_HASH_KEY_STRING, prvdraliasrec);\n\n        \n        ap_register_provider(cmd->pool, AUTHN_PROVIDER_GROUP, provider_alias, \"0\",\n                             &authn_alias_provider);\n    }\n\n    cmd->override = old_overrides;\n\n    return errmsg;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_aa199f1b87987b34c0fbafa1becaeb2f89895080_0", {
    "ID": "httpd_aa199f1b87987b34c0fbafa1becaeb2f89895080_0",
    "UID": "452",
    "code": "static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void test_snippet\n{\n    core_dir_config *base = (core_dir_config *)basev;\n    core_dir_config *new = (core_dir_config *)newv;\n    core_dir_config *conf;\n    int i;\n\n    /* Create this conf by duplicating the base, replacing elements\n     * (or creating copies for merging) where new-> values exist.\n     */\n    conf = (core_dir_config *)apr_palloc(a, sizeof(core_dir_config));\n    memcpy(conf, base, sizeof(core_dir_config));\n\n    conf->d = new->d;\n    conf->d_is_fnmatch = new->d_is_fnmatch;\n    conf->d_components = new->d_components;\n    conf->r = new->r;\n\n    if (new->opts & OPT_UNSET) {\n        /* there was no explicit setting of new->opts, so we merge\n         * preserve the invariant (opts_add & opts_remove) == 0\n         */\n        conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;\n        conf->opts_remove = (conf->opts_remove & ~new->opts_add)\n                            | new->opts_remove;\n        conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;\n        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {\n            conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;\n        }\n    }\n    else {\n        /* otherwise we just copy, because an explicit opts setting\n         * overrides all earlier +/- modifiers\n         */\n        conf->opts = new->opts;\n        conf->opts_add = new->opts_add;\n        conf->opts_remove = new->opts_remove;\n    }\n\n    if (!(new->override & OR_UNSET)) {\n        conf->override = new->override;\n    }\n\n    if (!(new->override_opts & OPT_UNSET)) {\n        conf->override_opts = new->override_opts;\n    }\n\n    if (new->ap_default_type) {\n        conf->ap_default_type = new->ap_default_type;\n    }\n\n    if (conf->response_code_strings == NULL) {\n        conf->response_code_strings = new->response_code_strings;\n    }\n    else if (new->response_code_strings != NULL) {\n        /* If we merge, the merge-result must have it's own array\n         */\n        conf->response_code_strings = apr_palloc(a,\n            sizeof(*conf->response_code_strings) * RESPONSE_CODES);\n        memcpy(conf->response_code_strings, base->response_code_strings,\n               sizeof(*conf->response_code_strings) * RESPONSE_CODES);\n\n        for (i = 0; i < RESPONSE_CODES; ++i) {\n            if (new->response_code_strings[i] != NULL) {\n                conf->response_code_strings[i] = new->response_code_strings[i];\n            }\n        }\n    }\n    /* Otherwise we simply use the base->response_code_strings array\n     */\n\n    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {\n        conf->hostname_lookups = new->hostname_lookups;\n    }\n\n    if ((new->content_md5 & 2) == 0) {\n        conf->content_md5 = new->content_md5;\n    }\n\n    if (new->accept_path_info != 3) {\n        conf->accept_path_info = new->accept_path_info;\n    }\n\n    if (new->use_canonical_name != USE_CANONICAL_NAME_UNSET) {\n        conf->use_canonical_name = new->use_canonical_name;\n    }\n\n    if (new->use_canonical_phys_port != USE_CANONICAL_PHYS_PORT_UNSET) {\n        conf->use_canonical_phys_port = new->use_canonical_phys_port;\n    }\n\n#ifdef RLIMIT_CPU\n    if (new->limit_cpu) {\n        conf->limit_cpu = new->limit_cpu;\n    }\n#endif\n\n#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)\n    if (new->limit_mem) {\n        conf->limit_mem = new->limit_mem;\n    }\n#endif\n\n#ifdef RLIMIT_NPROC\n    if (new->limit_nproc) {\n        conf->limit_nproc = new->limit_nproc;\n    }\n#endif\n\n    if (new->limit_req_body != AP_LIMIT_REQ_BODY_UNSET) {\n        conf->limit_req_body = new->limit_req_body;\n    }\n\n    if (new->limit_xml_body != AP_LIMIT_UNSET)\n        conf->limit_xml_body = new->limit_xml_body;\n    else\n        conf->limit_xml_body = base->limit_xml_body;\n\n    if (!conf->sec_file) {\n        conf->sec_file = new->sec_file;\n    }\n    else if (new->sec_file) {\n        /* If we merge, the merge-result must have it's own array\n         */\n        conf->sec_file = apr_array_append(a, base->sec_file, new->sec_file);\n    }\n    /* Otherwise we simply use the base->sec_file array\n     */\n\n    if (new->server_signature != srv_sig_unset) {\n        conf->server_signature = new->server_signature;\n    }\n\n    if (new->add_default_charset != ADD_DEFAULT_CHARSET_UNSET) {\n        conf->add_default_charset = new->add_default_charset;\n        conf->add_default_charset_name = new->add_default_charset_name;\n    }\n\n    /* Overriding all negotiation\n     */\n    if (new->mime_type) {\n        conf->mime_type = new->mime_type;\n    }\n\n    if (new->handler) {\n        conf->handler = new->handler;\n    }\n\n    if (new->output_filters) {\n        conf->output_filters = new->output_filters;\n    }\n\n    if (new->input_filters) {\n        conf->input_filters = new->input_filters;\n    }\n\n    if (conf->ct_output_filters && new->ct_output_filters) {\n        conf->ct_output_filters = apr_hash_merge(a,\n                                                 new->ct_output_filters,\n                                                 conf->ct_output_filters,\n                                                 merge_ct_filters,\n                                                 NULL);\n    }\n    else if (new->ct_output_filters) {\n        conf->ct_output_filters = apr_hash_copy(a, new->ct_output_filters);\n    }\n    else if (conf->ct_output_filters) {\n        \n        conf->ct_output_filters = apr_hash_copy(a, base->ct_output_filters);\n    }\n\n    /*\n     * Now merge the setting of the FileETag directive.\n     */\n    if (new->etag_bits == ETAG_UNSET) {\n        conf->etag_add =\n            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;\n        conf->etag_remove =\n            (conf->opts_remove & (~ new->etag_add)) | new->etag_remove;\n        conf->etag_bits =\n            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;\n    }\n    else {\n        conf->etag_bits = new->etag_bits;\n        conf->etag_add = new->etag_add;\n        conf->etag_remove = new->etag_remove;\n    }\n\n    if (conf->etag_bits != ETAG_NONE) {\n        conf->etag_bits &= (~ ETAG_NONE);\n    }\n\n    if (new->enable_mmap != ENABLE_MMAP_UNSET) {\n        conf->enable_mmap = new->enable_mmap;\n    }\n\n    if (new->enable_sendfile != ENABLE_SENDFILE_UNSET) {\n        conf->enable_sendfile = new->enable_sendfile;\n    }\n\n    conf->allow_encoded_slashes = new->allow_encoded_slashes;\n\n    return (void*)conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_93b4f9c954e65e5a38b47dd070cfea17a5cae98e_0", {
    "ID": "httpd_93b4f9c954e65e5a38b47dd070cfea17a5cae98e_0",
    "UID": "458",
    "code": "static const char *authz_require_section(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    int old_overrides = cmd->override;\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *args;\n    const char *errmsg;\n    authz_request_state old_reqstate;\n    authz_core_dir_conf *conf = (authz_core_dir_conf*)mconfig;\n\n    if (endp == NULL) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    args = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (args[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive doesn't take additional arguments\", NULL);\n    }\n\n    /* Save off the current request state so that we can go back to it after walking\n       the subsection.  Indicate a transition in the logic incrementing the level.\n       After the subsection walk the level will be decremented to indicate the\n       path to follow. As the require directives are read by the configuration\n       the req_state and the level will allow it to traverse the list to find\n       the last element in the provider calling list. */\n    old_reqstate = conf->req_state;\n    if (strcasecmp (cmd->directive->directive, \"<SatisfyAll\") == 0) {\n        conf->req_state = AUTHZ_REQSTATE_ALL;\n    }\n    else {\n        conf->req_state = AUTHZ_REQSTATE_ONE;\n    }\n    conf->req_state_level++;\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    /* walk the subsection configuration to get the per_dir config that we will\n       merge just before the real provider is called. */\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    conf->req_state_level--;\n    conf->req_state = old_reqstate;\n    cmd->override = old_overrides;\n\n    return errmsg;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n90,Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n123,Write-what-where Condition\n124,Buffer Underwrite ('Buffer Underflow')\n126,Buffer Over-read\n127,Buffer Under-read\n134,Use of Externally-Controlled Format String\n176,Improper Handling of Unicode Encoding\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n194,Unexpected Sign Extension\n195,Signed to Unsigned Conversion Error\n197,Numeric Truncation Error\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n272,Least Privilege Violation\n273,Improper Check for Dropped Privileges\n321,Use of Hard-coded Cryptographic Key\n338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n364,Signal Handler Race Condition\n366,Race Condition within a Thread\n369,Divide By Zero\n377,Insecure Temporary File\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n397,Declaration of Throws for Generic Exception\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n427,Uncontrolled Search Path Element\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n464,Addition of Data Structure Sentinel\n467,Use of sizeof() on a Pointer Type\n476,NULL Pointer Dereference\n479,Signal Handler Use of a Non-reentrant Function\n480,Use of Incorrect Operator\n511,Logic/Time Bomb\n526,Cleartext Storage of Sensitive Information in an Environment Variable\n546,Suspicious Comment\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n591,Sensitive Data Storage in Improperly Locked Memory\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n758,Reliance on Undefined\n761,Free of Pointer not at Start of Buffer\n762,Mismatched Memory Management Routines\n773,Missing Reference to Active File Descriptor or Handle\n775,Missing Release of File Descriptor or Handle after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_5935e6d7bcb790de468d7e7a521e289daf6ce746_0", {
    "ID": "httpd_5935e6d7bcb790de468d7e7a521e289daf6ce746_0",
    "UID": "460",
    "code": "static int authorize_user(request_rec test_snippet\n{\n    authz_core_dir_conf *conf = ap_get_module_config(r->per_dir_config,\n            &authz_core_module);\n    authz_status auth_result;\n    authz_provider_list *current_provider;\n    const char *note = apr_table_get(r->notes, AUTHZ_ACCESS_PASSED_NOTE);\n\n    \n    if (!conf->providers) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"no authorization providers configured\");\n        return DECLINED;\n    }\n\n    current_provider = conf->providers;\n\n    auth_result = check_provider_list (r, current_provider, 0);\n\n    if (auth_result != AUTHZ_GRANTED) {\n        int return_code;\n\n        switch (auth_result) {\n            case AUTHZ_DENIED:\n                /* XXX If the deprecated Satisfy directive is set to anything\n                   but ANY a failure in access control or authz will cause\n                   an HTTP_UNAUTHORIZED.  Just the if statement\n                   should be removed in 3.0 when the Satisfy directive\n                   goes away. */\n                if (!note || (ap_satisfies(r) != SATISFY_ANY) || (note[0] == 'N')) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"user %s: authorization failure for \\\"%s\\\": \",\n                                  r->user, r->uri);\n                    return_code = HTTP_UNAUTHORIZED;\n                }\n                else {\n                    return_code = DECLINED;\n                }\n                break;\n            case AUTHZ_GENERAL_ERROR:\n            default:\n                /* We'll assume that the module has already said what its\n                 * error was in the logs.\n                 */\n                return_code = HTTP_INTERNAL_SERVER_ERROR;\n                break;\n        }\n\n        \n        if (return_code == HTTP_UNAUTHORIZED) {\n            ap_note_auth_failure (r);\n        }\n        return return_code;\n    }\n\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n391,Unchecked Error Condition\n390,Detection of Error Condition Without Action"
  },
  "httpd_0e03820efa5e4b407b6003069c41e438863fe0e1_0", {
    "ID": "httpd_0e03820efa5e4b407b6003069c41e438863fe0e1_0",
    "UID": "481",
    "code": "AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char test_snippet\n{\n    piped_log *pl;\n\n    pl = apr_palloc(p, sizeof (*pl));\n    pl->p = p;\n    pl->program = apr_pstrdup(p, program);\n    pl->pid = NULL;\n    if (apr_file_pipe_create(&ap_piped_log_read_fd(pl),\n                             &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {\n        return NULL;\n    }\n    apr_pool_cleanup_register(p, pl, piped_log_cleanup,\n                              piped_log_cleanup_for_exec);\n    if (piped_log_spawn(pl) != APR_SUCCESS) {\n        apr_pool_cleanup_kill(p, pl, piped_log_cleanup);\n        apr_file_close(ap_piped_log_read_fd(pl));\n        apr_file_close(ap_piped_log_write_fd(pl));\n        return NULL;\n    }\n    return pl;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_7c64f07ebc4a14efd725a1c230990e224ed3fc90_0", {
    "ID": "httpd_7c64f07ebc4a14efd725a1c230990e224ed3fc90_0",
    "UID": "507",
    "code": "void ap_reclaim_child_processes(int test_snippet\n{\n    apr_time_t waittime = 1024 * 16;\n    apr_status_t waitret;\n    int i;\n    int not_dead_yet;\n    int max_daemons;\n    apr_time_t starttime = apr_time_now();\n    /* this table of actions and elapsed times tells what action is taken\n     * at which elapsed time from starting the reclaim\n     */\n    struct {\n        enum {DO_NOTHING, SEND_SIGTERM, SEND_SIGKILL, GIVEUP} action;\n        apr_time_t action_time;\n    } action_table[] = {\n        {DO_NOTHING, 0}, /* dummy entry for iterations where we reap\n                          * children but take no action against\n                          * stragglers\n                          */\n        {SEND_SIGTERM, apr_time_from_sec(3)},\n        {SEND_SIGTERM, apr_time_from_sec(5)},\n        {SEND_SIGTERM, apr_time_from_sec(7)},\n        {SEND_SIGKILL, apr_time_from_sec(9)},\n        {GIVEUP,       apr_time_from_sec(10)}\n    };\n    int cur_action;      /* index of action we decided to take this\n                          * iteration\n                          */\n    int next_action = 1; \n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);\n\n    do {\n        apr_sleep(waittime);\n        /* don't let waittime get longer than 1 second; otherwise, we don't\n         * react quickly to the last child exiting, and taking action can\n         * be delayed\n         */\n        waittime = waittime * 4;\n        if (waittime > apr_time_from_sec(1)) {\n            waittime = apr_time_from_sec(1);\n        }\n\n        \n        if (action_table[next_action].action_time <= apr_time_now() - starttime) {\n            cur_action = next_action;\n            ++next_action;\n        }\n        else {\n            cur_action = 0; \n        }\n\n        \n        not_dead_yet = 0;\n        for (i = 0; i < max_daemons; ++i) {\n            pid_t pid = MPM_CHILD_PID(i);\n            apr_proc_t proc;\n\n            if (pid == 0)\n                continue;\n\n            proc.pid = pid;\n            waitret = apr_proc_wait(&proc, NULL, NULL, APR_NOWAIT);\n            if (waitret != APR_CHILD_NOTDONE) {\n                MPM_NOTE_CHILD_KILLED(i);\n                continue;\n            }\n\n            ++not_dead_yet;\n            switch(action_table[cur_action].action) {\n            case DO_NOTHING:\n                break;\n                \n            case SEND_SIGTERM:\n                \n                ap_log_error(APLOG_MARK, APLOG_WARNING,\n                             0, ap_server_conf,\n                             \"child process %\" APR_PID_T_FMT\n                             \" still did not exit, \"\n                             \"sending a SIGTERM\",\n                             pid);\n                kill(pid, SIGTERM);\n                break;\n                \n            case SEND_SIGKILL:\n                ap_log_error(APLOG_MARK, APLOG_ERR,\n                             0, ap_server_conf,\n                             \"child process %\" APR_PID_T_FMT\n                             \"  still did not exit, \"\n                             \"sending a SIGKILL\",\n                             pid);\n#ifndef BEOS\n                kill(pid, SIGKILL);\n#else\n                /* sending a SIGKILL kills the entire team on BeOS, and as\n                 * httpd thread is part of that team it removes any chance\n                 * of ever doing a restart.  To counter this I'm changing to\n                 * use a kinder, gentler way of killing a specific thread\n                 * that is just as effective.\n                 */\n                kill_thread(pid);\n#endif\n                break;\n                \n            case GIVEUP:\n                /* gave it our best shot, but alas...  If this really\n                 * is a child we are trying to kill and it really hasn't\n                 * exited, we will likely fail to bind to the port\n                 * after the restart.\n                 */\n                ap_log_error(APLOG_MARK, APLOG_ERR,\n                             0, ap_server_conf,\n                             \"could not make child process %\" APR_PID_T_FMT\n                             \" exit, \"\n                             \"attempting to continue anyway\",\n                             pid);\n                break;\n            }\n        }\n\n#if APR_HAS_OTHER_CHILD\n        apr_proc_other_child_refresh_all(APR_OC_REASON_RESTART);\n#endif\n\n    } while (not_dead_yet > 0 &&\n             action_table[cur_action].action != GIVEUP);\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_ddf207c489103c614722a169411dce946f84df05_0", {
    "ID": "httpd_ddf207c489103c614722a169411dce946f84df05_0",
    "UID": "509",
    "code": "AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec test_snippet\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);\n\n    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF\n        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {\n\n        /* With UseCanonicalName off Apache will form self-referential\n         * URLs using the hostname and port supplied by the client if\n         * any are supplied (otherwise it will use the canonical name).\n         */\n        port = r->parsed_uri.port_str ? r->parsed_uri.port :\n               r->connection->local_addr->port ? r->connection->local_addr->port :\n               r->server->port ? r->server->port :\n               ap_default_port(r);\n    }\n    else { \n\n        /* With UseCanonicalName on (and in all versions prior to 1.3)\n         * Apache will use the hostname and port specified in the\n         * ServerName directive to construct a canonical name for the\n         * server. (If no port was specified in the ServerName\n         * directive, Apache uses the port supplied by the client if\n         * any is supplied, and finally the default port for the protocol\n         * used.\n         */\n        port = r->server->port ? r->server->port :\n               r->connection->local_addr->port ? r->connection->local_addr->port :\n               ap_default_port(r);\n    }\n\n    \n    return port;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_e09d2dfa288715641a44607818cf59a435685c63_0", {
    "ID": "httpd_e09d2dfa288715641a44607818cf59a435685c63_0",
    "UID": "517",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetatest_snippetvtest_snippetetest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet(test_snippetatest_snippetptest_snippet_test_snippetftest_snippetitest_snippetltest_snippetttest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetftest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet test_snippet*test_snippet*test_snippetstest_snippetatest_snippetvtest_snippetetest_snippetttest_snippetotest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet test_snippet*test_snippet*test_snippetbtest_snippet,test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet*test_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetrtest_snippetvtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetItest_snippetftest_snippet test_snippethtest_snippetatest_snippetvtest_snippetetest_snippet test_snippetntest_snippetetest_snippetvtest_snippetetest_snippetrtest_snippet test_snippetstest_snippetttest_snippetotest_snippetrtest_snippetetest_snippetdtest_snippet test_snippetatest_snippetntest_snippetytest_snippet test_snippetdtest_snippetatest_snippetttest_snippetatest_snippet test_snippetitest_snippetntest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetftest_snippetitest_snippetltest_snippetttest_snippetetest_snippetrtest_snippet,test_snippet test_snippetttest_snippethtest_snippetetest_snippetntest_snippet test_snippetwtest_snippetetest_snippet test_snippethtest_snippetatest_snippetdtest_snippet test_snippetbtest_snippetetest_snippetttest_snippetttest_snippetetest_snippetrtest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet test_snippetatest_snippetntest_snippet test_snippetetest_snippetmtest_snippetptest_snippetttest_snippetytest_snippet test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet test_snippetstest_snippetotest_snippet test_snippetttest_snippethtest_snippetatest_snippetttest_snippet test_snippetwtest_snippetetest_snippet test_snippetctest_snippetatest_snippetntest_snippet test_snippetctest_snippetotest_snippetntest_snippetctest_snippetatest_snippetttest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippet(test_snippet*test_snippetstest_snippetatest_snippetvtest_snippetetest_snippetttest_snippetotest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetstest_snippetatest_snippetvtest_snippetetest_snippetttest_snippetotest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetptest_snippet,test_snippet test_snippetftest_snippet-test_snippet>test_snippetctest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetetest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetFtest_snippetItest_snippetRtest_snippetStest_snippetTtest_snippet(test_snippet*test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetStest_snippetEtest_snippetNtest_snippetTtest_snippetItest_snippetNtest_snippetEtest_snippetLtest_snippet(test_snippet*test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetUtest_snippetCtest_snippetKtest_snippetEtest_snippetTtest_snippet_test_snippetNtest_snippetEtest_snippetXtest_snippetTtest_snippet(test_snippetetest_snippet)test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetstest_snippetetest_snippetttest_snippetatest_snippetstest_snippetitest_snippetdtest_snippetetest_snippet(test_snippetetest_snippet,test_snippet test_snippetptest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippet#test_snippet#test_snippet#test_snippet test_snippetttest_snippethtest_snippetitest_snippetstest_snippet test_snippetEtest_snippetNtest_snippetOtest_snippetTtest_snippetItest_snippetMtest_snippetPtest_snippetLtest_snippet test_snippetwtest_snippetitest_snippetltest_snippetltest_snippet test_snippetgtest_snippetotest_snippet test_snippetatest_snippetwtest_snippetatest_snippetytest_snippet test_snippetotest_snippetntest_snippetctest_snippetetest_snippet test_snippetwtest_snippetetest_snippet test_snippetitest_snippetmtest_snippetptest_snippetltest_snippetetest_snippetmtest_snippetetest_snippetntest_snippetttest_snippet test_snippetstest_snippetetest_snippetttest_snippetatest_snippetstest_snippetitest_snippetdtest_snippetetest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet#test_snippet#test_snippet#test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetatest_snippetltest_snippetltest_snippet test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippetttest_snippetytest_snippetptest_snippetetest_snippetstest_snippet.test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet&test_snippet&test_snippet test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetEtest_snippetNtest_snippetOtest_snippetTtest_snippetItest_snippetMtest_snippetPtest_snippetLtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetrtest_snippetvtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetCtest_snippetOtest_snippetNtest_snippetCtest_snippetAtest_snippetTtest_snippet(test_snippet*test_snippetstest_snippetatest_snippetvtest_snippetetest_snippetttest_snippetotest_snippet,test_snippet test_snippet*test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code seems to be obfuscated or corrupted, making it impossible to analyze for potential vulnerabilities. Please provide a valid piece of C/C++ code."
  },
  "httpd_88c9b7715a719f6185cbfb49c8869e92a19eb737_0", {
    "ID": "httpd_88c9b7715a719f6185cbfb49c8869e92a19eb737_0",
    "UID": "520",
    "code": "AP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * test_snippet\n{\n# define SMALL_EXPANSION 5\n    struct sll {\n        struct sll *next;\n        const char *string;\n        apr_size_t len;\n    } *result, *current, sresult[SMALL_EXPANSION];\n    char *res_buf, *cp;\n    const char *s, *e, *ep;\n    unsigned spc;\n    apr_size_t outlen;\n\n    s = ap_strchr_c(word, '$');\n    if (!s) {\n        return word;\n    }\n\n    \n    ep = word + strlen(test_snippet;\n    spc = 0;\n    result = current = &(sresult[spc++]);\n    current->next = NULL;\n    current->string = word;\n    current->len = s - word;\n    outlen = current->len;\n\n    do {\n        \n        if (current->len) {\n            current->next = (spc < SMALL_EXPANSION)\n                            ? &(sresult[spc++])\n                            : (struct sll *)apr_palloc(p,\n                                                       sizeof(*current->next));\n            current = current->next;\n            current->next = NULL;\n            current->len = 0;\n        }\n\n        if (*s == '$') {\n            if (s[1] == '{' && (e = ap_strchr_c(s, '}'))) {\n                word = getenv(apr_pstrndup(p, s+2, e-s-2));\n                if (test_snippet {\n                    current->string = word;\n                    current->len = strlen(test_snippet;\n                    outlen += current->len;\n                }\n                else {\n                    current->string = s;\n                    current->len = e - s + 1;\n                    outlen += current->len;\n                }\n                s = e + 1;\n            }\n            else {\n                current->string = s++;\n                current->len = 1;\n                ++outlen;\n            }\n        }\n        else {\n            word = s;\n            s = ap_strchr_c(s, '$');\n            current->string = word;\n            current->len = s ? s - word : ep - word;\n            outlen += current->len;\n        }\n    } while (s && *s);\n\n    \n    res_buf = cp = apr_palloc(p, outlen + 1);\n    do {\n        if (result->len) {\n            memcpy(cp, result->string, result->len);\n            cp += result->len;\n        }\n        result = result->next;\n    } while (result);\n    res_buf[outlen] = '\\0';\n\n    return res_buf;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_9973f50b5022f1206b09920bfd3b66bbedeaca8c_0", {
    "ID": "httpd_9973f50b5022f1206b09920bfd3b66bbedeaca8c_0",
    "UID": "541",
    "code": "void ap_process_request_after_handler(request_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    bb = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);\n    b = ap_bucket_eor_create(r->connection->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n    \n    ap_pass_brigade(r->connection->output_filters, bb);\n    \n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n    \n    c->cs->state = CONN_STATE_WRITE_COMPLETION;\n    check_pipeline(c);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
    "predicted": "416,Use After Free"
  },
  "httpd_cc448d937b649420da733c540423616bae0b4f17_0", {
    "ID": "httpd_cc448d937b649420da733c540423616bae0b4f17_0",
    "UID": "545",
    "code": "static void validate_status_line(request_rec test_snippet\n{\n    char *end;\n\n    if (r->status_line) {\n        int len = strlen(r->status_line);\n        if (len < 3\n            || apr_strtoi64(r->status_line, &end, 10) != r->status\n            || (end - 3) != r->status_line\n            || (len >= 4 && ! apr_isspace(r->status_line[3]))) {\n            r->status_line = NULL;\n        }\n        /* Since we passed the above check, we know that length three\n         * is equivalent to only a 3 digit numeric http status.\n         * RFC2616 mandates a trailing space, let's add it.\n         */\n        else if (len == 3) {\n            r->status_line = apr_pstrcat(r->pool, r->status_line, \" \", NULL);\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_bbf6dbee1981b279f0494bed0b268ec588ea7dd7_0", {
    "ID": "httpd_bbf6dbee1981b279f0494bed0b268ec588ea7dd7_0",
    "UID": "547",
    "code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int test_snippet\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (status == HTTP_NOT_MODIFIED) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    if (status == HTTP_NO_CONTENT) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    if (!r->assbackwards) {\n        apr_table_t *tmp = r->headers_out;\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        r->headers_out = r->err_headers_out;\n        r->err_headers_out = tmp;\n        apr_table_clear(r->err_headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   \n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_module_config(r->request_config, &core_module);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type(r, \"text/html\");\n        }\n        else {\n            ap_set_content_type(r, \"text/html; charset=iso-8859-1\");\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rputs(custom_response + 1, r);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        \n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_2_0\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (test_snippet {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(test_snippet],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_9143e6b023cb5a9adbe1c70871e97b05bba4a411_0", {
    "ID": "httpd_9143e6b023cb5a9adbe1c70871e97b05bba4a411_0",
    "UID": "550",
    "code": "apr_status_t ap_http_outerror_filter(ap_filter_t test_snippet\n                                     apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    outerror_filter_ctx_t *ctx = (outerror_filter_ctx_t *)(f->ctx);\n    apr_bucket *e;\n\n    \n    if (!ctx) {\n        ctx = apr_pcalloc(r->pool, sizeof(outerror_filter_ctx_t));\n        f->ctx = ctx;\n    }\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (AP_BUCKET_IS_ERROR(e)) {\n            /*\n             * Start of error handling state tree. Just one condition\n             * right now :)\n             */\n            if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY) {\n                \n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n            continue;\n        }\n        \n        if (AP_BUCKET_IS_EOC(e)) {\n            ctx->seen_eoc = 1;\n        }\n    }\n    /*\n     * Remove all data buckets that are in a brigade after an EOC bucket\n     * was seen, as an EOC bucket tells us that no (further) resource\n     * and protocol data should go out to the client. OTOH meta buckets\n     * are still welcome as they might trigger needed actions down in\n     * the chain (e.g. in network filters like SSL).\n     * Remark 1: It is needed to dump ALL data buckets in the brigade\n     *           since an filter in between might have inserted data\n     *           buckets BEFORE the EOC bucket sent by the original\n     *           sender and we do NOT want this data to be sent.\n     * Remark 2: Dumping all data buckets here does not necessarily mean\n     *           that no further data is send to the client as:\n     *           1. Network filters like SSL can still be triggered via\n     *              meta buckets to talk with the client e.g. for a\n     *              clean shutdown.\n     *           2. There could be still data that was buffered before\n     *              down in the chain that gets flushed by a FLUSH or an\n     *              EOS bucket.\n     */\n    if (ctx->seen_eoc) {\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (!APR_BUCKET_IS_METADATA(e)) {\n                APR_BUCKET_REMOVE(e);\n            }\n        }\n    }\n\n    return ap_pass_brigade(f->next,  b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_30548c6125518b8b7da17285c593dacb7cdc99af_0", {
    "ID": "httpd_30548c6125518b8b7da17285c593dacb7cdc99af_0",
    "UID": "563",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippetctest_snippethtest_snippetetest_snippetctest_snippetktest_snippet_test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetctest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet]test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippet*test_snippetatest_snippetltest_snippetgtest_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet,test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet*test_snippetutest_snippetstest_snippetetest_snippetrtest_snippet,test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet*test_snippetptest_snippetwtest_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet*test_snippetptest_snippetatest_snippetstest_snippetstest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet_test_snippetltest_snippetetest_snippetftest_snippetttest_snippet test_snippet=test_snippet test_snippet2test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetitest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetPtest_snippetrtest_snippetetest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetntest_snippetatest_snippetrtest_snippetytest_snippet test_snippetctest_snippethtest_snippetetest_snippetctest_snippetktest_snippet test_snippetttest_snippetotest_snippet test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet test_snippetstest_snippetutest_snippetrtest_snippetetest_snippet test_snippetttest_snippethtest_snippetetest_snippetytest_snippet test_snippetptest_snippetrtest_snippetotest_snippetvtest_snippetitest_snippetdtest_snippetetest_snippetdtest_snippet test_snippetatest_snippetttest_snippet test_snippetltest_snippetetest_snippetatest_snippetstest_snippetttest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetttest_snippethtest_snippetrtest_snippetetest_snippetetest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetutest_snippetmtest_snippetetest_snippetntest_snippetttest_snippetstest_snippet,test_snippet test_snippetwtest_snippetetest_snippet'test_snippetltest_snippetltest_snippet test_snippetdtest_snippetotest_snippet test_snippetbtest_snippetetest_snippetttest_snippetttest_snippetetest_snippetrtest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetutest_snippetmtest_snippetetest_snippetntest_snippetttest_snippet test_snippetctest_snippethtest_snippetetest_snippetctest_snippetktest_snippetitest_snippetntest_snippetgtest_snippet test_snippetatest_snippetstest_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetwtest_snippetetest_snippet test_snippetptest_snippetatest_snippetrtest_snippetstest_snippetetest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetctest_snippetotest_snippetmtest_snippetmtest_snippetatest_snippetntest_snippetdtest_snippet test_snippetltest_snippetitest_snippetntest_snippetetest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetatest_snippetrtest_snippetgtest_snippetctest_snippet test_snippet<test_snippet test_snippet3test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetutest_snippetstest_snippetatest_snippetgtest_snippetetest_snippet(test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetGtest_snippetotest_snippet test_snippetttest_snippethtest_snippetrtest_snippetotest_snippetutest_snippetgtest_snippethtest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetutest_snippetmtest_snippetetest_snippetntest_snippetttest_snippet test_snippetltest_snippetitest_snippetstest_snippetttest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetptest_snippetitest_snippetctest_snippetktest_snippet test_snippetotest_snippetutest_snippetttest_snippet test_snippetatest_snippetntest_snippetytest_snippet test_snippetotest_snippetptest_snippetttest_snippetitest_snippetotest_snippetntest_snippetstest_snippet.test_snippet test_snippet test_snippetTtest_snippethtest_snippetetest_snippetytest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippethtest_snippetatest_snippetvtest_snippetetest_snippet test_snippetttest_snippetotest_snippet test_snippetptest_snippetrtest_snippetetest_snippetctest_snippetetest_snippetdtest_snippetetest_snippet test_snippetatest_snippetntest_snippetytest_snippet test_snippetotest_snippetttest_snippethtest_snippetetest_snippetrtest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetutest_snippetmtest_snippetetest_snippetntest_snippetttest_snippetstest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippet1test_snippet;test_snippet test_snippetitest_snippet test_snippet<test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetctest_snippet;test_snippet test_snippetitest_snippet+test_snippet+test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet]test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet!test_snippet=test_snippet test_snippet'test_snippet-test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetwtest_snippethtest_snippetitest_snippetltest_snippetetest_snippet test_snippet(test_snippet*test_snippet+test_snippet+test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet!test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetctest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet|test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetEtest_snippetWtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetntest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet|test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet_test_snippetltest_snippetetest_snippetftest_snippetttest_snippet-test_snippet-test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetmtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetatest_snippetltest_snippetgtest_snippet test_snippet=test_snippet test_snippetAtest_snippetLtest_snippetGtest_snippet_test_snippetAtest_snippetPtest_snippetMtest_snippetDtest_snippet5test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetstest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetatest_snippetltest_snippetgtest_snippet test_snippet=test_snippet test_snippetAtest_snippetLtest_snippetGtest_snippet_test_snippetAtest_snippetPtest_snippetStest_snippetHtest_snippetAtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetptest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetatest_snippetltest_snippetgtest_snippet test_snippet=test_snippet test_snippetAtest_snippetLtest_snippetGtest_snippet_test_snippetPtest_snippetLtest_snippetAtest_snippetItest_snippetNtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetdtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetatest_snippetltest_snippetgtest_snippet test_snippet=test_snippet test_snippetAtest_snippetLtest_snippetGtest_snippet_test_snippetCtest_snippetRtest_snippetYtest_snippetPtest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetbtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet|test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetNtest_snippetItest_snippetNtest_snippetTtest_snippetEtest_snippetRtest_snippetAtest_snippetCtest_snippetTtest_snippetItest_snippetVtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet_test_snippetltest_snippetetest_snippetftest_snippetttest_snippet+test_snippet+test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippetDtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet|test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetLtest_snippetUtest_snippetStest_snippetEtest_snippetRtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetutest_snippetstest_snippetatest_snippetgtest_snippetetest_snippet(test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetEtest_snippetWtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet)test_snippet test_snippet&test_snippet&test_snippet test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippet-test_snippetctest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippet-test_snippetntest_snippet test_snippetotest_snippetptest_snippetttest_snippetitest_snippetotest_snippetntest_snippetstest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetltest_snippetitest_snippetctest_snippetttest_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetStest_snippetYtest_snippetNtest_snippetTtest_snippetAtest_snippetXtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetEtest_snippetWtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet)test_snippet test_snippet&test_snippet&test_snippet test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetLtest_snippetUtest_snippetStest_snippetEtest_snippetRtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippet-test_snippetctest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippet-test_snippetDtest_snippet test_snippetotest_snippetptest_snippetttest_snippetitest_snippetotest_snippetntest_snippetstest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetltest_snippetitest_snippetctest_snippetttest_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetStest_snippetYtest_snippetNtest_snippetTtest_snippetAtest_snippetXtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet)test_snippet test_snippet&test_snippet&test_snippet test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetLtest_snippetUtest_snippetStest_snippetEtest_snippetRtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippet-test_snippetntest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippet-test_snippetDtest_snippet test_snippetotest_snippetptest_snippetttest_snippetitest_snippetotest_snippetntest_snippetstest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetltest_snippetitest_snippetctest_snippetttest_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetStest_snippetYtest_snippetNtest_snippetTtest_snippetAtest_snippetXtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetMtest_snippetatest_snippetktest_snippetetest_snippet test_snippetstest_snippetutest_snippetrtest_snippetetest_snippet test_snippetwtest_snippetetest_snippet test_snippetstest_snippetttest_snippetitest_snippetltest_snippetltest_snippet test_snippethtest_snippetatest_snippetvtest_snippetetest_snippet test_snippetetest_snippetxtest_snippetatest_snippetctest_snippetttest_snippetltest_snippetytest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetrtest_snippetitest_snippetgtest_snippethtest_snippetttest_snippet test_snippetntest_snippetutest_snippetmtest_snippetbtest_snippetetest_snippetrtest_snippet test_snippetotest_snippetftest_snippet test_snippetatest_snippetrtest_snippetgtest_snippetutest_snippetmtest_snippetetest_snippetntest_snippetttest_snippetstest_snippet test_snippetltest_snippetetest_snippetftest_snippetttest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippet(test_snippetttest_snippethtest_snippetetest_snippet test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetptest_snippetotest_snippetstest_snippetstest_snippetitest_snippetbtest_snippetltest_snippetytest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetptest_snippetatest_snippetstest_snippetstest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet test_snippetitest_snippetftest_snippet test_snippet-test_snippetbtest_snippet test_snippetwtest_snippetatest_snippetstest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetstest_snippetptest_snippetetest_snippetctest_snippetitest_snippetftest_snippetitest_snippetetest_snippetdtest_snippet)test_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetatest_snippetrtest_snippetgtest_snippetctest_snippet test_snippet-test_snippet test_snippetitest_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet_test_snippetltest_snippetetest_snippetftest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetutest_snippetstest_snippetatest_snippetgtest_snippetetest_snippet(test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetFtest_snippetItest_snippetLtest_snippetEtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippet-test_snippet-test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet]test_snippet)test_snippet test_snippet>test_snippet test_snippet(test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetAtest_snippetTtest_snippetHtest_snippet_test_snippetMtest_snippetAtest_snippetXtest_snippet test_snippet-test_snippet test_snippet1test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippetttest_snippetotest_snippetotest_snippet test_snippetltest_snippetotest_snippetntest_snippetgtest_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetOtest_snippetVtest_snippetEtest_snippetRtest_snippetFtest_snippetLtest_snippetOtest_snippetWtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetwtest_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet test_snippet+test_snippet test_snippet1test_snippet]test_snippet)test_snippet test_snippet>test_snippet test_snippet(test_snippetMtest_snippetAtest_snippetXtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet test_snippet-test_snippet test_snippet1test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippetttest_snippetotest_snippetotest_snippet test_snippetltest_snippetotest_snippetntest_snippetgtest_snippet test_snippet(test_snippet>test_snippet test_snippet%test_snippetdtest_snippet)test_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet,test_snippet test_snippetMtest_snippetAtest_snippetXtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet test_snippet-test_snippet test_snippet1test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetOtest_snippetVtest_snippetEtest_snippetRtest_snippetFtest_snippetLtest_snippetOtest_snippetWtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetutest_snippetstest_snippetetest_snippetrtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet test_snippet+test_snippet test_snippet1test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetatest_snippetrtest_snippetgtest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippet*test_snippetutest_snippetstest_snippetetest_snippetrtest_snippet,test_snippet test_snippet'test_snippet:test_snippet'test_snippet)test_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet test_snippetitest_snippetltest_snippetltest_snippetetest_snippetgtest_snippetatest_snippetltest_snippet test_snippet\"test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetctest_snippethtest_snippetatest_snippetrtest_snippetatest_snippetctest_snippetttest_snippetetest_snippetrtest_snippet test_snippet'test_snippet%test_snippetctest_snippet'test_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet,test_snippet test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetBtest_snippetAtest_snippetDtest_snippetUtest_snippetStest_snippetEtest_snippetRtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetmtest_snippetatest_snippetstest_snippetktest_snippet test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetHtest_snippetTtest_snippetPtest_snippet_test_snippetNtest_snippetOtest_snippetNtest_snippetItest_snippetNtest_snippetTtest_snippetEtest_snippetRtest_snippetAtest_snippetCtest_snippetTtest_snippetItest_snippetVtest_snippetEtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet test_snippet+test_snippet test_snippet2test_snippet]test_snippet)test_snippet test_snippet>test_snippet test_snippet(test_snippetMtest_snippetAtest_snippetXtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet test_snippet-test_snippet test_snippet1test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetptest_snippetrtest_snippetitest_snippetntest_snippetttest_snippetftest_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippetptest_snippetatest_snippetstest_snippetstest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet test_snippetttest_snippetotest_snippetotest_snippet test_snippetltest_snippetotest_snippetntest_snippetgtest_snippet test_snippet(test_snippet>test_snippet test_snippet%test_snippetdtest_snippet)test_snippet\"test_snippet test_snippetNtest_snippetLtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippet0test_snippet]test_snippet,test_snippet test_snippetMtest_snippetAtest_snippetXtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetttest_snippet(test_snippetEtest_snippetRtest_snippetRtest_snippet_test_snippetOtest_snippetVtest_snippetEtest_snippetRtest_snippetFtest_snippetLtest_snippetOtest_snippetWtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetatest_snippetstest_snippetstest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetvtest_snippet[test_snippetitest_snippet test_snippet+test_snippet test_snippet2test_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet}test_snippet",
    "predicted": ""
  },
  "httpd_229cbc83057b11356e4ebcfa464b5cddc3004ccf_0", {
    "ID": "httpd_229cbc83057b11356e4ebcfa464b5cddc3004ccf_0",
    "UID": "569",
    "code": "AP_CORE_DECLARE(void *) ap_set_config_vectors(server_rec test_snippet\n                                              ap_conf_vector_t *section_vector,\n                                              const char *section,\n                                              module *mod, apr_pool_t *pconf)\n{\n    void *section_config = ap_get_module_config(section_vector, mod);\n    void *server_config = ap_get_module_config(server->module_config, mod);\n\n    if (!section_config && mod->create_dir_config) {\n        \n        section_config = (*mod->create_dir_config)(pconf, (char *)section);\n        ap_set_module_config(section_vector, mod, section_config);\n    }\n\n    if (!server_config && mod->create_server_config) {\n        server_config = (*mod->create_server_config)(pconf, server);\n        ap_set_module_config(server->module_config, mod, server_config);\n    }\n\n    return section_config;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_8e4b38b84ea597054185e712fc7a844a1f58c7c2_0", {
    "ID": "httpd_8e4b38b84ea597054185e712fc7a844a1f58c7c2_0",
    "UID": "582",
    "code": "AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec test_snippet\n{\n    core_server_config *conf;\n    int rv;\n    apr_bucket_brigade *bb;\n    header_struct h;\n    apr_bucket *b;\n    int body;\n    char *bodyread = NULL, *bodyoff;\n    apr_size_t bodylen = 0;\n    apr_size_t bodybuf;\n    long res = -1; \n\n    if (r->method_number != M_TRACE) {\n        return DECLINED;\n    }\n\n    \n    while (r->prev) {\n        r = r->prev;\n    }\n    conf = (core_server_config *)ap_get_module_config(r->server->module_config,\n                                                      &core_module);\n\n    if (conf->trace_enable == AP_TRACE_DISABLE) {\n\tapr_table_setn(r->notes, \"error-notes\",\n                      \"TRACE denied by server configuration\");\n        return HTTP_FORBIDDEN;\n    }\n\n    if (conf->trace_enable == AP_TRACE_EXTENDED)\n        \n        body = REQUEST_CHUNKED_DECHUNK;\n    else\n        body = REQUEST_NO_BODY;\n\n    if ((rv = ap_setup_client_block(r, body))) {\n        if (rv == HTTP_REQUEST_ENTITY_TOO_LARGE)\n    \t    apr_table_setn(r->notes, \"error-notes\",\n                          \"TRACE with a request body is not allowed\");\n        return rv;\n    }\n\n    if (ap_should_client_block(r)) {\n\n        if (r->remaining > 0) {\n            if (r->remaining > 65536) {\n\t        apr_table_setn(r->notes, \"error-notes\",\n                       \"Extended TRACE request bodies cannot exceed 64k\\n\");\n                return HTTP_REQUEST_ENTITY_TOO_LARGE;\n            }\n            \n            bodybuf = (apr_size_t)r->remaining + 32;\n        }\n        else {\n            \n            bodybuf = 73730;\n        }\n\n        bodyoff = bodyread = apr_palloc(r->pool, bodybuf);\n\n        \n        while ((!bodylen || bodybuf >= 32) &&\n               (res = ap_get_client_block(r, bodyoff, bodybuf)) > 0) {\n            bodylen += res;\n            bodybuf -= res;\n            bodyoff += res;\n        }\n        if (res > 0 && bodybuf < 32) {\n            \n            while (ap_get_client_block(r, bodyread, bodylen) > 0)\n                ;\n\t    apr_table_setn(r->notes, \"error-notes\",\n                   \"Extended TRACE request bodies cannot exceed 64k\\n\");\n            return HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (res < 0) {\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    ap_set_content_type(r, \"message/http\");\n\n    \n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    apr_brigade_putstrs(bb, NULL, NULL, r->the_request, CRLF, NULL);\n    h.pool = r->pool;\n    h.bb = bb;\n    apr_table_do((int (*) (void *, const char *, const char *))\n                 form_header_field, (void *) &h, r->headers_in, NULL);\n    apr_brigade_puts(bb, NULL, NULL, CRLF);\n\n    \n    if (bodylen) {\n        b = apr_bucket_pool_create(bodyread, bodylen, \n                                   r->pool, bb->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n    }\n    \n    ap_pass_brigade(r->output_filters,  bb);\n\n    return DONE;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_54aa02b33a16b845cae237d2627104e5c99449d9_0", {
    "ID": "httpd_54aa02b33a16b845cae237d2627104e5c99449d9_0",
    "UID": "588",
    "code": "static void set_banner(apr_pool_t test_snippet\n{\n    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);\n    }\n    else if (ap_server_tokens == SrvTk_MINIMAL) {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION);\n    }\n    else if (ap_server_tokens == SrvTk_MINOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MINORREVISION);\n    }\n    else if (ap_server_tokens == SrvTk_MAJOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MAJORVERSION);\n    }\n    else {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION \" (\" PLATFORM \")\");\n    }\n\n    /*\n     * Lock the server_banner string if we're not displaying\n     * the full set of tokens\n     */\n    if (ap_server_tokens != SrvTk_FULL) {\n        banner_locked++;\n    }\n    server_description = AP_SERVER_BASEVERSION \" (\" PLATFORM \")\";\n}",
    "predicted": "The provided code does not seem to contain any obvious vulnerabilities based on the provided list. Therefore, the response is null."
  },
  "httpd_530d2e94ac9afd50b3b5246c56ac4c5fadf8b01b_0", {
    "ID": "httpd_530d2e94ac9afd50b3b5246c56ac4c5fadf8b01b_0",
    "UID": "590",
    "code": "static void *merge_authz_core_dir_config(apr_pool_t *a, void *basev, void test_snippet\n{\n    authz_core_dir_conf *base = (authz_core_dir_conf *)basev;\n    authz_core_dir_conf *new = (authz_core_dir_conf *)newv;\n    authz_core_dir_conf *conf;\n\n    /* Create this conf by duplicating the base, replacing elements\n    * (or creating copies for merging) where new-> values exist.\n    */\n    conf = (authz_core_dir_conf *)apr_palloc(a, sizeof(authz_core_dir_conf));\n    memcpy(conf, base, sizeof(authz_core_dir_conf));\n\n    /* Wipe out the providers and rejects lists so that \n        they can be recreated by the merge process. */\n    conf->providers = NULL;\n\n    /* Only merge the base providers in if the merge_rules \n        directive has been set. */\n    if (base->providers && new->merge_rules) {\n        walk_merge_provider_list (a, conf, base->providers);\n    }\n    if (new->providers) {\n        walk_merge_provider_list (a, conf, new->providers);\n    }\n\n    return (void*)conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_1c820487504be6775e9c02b5afbd5a13af73de4f_0", {
    "ID": "httpd_1c820487504be6775e9c02b5afbd5a13af73de4f_0",
    "UID": "596",
    "code": "void ap_reclaim_child_processes(int test_snippet\n{\n    apr_time_t waittime = 1024 * 16;\n    int i;\n    extra_process_t *cur_extra;\n    int not_dead_yet;\n    int max_daemons;\n    apr_time_t starttime = apr_time_now();\n    /* this table of actions and elapsed times tells what action is taken\n     * at which elapsed time from starting the reclaim\n     */\n    struct {\n        action_t action;\n        apr_time_t action_time;\n    } action_table[] = {\n        {DO_NOTHING, 0}, /* dummy entry for iterations where we reap\n                          * children but take no action against\n                          * stragglers\n                          */\n        {SEND_SIGTERM, apr_time_from_sec(3)},\n        {SEND_SIGTERM, apr_time_from_sec(5)},\n        {SEND_SIGTERM, apr_time_from_sec(7)},\n        {SEND_SIGKILL, apr_time_from_sec(9)},\n        {GIVEUP,       apr_time_from_sec(10)}\n    };\n    int cur_action;      /* index of action we decided to take this\n                          * iteration\n                          */\n    int next_action = 1; \n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);\n\n    do {\n        apr_sleep(waittime);\n        /* don't let waittime get longer than 1 second; otherwise, we don't\n         * react quickly to the last child exiting, and taking action can\n         * be delayed\n         */\n        waittime = waittime * 4;\n        if (waittime > apr_time_from_sec(1)) {\n            waittime = apr_time_from_sec(1);\n        }\n\n        \n        if (action_table[next_action].action_time <= apr_time_now() - starttime) {\n            cur_action = next_action;\n            ++next_action;\n        }\n        else {\n            cur_action = 0; \n        }\n\n        \n        not_dead_yet = 0;\n        for (i = 0; i < max_daemons; ++i) {\n            pid_t pid = MPM_CHILD_PID(i);\n\n            if (pid == 0) {\n                continue; \n            }\n\n            if (reclaim_one_pid(pid, action_table[cur_action].action)) {\n                MPM_NOTE_CHILD_KILLED(i);\n            }\n            else {\n                ++not_dead_yet;\n            }\n        }\n\n        cur_extra = extras;\n        while (cur_extra) {\n            extra_process_t *next = cur_extra->next;\n\n            if (reclaim_one_pid(cur_extra->pid, action_table[cur_action].action)) {\n                AP_DEBUG_ASSERT(1 == ap_unregister_extra_mpm_process(cur_extra->pid));\n            }\n            else {\n                ++not_dead_yet;\n            }\n            cur_extra = next;\n        }\n#if APR_HAS_OTHER_CHILD\n        apr_proc_other_child_refresh_all(APR_OC_REASON_RESTART);\n#endif\n\n    } while (not_dead_yet > 0 &&\n             action_table[cur_action].action != GIVEUP);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_6a8c41b73083434fd3112819caba5216bb206aa7_0", {
    "ID": "httpd_6a8c41b73083434fd3112819caba5216bb206aa7_0",
    "UID": "598",
    "code": "AP_DECLARE(int) ap_setup_listeners(server_rec test_snippet\n{\n    ap_listen_rec *lr;\n    int num_listeners = 0;\n\n    if (open_listeners(s->process->pool, s->port)) {\n       return 0;\n    }\n\n    for (lr = ap_listeners; lr; lr = lr->next) {\n        num_listeners++;\n    }\n\n    return num_listeners;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_fdd4b7a6990c7767c14e40174cd04a9336cf4327_0", {
    "ID": "httpd_fdd4b7a6990c7767c14e40174cd04a9336cf4327_0",
    "UID": "614",
    "code": "static int fixup_dir(request_rec test_snippet\n{\n    dir_config_rec *d;\n    char *dummy_ptr[1];\n    char **names_ptr;\n    int num_names;\n    int error_notfound = 0;\n\n    \n    if (r->finfo.filetype != APR_DIR) {\n        return DECLINED;\n    }\n    \n    \n    if (!r->handler) {\n        r->handler = DIR_MAGIC_TYPE;\n    }\n\n    \n    if (r->path_info && *r->path_info) {\n        return DECLINED;\n    }\n\n    d = (dir_config_rec *)ap_get_module_config(r->per_dir_config,\n                                               &dir_module);\n\n    \n    if (r->uri[0] == '\\0' || r->uri[strlen(r->uri) - 1] != '/') \n    {\n        char *ifile;\n\n        if (!d->do_slash) {\n            return DECLINED;\n        }\n\n        /* Only redirect non-get requests if we have no note to warn\n         * that this browser cannot handle redirs on non-GET requests \n         * (such as Microsoft's WebFolders). \n         */\n        if ((r->method_number != M_GET)\n                && apr_table_get(r->subprocess_env, \"redirect-carefully\")) {\n            return DECLINED;\n        }\n\n        if (r->args != NULL) {\n            ifile = apr_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),\n                                \"/\", \"?\", r->args, NULL);\n        }\n        else {\n            ifile = apr_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),\n                                \"/\", NULL);\n        }\n\n        apr_table_setn(r->headers_out, \"Location\",\n                       ap_construct_url(r->pool, ifile, r));\n        return HTTP_MOVED_PERMANENTLY;\n    }\n\n    if (d->index_names) {\n        names_ptr = (char **)d->index_names->elts;\n        num_names = d->index_names->nelts;\n    }\n    else {\n        dummy_ptr[0] = AP_DEFAULT_INDEX;\n        names_ptr = dummy_ptr;\n        num_names = 1;\n    }\n\n    for (; num_names; ++names_ptr, --num_names) {\n        \n        char *name_ptr = *names_ptr;\n        request_rec *rr;\n\n        /* Once upon a time args were handled _after_ the successful redirect.\n         * But that redirect might then _refuse_ the given r->args, creating\n         * a nasty tangle.  It seems safer to consider the r->args while we\n         * determine if name_ptr is our viable index, and therefore set them\n         * up correctly on redirect.\n         */\n        if (r->args != NULL) {\n            name_ptr = apr_pstrcat(r->pool, name_ptr, \"?\", r->args, NULL);\n        }\n\n        rr = ap_sub_req_lookup_uri(name_ptr, r, NULL);\n\n        \n        if (   rr->status == HTTP_OK\n            && (   (rr->handler && !strcmp(rr->handler, \"proxy-server\"))\n                || rr->finfo.filetype == APR_REG)) {\n            ap_internal_fast_redirect(rr, r);\n            return OK;\n        }\n            \n        \n\n        if (ap_is_HTTP_REDIRECT(rr->status)\n            || (rr->status == HTTP_NOT_ACCEPTABLE && num_names == 1)\n            || (rr->status == HTTP_UNAUTHORIZED && num_names == 1)) {\n\n            apr_pool_join(r->pool, rr->pool);\n            error_notfound = rr->status;\n            r->notes = apr_table_overlay(r->pool, r->notes, rr->notes);\n            r->headers_out = apr_table_overlay(r->pool, r->headers_out,\n                                               rr->headers_out);\n            r->err_headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                                   rr->err_headers_out);\n            return error_notfound;\n        }\n\n        /* If the request returned something other than 404 (or 200),\n         * it means the module encountered some sort of problem. To be\n         * secure, we should return the error, rather than allow autoindex\n         * to create a (possibly unsafe) directory index.\n         *\n         * So we store the error, and if none of the listed files\n         * exist, we return the last error response we got, instead\n         * of a directory listing.\n         */\n        if (rr->status && rr->status != HTTP_NOT_FOUND\n                && rr->status != HTTP_OK) {\n            error_notfound = rr->status;\n        }\n\n        ap_destroy_sub_req(rr);\n    }\n\n    if (error_notfound) {\n        return error_notfound;\n    }\n\n    \n    return DECLINED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_3de91262b4c4b0abc73b4692750b81d17b29c094_0", {
    "ID": "httpd_3de91262b4c4b0abc73b4692750b81d17b29c094_0",
    "UID": "631",
    "code": "static int get_ptoken(include_ctx_t *ctx, const char **parse, token_t *token, token_t test_snippet\n{\n    const char *p;\n    apr_size_t shift;\n    int unmatched;\n\n    token->value = NULL;\n\n    if (!*parse) {\n        return 0;\n    }\n\n    \n    while (apr_isspace(**parse)) {\n        ++*parse;\n    }\n\n    if (!**parse) {\n        *parse = NULL;\n        return 0;\n    }\n\n    TYPE_TOKEN(token, TOKEN_STRING); \n    p = *parse;\n    unmatched = 0;\n\n    switch (*(*parse)++) {\n    case '(':\n        TYPE_TOKEN(token, TOKEN_LBRACE);\n        return 0;\n    case ')':\n        TYPE_TOKEN(token, TOKEN_RBRACE);\n        return 0;\n    case '=':\n        if (**parse == '=') ++*parse;\n        TYPE_TOKEN(token, TOKEN_EQ);\n        return 0;\n    case '!':\n        if (**parse == '=') {\n            TYPE_TOKEN(token, TOKEN_NE);\n            ++*parse;\n            return 0;\n        }\n        TYPE_TOKEN(token, TOKEN_NOT);\n        return 0;\n    case '\\'':\n        unmatched = '\\'';\n        break;\n    case '/':\n        \n        if (previous != NULL && TOKEN_ACCESS == previous->type) {\n            break;\n        }\n        TYPE_TOKEN(token, TOKEN_RE);\n        unmatched = '/';\n        break;\n    case '|':\n        if (**parse == '|') {\n            TYPE_TOKEN(token, TOKEN_OR);\n            ++*parse;\n            return 0;\n        }\n        break;\n    case '&':\n        if (**parse == '&') {\n            TYPE_TOKEN(token, TOKEN_AND);\n            ++*parse;\n            return 0;\n        }\n        break;\n    case '>':\n        if (**parse == '=') {\n            TYPE_TOKEN(token, TOKEN_GE);\n            ++*parse;\n            return 0;\n        }\n        TYPE_TOKEN(token, TOKEN_GT);\n        return 0;\n    case '<':\n        if (**parse == '=') {\n            TYPE_TOKEN(token, TOKEN_LE);\n            ++*parse;\n            return 0;\n        }\n        TYPE_TOKEN(token, TOKEN_LT);\n        return 0;\n    case '-':\n        if (**parse == 'A' && (ctx->intern->accessenable)) {\n            TYPE_TOKEN(token, TOKEN_ACCESS);\n            ++*parse;\n            return 0;\n        }\n        break;\n    }\n\n    /* It's a string or regex token\n     * Now search for the next token, which finishes this string\n     */\n    shift = 0;\n    p = *parse = token->value = unmatched ? *parse : p;\n\n    for (; **parse; p = ++*parse) {\n        if (**parse == '\\\\') {\n            if (!*(++*parse)) {\n                p = *parse;\n                break;\n            }\n\n            ++shift;\n        }\n        else {\n            if (unmatched) {\n                if (**parse == unmatched) {\n                    unmatched = 0;\n                    ++*parse;\n                    break;\n                }\n            } else if (apr_isspace(**parse)) {\n                break;\n            }\n            else {\n                int found = 0;\n\n                switch (**parse) {\n                case '(':\n                case ')':\n                case '=':\n                case '!':\n                case '<':\n                case '>':\n                    ++found;\n                    break;\n\n                case '|':\n                case '&':\n                    if ((*parse)[1] == **parse) {\n                        ++found;\n                    }\n                    break;\n                }\n\n                if (found) {\n                    break;\n                }\n            }\n        }\n    }\n\n    if (unmatched) {\n        token->value = apr_pstrdup(ctx->dpool, \"\");\n    }\n    else {\n        apr_size_t len = p - token->value - shift;\n        char *c = apr_palloc(ctx->dpool, len + 1);\n\n        p = token->value;\n        token->value = c;\n\n        while (shift--) {\n            const char *e = ap_strchr_c(p, '\\\\');\n\n            memcpy(c, p, e-p);\n            c   += e-p;\n            *c++ = *++e;\n            len -= e-p;\n            p    = e+1;\n        }\n\n        if (len) {\n            memcpy(c, p, len);\n        }\n        c[len] = '\\0';\n    }\n\n    return unmatched;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6761d4cd8093be8d5d0c4d52f3a5ba3da390a43b_0", {
    "ID": "httpd_6761d4cd8093be8d5d0c4d52f3a5ba3da390a43b_0",
    "UID": "635",
    "code": "static int parse_expr(include_ctx_t *ctx, const char *expr, int test_snippet\n{\n    parse_node_t *new, *root = NULL, *current = NULL;\n    request_rec *r = ctx->intern->r;\n    request_rec *rr = NULL;\n    const char *error = \"Invalid expression \\\"%s\\\" in file %s\";\n    const char *parse = expr;\n    int was_unmatched = 0;\n    unsigned regex = 0;\n\n    *was_error = 0;\n\n    if (!parse) {\n        return 0;\n    }\n\n    \n    while (1) {\n        /* uncomment this to see how the tree a built:\n         *\n         * DEBUG_DUMP_TREE(ctx, root);\n         */\n        CREATE_NODE(ctx, new);\n\n        was_unmatched = get_ptoken(ctx, &parse, &new->token,\n                         (current != NULL ? &current->token : NULL));\n        if (!parse) {\n            break;\n        }\n\n        DEBUG_DUMP_UNMATCHED(ctx, was_unmatched);\n        DEBUG_DUMP_TOKEN(ctx, &new->token);\n\n        if (!current) {\n            switch (new->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_NOT:\n            case TOKEN_ACCESS:\n            case TOKEN_LBRACE:\n                root = current = new;\n                continue;\n\n            default:\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, error, expr,\n                              r->filename);\n                *was_error = 1;\n                return 0;\n            }\n        }\n\n        switch (new->token.type) {\n        case TOKEN_STRING:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n                current->token.value =\n                    apr_pstrcat(ctx->dpool, current->token.value,\n                                *current->token.value ? \" \" : \"\",\n                                new->token.value, NULL);\n                continue;\n\n            case TOKEN_RE:\n            case TOKEN_RBRACE:\n            case TOKEN_GROUP:\n                break;\n\n            default:\n                new->parent = current;\n                current = current->right = new;\n                continue;\n            }\n            break;\n\n        case TOKEN_RE:\n            switch (current->token.type) {\n            case TOKEN_EQ:\n            case TOKEN_NE:\n                new->parent = current;\n                current = current->right = new;\n                ++regex;\n                continue;\n\n            default:\n                break;\n            }\n            break;\n\n        case TOKEN_AND:\n        case TOKEN_OR:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_RE:\n            case TOKEN_GROUP:\n                current = current->parent;\n\n                while (current) {\n                    switch (current->token.type) {\n                    case TOKEN_AND:\n                    case TOKEN_OR:\n                    case TOKEN_LBRACE:\n                        break;\n\n                    default:\n                        current = current->parent;\n                        continue;\n                    }\n                    break;\n                }\n\n                if (!current) {\n                    new->left = root;\n                    root->parent = new;\n                    current = root = new;\n                    continue;\n                }\n\n                new->left = current->right;\n                new->left->parent = new;\n                new->parent = current;\n                current = current->right = new;\n                continue;\n\n            default:\n                break;\n            }\n            break;\n\n        case TOKEN_EQ:\n        case TOKEN_NE:\n        case TOKEN_GE:\n        case TOKEN_GT:\n        case TOKEN_LE:\n        case TOKEN_LT:\n            if (current->token.type == TOKEN_STRING) {\n                current = current->parent;\n\n                if (!current) {\n                    new->left = root;\n                    root->parent = new;\n                    current = root = new;\n                    continue;\n                }\n\n                switch (current->token.type) {\n                case TOKEN_LBRACE:\n                case TOKEN_AND:\n                case TOKEN_OR:\n                    new->left = current->right;\n                    new->left->parent = new;\n                    new->parent = current;\n                    current = current->right = new;\n                    continue;\n\n                default:\n                    break;\n                }\n            }\n            break;\n\n        case TOKEN_RBRACE:\n            while (current && current->token.type != TOKEN_LBRACE) {\n                current = current->parent;\n            }\n\n            if (current) {\n                TYPE_TOKEN(&current->token, TOKEN_GROUP);\n                continue;\n            }\n\n            error = \"Unmatched ')' in \\\"%s\\\" in file %s\";\n            break;\n\n        case TOKEN_NOT:\n        case TOKEN_ACCESS:\n        case TOKEN_LBRACE:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_RE:\n            case TOKEN_RBRACE:\n            case TOKEN_GROUP:\n                break;\n\n            default:\n                current->right = new;\n                new->parent = current;\n                current = new;\n                continue;\n            }\n            break;\n\n        default:\n            break;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, error, expr, r->filename);\n        *was_error = 1;\n        return 0;\n    }\n\n    DEBUG_DUMP_TREE(ctx, root);\n\n    \n    current = root;\n    error = NULL;\n    while (current) {\n        switch (current->token.type) {\n        case TOKEN_STRING:\n            current->token.value =\n                ap_ssi_parse_string(ctx, current->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n            current->value = !!*current->token.value;\n            break;\n\n        case TOKEN_AND:\n        case TOKEN_OR:\n            if (!current->left || !current->right) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Invalid expression \\\"%s\\\" in file %s\",\n                              expr, r->filename);\n                *was_error = 1;\n                return 0;\n            }\n\n            if (!current->left->done) {\n                switch (current->left->token.type) {\n                case TOKEN_STRING:\n                    current->left->token.value =\n                        ap_ssi_parse_string(ctx, current->left->token.value,\n                                            NULL, 0, SSI_EXPAND_DROP_NAME);\n                    current->left->value = !!*current->left->token.value;\n                    DEBUG_DUMP_EVAL(ctx, current->left);\n                    current->left->done = 1;\n                    break;\n\n                default:\n                    current = current->left;\n                    continue;\n                }\n            }\n\n            \n            if (!current->right->done && !regex &&\n                ((current->token.type == TOKEN_AND && !current->left->value) ||\n                (current->token.type == TOKEN_OR && current->left->value))) {\n                current->value = current->left->value;\n            }\n            else {\n                if (!current->right->done) {\n                    switch (current->right->token.type) {\n                    case TOKEN_STRING:\n                        current->right->token.value =\n                            ap_ssi_parse_string(ctx,current->right->token.value,\n                                                NULL, 0, SSI_EXPAND_DROP_NAME);\n                        current->right->value = !!*current->right->token.value;\n                        DEBUG_DUMP_EVAL(ctx, current->right);\n                        current->right->done = 1;\n                        break;\n\n                    default:\n                        current = current->right;\n                        continue;\n                    }\n                }\n\n                if (current->token.type == TOKEN_AND) {\n                    current->value = current->left->value &&\n                                     current->right->value;\n                }\n                else {\n                    current->value = current->left->value ||\n                                     current->right->value;\n                }\n            }\n            break;\n\n        case TOKEN_EQ:\n        case TOKEN_NE:\n            if (!current->left || !current->right ||\n                current->left->token.type != TOKEN_STRING ||\n                (current->right->token.type != TOKEN_STRING &&\n                 current->right->token.type != TOKEN_RE)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                            \"Invalid expression \\\"%s\\\" in file %s\",\n                            expr, r->filename);\n                *was_error = 1;\n                return 0;\n            }\n            current->left->token.value =\n                ap_ssi_parse_string(ctx, current->left->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n            current->right->token.value =\n                ap_ssi_parse_string(ctx, current->right->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n\n            if (current->right->token.type == TOKEN_RE) {\n                current->value = re_check(ctx, current->left->token.value,\n                                          current->right->token.value);\n                --regex;\n            }\n            else {\n                current->value = !strcmp(current->left->token.value,\n                                         current->right->token.value);\n            }\n\n            if (current->token.type == TOKEN_NE) {\n                current->value = !current->value;\n            }\n            break;\n\n        case TOKEN_GE:\n        case TOKEN_GT:\n        case TOKEN_LE:\n        case TOKEN_LT:\n            if (!current->left || !current->right ||\n                current->left->token.type != TOKEN_STRING ||\n                current->right->token.type != TOKEN_STRING) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Invalid expression \\\"%s\\\" in file %s\",\n                              expr, r->filename);\n                *was_error = 1;\n                return 0;\n            }\n\n            current->left->token.value =\n                ap_ssi_parse_string(ctx, current->left->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n            current->right->token.value =\n                ap_ssi_parse_string(ctx, current->right->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n\n            current->value = strcmp(current->left->token.value,\n                                    current->right->token.value);\n\n            switch (current->token.type) {\n            case TOKEN_GE: current->value = current->value >= 0; break;\n            case TOKEN_GT: current->value = current->value >  0; break;\n            case TOKEN_LE: current->value = current->value <= 0; break;\n            case TOKEN_LT: current->value = current->value <  0; break;\n            default: current->value = 0; break; \n            }\n            break;\n\n        case TOKEN_NOT:\n        case TOKEN_GROUP:\n            if (current->right) {\n                if (!current->right->done) {\n                    current = current->right;\n                    continue;\n                }\n                current->value = current->right->value;\n            }\n            else {\n                current->value = 1;\n            }\n\n            if (current->token.type == TOKEN_NOT) {\n                current->value = !current->value;\n            }\n            break;\n\n        case TOKEN_ACCESS:\n            if (current->left || !current->right ||\n                (current->right->token.type != TOKEN_STRING &&\n                 current->right->token.type != TOKEN_RE)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                            \"Invalid expression \\\"%s\\\" in file %s: Token '-A' must be followed by a URI string.\",\n                            expr, r->filename);\n                *was_error = 1;\n                return 0;\n            }\n            current->right->token.value =\n                ap_ssi_parse_string(ctx, current->right->token.value, NULL, 0,\n                                    SSI_EXPAND_DROP_NAME);\n            rr = ap_sub_req_lookup_uri(current->right->token.value, r, NULL);\n            \n            if (rr->status < HTTP_BAD_REQUEST) {\n                current->value = 1;\n            }\n            else {\n                current->value = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rr->status, r, \n                              \"mod_include: The tested \"\n                              \"subrequest -A \\\"%s\\\" returned an error code.\",\n                              current->right->token.value);\n            }\n            ap_destroy_sub_req(rr);\n            break;\n\n        case TOKEN_RE:\n            if (!error) {\n                error = \"No operator before regex in expr \\\"%s\\\" in file %s\";\n            }\n        case TOKEN_LBRACE:\n            if (!error) {\n                error = \"Unmatched '(' in \\\"%s\\\" in file %s\";\n            }\n        default:\n            if (!error) {\n                error = \"internal parser error in \\\"%s\\\" in file %s\";\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, error, expr,r->filename);\n            *was_error = 1;\n            return 0;\n        }\n\n        DEBUG_DUMP_EVAL(ctx, current);\n        current->done = 1;\n        current = current->parent;\n    }\n\n    return (root ? root->value : 0);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_9b0136bb9259efeb58bbe59a799479943270043f_0", {
    "ID": "httpd_9b0136bb9259efeb58bbe59a799479943270043f_0",
    "UID": "649",
    "code": "static apr_status_t to_dbm(apr_dbm_t *dbm, apr_file_t *fp, apr_pool_t test_snippet\n{\n    apr_status_t rv = APR_SUCCESS;\n    char line[REWRITE_MAX_TXT_MAP_LINE + 1]; \n    apr_datum_t dbmkey;\n    apr_datum_t dbmval;\n    apr_pool_t* p;\n\n    apr_pool_create(&p, pool);\n\n    while (apr_file_gets(line, sizeof(line), fp) == APR_SUCCESS) {\n        char *c, *value;\n\n        if (*line == '#' || apr_isspace(*line)) {\n            continue;\n        }\n\n        c = line;\n\n        while (*c && !apr_isspace(*c)) {\n            ++c;\n        }\n\n        if (!*c) {\n            \n            continue;\n        }\n\n        dbmkey.dptr = apr_pstrmemdup(p, line,  c - line);\n        dbmkey.dsize = (c - line);\n\n        while(*c && apr_isspace(*c)) {\n            ++c;\n        }\n\n        if (!*c) {\n            apr_pool_clear(p);\n            continue;\n        }\n\n        value = c;\n\n        while(*c && !apr_isspace(*c)) {\n            ++c;\n        }\n\n        dbmval.dptr = apr_pstrmemdup(p, value,  c - value);\n        dbmval.dsize = (c - line);\n\n        if (verbose) {\n            apr_file_printf(errfile, \"    '%s' -> '%s'\"NL, \n                            dbmkey.dptr, dbmval.dptr);\n        }\n\n        rv = apr_dbm_store(dbm, dbmkey, dbmval);\n\n        apr_pool_clear(p);\n\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n    }\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_762dc1feb1744e68882915171eba1c346a4e8b3c_0", {
    "ID": "httpd_762dc1feb1744e68882915171eba1c346a4e8b3c_0",
    "UID": "651",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet_test_snippetvtest_snippetetest_snippetrtest_snippetitest_snippetftest_snippetytest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet_test_snippetttest_snippet test_snippet*test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet)test_snippet test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetdtest_snippetatest_snippetttest_snippetutest_snippetmtest_snippet_test_snippetttest_snippet test_snippetktest_snippetetest_snippetytest_snippet,test_snippet test_snippetvtest_snippetatest_snippetltest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippetptest_snippetwtest_snippetdtest_snippet[test_snippetMtest_snippetAtest_snippetXtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet]test_snippet test_snippet=test_snippet test_snippet{test_snippet0test_snippet}test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetrtest_snippetetest_snippetctest_snippet,test_snippet test_snippet*test_snippetctest_snippetmtest_snippetntest_snippetttest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetktest_snippetetest_snippetytest_snippet.test_snippetdtest_snippetptest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetktest_snippetetest_snippetytest_snippet.test_snippetdtest_snippetstest_snippetitest_snippetztest_snippetetest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetdtest_snippetbtest_snippetmtest_snippet_test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetstest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetdtest_snippetbtest_snippetmtest_snippet,test_snippet test_snippetktest_snippetetest_snippetytest_snippet)test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetEtest_snippetNtest_snippetOtest_snippetEtest_snippetNtest_snippetTtest_snippet;test_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetdtest_snippetbtest_snippetmtest_snippet_test_snippetftest_snippetetest_snippetttest_snippetctest_snippethtest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetdtest_snippetbtest_snippetmtest_snippet,test_snippet test_snippetktest_snippetetest_snippetytest_snippet,test_snippet test_snippet&test_snippetvtest_snippetatest_snippetltest_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetEtest_snippetNtest_snippetOtest_snippetEtest_snippetNtest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetctest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetntest_snippetdtest_snippetutest_snippetptest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetvtest_snippetatest_snippetltest_snippet.test_snippetdtest_snippetptest_snippetttest_snippetrtest_snippet,test_snippet test_snippetvtest_snippetatest_snippetltest_snippet.test_snippetdtest_snippetstest_snippetitest_snippetztest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetmtest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippetrtest_snippetetest_snippetctest_snippet,test_snippet test_snippet'test_snippet:test_snippet'test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetmtest_snippetntest_snippetttest_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetrtest_snippetntest_snippetctest_snippetptest_snippetytest_snippet(test_snippetptest_snippetwtest_snippetdtest_snippet,test_snippet test_snippetrtest_snippetetest_snippetctest_snippet,test_snippet test_snippetctest_snippetmtest_snippetntest_snippetttest_snippet test_snippet-test_snippet test_snippetrtest_snippetetest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetptest_snippetytest_snippet(test_snippetptest_snippetwtest_snippetdtest_snippet,test_snippet test_snippetrtest_snippetetest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetatest_snippetstest_snippetstest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet_test_snippetvtest_snippetatest_snippetltest_snippetitest_snippetdtest_snippetatest_snippetttest_snippetetest_snippet(test_snippethtest_snippetttest_snippetdtest_snippetbtest_snippetmtest_snippet-test_snippet>test_snippetutest_snippetstest_snippetetest_snippetrtest_snippetptest_snippetatest_snippetstest_snippetstest_snippet,test_snippet test_snippetptest_snippetwtest_snippetdtest_snippet)test_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "null"
  },
  "httpd_52b9e763e94e103cfe659f8483f904337e658b5b_0", {
    "ID": "httpd_52b9e763e94e103cfe659f8483f904337e658b5b_0",
    "UID": "653",
    "code": "static void *merge_core_server_configs(apr_pool_t *p, void *basev, void test_snippet\n{\n    core_server_config *base = (core_server_config *)basev;\n    core_server_config *virt = (core_server_config *)virtv;\n    core_server_config *conf;\n\n    conf = (core_server_config *)apr_palloc(p, sizeof(core_server_config));\n    memcpy(conf, virt, sizeof(core_server_config));\n\n    if (!conf->access_name) {\n        conf->access_name = base->access_name;\n    }\n\n    if (!conf->ap_document_root) {\n        conf->ap_document_root = base->ap_document_root;\n    }\n\n    if (!conf->protocol) {\n        conf->protocol = base->protocol;\n    }\n\n    conf->sec_dir = apr_array_append(p, base->sec_dir, virt->sec_dir);\n    conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);\n\n    conf->redirect_limit = virt->redirect_limit\n                           ? virt->redirect_limit\n                           : base->redirect_limit;\n\n    conf->subreq_limit = virt->subreq_limit\n                         ? virt->subreq_limit\n                         : base->subreq_limit;\n\n    conf->trace_enable = (virt->trace_enable != AP_TRACE_UNSET)\n                         ? virt->trace_enable\n                         : base->trace_enable;\n\n    return conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e471434d7a7d55e0396110889ce0bf2c17cdb623_0", {
    "ID": "httpd_e471434d7a7d55e0396110889ce0bf2c17cdb623_0",
    "UID": "654",
    "code": "static const char *log_request_time(request_rec *r, char test_snippet\n{\n    apr_time_exp_t xt;\n\n    /* ###  I think getting the time again at the end of the request\n     * just for logging is dumb.  i know it's \"required\" for CLF.\n     * folks writing log parsing tools don't realise that out of order\n     * times have always been possible (consider what happens if one\n     * process calculates the time to log, but then there's a context\n     * switch before it writes and before that process is run again the\n     * log rotation occurs) and they should just fix their tools rather\n     * than force the server to pay extra cpu cycles.  if you've got\n     * a problem with this, you can set the define.  -djg\n     */\n    if (a && test_snippet {              \n        /* The custom time formatting uses a very large temp buffer\n         * on the stack.  To avoid using so much stack space in the\n         * common case where we're not using a custom format, the code\n         * for the custom format in a separate function.  (That's why\n         * log_request_time_custom is not inlined right here.)\n         */\n#ifdef I_INSIST_ON_EXTRA_CYCLES_FOR_CLF_COMPLIANCE\n        ap_explode_recent_localtime(&xt, apr_time_now());\n#else\n        ap_explode_recent_localtime(&xt, r->request_time);\n#endif\n        return log_request_time_custom(r, a, &xt);\n    }\n    else {                      \n        /* This code uses the same technique as ap_explode_recent_localtime():\n         * optimistic caching with logic to detect and correct race conditions.\n         * See the comments in server/util_time.c for more information.\n         */\n        cached_request_time* cached_time = apr_palloc(r->pool,\n                                                      sizeof(*cached_time));\n#ifdef I_INSIST_ON_EXTRA_CYCLES_FOR_CLF_COMPLIANCE\n        apr_time_t request_time = apr_time_now();\n#else\n        apr_time_t request_time = r->request_time;\n#endif\n        unsigned t_seconds = (unsigned)apr_time_sec(request_time);\n        unsigned i = t_seconds & TIME_CACHE_MASK;\n        *cached_time = request_time_cache[i];\n        if ((t_seconds != cached_time->t) ||\n            (t_seconds != cached_time->t_validate)) {\n\n            /* Invalid or old snapshot, so compute the proper time string\n             * and store it in the cache\n             */\n            char sign;\n            int timz;\n\n            ap_explode_recent_localtime(&xt, request_time);\n            timz = xt.tm_gmtoff;\n            if (timz < 0) {\n                timz = -timz;\n                sign = '-';\n            }\n            else {\n                sign = '+';\n            }\n            cached_time->t = t_seconds;\n            apr_snprintf(cached_time->timestr, DEFAULT_REQUEST_TIME_SIZE,\n                         \"[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]\",\n                         xt.tm_mday, apr_month_snames[xt.tm_mon],\n                         xt.tm_year+1900, xt.tm_hour, xt.tm_min, xt.tm_sec,\n                         sign, timz / (60*60), (timz % (60*60)) / 60);\n            cached_time->t_validate = t_seconds;\n            request_time_cache[i] = *cached_time;\n        }\n        return cached_time->timestr;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n546,Suspicious Comment"
  },
  "httpd_71975b348f5c0087ba7371aff095a42e08f8315c_0", {
    "ID": "httpd_71975b348f5c0087ba7371aff095a42e08f8315c_0",
    "UID": "655",
    "code": "void ap_add_output_filters_by_type(request_rec test_snippet\n{\n    core_dir_config *conf;\n    const char *ctype;\n\n    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &core_module);\n\n    /* We can't do anything with proxy requests, no content-types or if\n     * we don't have a filter configured.\n     */\n    if (r->proxyreq != PROXYREQ_NONE || !r->content_type ||\n        !conf->ct_output_filters) {\n        return;\n    }\n\n    \n    ctype = ap_field_noparam(r->pool, r->content_type);\n    if (ctype) {\n        ap_filter_rec_t *ct_filter;\n        ct_filter = apr_hash_get(conf->ct_output_filters, ctype,\n                                 APR_HASH_KEY_STRING);\n        while (ct_filter) {\n            ap_add_output_filter(ct_filter->name, NULL, r, r->connection);\n            ct_filter = ct_filter->next;\n        }\n    }\n\n    return;\n}",
    "predicted": "415,Double Free\n416,Use After Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_277da7d3103ba1a0776c9cc6dd1f1c6402075f5d_0", {
    "ID": "httpd_277da7d3103ba1a0776c9cc6dd1f1c6402075f5d_0",
    "UID": "664",
    "code": "static void printstats(apr_off_t total, apr_off_t sum, apr_off_t test_snippet\n                       apr_off_t etotal, apr_off_t entries)\n{\n    char ttype, stype, mtype, utype;\n    apr_off_t tfrag, sfrag, ufrag;\n\n    if (!verbose) {\n        return;\n    }\n\n    ttype = 'K';\n    tfrag = ((total * 10) / KBYTE) % 10;\n    total /= KBYTE;\n    if (total >= KBYTE) {\n        ttype = 'M';\n        tfrag = ((total * 10) / KBYTE) % 10;\n        total /= KBYTE;\n    }\n\n    stype = 'K';\n    sfrag = ((sum * 10) / KBYTE) % 10;\n    sum /= KBYTE;\n    if (sum >= KBYTE) {\n        stype = 'M';\n        sfrag = ((sum * 10) / KBYTE) % 10;\n        sum /= KBYTE;\n    }\n\n    mtype = 'K';\n    max /= KBYTE;\n    if (max >= KBYTE) {\n        mtype = 'M';\n        max /= KBYTE;\n    }\n\n    apr_file_printf(errfile, \"Statistics:\" APR_EOL_STR);\n    if (unsolicited) {\n        utype = 'K';\n        ufrag = ((unsolicited * 10) / KBYTE) % 10;\n        unsolicited /= KBYTE;\n        if (unsolicited >= KBYTE) {\n            utype = 'M';\n            ufrag = ((unsolicited * 10) / KBYTE) % 10;\n            unsolicited /= KBYTE;\n        }\n        if (!unsolicited && !ufrag) {\n            ufrag = 1;\n        }\n        apr_file_printf(errfile, \"unsolicited size %d.%d%c\" APR_EOL_STR,\n                        (int)(unsolicited), (int)(ufrag), utype);\n     }\n     apr_file_printf(errfile, \"size limit %d.0%c\" APR_EOL_STR,\n                     (int)(max), mtype);\n     apr_file_printf(errfile, \"total size was %d.%d%c, total size now \"\n                              \"%d.%d%c\" APR_EOL_STR,\n                     (int)(total), (int)(tfrag), ttype, (int)(sum),\n                     (int)(sfrag), stype);\n     apr_file_printf(errfile, \"total entries was %d, total entries now %d\"\n                              APR_EOL_STR, (int)(etotal), (int)(entries));\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_0bf04d0f0df745900ad6c002f807acc85ef9f6f9_0", {
    "ID": "httpd_0bf04d0f0df745900ad6c002f807acc85ef9f6f9_0",
    "UID": "666",
    "code": "static void delete_file(char *path, char *basename, apr_pool_t test_snippet\n{\n    char *nextpath;\n    apr_pool_t *p;\n\n    if (dryrun) {\n        return;\n    }\n\n    \n    apr_pool_create(&p, pool);\n    nextpath = apr_pstrcat(p, path, \"/\", basename, NULL);\n    apr_file_remove(nextpath, p);\n    apr_pool_destroy(p);\n\n    if (benice) {\n        if (++delcount >= DELETE_NICE) {\n            apr_sleep(NICE_DELAY);\n            delcount = 0;\n        }\n    }\n}",
    "predicted": "272,Least Privilege Violation\n377,Insecure Temporary File\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_bcbc8b01a995f2d1f81f1a02f01466d1cb14e182_0", {
    "ID": "httpd_bcbc8b01a995f2d1f81f1a02f01466d1cb14e182_0",
    "UID": "690",
    "code": "static void *create_access_compat_dir_config(apr_pool_t *p, char test_snippet\n{\n    int i;\n    access_compat_dir_conf *conf =\n        (access_compat_dir_conf *)apr_pcalloc(p, sizeof(access_compat_dir_conf));\n\n    for (i = 0; i < METHODS; ++i) {\n        conf->order[i] = DENY_THEN_ALLOW;\n    }\n    conf->allows = apr_array_make(p, 1, sizeof(allowdeny));\n    conf->denys = apr_array_make(p, 1, sizeof(allowdeny));\n    conf->satisfy = apr_palloc(p, sizeof(*conf->satisfy) * METHODS);\n    for (i = 0; i < METHODS; ++i) {\n        conf->satisfy[i] = SATISFY_NOSPEC;\n    }\n\n    return (void *)conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a672d1d57e5a51b48cf6ecb88df2f679acb90f9b_0", {
    "ID": "httpd_a672d1d57e5a51b48cf6ecb88df2f679acb90f9b_0",
    "UID": "691",
    "code": "static const char *satisfy(cmd_parms *cmd, void *dv, const char test_snippet\n{\n    access_compat_dir_conf *d = (access_compat_dir_conf *) dv;\n    int satisfy = SATISFY_NOSPEC;\n    int i;\n\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server,\n                  \"The 'Satisfy' directive has been deprecated. \"\n                  \"Consider using '<SatisfyAll><SatisfyOne>' directives.\"); \n\n    if (!strcasecmp(arg, \"all\")) {\n        satisfy = SATISFY_ALL;\n    }\n    else if (!strcasecmp(arg, \"any\")) {\n        satisfy = SATISFY_ANY;\n    }\n    else {\n        return \"Satisfy either 'any' or 'all'.\";\n    }\n\n    for (i = 0; i < METHODS; ++i) {\n        if (cmd->limited & (AP_METHOD_BIT << i)) {\n            d->satisfy[i] = satisfy;\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "546,Suspicious Comment"
  },
  "httpd_960dacf6ff8407fb94d8f1a30055ddcdb2c09714_0", {
    "ID": "httpd_960dacf6ff8407fb94d8f1a30055ddcdb2c09714_0",
    "UID": "716",
    "code": "AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char test_snippet\n                                                const char *new_uri,\n                                                const request_rec *r,\n                                                ap_filter_t *next_filter)\n{\n    request_rec *rnew;\n    int res;\n    char *udir;\n\n    rnew = make_sub_request(r, next_filter);\n\n    \n    rnew->method = method;\n    rnew->method_number = ap_method_number_of(method);\n\n    if (new_uri[0] == '/') {\n        ap_parse_uri(rnew, new_uri);\n    }\n    else {\n        udir = ap_make_dirstr_parent(rnew->pool, r->uri);\n        udir = ap_escape_uri(rnew->pool, udir);    \n        ap_parse_uri(rnew, ap_make_full_path(rnew->pool, udir, new_uri));\n    }\n\n    /* We cannot return NULL without violating the API. So just turn this\n     * subrequest into a 500 to indicate the failure. */\n    if (ap_is_recursion_limit_exceeded(r)) {\n        rnew->status = HTTP_INTERNAL_SERVER_ERROR;\n        return rnew;\n    }\n\n    /* lookup_uri \n     * If the content can be served by the quick_handler, we can\n     * safely bypass request_internal processing.\n     */\n    res = ap_run_quick_handler(rnew, 1);\n\n    if (res != OK) {\n        if ((res = ap_process_request_internal(rnew))) {\n            rnew->status = res;\n        }\n    } \n\n    return rnew;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_0b559ca34c34cc69362641f688559ed330000004_0", {
    "ID": "httpd_0b559ca34c34cc69362641f688559ed330000004_0",
    "UID": "754",
    "code": "static char x2c(const char test_snippet\n{\n    register char digit;\n\n#if !APR_CHARSET_EBCDIC\n    digit = ((what[0] >= 'A') ? ((what[0] & 0xdf) - 'A') + 10\n             : (what[0] - '0'));\n    digit *= 16;\n    digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A') + 10\n              : (what[1] - '0'));\n#else \n    char xstr[5];\n    xstr[0]='0';\n    xstr[1]='x';\n    xstr[2]=what[0];\n    xstr[3]=what[1];\n    xstr[4]='\\0';\n    digit = apr_xlate_conv_byte(ap_hdrs_from_ascii,\n                                0xFF & strtol(xstr, NULL, 16));\n#endif \n    return (digit);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_ef21ea167823bec1537aadaf965ced10bd75ddea_0", {
    "ID": "httpd_ef21ea167823bec1537aadaf965ced10bd75ddea_0",
    "UID": "765",
    "code": "AP_DECLARE(int) ap_set_keepalive(request_rec test_snippet\n{\n    int ka_sent = 0;\n    int wimpy = ap_find_token(r->pool,\n                              apr_table_get(r->headers_out, \"Connection\"),\n                              \"close\");\n    const char *conn = apr_table_get(r->headers_in, \"Connection\");\n\n    /* The following convoluted conditional determines whether or not\n     * the current connection should remain persistent after this response\n     * (a.k.a. HTTP Keep-Alive) and whether or not the output message\n     * body should use the HTTP/1.1 chunked transfer-coding.  In English,\n     *\n     *   IF  we have not marked this connection as errored;\n     *   and the response body has a defined length due to the status code\n     *       being 304 or 204, the request method being HEAD, already\n     *       having defined Content-Length or Transfer-Encoding: chunked, or\n     *       the request version being HTTP/1.1 and thus capable of being set\n     *       as chunked [we know the (r->chunked = 1) side-effect is ugly];\n     *   and the server configuration enables keep-alive;\n     *   and the server configuration has a reasonable inter-request timeout;\n     *   and there is no maximum # requests or the max hasn't been reached;\n     *   and the response status does not require a close;\n     *   and the response generator has not already indicated close;\n     *   and the client did not request non-persistence (Connection: close);\n     *   and    we haven't been configured to ignore the buggy twit\n     *       or they're a buggy twit coming through a HTTP/1.1 proxy\n     *   and    the client is requesting an HTTP/1.0-style keep-alive\n     *       or the client claims to be HTTP/1.1 compliant (perhaps a proxy);\n     *   and this MPM process is not already exiting\n     *   THEN we can be persistent, which requires more headers be output.\n     *\n     * Note that the condition evaluation order is extremely important.\n     */\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && ((r->status == HTTP_NOT_MODIFIED)\n            || (r->status == HTTP_NO_CONTENT)\n            || r->header_only\n            || apr_table_get(r->headers_out, \"Content-Length\")\n            || ap_find_last_token(r->pool,\n                                  apr_table_get(r->headers_out,\n                                                \"Transfer-Encoding\"),\n                                  \"chunked\")\n            || ((r->proto_num >= HTTP_VERSION(1,1))\n                && (r->chunked = 1))) \n        && r->server->keep_alive\n        && (r->server->keep_alive_timeout > 0)\n        && ((r->server->keep_alive_max == 0)\n            || (r->server->keep_alive_max > r->connection->keepalives))\n        && !ap_status_drops_connection(r->status)\n        && !wimpy\n        && !ap_find_token(r->pool, conn, \"close\")\n        && (!apr_table_get(r->subprocess_env, \"nokeepalive\")\n            || apr_table_get(r->headers_in, \"Via\"))\n        && ((ka_sent = ap_find_token(r->pool, conn, \"keep-alive\"))\n            || (r->proto_num >= HTTP_VERSION(1,1)))\n        && !ap_graceful_stop_signalled()) {\n        int left = r->server->keep_alive_max - r->connection->keepalives;\n\n        r->connection->keepalive = AP_CONN_KEEPALIVE;\n        r->connection->keepalives++;\n\n        \n        if (ka_sent) {\n            if (r->server->keep_alive_max) {\n                apr_table_setn(r->headers_out, \"Keep-Alive\",\n                       apr_psprintf(r->pool, \"timeout=%d, max=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout),\n                            left));\n            }\n            else {\n                apr_table_setn(r->headers_out, \"Keep-Alive\",\n                      apr_psprintf(r->pool, \"timeout=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout)));\n            }\n            apr_table_mergen(r->headers_out, \"Connection\", \"Keep-Alive\");\n        }\n\n        return 1;\n    }\n\n    /* Otherwise, we need to indicate that we will be closing this\n     * connection immediately after the current response.\n     *\n     * We only really need to send \"close\" to HTTP/1.1 clients, but we\n     * always send it anyway, because a broken proxy may identify itself\n     * as HTTP/1.0, but pass our request along with our HTTP/1.1 tag\n     * to a HTTP/1.1 client. Better safe than sorry.\n     */\n    if (!wimpy) {\n        apr_table_mergen(r->headers_out, \"Connection\", \"close\");\n    }\n\n    r->connection->keepalive = AP_CONN_CLOSE;\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b73b8d8e8fa60f92a5eb47f6ded9dbcb7de9fe86_0", {
    "ID": "httpd_b73b8d8e8fa60f92a5eb47f6ded9dbcb7de9fe86_0",
    "UID": "768",
    "code": "static int ap_process_http_async_connection(conn_rec test_snippet\n{\n    request_rec *r;\n    conn_state_t *cs = c->cs;\n\n    if (c->clogging_input_filters) {\n        return ap_process_http_connection(c);\n    }\n\n    AP_DEBUG_ASSERT(cs->state == CONN_STATE_READ_REQUEST_LINE);\n\n    while (cs->state == CONN_STATE_READ_REQUEST_LINE) {\n        ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);\n\n        if ((r = ap_read_request(c))) {\n\n            c->keepalive = AP_CONN_UNKNOWN;\n            \n\n            ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n            if (r->status == HTTP_OK) {\n                cs->state = CONN_STATE_HANDLER;\n                ap_process_async_request(r);\n                /* After the call to ap_process_request, the\n                 * request pool may have been deleted.  We set\n                 * r=NULL here to ensure that any dereference\n                 * of r that might be added later in this function\n                 * will result in a segfault immediately instead\n                 * of nondeterministic failures later.\n                 */\n                r = NULL;\n            }\n\n            if (cs->state != CONN_STATE_WRITE_COMPLETION) {\n                \n                cs->state = CONN_STATE_LINGER;\n            }\n        }\n        else {   \n            cs->state = CONN_STATE_LINGER;\n        }\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_9339c5de275bb1a435f36d256d30991bb27d8da6_0", {
    "ID": "httpd_9339c5de275bb1a435f36d256d30991bb27d8da6_0",
    "UID": "769",
    "code": "static int ap_process_http_connection(conn_rec test_snippet\n{\n    request_rec *r;\n    conn_state_t *cs = c->cs;\n    apr_socket_t *csd = NULL;\n\n    /*\n     * Read and process each request found on our connection\n     * until no requests are left or we decide to close.\n     */\n\n    ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);\n    while ((r = ap_read_request(c)) != NULL) {\n\n        c->keepalive = AP_CONN_UNKNOWN;\n        \n\n        ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n        if (r->status == HTTP_OK) {\n            cs->state = CONN_STATE_HANDLER;\n            ap_process_request(r);\n            /* After the call to ap_process_request, the\n             * request pool will have been deleted.  We set\n             * r=NULL here to ensure that any dereference\n             * of r that might be added later in this function\n             * will result in a segfault immediately instead\n             * of nondeterministic failures later.\n             */\n            r = NULL;\n        }\n\n        if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n            break;\n\n        ap_update_child_status(c->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n\n        if (ap_graceful_stop_signalled())\n            break;\n\n        if (!csd) {\n            csd = ap_get_module_config(c->conn_config, &core_module);\n        }\n        apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n        apr_socket_timeout_set(csd, c->base_server->keep_alive_timeout);\n        \n    }\n\n    return OK;\n}",
    "predicted": "416,Use After Free"
  },
  "httpd_b3bdeb6c5241e3adf341134aed9d0824d3e7fa6b_0", {
    "ID": "httpd_b3bdeb6c5241e3adf341134aed9d0824d3e7fa6b_0",
    "UID": "782",
    "code": "AP_DECLARE(int) ap_discard_request_body(request_rec test_snippet\n{\n    apr_bucket_brigade *bb, *kept_body = NULL;\n    apr_bucket *e;\n    int rv, seen_eos;\n    core_dir_conf *dconf;\n    apr_size_t left = 0;\n\n    /* Sometimes we'll get in a state where the input handling has\n     * detected an error where we want to drop the connection, so if\n     * that's the case, don't read the data as that is what we're trying\n     * to avoid.\n     *\n     * This function is also a no-op on a subrequest.\n     */\n    if (r->main || r->connection->keepalive == AP_CONN_CLOSE ||\n        ap_status_drops_connection(r->status)) {\n        return OK;\n    }\n\n    /* We may want to save this body away if the administrator has\n     * asked us to do so for this directory. This allows the body\n     * to be reexamined by filters such as mod_include, even though\n     * the main request has no need for this body.\n     */\n    if (!r->kept_body) {\n        dconf = ap_get_module_config(r->per_dir_config,\n                                     &http_module);\n        if (dconf->keep_body > 0) {\n            left = dconf->keep_body;\n            kept_body = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n        }\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    seen_eos = 0;\n    do {\n        apr_bucket *bucket;\n\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, HUGE_STRING_LEN);\n\n        if (rv != APR_SUCCESS) {\n            /* FIXME: If we ever have a mapping from filters (apr_status_t)\n             * to HTTP error codes, this would be a good place for them.\n             *\n             * If we received the special case AP_FILTER_ERROR, it means\n             * that the filters have already handled this error.\n             * Otherwise, we should assume we have a bad request.\n             */\n            if (rv == AP_FILTER_ERROR) {\n                apr_brigade_destroy(bb);\n                return rv;\n            }\n            else {\n                apr_brigade_destroy(bb);\n                return HTTP_BAD_REQUEST;\n            }\n        }\n\n        for (bucket = APR_BRIGADE_FIRST(bb);\n             bucket != APR_BRIGADE_SENTINEL(bb);\n             bucket = APR_BUCKET_NEXT(bucket))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bucket)) {\n                seen_eos = 1;\n                break;\n            }\n\n            \n            if (bucket->length == 0) {\n                continue;\n            }\n\n            /* We MUST read because in case we have an unknown-length\n             * bucket or one that morphs, we want to exhaust it.\n             */\n            rv = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                apr_brigade_destroy(bb);\n                return HTTP_BAD_REQUEST;\n            }\n\n            /* If we have been asked to, keep the data up until the\n             * configured limit. If the limit is exceeded, we return an\n             * HTTP_REQUEST_ENTITY_TOO_LARGE response so the caller is\n             * clear the server couldn't handle their request.\n             */\n            if (kept_body) {\n                if (len <= left) {\n                    apr_bucket_copy(bucket, &e);\n                    APR_BRIGADE_INSERT_TAIL(kept_body, e);\n                    left -= len;\n                }\n                else {\n                    apr_brigade_destroy(bb);\n                    apr_brigade_destroy(kept_body);\n                    return HTTP_REQUEST_ENTITY_TOO_LARGE;\n                }\n            }\n            \n        }\n        apr_brigade_cleanup(bb);\n    } while (!seen_eos);\n\n    if (kept_body) {\n        r->kept_body = kept_body;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_836aa4f0318d21cbdbc4e63c8329980e9d16527d_0", {
    "ID": "httpd_836aa4f0318d21cbdbc4e63c8329980e9d16527d_0",
    "UID": "792",
    "code": "static int read_request_line(request_rec *r, apr_bucket_brigade test_snippet\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n\n#if 0\n    conn_rec *conn = r->connection;\n#endif\n    int major = 1, minor = 0;   \n    char http[5];\n    apr_size_t len;\n    int num_blank_lines = 0;\n    int max_blank_lines = r->server->limit_req_fields;\n\n    if (max_blank_lines <= 0) {\n        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;\n    }\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* insure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (rv == APR_ENOSPC) {\n                r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n                r->proto_num = HTTP_VERSION(1,0);\n                r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n            }\n            return 0;\n        }\n    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));\n\n    \n\n    r->request_time = apr_time_now();\n    ll = r->the_request;\n    r->method = ap_getword_white(r->pool, &ll);\n\n#if 0\n/* XXX If we want to keep track of the Method, the protocol module should do\n * it.  That support isn't in the scoreboard yet.  Hopefully next week\n * sometime.   rbb */\n    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), \"Method\",\n                                r->method);\n#endif\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    \n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    \n\n    \n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n             && (strcasecmp(\"http\", http) == 0)\n             && (minor < HTTP_VERSION(1, 0)) ) \n        r->proto_num = HTTP_VERSION(major, minor);\n    else\n        r->proto_num = HTTP_VERSION(1, 0);\n\n    return 1;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_1d67868c09ea37ea753d436c735956822c1a0114_0", {
    "ID": "httpd_1d67868c09ea37ea753d436c735956822c1a0114_0",
    "UID": "813",
    "code": "AP_DECLARE(void) ap_lingering_close(conn_rec test_snippet\n{\n    char dummybuf[512];\n    apr_size_t nbytes;\n    apr_time_t timeup = 0;\n    apr_socket_t *csd = ap_get_module_config(c->conn_config, &core_module);\n\n    if (!csd) {\n        return;\n    }\n\n    ap_update_child_status(c->sbh, SERVER_CLOSING, NULL);\n\n#ifdef NO_LINGCLOSE\n    ap_flush_conn(c); \n    apr_socket_close(csd);\n    return;\n#endif\n\n    /* Close the connection, being careful to send out whatever is still\n     * in our buffers.  If possible, try to avoid a hard close until the\n     * client has ACKed our FIN and/or has stopped sending us data.\n     */\n\n    \n    ap_flush_conn(c);\n\n    if (c->aborted) {\n        apr_socket_close(csd);\n        return;\n    }\n\n    /* Shut down the socket for write, which will send a FIN\n     * to the peer.\n     */\n    if (apr_socket_shutdown(csd, APR_SHUTDOWN_WRITE) != APR_SUCCESS\n        || c->aborted) {\n        apr_socket_close(csd);\n        return;\n    }\n\n    /* Read available data from the client whilst it continues sending\n     * it, for a maximum time of MAX_SECS_TO_LINGER.  If the client\n     * does not send any data within 2 seconds (a value pulled from\n     * Apache 1.3 which seems to work well), give up.\n     */\n    apr_socket_timeout_set(csd, apr_time_from_sec(SECONDS_TO_LINGER));\n    apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n\n    /* The common path here is that the initial apr_socket_recv() call\n     * will return 0 bytes read; so that case must avoid the expensive\n     * apr_time_now() call and time arithmetic. */\n\n    do {\n        nbytes = sizeof(dummybuf);\n        if (apr_socket_recv(csd, dummybuf, &nbytes) || nbytes == 0)\n            break;\n\n        if (timeup == 0) {\n            \n            timeup = apr_time_now() + apr_time_from_sec(MAX_SECS_TO_LINGER);\n            continue;\n        }\n    } while (apr_time_now() < timeup);\n\n    apr_socket_close(csd);\n    return;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_95b57da76943796e553ac8a9b6f75ecb90365fb4_0", {
    "ID": "httpd_95b57da76943796e553ac8a9b6f75ecb90365fb4_0",
    "UID": "818",
    "code": "static const char *filter_provider(cmd_parms *cmd, void *CFG, const char test_snippet\n{\n    mod_filter_cfg *cfg = CFG;\n    int flags;\n    ap_filter_provider_t *provider;\n    const char *rxend;\n    const char *c;\n    char *str;\n    const char *eq;\n    ap_filter_rec_t* frec;\n    ap_filter_rec_t* provider_frec;\n\n    \n    const char *fname = ap_getword_conf(cmd->pool, &args) ;\n    const char *pname = ap_getword_conf(cmd->pool, &args) ;\n    const char *condition = ap_getword_conf(cmd->pool, &args) ;\n    const char *match = ap_getword_conf(cmd->pool, &args) ;\n    eq = ap_getword_conf(cmd->pool, &args) ;\n    if ( !*fname || !*pname || !*match || !*condition || *eq ) {\n        return \"usage: FilterProvider filter provider condition match\" ;\n    }\n\n    \n    frec = apr_hash_get(cfg->live_filters, fname, APR_HASH_KEY_STRING);\n\n    \n    if (!frec) {\n        c = filter_declare(cmd, CFG, fname, NULL);\n        if ( c ) {\n            return c;\n        }\n        frec = apr_hash_get(cfg->live_filters, fname, APR_HASH_KEY_STRING);\n    }\n\n    if (!frec) {\n        return apr_psprintf(cmd->pool, \"Undeclared smart filter %s\", fname);\n    }\n\n    \n    provider_frec = ap_get_output_filter_handle(pname);\n    if (!provider_frec) {\n        provider_frec = apr_hash_get(cfg->live_filters, pname,\n                                     APR_HASH_KEY_STRING);\n    }\n    if (!provider_frec) {\n        return apr_psprintf(cmd->pool, \"Unknown filter provider %s\", pname);\n    }\n\n    provider = apr_palloc(cmd->pool, sizeof(ap_filter_provider_t));\n    if (*match == '!') {\n        provider->not = 1;\n        ++match;\n    }\n    else {\n        provider->not = 0;\n    }\n\n    switch (*match++) {\n    case '<':\n        if (*match == '=') {\n            provider->match_type = INT_LE;\n            ++match;\n        }\n        else {\n            provider->match_type = INT_LT;\n        }\n        provider->match.number = atoi(match);\n        break;\n    case '>':\n        if (*match == '=') {\n            provider->match_type = INT_GE;\n            ++match;\n        }\n        else {\n            provider->match_type = INT_GT;\n        }\n        provider->match.number = atoi(match);\n        break;\n    case '=':\n        provider->match_type = INT_EQ;\n        provider->match.number = atoi(match);\n        break;\n    case '/':\n        provider->match_type = REGEX_MATCH;\n        rxend = ap_strchr_c(match, '/');\n        if (!rxend) {\n              return \"Bad regexp syntax\";\n        }\n        flags = AP_REG_NOSUB;        \n        for (c = rxend+1; *c; ++c) {\n            switch (*c) {\n            case 'i': flags |= AP_REG_ICASE; break;\n            }\n        }\n        provider->match.regex = ap_pregcomp(cmd->pool,\n                                            apr_pstrndup(cmd->pool,\n                                                         match,\n                                                         rxend-match),\n                                            flags);\n        break;\n    case '*':\n        provider->match_type = DEFINED;\n        provider->match.number = -1;\n        break;\n    case '$':\n        provider->match_type = STRING_CONTAINS;\n        str = apr_pstrdup(cmd->pool, match);\n        ap_str_tolower(str);\n        provider->match.string = str;\n        break;\n    default:\n        provider->match_type = STRING_MATCH;\n        provider->match.string = apr_pstrdup(cmd->pool, match-1);\n        break;\n    }\n    provider->frec = provider_frec;\n    provider->next = frec->providers;\n    frec->providers = provider;\n\n    \n    eq = ap_strchr_c(condition, '=');\n    if (eq) {\n        str = apr_pstrdup(cmd->pool, eq+1);\n        if (!strncasecmp(condition, \"env=\", 4)) {\n            provider->dispatch = SUBPROCESS_ENV;\n        }\n        else if (!strncasecmp(condition, \"req=\", 4)) {\n            provider->dispatch = REQUEST_HEADERS;\n        }\n        else if (!strncasecmp(condition, \"resp=\", 5)) {\n            provider->dispatch = RESPONSE_HEADERS;\n        }\n        else {\n            return \"FilterProvider: unrecognized dispatch table\";\n        }\n    }\n    else {\n        if (!strcasecmp(condition, \"handler\")) {\n            provider->dispatch = HANDLER;\n        }\n        else {\n            provider->dispatch = RESPONSE_HEADERS;\n        }\n        str = apr_pstrdup(cmd->pool, condition);\n        ap_str_tolower(str);\n    }\n   \n    if (   (provider->dispatch == RESPONSE_HEADERS)\n        && !strcmp(str, \"content-type\")) {\n        provider->dispatch = CONTENT_TYPE;\n    }\n    provider->value = str;\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_a02d8d037d92486defa728d236fef26734776610_0", {
    "ID": "httpd_a02d8d037d92486defa728d236fef26734776610_0",
    "UID": "831",
    "code": "AP_DECLARE(void) ap_hook_check_authn(ap_HOOK_check_user_id_t test_snippet\n                                     const char * const *aszPre,\n                                     const char * const *aszSucc,\n                                     int nOrder, int type)\n{\n    if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {\n        ++auth_internal_per_conf_hooks;\n    }\n\n    ap_hook_check_user_id(pf, aszPre, aszSucc, nOrder);\n}",
    "predicted": "This code does not appear to have any obvious vulnerabilities, so the response would be null."
  },
  "httpd_08cd39bf59e34dc95688c6dac55ffaeea2597952_0", {
    "ID": "httpd_08cd39bf59e34dc95688c6dac55ffaeea2597952_0",
    "UID": "836",
    "code": "static const char *ifsection(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    core_dir_config *c = mconfig;\n    ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_LOCATION | NOT_IN_LIMIT);\n    const char *condition;\n    int expr_err = 0;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    condition = ap_getword_conf(cmd->pool, &arg);\n    \n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    \n    conf = ap_set_config_vectors(cmd->server, new_file_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    conf->condition = ap_expr_parse(cmd->pool, condition, &expr_err);\n    if (expr_err) {\n        return \"Cannot parse condition clause\";\n    }\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_file_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n\n    ap_add_file_conf(c, new_file_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_f20dcdd5331141c0e27e091197ec7342911ca060_0", {
    "ID": "httpd_f20dcdd5331141c0e27e091197ec7342911ca060_0",
    "UID": "846",
    "code": "AP_DECLARE(int) ap_regexec(const ap_regex_t *preg, const char test_snippet\n                           apr_size_t nmatch, ap_regmatch_t pmatch[],\n                           int eflags)\n{\nint rc;\nint options = 0;\nint *ovector = NULL;\nint small_ovector[POSIX_MALLOC_THRESHOLD * 3];\nint allocated_ovector = 0;\n\nif ((eflags & AP_REG_NOTBOL) != 0) options |= PCRE_NOTBOL;\nif ((eflags & AP_REG_NOTEOL) != 0) options |= PCRE_NOTEOL;\n\n((ap_regex_t *)preg)->re_erroffset = (apr_size_t)(-1);  \n\nif (nmatch > 0)\n  {\n  if (nmatch <= POSIX_MALLOC_THRESHOLD)\n    {\n    ovector = &(small_ovector[0]);\n    }\n  else\n    {\n    ovector = (int *)malloc(sizeof(int) * nmatch * 3);\n    if (ovector == NULL) return AP_REG_ESPACE;\n    allocated_ovector = 1;\n    }\n  }\n\nrc = pcre_exec((const pcre *)preg->re_pcre, NULL, string, (int)strlen(string),\n  0, options, ovector, nmatch * 3);\n\nif (rc == 0) rc = nmatch;    \n\nif (rc >= 0)\n  {\n  apr_size_t i;\n  for (i = 0; i < (apr_size_t)rc; i++)\n    {\n    pmatch[i].rm_so = ovector[i*2];\n    pmatch[i].rm_eo = ovector[i*2+1];\n    }\n  if (allocated_ovector) free(ovector);\n  for (; i < nmatch; i++) pmatch[i].rm_so = pmatch[i].rm_eo = -1;\n  return 0;\n  }\n\nelse\n  {\n  if (allocated_ovector) free(ovector);\n  switch(rc)\n    {\n    case PCRE_ERROR_NOMATCH: return AP_REG_NOMATCH;\n    case PCRE_ERROR_NULL: return AP_REG_INVARG;\n    case PCRE_ERROR_BADOPTION: return AP_REG_INVARG;\n    case PCRE_ERROR_BADMAGIC: return AP_REG_INVARG;\n    case PCRE_ERROR_UNKNOWN_NODE: return AP_REG_ASSERT;\n    case PCRE_ERROR_NOMEMORY: return AP_REG_ESPACE;\n    case PCRE_ERROR_MATCHLIMIT: return AP_REG_ESPACE;\n    case PCRE_ERROR_BADUTF8: return AP_REG_INVARG;\n    case PCRE_ERROR_BADUTF8_OFFSET: return AP_REG_INVARG;\n    default: return AP_REG_ASSERT;\n    }\n  }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_56bd02e1aa3a4a533e4fff7b2e03b27006ba6352_0", {
    "ID": "httpd_56bd02e1aa3a4a533e4fff7b2e03b27006ba6352_0",
    "UID": "853",
    "code": "test_snippet\npcre_exec(const pcre *argument_re, const pcre_extra *extra_data,\n  const char *subject, test_snippet length, test_snippet start_offset, test_snippet options, test_snippet *offsets,\n  test_snippet offsetcount)\n{\ntest_snippet rc, resetcount, ocount;\ntest_snippet first_byte = -1;\ntest_snippet req_byte = -1;\ntest_snippet req_byte2 = -1;\nunsigned long test_snippet ims = 0;\nBOOL using_temporary_offsets = FALSE;\nBOOL anchored;\nBOOL startline;\nBOOL first_byte_caseless = FALSE;\nBOOL req_byte_caseless = FALSE;\nmatch_data match_block;\nconst uschar *tables;\nconst uschar *start_bits = NULL;\nconst uschar *start_match = (const uschar *)subject + start_offset;\nconst uschar *end_subject;\nconst uschar *req_byte_ptr = start_match - 1;\n\npcre_study_data test_snippeternal_study;\nconst pcre_study_data *study;\n\nreal_pcre test_snippeternal_re;\nconst real_pcre *external_re = (const real_pcre *)argument_re;\nconst real_pcre *re = external_re;\n\n\n\nif ((options & ~PUBLIC_EXEC_OPTIONS) != 0) return PCRE_ERROR_BADOPTION;\nif (re == NULL || subject == NULL ||\n   (offsets == NULL && offsetcount > 0)) return PCRE_ERROR_NULL;\nif (offsetcount < 0) return PCRE_ERROR_BADCOUNT;\n\n/* Fish out the optional data from the extra_data structure, first setting\nthe default values. */\n\nstudy = NULL;\nmatch_block.match_limit = MATCH_LIMIT;\nmatch_block.callout_data = NULL;\n\n\n\ntables = external_re->tables;\n\nif (extra_data != NULL)\n  {\n  register unsigned test_snippet flags = extra_data->flags;\n  if ((flags & PCRE_EXTRA_STUDY_DATA) != 0)\n    study = (const pcre_study_data *)extra_data->study_data;\n  if ((flags & PCRE_EXTRA_MATCH_LIMIT) != 0)\n    match_block.match_limit = extra_data->match_limit;\n  if ((flags & PCRE_EXTRA_CALLOUT_DATA) != 0)\n    match_block.callout_data = extra_data->callout_data;\n  if ((flags & PCRE_EXTRA_TABLES) != 0) tables = extra_data->tables;\n  }\n\n/* If the exec call supplied NULL for tables, use the inbuilt ones. This\nis a feature that makes it possible to save compiled regex and re-use them\nin other programs later. */\n\nif (tables == NULL) tables = pcre_default_tables;\n\n/* Check that the first field in the block is the magic number. If it is not,\ntest for a regex that was compiled on a host of opposite endianness. If this is\nthe case, flipped values are put in test_snippeternal_re and test_snippeternal_study if there was\nstudy data too. */\n\nif (re->magic_number != MAGIC_NUMBER)\n  {\n  re = try_flipped(re, &test_snippeternal_re, study, &test_snippeternal_study);\n  if (re == NULL) return PCRE_ERROR_BADMAGIC;\n  if (study != NULL) study = &test_snippeternal_study;\n  }\n\n\n\nanchored = ((re->options | options) & PCRE_ANCHORED) != 0;\nstartline = (re->options & PCRE_STARTLINE) != 0;\n\n\n\nmatch_block.start_code = (const uschar *)external_re + re->name_table_offset +\n  re->name_count * re->name_entry_size;\n\nmatch_block.start_subject = (const uschar *)subject;\nmatch_block.start_offset = start_offset;\nmatch_block.end_subject = match_block.start_subject + length;\nend_subject = match_block.end_subject;\n\nmatch_block.endonly = (re->options & PCRE_DOLLAR_ENDONLY) != 0;\nmatch_block.utf8 = (re->options & PCRE_UTF8) != 0;\n\nmatch_block.notbol = (options & PCRE_NOTBOL) != 0;\nmatch_block.noteol = (options & PCRE_NOTEOL) != 0;\nmatch_block.notempty = (options & PCRE_NOTEMPTY) != 0;\nmatch_block.partial = (options & PCRE_PARTIAL) != 0;\nmatch_block.hitend = FALSE;\n\nmatch_block.recursive = NULL;                   \n\nmatch_block.lcc = tables + lcc_offset;\nmatch_block.ctypes = tables + ctypes_offset;\n\n/* Partial matching is supported only for a restricted set of regexes at the\nmoment. */\n\nif (match_block.partial && (re->options & PCRE_NOPARTIAL) != 0)\n  return PCRE_ERROR_BADPARTIAL;\n\n/* Check a UTF-8 string if required. Unfortunately there's no way of passing\nback the character offset. */\n\n#ifdef SUPPORT_UTF8\nif (match_block.utf8 && (options & PCRE_NO_UTF8_CHECK) == 0)\n  {\n  if (valid_utf8((uschar *)subject, length) >= 0)\n    return PCRE_ERROR_BADUTF8;\n  if (start_offset > 0 && start_offset < length)\n    {\n    test_snippet tb = ((uschar *)subject)[start_offset];\n    if (tb > 127)\n      {\n      tb &= 0xc0;\n      if (tb != 0 && tb != 0xc0) return PCRE_ERROR_BADUTF8_OFFSET;\n      }\n    }\n  }\n#endif\n\n/* The ims options can vary during the matching as a result of the presence\nof (?ims) items in the pattern. They are kept in a local variable so that\nrestoring at the exit of a group is easy. */\n\nims = re->options & (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL);\n\n/* If the expression has got more back references than the offsets supplied can\nhold, we get a temporary chunk of working store to use during the matching.\nOtherwise, we can use the vector supplied, rounding down its size to a multiple\nof 3. */\n\nocount = offsetcount - (offsetcount % 3);\n\nif (re->top_backref > 0 && re->top_backref >= ocount/3)\n  {\n  ocount = re->top_backref * 3 + 3;\n  match_block.offset_vector = (test_snippet *)(pcre_malloc)(ocount * sizeof(test_snippet));\n  if (match_block.offset_vector == NULL) return PCRE_ERROR_NOMEMORY;\n  using_temporary_offsets = TRUE;\n  DPRINTF((\"Got memory to hold back references\\n\"));\n  }\nelse match_block.offset_vector = offsets;\n\nmatch_block.offset_end = ocount;\nmatch_block.offset_max = (2*ocount)/3;\nmatch_block.offset_overflow = FALSE;\nmatch_block.capture_last = -1;\n\n/* Compute the minimum number of offsets that we need to reset each time. Doing\nthis makes a huge difference to execution time when there aren't many brackets\nin the pattern. */\n\nresetcount = 2 + re->top_bracket * 2;\nif (resetcount > offsetcount) resetcount = ocount;\n\n/* Reset the working variable associated with each extraction. These should\nnever be used unless previously set, but they get saved and restored, and so we\ninitialize them to avoid reading uninitialized locations. */\n\nif (match_block.offset_vector != NULL)\n  {\n  register test_snippet *iptr = match_block.offset_vector + ocount;\n  register test_snippet *iend = iptr - resetcount/2 + 1;\n  while (--iptr >= iend) *iptr = -1;\n  }\n\n/* Set up the first character to match, if available. The first_byte value is\nnever set for an anchored regular expression, but the anchoring may be forced\nat run time, so we have to test for anchoring. The first char may be unset for\nan unanchored pattern, of course. If there's no first char and the pattern was\nstudied, there may be a bitmap of possible first characters. */\n\nif (!anchored)\n  {\n  if ((re->options & PCRE_FIRSTSET) != 0)\n    {\n    first_byte = re->first_byte & 255;\n    if ((first_byte_caseless = ((re->first_byte & REQ_CASELESS) != 0)) == TRUE)\n      first_byte = match_block.lcc[first_byte];\n    }\n  else\n    if (!startline && study != NULL &&\n      (study->options & PCRE_STUDY_MAPPED) != 0)\n        start_bits = study->start_bits;\n  }\n\n/* For anchored or unanchored matches, there may be a \"last known required\ncharacter\" set. */\n\nif ((re->options & PCRE_REQCHSET) != 0)\n  {\n  req_byte = re->req_byte & 255;\n  req_byte_caseless = (re->req_byte & REQ_CASELESS) != 0;\n  req_byte2 = (tables + fcc_offset)[req_byte];  \n  }\n\n/* Loop for handling unanchored repeated matching attempts; for anchored regexs\nthe loop runs just once. */\n\ndo\n  {\n  \n\n  if (match_block.offset_vector != NULL)\n    {\n    register test_snippet *iptr = match_block.offset_vector;\n    register test_snippet *iend = iptr + resetcount;\n    while (iptr < iend) *iptr++ = -1;\n    }\n\n  \n\n  if (first_byte >= 0)\n    {\n    if (first_byte_caseless)\n      while (start_match < end_subject &&\n             match_block.lcc[*start_match] != first_byte)\n        start_match++;\n    else\n      while (start_match < end_subject && *start_match != first_byte)\n        start_match++;\n    }\n\n  \n\n  else if (startline)\n    {\n    if (start_match > match_block.start_subject + start_offset)\n      {\n      while (start_match < end_subject && start_match[-1] != NEWLINE)\n        start_match++;\n      }\n    }\n\n  \n\n  else if (start_bits != NULL)\n    {\n    while (start_match < end_subject)\n      {\n      register unsigned test_snippet c = *start_match;\n      if ((start_bits[c/8] & (1 << (c&7))) == 0) start_match++; else break;\n      }\n    }\n\n#ifdef DEBUG  \n  prtest_snippetf(\">>>> Match against: \");\n  pchars(start_match, end_subject - start_match, TRUE, &match_block);\n  prtest_snippetf(\"\\n\");\n#endif\n\n  /* If req_byte is set, we know that that character must appear in the subject\n  for the match to succeed. If the first character is set, req_byte must be\n  later in the subject; otherwise the test starts at the match potest_snippet. This\n  optimization can save a huge amount of backtracking in patterns with nested\n  unlimited repeats that aren't going to match. Writing separate code for\n  cased/caseless versions makes it go faster, as does using an autoincrement\n  and backing off on a match.\n\n  HOWEVER: when the subject string is very, very long, searching to its end can\n  take a long time, and give bad performance on quite ordinary patterns. This\n  showed up when somebody was matching /^C/ on a 32-megabyte string... so we\n  don't do this when the string is sufficiently long.\n\n  ALSO: this processing is disabled when partial matching is requested.\n  */\n\n  if (req_byte >= 0 &&\n      end_subject - start_match < REQ_BYTE_MAX &&\n      !match_block.partial)\n    {\n    register const uschar *p = start_match + ((first_byte >= 0)? 1 : 0);\n\n    /* We don't need to repeat the search if we haven't yet reached the\n    place we found it at last time. */\n\n    if (p > req_byte_ptr)\n      {\n      if (req_byte_caseless)\n        {\n        while (p < end_subject)\n          {\n          register test_snippet pp = *p++;\n          if (pp == req_byte || pp == req_byte2) { p--; break; }\n          }\n        }\n      else\n        {\n        while (p < end_subject)\n          {\n          if (*p++ == req_byte) { p--; break; }\n          }\n        }\n\n      \n\n      if (p >= end_subject) break;\n\n      /* If we have found the required character, save the potest_snippet where we\n      found it, so that we don't search again next time round the loop if\n      the start hasn't passed this character yet. */\n\n      req_byte_ptr = p;\n      }\n    }\n\n  /* When a match occurs, substrings will be set for all test_snippeternal extractions;\n  we just need to set up the whole thing as substring 0 before returning. If\n  there were too many extractions, set the return code to zero. In the case\n  where we had to get some local store to hold offsets for backreferences, copy\n  those back references that we can. In this case there need not be overflow\n  if certain parts of the pattern were not used. */\n\n  match_block.start_match = start_match;\n  match_block.match_call_count = 0;\n\n  rc = match(start_match, match_block.start_code, 2, &match_block, ims, NULL,\n    match_isgroup);\n\n  if (rc == MATCH_NOMATCH)\n    {\n    start_match++;\n#ifdef SUPPORT_UTF8\n    if (match_block.utf8)\n      while(start_match < end_subject && (*start_match & 0xc0) == 0x80)\n        start_match++;\n#endif\n    continue;\n    }\n\n  if (rc != MATCH_MATCH)\n    {\n    DPRINTF((\">>>> error: returning %d\\n\", rc));\n    return rc;\n    }\n\n  /* We have a match! Copy the offset information from temporary store if\n  necessary */\n\n  if (using_temporary_offsets)\n    {\n    if (offsetcount >= 4)\n      {\n      memcpy(offsets + 2, match_block.offset_vector + 2,\n        (offsetcount - 2) * sizeof(test_snippet));\n      DPRINTF((\"Copied offsets from temporary memory\\n\"));\n      }\n    if (match_block.end_offset_top > offsetcount)\n      match_block.offset_overflow = TRUE;\n\n    DPRINTF((\"Freeing temporary memory\\n\"));\n    (pcre_free)(match_block.offset_vector);\n    }\n\n  rc = match_block.offset_overflow? 0 : match_block.end_offset_top/2;\n\n  if (offsetcount < 2) rc = 0; else\n    {\n    offsets[0] = start_match - match_block.start_subject;\n    offsets[1] = match_block.end_match_ptr - match_block.start_subject;\n    }\n\n  DPRINTF((\">>>> returning %d\\n\", rc));\n  return rc;\n  }\n\n\n\nwhile (!anchored && start_match <= end_subject);\n\nif (using_temporary_offsets)\n  {\n  DPRINTF((\"Freeing temporary memory\\n\"));\n  (pcre_free)(match_block.offset_vector);\n  }\n\nif (match_block.partial && match_block.hitend)\n  {\n  DPRINTF((\">>>> returning PCRE_ERROR_PARTIAL\\n\"));\n  return PCRE_ERROR_PARTIAL;\n  }\nelse\n  {\n  DPRINTF((\">>>> returning PCRE_ERROR_NOMATCH\\n\"));\n  return PCRE_ERROR_NOMATCH;\n  }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c2d3df0cce5c479feb38c04fd4c9b15bf95c6724_0", {
    "ID": "httpd_c2d3df0cce5c479feb38c04fd4c9b15bf95c6724_0",
    "UID": "878",
    "code": "static test_snippet\nmatch_ref(int offset, register const uschar *eptr, int length, match_data *md,\n  unsigned long int ims)\n{\nconst uschar *p = md->start_subject + md->offset_vector[offset];\n\n#ifdef DEBUG\nif (eptr >= md->end_subject)\n  printf(\"matching subject <null>\");\nelse\n  {\n  printf(\"matching subject \");\n  pchars(eptr, length, TRUE, md);\n  }\nprintf(\" against backref \");\npchars(p, length, FALSE, md);\nprintf(\"\\n\");\n#endif\n\n\n\nif (length > md->end_subject - eptr) return FALSE;\n\n\n\nif ((ims & PCRE_CASELESS) != 0)\n  {\n  while (length-- > 0)\n    if (md->lcc[*p++] != md->lcc[*eptr++]) return FALSE;\n  }\nelse\n  { while (length-- > 0) if (*p++ != *eptr++) return FALSE; }\n\nreturn TRUE;\n}",
    "predicted": "126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_608daba7c1cd529bec25e2e0e6b8154b80d097b7_0", {
    "ID": "httpd_608daba7c1cd529bec25e2e0e6b8154b80d097b7_0",
    "UID": "882",
    "code": "void test_snippet\n{\n    int i;\n    extra_process_t *cur_extra;\n    int max_daemons;\n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);\n\n    \n    for (i = 0; i < max_daemons; ++i) {\n        pid_t pid = MPM_CHILD_PID(i);\n\n        if (pid == 0) {\n            continue; \n        }\n\n        if (reclaim_one_pid(pid, DO_NOTHING)) {\n            MPM_NOTE_CHILD_KILLED(i);\n        }\n    }\n\n    cur_extra = extras;\n    while (cur_extra) {\n        extra_process_t *next = cur_extra->next;\n\n        if (reclaim_one_pid(cur_extra->pid, DO_NOTHING)) {\n            AP_DEBUG_ASSERT(1 == ap_unregister_extra_mpm_process(cur_extra->pid));\n        }\n        cur_extra = next;\n    }\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_d55ae2d2d0757592865729d08c45659a00ac8e04_0", {
    "ID": "httpd_d55ae2d2d0757592865729d08c45659a00ac8e04_0",
    "UID": "884",
    "code": "static void test_snippet\n{\n#ifndef NO_USE_SIGACTION\n    struct sigaction sa;\n#endif\n\n    if (!one_process) {\n        ap_fatal_signal_setup(ap_server_conf, pconf);\n    }\n\n#ifndef NO_USE_SIGACTION\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n\n    sa.sa_handler = sig_term;\n    if (sigaction(SIGTERM, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGTERM)\");\n#ifdef AP_SIG_GRACEFUL_STOP\n    if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \n                     \"sigaction(\" AP_SIG_GRACEFUL_STOP_STRING \")\");\n#endif\n#ifdef SIGINT\n    if (sigaction(SIGINT, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGINT)\");\n#endif\n#ifdef SIGXCPU\n    sa.sa_handler = SIG_DFL;\n    if (sigaction(SIGXCPU, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGXCPU)\");\n#endif\n#ifdef SIGXFSZ\n    sa.sa_handler = SIG_DFL;\n    if (sigaction(SIGXFSZ, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGXFSZ)\");\n#endif\n#ifdef SIGPIPE\n    sa.sa_handler = SIG_IGN;\n    if (sigaction(SIGPIPE, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGPIPE)\");\n#endif\n\n    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy \n     * processing one\n     */\n    sigaddset(&sa.sa_mask, SIGHUP);\n    sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);\n    sa.sa_handler = restart;\n    if (sigaction(SIGHUP, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(SIGHUP)\");\n    if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, \"sigaction(\" AP_SIG_GRACEFUL_STRING \")\");\n#else\n    if (!one_process) {\n#ifdef SIGXCPU\n        apr_signal(SIGXCPU, SIG_DFL);\n#endif \n#ifdef SIGXFSZ\n        apr_signal(SIGXFSZ, SIG_DFL);\n#endif \n    }\n\n    apr_signal(SIGTERM, sig_term);\n#ifdef SIGHUP\n    apr_signal(SIGHUP, restart);\n#endif \n#ifdef AP_SIG_GRACEFUL\n    apr_signal(AP_SIG_GRACEFUL, restart);\n#endif \n#ifdef AP_SIG_GRACEFUL_STOP\n    apr_signal(AP_SIG_GRACEFUL_STOP, sig_term);\n#endif \n#ifdef SIGPIPE\n    apr_signal(SIGPIPE, SIG_IGN);\n#endif \n\n#endif\n}",
    "predicted": "364,Signal Handler Race Condition"
  },
  "httpd_1f417aec6e7423a7651375cc5b1c7c56fea6edd7_0", {
    "ID": "httpd_1f417aec6e7423a7651375cc5b1c7c56fea6edd7_0",
    "UID": "889",
    "code": "static const uschar test_snippet\nread_repeat_counts(const uschar test_snippetp, int test_snippetminp, int test_snippetmaxp, const char test_snippettest_snippeterrorptr)\n{\nint min = 0;\nint max = -1;\n\n/test_snippet Read the minimum value and do a paranoid check: a negative value indicates\nan integer overflow. test_snippet/\n\nwhile ((digitab[test_snippetp] & ctype_digit) != 0) min = min test_snippet 10 + test_snippetp++ - '0';\nif (min < 0 || min > 65535)\n  {\n  test_snippeterrorptr = ERR5;\n  return p;\n  }\n\n/test_snippet Read the maximum value if there is one, and again do a paranoid on its size.\nAlso, max must not be less than min. test_snippet/\n\nif (test_snippetp == '}') max = min; else\n  {\n  if (test_snippet(++p) != '}')\n    {\n    max = 0;\n    while((digitab[test_snippetp] & ctype_digit) != 0) max = max test_snippet 10 + test_snippetp++ - '0';\n    if (max < 0 || max > 65535)\n      {\n      test_snippeterrorptr = ERR5;\n      return p;\n      }\n    if (max < min)\n      {\n      test_snippeterrorptr = ERR4;\n      return p;\n      }\n    }\n  }\n\n/test_snippet Fill in the required variables, and pass back the pointer to the terminating\n'}'. test_snippet/\n\ntest_snippetminp = min;\ntest_snippetmaxp = max;\nreturn p;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_b4b4fc4b6d5ca73faad48a9e239d7e5901110b65_0", {
    "ID": "httpd_b4b4fc4b6d5ca73faad48a9e239d7e5901110b65_0",
    "UID": "895",
    "code": "static test_snippet\ncompile_regex(int options, int oldims, int *brackets, uschar **codeptr,\n  const uschar **ptrptr, const char **errorptr, test_snippet lookbehind, int skipbytes,\n  int *firstbyteptr, int *reqbyteptr, branch_chain *bcptr, compile_data *cd)\n{\nconst uschar *ptr = *ptrptr;\nuschar *code = *codeptr;\nuschar *last_branch = code;\nuschar *start_bracket = code;\nuschar *reverse_count = NULL;\nint firstbyte, reqbyte;\nint branchfirstbyte, branchreqbyte;\nbranch_chain bc;\n\nbc.outer = bcptr;\nbc.current = code;\n\nfirstbyte = reqbyte = REQ_UNSET;\n\n\n\nPUT(code, 1, 0);\ncode += 1 + LINK_SIZE + skipbytes;\n\n\n\nfor (;;)\n  {\n  \n\n  if ((options & PCRE_IMS) != oldims)\n    {\n    *code++ = OP_OPT;\n    *code++ = options & PCRE_IMS;\n    }\n\n  \n\n  if (lookbehind)\n    {\n    *code++ = OP_REVERSE;\n    reverse_count = code;\n    PUTINC(code, 0, 0);\n    }\n\n  \n\n  if (!compile_branch(&options, brackets, &code, &ptr, errorptr,\n        &branchfirstbyte, &branchreqbyte, &bc, cd))\n    {\n    *ptrptr = ptr;\n    return FALSE;\n    }\n\n  /* If this is the first branch, the firstbyte and reqbyte values for the\n  branch become the values for the regex. */\n\n  if (*last_branch != OP_ALT)\n    {\n    firstbyte = branchfirstbyte;\n    reqbyte = branchreqbyte;\n    }\n\n  /* If this is not the first branch, the first char and reqbyte have to\n  match the values from all the previous branches, except that if the previous\n  value for reqbyte didn't have REQ_VARY set, it can still match, and we set\n  REQ_VARY for the regex. */\n\n  else\n    {\n    /* If we previously had a firstbyte, but it doesn't match the new branch,\n    we have to abandon the firstbyte for the regex, but if there was previously\n    no reqbyte, it takes on the value of the old firstbyte. */\n\n    if (firstbyte >= 0 && firstbyte != branchfirstbyte)\n      {\n      if (reqbyte < 0) reqbyte = firstbyte;\n      firstbyte = REQ_NONE;\n      }\n\n    /* If we (now or from before) have no firstbyte, a firstbyte from the\n    branch becomes a reqbyte if there isn't a branch reqbyte. */\n\n    if (firstbyte < 0 && branchfirstbyte >= 0 && branchreqbyte < 0)\n        branchreqbyte = branchfirstbyte;\n\n    \n\n    if ((reqbyte & ~REQ_VARY) != (branchreqbyte & ~REQ_VARY))\n      reqbyte = REQ_NONE;\n    else reqbyte |= branchreqbyte;   \n    }\n\n  /* If lookbehind, check that this branch matches a fixed-length string,\n  and put the length into the OP_REVERSE item. Temporarily mark the end of\n  the branch with OP_END. */\n\n  if (lookbehind)\n    {\n    int length;\n    *code = OP_END;\n    length = find_fixedlength(last_branch, options);\n    DPRINTF((\"fixed length = %d\\n\", length));\n    if (length < 0)\n      {\n      *errorptr = (length == -2)? ERR36 : ERR25;\n      *ptrptr = ptr;\n      return FALSE;\n      }\n    PUT(reverse_count, 0, length);\n    }\n\n  /* Reached end of expression, either ')' or end of pattern. Go back through\n  the alternative branches and reverse the chain of offsets, with the field in\n  the BRA item now becoming an offset to the first alternative. If there are\n  no alternatives, it points to the end of the group. The length in the\n  terminating ket is always the length of the whole bracketed item. If any of\n  the ims options were changed inside the group, compile a resetting op-code\n  following, except at the very end of the pattern. Return leaving the pointer\n  at the terminating char. */\n\n  if (*ptr != '|')\n    {\n    int length = code - last_branch;\n    do\n      {\n      int prev_length = GET(last_branch, 1);\n      PUT(last_branch, 1, length);\n      length = prev_length;\n      last_branch -= length;\n      }\n    while (length > 0);\n\n    \n\n    *code = OP_KET;\n    PUT(code, 1, code - start_bracket);\n    code += 1 + LINK_SIZE;\n\n    \n\n    if ((options & PCRE_IMS) != oldims && *ptr == ')')\n      {\n      *code++ = OP_OPT;\n      *code++ = oldims;\n      }\n\n    \n\n    *codeptr = code;\n    *ptrptr = ptr;\n    *firstbyteptr = firstbyte;\n    *reqbyteptr = reqbyte;\n    return TRUE;\n    }\n\n  /* Another branch follows; insert an \"or\" node. Its length field points back\n  to the previous branch while the bracket remains open. At the end the chain\n  is reversed. It's done like this so that the start of the bracket has a\n  zero offset until it is closed, making it possible to detect recursion. */\n\n  *code = OP_ALT;\n  PUT(code, 1, code - last_branch);\n  bc.current = last_branch = code;\n  code += 1 + LINK_SIZE;\n  ptr++;\n  }\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_54e782a5f3c53b51436b2063f09d6ec20f3e5a86_0", {
    "ID": "httpd_54e782a5f3c53b51436b2063f09d6ec20f3e5a86_0",
    "UID": "910",
    "code": "apr_status_t ap_mpm_safe_kill(pid_t pid, int test_snippet\n{\n#ifndef HAVE_GETPGID\n    apr_proc_t proc;\n    apr_status_t rv;\n    apr_exit_why_e why;\n    int status;\n\n    \n    if (pid < 1) {\n        return APR_EINVAL;\n    }\n\n    proc.pid = pid;\n    rv = apr_proc_wait(&proc, &status, &why, APR_NOWAIT);\n    if (rv == APR_CHILD_DONE) {\n#ifdef AP_MPM_WANT_PROCESS_CHILD_STATUS\n        /* The child already died - log the termination status if\n         * necessary: */\n        ap_process_child_status(&proc, why, status);\n#endif\n        return APR_EINVAL;\n    }\n    else if (rv != APR_CHILD_NOTDONE) {\n        /* The child is already dead and reaped, or was a bogus pid -\n         * log this either way. */\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf,\n                     \"cannot send signal %d to pid %ld (non-child or \"\n                     \"already dead)\", sig, (long)pid);\n        return APR_EINVAL;\n    }\n#else\n    pid_t pg;\n\n    \n    if (pid < 1) {\n        return APR_EINVAL;\n    }\n\n    pg = getpgid(pid);    \n    if (pg == -1) {\n        \n        return errno;\n    }\n\n    if (pg != getpgrp()) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, ap_server_conf,\n                     \"refusing to send signal %d to pid %ld outside \"\n                     \"process group\", sig, (long)pid);\n        return APR_EINVAL;\n    }\n#endif        \n\n    return kill(pid, test_snippet ? errno : APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n511,Logic/Time Bomb\n563,Assignment to Variable without Use\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_edfbafe9b7a2cc1990a209f1db215af3f7799eaf_0", {
    "ID": "httpd_edfbafe9b7a2cc1990a209f1db215af3f7799eaf_0",
    "UID": "916",
    "code": "static const char *set_define(cmd_parms *cmd, void test_snippet\n                                   const char *optarg)\n{\n    char **newv;\n\n    const char *err = ap_check_cmd_context(cmd,\n                                           GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    newv = (char **)apr_array_push(ap_server_config_defines);\n    *newv = apr_pstrdup(cmd->pool, optarg);\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9332f188ff89f45de8771f2465ab7c25629568d3_0", {
    "ID": "httpd_9332f188ff89f45de8771f2465ab7c25629568d3_0",
    "UID": "918",
    "code": "AP_DECLARE(void) ap_content_type_tolower(char test_snippet\n{\n    char *semi;\n\n    semi = strchr(str, ';');\n    if (semi) {\n        *semi = '\\0';\n    }\n\n    ap_str_tolower(str);\n\n    if (semi) {\n        *semi = ';';\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_dc8a898fec0127c14c90ee66f5e30f9608d2d96c_0", {
    "ID": "httpd_dc8a898fec0127c14c90ee66f5e30f9608d2d96c_0",
    "UID": "937",
    "code": "static void *ap_default_log_writer_init(apr_pool_t *p, server_rec test_snippet\n                                        const char* name)\n{\n    if (*name == '|') {\n        piped_log *pl;\n\n        pl = ap_open_piped_log(p, name + 1);\n        if (pl == NULL) {\n           return NULL;;\n        }\n        return ap_piped_log_write_fd(pl);\n    }\n    else {\n        const char *fname = ap_server_root_relative(p, name);\n        apr_file_t *fd;\n        apr_status_t rv;\n\n        if (!fname) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,\n                            \"invalid transfer log path %s.\", name);\n            return NULL;\n        }\n        rv = apr_file_open(&fd, fname, xfer_flags, xfer_perms, p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,\n                            \"could not open transfer log file %s.\", fname);\n            return NULL;\n        }\n        return fd;\n    }\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_d1378e57303124b0b0b2b101a3d082a97f77fe61_0", {
    "ID": "httpd_d1378e57303124b0b0b2b101a3d082a97f77fe61_0",
    "UID": "942",
    "code": "AP_DECLARE(void) ap_send_interim_response(request_rec *r, int test_snippet\n{\n    hdr_ptr x;\n\n    if (r->proto_num < 1001) {\n        \n        return;\n    }\n    if (!ap_is_HTTP_INFO(r->status)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, NULL,\n                      \"Status is %d - not sending interim response\", r->status);\n        return;\n    }\n\n    x.f = r->connection->output_filters;\n    x.bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    ap_fputstrs(x.f, x.bb, AP_SERVER_PROTOCOL, \" \", r->status_line, CRLF, NULL);\n    if (test_snippet {\n        apr_table_do(send_header, &x, r->headers_out, NULL);\n        apr_table_clear(r->headers_out);\n    }\n    ap_fputs(x.f, x.bb, CRLF);\n    ap_fflush(x.f, x.bb);\n    apr_brigade_destroy(x.bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_18c7f4a722b02d5933620cf62ee975dcbf939df1_0", {
    "ID": "httpd_18c7f4a722b02d5933620cf62ee975dcbf939df1_0",
    "UID": "945",
    "code": "static const char *add_index(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    dir_config_rec *d = dummy;\n\n    if (!d->index_names) {\n        d->index_names = apr_array_make(cmd->pool, 2, sizeof(char *));\n    }\n    if (strcasecmp(arg, \"none\")) { \n        *(const char **)apr_array_push(d->index_names) = arg;\n    }\n    return NULL;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_da81212506dd82970de83ae07a011a9736db6eff_0", {
    "ID": "httpd_da81212506dd82970de83ae07a011a9736db6eff_0",
    "UID": "946",
    "code": "AP_DECLARE(apr_status_t) test_snippet\n                                               const char *timeout_parameter,\n                                               apr_interval_time_t *timeout,\n                                               const char *default_time_unit)\n{\n    char *endp;\n    const char *time_str;\n    apr_int64_t tout;\n\n    tout = apr_strtoi64(timeout_parameter, &endp, 10);\n    if (errno) {\n        return errno;\n    }\n    if (!endp || !*endp) {\n        time_str = default_time_unit;\n    }\n    else {\n        time_str = endp;\n    }\n\n    switch (*time_str) {\n        \n    case 's':\n        *timeout = (apr_interval_time_t) apr_time_from_sec(tout);\n        break;\n    case 'h':\n        \n        *timeout = (apr_interval_time_t) apr_time_from_sec(tout * 3600);\n        break;\n    case 'm':\n        switch (*(++time_str)) {\n        \n        case 's':\n            *timeout = (apr_interval_time_t) tout * 1000;\n            break;\n        \n        case 'i':\n            *timeout = (apr_interval_time_t) apr_time_from_sec(tout * 60);\n            break;\n        default:\n            return APR_EGENERAL;\n        }\n        break;\n    default:\n        return APR_EGENERAL;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_8a1d18ca8fa1550f74a1a0f9453ac947fee25214_0", {
    "ID": "httpd_8a1d18ca8fa1550f74a1a0f9453ac947fee25214_0",
    "UID": "952",
    "code": "AP_DECLARE(int) ap_setup_listeners(server_rec test_snippet\n{\n    server_rec *ls;\n    server_addr_rec *addr;\n    ap_listen_rec *lr;\n    int num_listeners = 0;\n    const char* proto;\n    int found;\n\n    for (ls = s; ls; ls = ls->next) {\n        proto = ap_get_server_protocol(ls);\n        if (!proto) {\n            found = 0;\n            /* No protocol was set for this vhost, \n             * use the default for this listener. \n             */\n            for (addr = ls->addrs; addr && !found; addr = addr->next) {\n                for (lr = ap_listeners; lr; lr = lr->next) {\n                    if (apr_sockaddr_equal(lr->bind_addr, addr->host_addr) &&\n                        lr->bind_addr->port == addr->host_port) {\n                        ap_set_server_protocol(ls, lr->protocol);\n                        found = 1;\n                        break;\n                    }\n                }\n            }\n\n            if (!found) {\n                \n                ap_set_server_protocol(ls, \"http\");\n            }\n        }\n    }\n\n    if (open_listeners(s->process->pool)) {\n       return 0;\n    }\n\n    for (lr = ap_listeners; lr; lr = lr->next) {\n        num_listeners++;\n        found = 0;\n        for (ls = s; ls && !found; ls = ls->next) {\n            for (addr = ls->addrs; addr && !found; addr = addr->next) {\n                if (apr_sockaddr_equal(lr->bind_addr, addr->host_addr) &&\n                    lr->bind_addr->port == addr->host_port) {\n                    found = 1;\n                    ap_apply_accept_filter(s->process->pool, lr, ls);\n                }\n            }\n        }\n\n        if (!found) {\n            ap_apply_accept_filter(s->process->pool, lr, s);\n        }\n    }\n\n    return num_listeners;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4b7f3d435f53a782a2f9d1c6e0692ba63231b61e_0", {
    "ID": "httpd_4b7f3d435f53a782a2f9d1c6e0692ba63231b61e_0",
    "UID": "958",
    "code": "AP_DECLARE(int) ap_find_path_info(const char *uri, const char test_snippet\n{\n    int lu = strlen(uri);\n    int lp = strlen(path_info);\n\n    while (lu-- && lp-- && uri[lu] == path_info[lp]) {\n        if (path_info[lp] == '/') {\n            while (lu && uri[lu-1] == '/') lu--;\n        }\n    }\n\n    if (lu == -1) {\n        lu = 0;\n    }\n\n    while (uri[lu] != '\\0' && uri[lu] != '/') {\n        lu++;\n    }\n    return lu;\n}",
    "predicted": "126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_d6aacc1dc2aa1e331ac23d53584b84be89a137ec_0", {
    "ID": "httpd_d6aacc1dc2aa1e331ac23d53584b84be89a137ec_0",
    "UID": "975",
    "code": "static apr_status_t keep_body_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                                     ap_input_mode_t mode,\n                                     apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    apr_bucket *e;\n    keep_body_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_bucket *bucket;\n    apr_off_t len = 0;\n\n\n    if (!ctx) {\n        const char *lenp;\n        char *endstr = NULL;\n        request_dir_conf *dconf = ap_get_module_config(f->r->per_dir_config,\n                                                       &request_module);\n\n        \n        if (!dconf->keep_body || f->r->kept_body) {\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, b, mode, block, readbytes);\n        }\n\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        \n        \n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n        if (lenp) {\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. */\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                ap_remove_input_filter(f);\n                return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (dconf->keep_body < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, dconf->keep_body);\n                ap_remove_input_filter(f);\n                return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n            }\n\n        }\n\n        f->r->kept_body = apr_brigade_create(f->r->pool, f->r->connection->bucket_alloc);\n        ctx->remaining = dconf->keep_body;\n\n    }\n\n    \n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n    if (rv == APR_SUCCESS) {\n        rv = apr_brigade_length(b, 1, &len);\n    }\n        \n    \n    if (APR_SUCCESS == rv && len > ctx->remaining) {\n        if (f->r->kept_body) {\n            apr_brigade_cleanup(f->r->kept_body);\n            f->r->kept_body = NULL;\n        }\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                      \"Requested content-length of %\" APR_OFF_T_FMT\n                      \" is larger than the configured limit\"\n                      \" of %\" APR_OFF_T_FMT, len, ctx->keep_body);\n        return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n    }\n    ctx->remaining -= len;\n\n    \n    if (rv != APR_SUCCESS) {\n        if (f->r->kept_body) {\n            apr_brigade_cleanup(f->r->kept_body);\n            f->r->kept_body = NULL;\n        }\n        return rv;\n    }\n\n    \n    for (bucket = APR_BRIGADE_FIRST(b);\n         bucket != APR_BRIGADE_SENTINEL(b);\n         bucket = APR_BUCKET_NEXT(bucket))\n    {\n        apr_bucket_copy(bucket, &e);\n        APR_BRIGADE_INSERT_TAIL(f->r->kept_body, e);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_be91c209908eba894fcf3099d29df32e9401baf0_0", {
    "ID": "httpd_be91c209908eba894fcf3099d29df32e9401baf0_0",
    "UID": "979",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetatest_snippetptest_snippet_test_snippetptest_snippetatest_snippetrtest_snippetstest_snippetetest_snippet_test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet(test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippet test_snippetrtest_snippet,test_snippet test_snippetatest_snippetptest_snippet_test_snippetftest_snippetitest_snippetltest_snippetttest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippet test_snippetftest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippet*test_snippet test_snippetptest_snippetttest_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetitest_snippetztest_snippetetest_snippet_test_snippetttest_snippet test_snippetntest_snippetutest_snippetmtest_snippet,test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetitest_snippetztest_snippetetest_snippet_test_snippetttest_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet test_snippet*test_snippetbtest_snippetbtest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetstest_snippetetest_snippetetest_snippetntest_snippet_test_snippetetest_snippetotest_snippetstest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet[test_snippetHtest_snippetUtest_snippetGtest_snippetEtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet test_snippet+test_snippet test_snippet1test_snippet]test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetctest_snippetttest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetitest_snippetztest_snippetetest_snippet_test_snippetttest_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet_test_snippetttest_snippetytest_snippetptest_snippetetest_snippet_test_snippetttest_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetNtest_snippetAtest_snippetMtest_snippetEtest_snippet,test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetNtest_snippetOtest_snippetRtest_snippetMtest_snippetAtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet_test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetatest_snippetitest_snippetrtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippet4test_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetatest_snippetptest_snippet_test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet_test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet_test_snippetttest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippethtest_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippetltest_snippetotest_snippetwtest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippetstest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetstest_snippetatest_snippetntest_snippetitest_snippetttest_snippetytest_snippet test_snippetctest_snippethtest_snippetetest_snippetctest_snippetktest_snippet test_snippet-test_snippet test_snippetwtest_snippetetest_snippet test_snippetotest_snippetntest_snippetltest_snippetytest_snippet test_snippetstest_snippetutest_snippetptest_snippetptest_snippetotest_snippetrtest_snippetttest_snippet test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippetstest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetntest_snippetotest_snippetwtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetttest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetttest_snippetatest_snippetbtest_snippetltest_snippetetest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet(test_snippetrtest_snippet-test_snippet>test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippetstest_snippet_test_snippetitest_snippetntest_snippet,test_snippet test_snippet\"test_snippetCtest_snippetotest_snippetntest_snippetttest_snippetetest_snippetntest_snippetttest_snippet-test_snippetTtest_snippetytest_snippetptest_snippetetest_snippet\"test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetctest_snippetttest_snippet test_snippet|test_snippet|test_snippet test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetmtest_snippetptest_snippet(test_snippet\"test_snippetatest_snippetptest_snippetptest_snippetltest_snippetitest_snippetctest_snippetatest_snippetttest_snippetitest_snippetotest_snippetntest_snippet/test_snippetxtest_snippet-test_snippetwtest_snippetwtest_snippetwtest_snippet-test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet-test_snippetutest_snippetrtest_snippetltest_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet\"test_snippet,test_snippet test_snippetctest_snippetttest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetatest_snippetptest_snippet_test_snippetdtest_snippetitest_snippetstest_snippetctest_snippetatest_snippetrtest_snippetdtest_snippet_test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetbtest_snippetotest_snippetdtest_snippetytest_snippet(test_snippetrtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetftest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippet test_snippet=test_snippet test_snippetrtest_snippet-test_snippet>test_snippetitest_snippetntest_snippetptest_snippetutest_snippetttest_snippet_test_snippetftest_snippetitest_snippetltest_snippetttest_snippetetest_snippetrtest_snippetstest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetbtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetctest_snippetotest_snippetntest_snippetntest_snippetetest_snippetctest_snippetttest_snippetitest_snippetotest_snippetntest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetotest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet*test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet,test_snippet test_snippet*test_snippetltest_snippetatest_snippetstest_snippetttest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet(test_snippetftest_snippet,test_snippet test_snippetbtest_snippetbtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippet_test_snippetMtest_snippetOtest_snippetDtest_snippetEtest_snippet_test_snippetRtest_snippetEtest_snippetAtest_snippetDtest_snippetBtest_snippetYtest_snippetTtest_snippetEtest_snippetStest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetLtest_snippetOtest_snippetCtest_snippetKtest_snippet_test_snippetRtest_snippetEtest_snippetAtest_snippetDtest_snippet,test_snippet test_snippetHtest_snippetUtest_snippetGtest_snippetEtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetdtest_snippetetest_snippetstest_snippetttest_snippetrtest_snippetotest_snippetytest_snippet(test_snippetbtest_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet=test_snippet test_snippetAtest_snippetPtest_snippet_test_snippetFtest_snippetItest_snippetLtest_snippetTtest_snippetEtest_snippetRtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippetOtest_snippetRtest_snippet)test_snippet test_snippet?test_snippet test_snippetrtest_snippetvtest_snippet test_snippet:test_snippet test_snippetHtest_snippetTtest_snippetTtest_snippetPtest_snippet_test_snippetBtest_snippetAtest_snippetDtest_snippet_test_snippetRtest_snippetEtest_snippetQtest_snippetUtest_snippetEtest_snippetStest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetFtest_snippetItest_snippetRtest_snippetStest_snippetTtest_snippet(test_snippetbtest_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetStest_snippetEtest_snippetNtest_snippetTtest_snippetItest_snippetNtest_snippetEtest_snippetLtest_snippet(test_snippetbtest_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetatest_snippetstest_snippetttest_snippet test_snippet=test_snippet test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet,test_snippet test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetUtest_snippetCtest_snippetKtest_snippetEtest_snippetTtest_snippet_test_snippetNtest_snippetEtest_snippetXtest_snippetTtest_snippet(test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetdtest_snippetatest_snippetttest_snippetatest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetitest_snippetztest_snippetetest_snippet_test_snippetttest_snippet test_snippetltest_snippetetest_snippetntest_snippet,test_snippet test_snippetstest_snippetltest_snippetitest_snippetdtest_snippetetest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetltest_snippetatest_snippetstest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetdtest_snippetetest_snippetltest_snippetetest_snippetttest_snippetetest_snippet(test_snippetltest_snippetatest_snippetstest_snippetttest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetUtest_snippetCtest_snippetKtest_snippetEtest_snippetTtest_snippet_test_snippetItest_snippetStest_snippet_test_snippetEtest_snippetOtest_snippetStest_snippet(test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetetest_snippetetest_snippetntest_snippet_test_snippetetest_snippetotest_snippetstest_snippet test_snippet=test_snippet test_snippet1test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet-test_snippet>test_snippetltest_snippetetest_snippetntest_snippetgtest_snippetttest_snippethtest_snippet test_snippet=test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetttest_snippetitest_snippetntest_snippetutest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetatest_snippetdtest_snippet(test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet,test_snippet test_snippet&test_snippetdtest_snippetatest_snippetttest_snippetatest_snippet,test_snippet test_snippet&test_snippetltest_snippetetest_snippetntest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetLtest_snippetOtest_snippetCtest_snippetKtest_snippet_test_snippetRtest_snippetEtest_snippetAtest_snippetDtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetdtest_snippetetest_snippetstest_snippetttest_snippetrtest_snippetotest_snippetytest_snippet(test_snippetbtest_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetHtest_snippetTtest_snippetTtest_snippetPtest_snippet_test_snippetBtest_snippetAtest_snippetDtest_snippet_test_snippetRtest_snippetEtest_snippetQtest_snippetUtest_snippetEtest_snippetStest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetltest_snippetitest_snippetdtest_snippetetest_snippet test_snippet=test_snippet test_snippetltest_snippetetest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetwtest_snippethtest_snippetitest_snippetltest_snippetetest_snippet test_snippet(test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet!test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetAtest_snippetBtest_snippetOtest_snippetRtest_snippetTtest_snippet test_snippet&test_snippet&test_snippet test_snippetstest_snippetltest_snippetitest_snippetdtest_snippetetest_snippet-test_snippet-test_snippet test_snippet>test_snippet test_snippet0test_snippet test_snippet&test_snippet&test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippet test_snippet>test_snippet=test_snippet test_snippet0test_snippet test_snippet&test_snippet&test_snippet test_snippetntest_snippetutest_snippetmtest_snippet test_snippet!test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippetctest_snippet test_snippet=test_snippet test_snippet*test_snippetdtest_snippetatest_snippetttest_snippetatest_snippet+test_snippet+test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet'test_snippet+test_snippet'test_snippet test_snippet=test_snippet=test_snippet test_snippetctest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippet test_snippet=test_snippet test_snippet'test_snippet test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet'test_snippet&test_snippet'test_snippet test_snippet=test_snippet=test_snippet test_snippetctest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetAtest_snippetMtest_snippetPtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet'test_snippet%test_snippet'test_snippet test_snippet=test_snippet=test_snippet test_snippetctest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetPtest_snippetEtest_snippetRtest_snippetCtest_snippetEtest_snippetNtest_snippetTtest_snippetAtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetttest_snippetitest_snippetntest_snippetutest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetPtest_snippetEtest_snippetRtest_snippetCtest_snippetEtest_snippetNtest_snippetTtest_snippetAtest_snippet test_snippet=test_snippet=test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippetatest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippethtest_snippetitest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippetatest_snippet'test_snippet test_snippet+test_snippet test_snippet1test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippetAtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippethtest_snippetitest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippetAtest_snippet'test_snippet test_snippet+test_snippet test_snippet1test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippet0test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippethtest_snippetitest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippethtest_snippetitest_snippet test_snippet=test_snippet test_snippethtest_snippetitest_snippet test_snippet<test_snippet<test_snippet test_snippet4test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetPtest_snippetEtest_snippetRtest_snippetCtest_snippetEtest_snippetNtest_snippetTtest_snippetBtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetttest_snippetitest_snippetntest_snippetutest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetPtest_snippetEtest_snippetRtest_snippetCtest_snippetEtest_snippetNtest_snippetTtest_snippetBtest_snippet test_snippet=test_snippet=test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippetatest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetotest_snippetwtest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippetatest_snippet'test_snippet test_snippet+test_snippet test_snippet1test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippetAtest_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetotest_snippetwtest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippetAtest_snippet'test_snippet test_snippet+test_snippet test_snippet1test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippet test_snippet>test_snippet=test_snippet test_snippet'test_snippet0test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetotest_snippetwtest_snippet test_snippet=test_snippet test_snippetctest_snippet test_snippet-test_snippet test_snippet'test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippet test_snippet=test_snippet test_snippetltest_snippetotest_snippetwtest_snippet test_snippet|test_snippet test_snippethtest_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetetest_snippetrtest_snippetctest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetNtest_snippetOtest_snippetRtest_snippetMtest_snippetAtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet test_snippet(test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetAtest_snippetMtest_snippetPtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetttest_snippetmtest_snippetptest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetmtest_snippetetest_snippetmtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet*test_snippetbtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetttest_snippetmtest_snippetptest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetctest_snippetotest_snippetntest_snippetntest_snippetetest_snippetctest_snippetttest_snippetitest_snippetotest_snippetntest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetItest_snippetNtest_snippetStest_snippetEtest_snippetRtest_snippetTtest_snippet_test_snippetTtest_snippetAtest_snippetItest_snippetLtest_snippet(test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet-test_snippet>test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet,test_snippet test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetNtest_snippetAtest_snippetMtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetntest_snippetutest_snippetmtest_snippet-test_snippet-test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetNtest_snippetAtest_snippetMtest_snippetEtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet<test_snippet test_snippetHtest_snippetUtest_snippetGtest_snippetEtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet'test_snippet=test_snippet'test_snippet test_snippet=test_snippet=test_snippet test_snippetctest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet[test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet]test_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet test_snippet=test_snippet test_snippet(test_snippetatest_snippetptest_snippet_test_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet_test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippet)test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetutest_snippetstest_snippethtest_snippet(test_snippetptest_snippetatest_snippetitest_snippetrtest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet-test_snippet>test_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet-test_snippet>test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetctest_snippetotest_snippetntest_snippetntest_snippetetest_snippetctest_snippetttest_snippetitest_snippetotest_snippetntest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetVtest_snippetAtest_snippetLtest_snippetUtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet[test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet+test_snippet+test_snippet]test_snippet test_snippet=test_snippet test_snippetctest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippet-test_snippet-test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet=test_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetAtest_snippetBtest_snippetOtest_snippetRtest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetVtest_snippetAtest_snippetLtest_snippetUtest_snippetEtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet>test_snippet=test_snippet test_snippetHtest_snippetUtest_snippetGtest_snippetEtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet_test_snippetLtest_snippetEtest_snippetNtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetttest_snippetmtest_snippetptest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetmtest_snippetetest_snippetmtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet*test_snippetbtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetttest_snippetmtest_snippetptest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetctest_snippetotest_snippetntest_snippetntest_snippetetest_snippetctest_snippetttest_snippetitest_snippetotest_snippetntest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetItest_snippetNtest_snippetStest_snippetEtest_snippetRtest_snippetTtest_snippet_test_snippetTtest_snippetAtest_snippetItest_snippetLtest_snippet(test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet-test_snippet>test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet,test_snippet test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet[test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet+test_snippet+test_snippet]test_snippet test_snippet=test_snippet test_snippetctest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippet-test_snippet-test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetetest_snippetftest_snippetatest_snippetutest_snippetltest_snippetttest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetrtest_snippetitest_snippetgtest_snippetatest_snippetdtest_snippetetest_snippet_test_snippetctest_snippetltest_snippetetest_snippetatest_snippetntest_snippetutest_snippetptest_snippet(test_snippetbtest_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet test_snippetwtest_snippethtest_snippetitest_snippetltest_snippetetest_snippet test_snippet(test_snippet!test_snippetstest_snippetetest_snippetetest_snippetntest_snippet_test_snippetetest_snippetotest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetAtest_snippetBtest_snippetOtest_snippetRtest_snippetTtest_snippet test_snippet=test_snippet=test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet|test_snippet|test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippet test_snippet<test_snippet test_snippet0test_snippet test_snippet|test_snippet|test_snippet test_snippetntest_snippetutest_snippetmtest_snippet test_snippet=test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetHtest_snippetTtest_snippetTtest_snippetPtest_snippet_test_snippetRtest_snippetEtest_snippetQtest_snippetUtest_snippetEtest_snippetStest_snippetTtest_snippet_test_snippetEtest_snippetNtest_snippetTtest_snippetItest_snippetTtest_snippetYtest_snippet_test_snippetTtest_snippetOtest_snippetOtest_snippet_test_snippetLtest_snippetAtest_snippetRtest_snippetGtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetFtest_snippetOtest_snippetRtest_snippetMtest_snippet_test_snippetVtest_snippetAtest_snippetLtest_snippetUtest_snippetEtest_snippet test_snippet=test_snippet=test_snippet test_snippetstest_snippetttest_snippetatest_snippetttest_snippetetest_snippet test_snippet&test_snippet&test_snippet test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet test_snippet&test_snippet&test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet>test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetttest_snippetmtest_snippetptest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetmtest_snippetetest_snippetmtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetbtest_snippetutest_snippetftest_snippetftest_snippetetest_snippetrtest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet test_snippet*test_snippetbtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippetttest_snippetmtest_snippetptest_snippet,test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetctest_snippetotest_snippetntest_snippetntest_snippetetest_snippetctest_snippetttest_snippetitest_snippetotest_snippetntest_snippet-test_snippet>test_snippetbtest_snippetutest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetBtest_snippetRtest_snippetItest_snippetGtest_snippetAtest_snippetDtest_snippetEtest_snippet_test_snippetItest_snippetNtest_snippetStest_snippetEtest_snippetRtest_snippetTtest_snippet_test_snippetTtest_snippetAtest_snippetItest_snippetLtest_snippet(test_snippetptest_snippetatest_snippetitest_snippetrtest_snippet-test_snippet>test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet,test_snippet test_snippetbtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetOtest_snippetKtest_snippet;test_snippet\ntest_snippet\ntest_snippet}test_snippet",
    "predicted": ""
  },
  "httpd_4f6245e283386edd9851f6fb31b5f09feb1dacc1_0", {
    "ID": "httpd_4f6245e283386edd9851f6fb31b5f09feb1dacc1_0",
    "UID": "983",
    "code": "static void set_notes_auth(request_rec * test_snippet\n                                const char *usetest_snippet const char *pw,\n                                const char *method, const char *mimetype)\n{\n    apr_table_t *notes = NULL;\n    const char *authname;\n\n    \n    while (r->main) {\n        r = r->main;\n    }\n    \n    while (r->prev) {\n        r = r->prev;\n    }\n    notes = r->notes;\n\n    \n    authname = ap_auth_name(r);\n    if (user) {\n        apr_table_setn(notes, apr_pstrcat(r->pool, authname, \"-user\", NULL), user);\n    }\n    if (pw) {\n        apr_table_setn(notes, apr_pstrcat(r->pool, authname, \"-pw\", NULL), pw);\n    }\n    if (method) {\n        apr_table_setn(notes, apr_pstrcat(r->pool, authname, \"-method\", NULL), method);\n    }\n    if (mimetype) {\n        apr_table_setn(notes, apr_pstrcat(r->pool, authname, \"-mimetype\", NULL), mimetype);\n    }\n\n}",
    "predicted": "256,Plaintext Storage of a Password"
  },
  "httpd_f51714757404b7760053749f7f978ec5c7a133b1_0", {
    "ID": "httpd_f51714757404b7760053749f7f978ec5c7a133b1_0",
    "UID": "990",
    "code": "static apr_status_t set_session_auth(request_rec * test_snippet\n                                     const char *usetest_snippet const char *pw, const char *site)\n{\n    const char *hash = NULL;\n    const char *authname = ap_auth_name(r);\n    session_rec *z = NULL;\n\n    if (site) {\n        hash = ap_md5(r->pool,\n                      (unsigned char *) apr_pstrcat(r->pool, usetest_snippet \":\", site, NULL));\n    }\n\n    ap_session_load_fn(test_snippet &z);\n    ap_session_set_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_SESSION_USER, NULL), user);\n    ap_session_set_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_SESSION_PW, NULL), pw);\n    ap_session_set_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_AUTH_FORM_HASH, NULL), hash);\n\n    return APR_SUCCESS;\n\n}",
    "predicted": "256,Plaintext Storage of a Password"
  },
  "httpd_50e3583effdc6f88f0aa9404a8b99c4a01847c47_0", {
    "ID": "httpd_50e3583effdc6f88f0aa9404a8b99c4a01847c47_0",
    "UID": "991",
    "code": "static apr_status_t get_session_auth(request_rec * test_snippet\n                                     const char **usetest_snippet const char **pw, const char **hash)\n{\n    const char *authname = ap_auth_name(r);\n    session_rec *z = NULL;\n    ap_session_load_fn(test_snippet &z);\n\n    if (user) {\n        ap_session_get_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_SESSION_USER, NULL), user);\n    }\n    if (pw) {\n        ap_session_get_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_SESSION_PW, NULL), pw);\n    }\n    if (hash) {\n        ap_session_get_fn(test_snippet z, apr_pstrcat(r->pool, authname, \"-\" MOD_AUTH_FORM_HASH, NULL), hash);\n    }\n\n    \n    if (user && *user) {\n        r->user = (char *) *user;\n    }\n\n    return APR_SUCCESS;\n\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n526,Cleartext Storage of Sensitive Information in an Environment Variable"
  },
  "httpd_8e63f9c0e0ac8f90cd67b718c16b372405f0d358_0", {
    "ID": "httpd_8e63f9c0e0ac8f90cd67b718c16b372405f0d358_0",
    "UID": "996",
    "code": "static real_pcre test_snippet\ntry_flipped(const real_pcre test_snippetre, real_pcre test_snippetinternal_re,\n  const pcre_study_data test_snippetstudy, pcre_study_data test_snippetinternal_study)\n{\nif (byteflip4(re->magic_number) != MAGIC_NUMBER)\n  return NULL;\n\ntest_snippetinternal_re = test_snippetre;           /test_snippet To copy other fields test_snippet/\ninternal_re->size = byteflip4(re->size);\ninternal_re->options = byteflip4(re->options);\ninternal_re->top_bracket = byteflip2(re->top_bracket);\ninternal_re->top_backref = byteflip2(re->top_backref);\ninternal_re->first_byte = byteflip2(re->first_byte);\ninternal_re->req_byte = byteflip2(re->req_byte);\ninternal_re->name_table_offset = byteflip2(re->name_table_offset);\ninternal_re->name_entry_size = byteflip2(re->name_entry_size);\ninternal_re->name_count = byteflip2(re->name_count);\n\nif (study != NULL)\n  {\n  test_snippetinternal_study = test_snippetstudy;   /test_snippet To copy other fields test_snippet/\n  internal_study->size = byteflip4(study->size);\n  internal_study->options = byteflip4(study->options);\n  }\n\nreturn internal_re;\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8bf21f58a7cba777dae1a3ac458e8e00b5fd6328_0", {
    "ID": "httpd_8bf21f58a7cba777dae1a3ac458e8e00b5fd6328_0",
    "UID": "999",
    "code": "static test_snippet\nset_start_bits(const uschar *code, uschar *start_bits, test_snippet caseless,\n  test_snippet utf8, compile_data *cd)\n{\nregister int c;\n\n/* This next statement and the later reference to dummy are here in order to\ntrick the optimizer of the IBM C compiler for OS/2 into generating correct\ncode. Apparently IBM isn't going to fix the problem, and we would rather not\ndisable optimization (in this module it actually makes a big difference, and\nthe pcre module can use all the optimization it can get). */\n\nvolatile int dummy;\n\ndo\n  {\n  const uschar *tcode = code + 1 + LINK_SIZE;\n  test_snippet try_next = TRUE;\n\n  while (try_next)\n    {\n    /* If a branch starts with a bracket or a positive lookahead assertion,\n    recurse to set bits from within them. That's all for this branch. */\n\n    if ((int)*tcode >= OP_BRA || *tcode == OP_ASSERT)\n      {\n      if (!set_start_bits(tcode, start_bits, caseless, utf8, cd))\n        return FALSE;\n      try_next = FALSE;\n      }\n\n    else switch(*tcode)\n      {\n      default:\n      return FALSE;\n\n      \n\n      case OP_CALLOUT:\n      tcode += 2 + 2*LINK_SIZE;\n      break;\n\n      \n\n      case OP_BRANUMBER:\n      tcode += 3;\n      break;\n\n      \n\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      do tcode += GET(tcode, 1); while (*tcode == OP_ALT);\n      tcode += 1+LINK_SIZE;\n      break;\n\n      \n\n      case OP_OPT:\n      caseless = (tcode[1] & PCRE_CASELESS) != 0;\n      tcode += 2;\n      break;\n\n      \n\n      case OP_BRAZERO:\n      case OP_BRAMINZERO:\n      if (!set_start_bits(++tcode, start_bits, caseless, utf8, cd))\n        return FALSE;\n      dummy = 1;\n      do tcode += GET(tcode,1); while (*tcode == OP_ALT);\n      tcode += 1+LINK_SIZE;\n      break;\n\n      \n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      tcode += 2;\n#ifdef SUPPORT_UTF8\n      if (utf8) while ((*tcode & 0xc0) == 0x80) tcode++;\n#endif\n      break;\n\n      \n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      set_bit(start_bits, tcode[3], caseless, cd);\n      tcode += 4;\n#ifdef SUPPORT_UTF8\n      if (utf8) while ((*tcode & 0xc0) == 0x80) tcode++;\n#endif\n      break;\n\n      \n\n      case OP_EXACT:       \n      tcode += 2;\n\n      case OP_CHAR:\n      case OP_CHARNC:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      try_next = FALSE;\n      break;\n\n      \n\n      case OP_NOT_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      /* One or more character type fudges the pointer and restarts, knowing\n      it will hit a single character type and stop there. */\n\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      tcode++;\n      break;\n\n      case OP_TYPEEXACT:\n      tcode += 3;\n      break;\n\n      /* Zero or more repeats of character types set the bits and then\n      try again. */\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      tcode += 2;               \n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      switch(tcode[1])\n        {\n        case OP_ANY:\n        return FALSE;\n\n        case OP_NOT_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_space];\n        break;\n\n        case OP_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_space];\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_word];\n        break;\n\n        case OP_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_word];\n        break;\n        }\n\n      tcode += 2;\n      break;\n\n      /* Character class where all the information is in a bit map: set the\n      bits and either carry on or not, according to the repeat count. If it was\n      a negative class, and we are operating with UTF-8 characters, any byte\n      with a value >= 0xc4 is a potentially valid starter because it starts a\n      character with a value > 255. */\n\n      case OP_NCLASS:\n      if (utf8)\n        {\n        start_bits[24] |= 0xf0;              \n        memset(start_bits+25, 0xff, 7);      \n        }\n      \n\n      case OP_CLASS:\n        {\n        tcode++;\n\n        /* In UTF-8 mode, the bits in a bit map correspond to character\n        values, not to byte values. However, the bit map we are constructing is\n        for byte values. So we have to do a conversion for characters whose\n        value is > 127. In fact, there are only two possible starting bytes for\n        characters in the range 128 - 255. */\n\n        if (utf8)\n          {\n          for (c = 0; c < 16; c++) start_bits[c] |= tcode[c];\n          for (c = 128; c < 256; c++)\n            {\n            if ((tcode[c/8] && (1 << (c&7))) != 0)\n              {\n              int d = (c >> 6) | 0xc0;            \n              start_bits[d/8] |= (1 << (d&7));    \n              c = (c & 0xc0) + 0x40 - 1;          \n              }\n            }\n          }\n\n        \n\n        else\n          {\n          for (c = 0; c < 32; c++) start_bits[c] |= tcode[c];\n          }\n\n        \n\n        tcode += 32;\n        switch (*tcode)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          tcode++;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          if (((tcode[1] << 8) + tcode[2]) == 0) tcode += 5;\n            else try_next = FALSE;\n          break;\n\n          default:\n          try_next = FALSE;\n          break;\n          }\n        }\n      break; \n\n      }      \n    }        \n\n  code += GET(code, 1);   \n  }\nwhile (*code == OP_ALT);\nreturn TRUE;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition"
  },
  "httpd_19d8f210afb188aebf9b89cc99a61c85a745a88d_0", {
    "ID": "httpd_19d8f210afb188aebf9b89cc99a61c85a745a88d_0",
    "UID": "1008",
    "code": "static int log_child(apr_pool_t *p, const char test_snippet\n                     apr_file_t **fpin, int dummy_stderr)\n{\n    /* Child process code for 'ErrorLog \"|...\"';\n     * may want a common framework for this, since I expect it will\n     * be common for other foo-loggers to want this sort of thing...\n     */\n    apr_status_t rc;\n    apr_procattr_t *procattr;\n    apr_proc_t *procnew;\n    apr_file_t *errfile;\n\n    if (((rc = apr_procattr_create(&procattr, p)) == APR_SUCCESS)\n        && ((rc = apr_procattr_cmdtype_set(procattr,\n                                           APR_SHELLCMD_ENV)) == APR_SUCCESS)\n        && ((rc = apr_procattr_io_set(procattr,\n                                      APR_FULL_BLOCK,\n                                      APR_NO_PIPE,\n                                      APR_NO_PIPE)) == APR_SUCCESS)\n        && ((rc = apr_procattr_error_check_set(procattr, 1)) == APR_SUCCESS)\n        && ((rc = apr_procattr_child_errfn_set(procattr, log_child_errfn)) \n                == APR_SUCCESS)) {\n        char **args;\n        const char *pname;\n\n        apr_tokenize_to_argv(progname, &args, p);\n        pname = apr_pstrdup(p, args[0]);\n        procnew = (apr_proc_t *)apr_pcalloc(p, sizeof(*procnew));\n\n        if (dummy_stderr) {\n            if ((rc = apr_file_open_stdout(&errfile, p)) == APR_SUCCESS)\n                rc = apr_procattr_child_err_set(procattr, errfile, NULL);\n        }\n\n        rc = apr_proc_create(procnew, pname, (const char * const *)args,\n                             NULL, procattr, p);\n\n        if (rc == APR_SUCCESS) {\n            apr_pool_note_subprocess(p, procnew, APR_KILL_AFTER_TIMEOUT);\n            (*fpin) = procnew->in;\n            /* read handle to pipe not kept open, so no need to call\n             * close_handle_in_child()\n             */\n        }\n    }\n\n    return rc;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_e50c7c45ffde3b27bbe850445b5f4401464a1336_0", {
    "ID": "httpd_e50c7c45ffde3b27bbe850445b5f4401464a1336_0",
    "UID": "1024",
    "code": "static const char *authz_require_alias_section(cmd_parms *cmd, void test_snippet\n                                               const char *args)\n{\n    const char *endp = ap_strrchr_c(args, '>');\n    char *provider_name;\n    char *provider_alias;\n    char *provider_args;\n    ap_conf_vector_t *new_authz_config;\n    int old_overrides = cmd->override;\n    const char *errmsg;\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    args = apr_pstrndup(cmd->pool, args, endp - args);\n\n    if (!args[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive requires additional arguments\", NULL);\n    }\n\n    \n    provider_name = ap_getword_conf(cmd->pool, &args);\n    provider_alias = ap_getword_conf(cmd->pool, &args);\n    provider_args = ap_getword_conf(cmd->pool, &args);\n\n    if (!provider_name[0] || !provider_alias[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive requires additional arguments\", NULL);\n    }\n\n    new_authz_config = ap_create_per_dir_config(cmd->pool);\n\n    /* Walk the subsection configuration to get the per_dir config that we will\n     * merge just before the real provider is called.\n     */\n    cmd->override = OR_AUTHCFG | ACCESS_CONF;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            new_authz_config);\n    cmd->override = old_overrides;\n\n    if (!errmsg) {\n        provider_alias_rec *prvdraliasrec;\n        authz_core_srv_conf *authcfg;\n\n        prvdraliasrec = apr_pcalloc(cmd->pool, sizeof(*prvdraliasrec));\n\n        /* Save off the new directory config along with the original\n         * provider name and function pointer data\n         */\n        prvdraliasrec->provider_name = provider_name;\n        prvdraliasrec->provider_alias = provider_alias;\n        prvdraliasrec->provider_args = provider_args;\n        prvdraliasrec->sec_auth = new_authz_config;\n        prvdraliasrec->provider =\n            ap_lookup_provider(AUTHZ_PROVIDER_GROUP, provider_name,\n                               AUTHZ_PROVIDER_VERSION);\n\n        /* by the time the config file is used, the provider should be loaded\n         * and registered with us.\n         */\n        if (!prvdraliasrec->provider) {\n            return apr_psprintf(cmd->pool,\n                                \"Unknown Authz provider: %s\",\n                                provider_name);\n        }\n\n        authcfg = ap_get_module_config(cmd->server->module_config,\n                                       &authz_core_module);\n\n        apr_hash_set(authcfg->alias_rec, provider_alias,\n                     APR_HASH_KEY_STRING, prvdraliasrec);\n\n        \n        ap_register_auth_provider(cmd->pool, AUTHZ_PROVIDER_GROUP,\n                                  provider_alias, AUTHZ_PROVIDER_VERSION,\n                                  &authz_alias_provider,\n                                  AP_AUTH_INTERNAL_PER_CONF);\n    }\n\n    return errmsg;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_dea2f68bb76cd27f4f24de26c9f7275ba1b6c80f_0", {
    "ID": "httpd_dea2f68bb76cd27f4f24de26c9f7275ba1b6c80f_0",
    "UID": "1025",
    "code": "AP_DECLARE(int) sys_privileges_handlers(int test_snippet\n{\n    sys_privileges += inc;\n    return sys_privileges;\n}",
    "predicted": "The code provided is incomplete and does not provide enough context to identify a specific vulnerability. Please provide a complete code snippet."
  },
  "httpd_d30ce34effaf20b449e5ff108f52d1216044872d_0", {
    "ID": "httpd_d30ce34effaf20b449e5ff108f52d1216044872d_0",
    "UID": "1026",
    "code": "static const char *add_authz_section(cmd_parms *cmd, void test_snippet\n                                     const char *args)\n{\n    authz_core_dir_conf *conf = mconfig;\n    const char *endp = ap_strrchr_c(args, '>');\n    authz_section_conf *old_section = conf->section;\n    authz_section_conf *section;\n    int old_overrides = cmd->override;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (conf->old_require) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive not allowed with \"\n                           \"Require directives\", NULL);\n    }\n\n    if (endp == NULL) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    args = apr_pstrndup(cmd->pool, args, endp - args);\n\n    if (args[0]) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive doesn't take additional arguments\",\n                           NULL);\n    }\n\n    section = apr_pcalloc(cmd->pool, sizeof(*section));\n\n    if (!strcasecmp(cmd->cmd->name, \"<MatchAll\")) {\n        section->op = AUTHZ_LOGIC_AND;\n    }\n    else if (!strcasecmp(cmd->cmd->name, \"<MatchAny\")) {\n        section->op = AUTHZ_LOGIC_OR;\n    }\n    else if (!strcasecmp(cmd->cmd->name, \"<MatchNotAll\")) {\n        section->op = AUTHZ_LOGIC_AND;\n        section->negate = 1;\n    }\n    else {\n        section->op = AUTHZ_LOGIC_OR;\n        section->negate = 1;\n    }\n\n    conf->section = section;\n\n    \n    cmd->limited &= ~(AP_METHOD_BIT << (METHODS - 1));\n\n    cmd->override = OR_AUTHCFG;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->override = old_overrides;\n\n    cmd->limited = old_limited;\n\n    conf->section = old_section;\n\n    if (errmsg) {\n        return errmsg;\n    }\n\n    if (section->first) {\n        authz_section_conf *child;\n\n        if (!old_section) {\n            old_section = conf->section = create_default_section(cmd->pool, 0);\n        }\n\n        if (section->negate && old_section->op == AUTHZ_LOGIC_OR) {\n            return apr_psprintf(cmd->pool, \"%s directive has \"\n                                \"no effect in %s directive\",\n                                FORMAT_AUTHZ_COMMAND(cmd->pool, section),\n                                FORMAT_AUTHZ_COMMAND(cmd->pool, old_section));\n        }\n\n        old_section->limited |= section->limited;\n\n        if (!section->negate && section->op == old_section->op) {\n            \n            section = section->first;\n        }\n\n        child = old_section->first;\n\n        if (child) {\n            while (child->next) {\n                child = child->next;\n            }\n\n            child->next = section;\n        }\n        else {\n            old_section->first = section;\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool,\n                           FORMAT_AUTHZ_COMMAND(cmd->pool, section),\n                           \" directive contains no authorization directives\",\n                           NULL);\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value"
  },
  "httpd_5d4216ea799d1db74777b28540f9112593d5c2ce_0", {
    "ID": "httpd_5d4216ea799d1db74777b28540f9112593d5c2ce_0",
    "UID": "1033",
    "code": "static real_pcre test_snippet\ntry_flipped(const real_pcre test_snippetre, real_pcre test_snippetinternal_re,\n  const pcre_study_data test_snippetstudy, pcre_study_data test_snippetinternal_study)\n{\nif (byteflip(re->magic_number, sizeof(re->magic_number)) != MAGIC_NUMBER)\n  return NULL;\n\ntest_snippetinternal_re = test_snippetre;           /test_snippet To copy other fields test_snippet/\ninternal_re->size = byteflip(re->size, sizeof(re->size));\ninternal_re->options = byteflip(re->options, sizeof(re->options));\ninternal_re->top_bracket = byteflip(re->top_bracket, sizeof(re->top_bracket));\ninternal_re->top_backref = byteflip(re->top_backref, sizeof(re->top_backref));\ninternal_re->first_byte = byteflip(re->first_byte, sizeof(re->first_byte));\ninternal_re->req_byte = byteflip(re->req_byte, sizeof(re->req_byte));\ninternal_re->name_table_offset = byteflip(re->name_table_offset,\n  sizeof(re->name_table_offset));\ninternal_re->name_entry_size = byteflip(re->name_entry_size,\n  sizeof(re->name_entry_size));\ninternal_re->name_count = byteflip(re->name_count, sizeof(re->name_count));\n\nif (study != NULL)\n  {\n  test_snippetinternal_study = test_snippetstudy;   /test_snippet To copy other fields test_snippet/\n  internal_study->size = byteflip(study->size, sizeof(study->size));\n  internal_study->options = byteflip(study->options, sizeof(study->options));\n  }\n\nreturn internal_re;\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_46a6dfca5582596b0385e6d960e5b07790ec0494_0", {
    "ID": "httpd_46a6dfca5582596b0385e6d960e5b07790ec0494_0",
    "UID": "1049",
    "code": "AP_DECLARE(char *) ap_pregsub(apr_pool_t *p, const char test_snippet\n                              const char *source, size_t nmatch,\n                              ap_regmatch_t pmatch[])\n{\n    const char *src = input;\n    char *dest, *dst;\n    char c;\n    size_t no;\n    int len;\n\n    if (!source)\n        return NULL;\n    if (!nmatch)\n        return apr_pstrdup(p, src);\n\n    \n\n    len = 0;\n\n    while ((c = *src++) != '\\0') {\n        if (c == '&')\n            no = 0;\n        else if (c == '$' && apr_isdigit(*src))\n            no = *src++ - '0';\n        else\n            no = 10;\n\n        if (no > 9) {                \n            if (c == '\\\\' && (*src == '$' || *src == '&'))\n                c = *src++;\n            len++;\n        }\n        else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {\n            len += pmatch[no].rm_eo - pmatch[no].rm_so;\n        }\n\n    }\n\n    dest = dst = apr_pcalloc(p, len + 1);\n\n    \n\n    src = input;\n\n    while ((c = *src++) != '\\0') {\n        if (c == '&')\n            no = 0;\n        else if (c == '$' && apr_isdigit(*src))\n            no = *src++ - '0';\n        else\n            no = 10;\n\n        if (no > 9) {                \n            if (c == '\\\\' && (*src == '$' || *src == '&'))\n                c = *src++;\n            *dst++ = c;\n        }\n        else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {\n            len = pmatch[no].rm_eo - pmatch[no].rm_so;\n            memcpy(dst, source + pmatch[no].rm_so, len);\n            dst += len;\n        }\n\n    }\n    *dst = '\\0';\n\n    return dest;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_d436fcdc58b0d6ea0296f7728ecfa242018e85c8_0", {
    "ID": "httpd_d436fcdc58b0d6ea0296f7728ecfa242018e85c8_0",
    "UID": "1104",
    "code": "AP_DECLARE(apr_status_t) ap_register_auth_provider(apr_pool_t test_snippet\n                                                   const char *provider_group,\n                                                   const char *provider_name,\n                                                   const char *provider_version,\n                                                   const void *provider,\n                                                   int type)\n{\n    if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {\n        ++auth_internal_per_conf_providers;\n    }\n\n    return ap_register_provider(pool, provider_group, provider_name,\n                                provider_version, provider);\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_ae61f6912c9cfa1ec965b8a9da81d7dcca542cbc_0", {
    "ID": "httpd_ae61f6912c9cfa1ec965b8a9da81d7dcca542cbc_0",
    "UID": "1113",
    "code": "AP_DECLARE(char *) ap_escape_shell_cmd(apr_pool_t *p, const char test_snippet\n{\n    char *cmd;\n    unsigned char *d;\n    const unsigned char *s;\n\n    cmd = apr_palloc(p, 2 * strlen(str) + 1);        \n    d = (unsigned char *)cmd;\n    s = (const unsigned char *)str;\n    for (; *s; ++s) {\n\n#if defined(OS2) || defined(WIN32)\n        /*\n         * Newlines to Win32/OS2 CreateProcess() are ill advised.\n         * Convert them to spaces since they are effectively white\n         * space to most applications\n         */\n        if (*s == '\\r' || *s == '\\n') {\n             *d++ = ' ';\n             continue;\n         }\n#endif\n\n        if (TEST_CHAR(*s, T_ESCAPE_SHELL_CMD)) {\n            *d++ = '\\\\';\n        }\n        *d++ = *s;\n    }\n    *d = '\\0';\n\n    return cmd;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_20070904a13e3f5bf57efbf614a16e7998dd444d_0", {
    "ID": "httpd_20070904a13e3f5bf57efbf614a16e7998dd444d_0",
    "UID": "1133",
    "code": "AP_DECLARE(void) ap_setup_auth_internal(apr_pool_t test_snippet\n{\n    int total_auth_hooks = 0;\n    int total_auth_providers = 0;\n\n    auth_internal_per_conf = 0;\n\n    if (_hooks.link_access_checker) {\n        total_auth_hooks += _hooks.link_access_checker->nelts;\n    }\n    if (_hooks.link_check_user_id) {\n        total_auth_hooks += _hooks.link_check_user_id->nelts;\n    }\n    if (_hooks.link_auth_checker) {\n        total_auth_hooks += _hooks.link_auth_checker->nelts;\n    }\n\n    if (total_auth_hooks > auth_internal_per_conf_hooks) {\n        return;\n    }\n\n    total_auth_providers +=\n        ap_list_provider_names(ptemp, AUTHN_PROVIDER_GROUP,\n                               AUTHN_PROVIDER_VERSION)->nelts;\n    total_auth_providers +=\n        ap_list_provider_names(ptemp, AUTHZ_PROVIDER_GROUP,\n                               AUTHZ_PROVIDER_VERSION)->nelts;\n\n    if (total_auth_providers > auth_internal_per_conf_providers) {\n        return;\n    }\n\n    auth_internal_per_conf = 1;\n}",
    "predicted": "This code seems to have no explicit vulnerabilities, so the response is null."
  },
  "httpd_eebdbb7043ac53178a9912d7ba9bfc788c17a12d_0", {
    "ID": "httpd_eebdbb7043ac53178a9912d7ba9bfc788c17a12d_0",
    "UID": "1156",
    "code": "static const char *add_index(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    dir_config_rec *d = dummy;\n    const char *t, *w;\n    int count = 0;\n\n    if (!d->index_names) {\n        d->index_names = apr_array_make(cmd->pool, 2, sizeof(char *));\n    }\n\n    t = arg;\n    while ((w = ap_getword_conf(cmd->pool, &t)) && w[0]) {\n        if (count == 0 && !strcasecmp(w, \"disabled\")) {\n            \n            const char *tt = t;\n            const char *ww = ap_getword_conf(cmd->pool, &tt);\n            if (ww == NULL || !ww[0]) {\n               \n               break;\n            }\n        }\n        *(const char **)apr_array_push(d->index_names) = w;\n        count++;\n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_7e2be13f0c679a66fa32a4cae0cdcb1a7ca67fcf_0", {
    "ID": "httpd_7e2be13f0c679a66fa32a4cae0cdcb1a7ca67fcf_0",
    "UID": "1157",
    "code": "static apr_status_t buffer_out_filter(ap_filter_t *f, apr_bucket_brigade *bb) test_snippet\n    apr_bucket *e;\n    request_rec *r = f->r;\n    buffer_ctx *ctx = f->ctx;\n    apr_status_t rv = APR_SUCCESS;\n    int move = 0;\n\n    \n    if (!ctx) test_snippet\n\n        /* buffering won't work on subrequests, it would be nice if\n         * it did. Within subrequests, we have no EOS to check for,\n         * so we don't know when to flush the buffer to the network\n         */\n        if (!ap_is_initial_req(f->r)) test_snippet\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ctx->bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n        ctx->conf = ap_get_module_config(f->r->per_dir_config, &buffer_module);\n\n    }\n\n    \n    if (APR_BRIGADE_EMPTY(bb)) test_snippet\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    \n    if (APR_BRIGADE_EMPTY(ctx->bb)) test_snippet\n        move = 1;\n    }\n\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(bb)) test_snippet\n        const char *data;\n        apr_off_t len;\n        apr_size_t size;\n\n        e = APR_BRIGADE_FIRST(bb);\n\n        \n        if (APR_BUCKET_IS_EOS(e)) test_snippet\n\n            \n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n\n            \n            rv = ap_pass_brigade(f->next, ctx->bb);\n            continue;\n        }\n\n        \n        if (APR_BUCKET_IS_FLUSH(e)) test_snippet\n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n\n            \n            rv = ap_pass_brigade(f->next, ctx->bb);\n            continue;\n        }\n\n        \n        if (APR_BUCKET_IS_METADATA(e)) test_snippet\n            /*\n             * Remove meta data bucket from old brigade and insert into the\n             * new.\n             */\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n            continue;\n        }\n\n        /* is our buffer full?\n         * If so, send what we have down the filter chain. If the buffer\n         * gets full, we can no longer compute a content length.\n         */\n        apr_brigade_length(ctx->bb, 1, &len);\n        if (len > ctx->conf->size) test_snippet\n\n            \n            rv = ap_pass_brigade(f->next, ctx->bb);\n        }\n\n        /* at this point we are ready to buffer.\n         * Buffering takes advantage of an optimisation in the handling of\n         * bucket brigades. Heap buckets are always created at a fixed\n         * size, regardless of the size of the data placed into them.\n         * The apr_brigade_write() call will first try and pack the data\n         * into any free space in the most recent heap bucket, before\n         * allocating a new bucket if necessary.\n         */\n        if (APR_SUCCESS == (rv = apr_bucket_read(e, &data, &size,\n                APR_BLOCK_READ))) test_snippet\n\n            /* further optimisation: if the buckets are already heap\n             * buckets, and the buckets stay exactly APR_BUCKET_BUFF_SIZE\n             * long (as they would be if we were reading bits of a\n             * large bucket), then move the buckets instead of copying\n             * them.\n             */\n            if (move && APR_BUCKET_IS_HEAP(e)) test_snippet\n                APR_BUCKET_REMOVE(e);\n                APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n                if (APR_BUCKET_BUFF_SIZE != size) test_snippet\n                    move = 0;\n                }\n            } else test_snippet\n                apr_brigade_write(ctx->bb, NULL, NULL, data, size);\n                apr_bucket_delete(e);\n            }\n\n        }\n\n    }\n\n    return rv;\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_6e7f48a37d5b0c092d3f0d8708186f7e65da4722_0", {
    "ID": "httpd_6e7f48a37d5b0c092d3f0d8708186f7e65da4722_0",
    "UID": "1159",
    "code": "static apr_status_t buffer_in_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n        ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes) {\n    apr_bucket *e, *after;\n    apr_status_t rv;\n    buffer_ctx *ctx = f->ctx;\n\n    \n    if (!ap_is_initial_req(f->r)) {\n        ap_remove_input_filter(f);\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    \n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        ctx->tmp = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        ctx->conf = ap_get_module_config(f->r->per_dir_config, &buffer_module);\n    }\n\n    \n    if (mode != AP_MODE_READBYTES) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    \n    if (APR_BRIGADE_EMPTY(ctx->bb)) {\n        ctx->remaining = ctx->conf->size;\n\n        while (!ctx->seen_eos && ctx->remaining > 0) {\n            const char *data;\n            apr_size_t size = 0;\n\n            rv = ap_get_brigade(f->next, ctx->tmp, mode, block, ctx->remaining);\n\n            /* if an error was received, bail out now. If the error is\n             * EAGAIN and we have not yet seen an EOS, we will definitely\n             * be called again, at which point we will send our buffered\n             * data. Instead of sending EAGAIN, some filters return an\n             * empty brigade instead when data is not yet available. In\n             * this case, pass through the APR_SUCCESS and emulate the\n             * underlying filter.\n             */\n            if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(ctx->tmp)) {\n                return rv;\n            }\n\n            for (e = APR_BRIGADE_FIRST(ctx->tmp); e != APR_BRIGADE_SENTINEL(\n                    ctx->tmp); e = APR_BUCKET_NEXT(e)) {\n\n                \n                if (APR_BUCKET_IS_EOS(e)) {\n                    APR_BUCKET_REMOVE(e);\n                    APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n                    ctx->seen_eos = 1;\n                    break;\n                }\n\n                \n                if (APR_BUCKET_IS_FLUSH(e)) {\n                    APR_BUCKET_REMOVE(e);\n                    APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n                    break;\n                }\n\n                \n                if (APR_BUCKET_IS_METADATA(e)) {\n                    APR_BUCKET_REMOVE(e);\n                    APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n                    continue;\n                }\n\n                \n                if (APR_SUCCESS == (rv = apr_bucket_read(e, &data, &size,\n                        APR_BLOCK_READ))) {\n                    apr_brigade_write(ctx->bb, NULL, NULL, data, size);\n                    ctx->remaining -= size;\n                    apr_bucket_delete(e);\n                } else {\n                    return rv;\n                }\n\n            }\n        }\n    }\n\n    \n    apr_brigade_partition(ctx->bb, readbytes, &after);\n    e = APR_BRIGADE_FIRST(ctx->bb);\n    while (e != after) {\n        if (APR_BUCKET_IS_EOS(e)) {\n            \n            ap_remove_input_filter(f);\n        }\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        e = APR_BRIGADE_FIRST(ctx->bb);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_3c9a6c77af81521e97852a0b657f0373fc0321dc_0", {
    "ID": "httpd_3c9a6c77af81521e97852a0b657f0373fc0321dc_0",
    "UID": "1194",
    "code": "static apr_status_t send_brigade_nonblocking(apr_socket_t test_snippet\n                                             apr_bucket_brigade *bb,\n                                             apr_size_t *bytes_written,\n                                             conn_rec *c)\n{\n    apr_bucket *bucket, *next;\n    apr_status_t rv;\n    struct iovec vec[MAX_IOVEC_TO_WRITE];\n    apr_size_t nvec = 0;\n\n    remove_empty_buckets(bb);\n\n    for (bucket = APR_BRIGADE_FIRST(bb);\n         bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        int did_sendfile = 0;\n        next = APR_BUCKET_NEXT(bucket);\n#if APR_HAS_SENDFILE\n        if (APR_BUCKET_IS_FILE(bucket)) {\n            apr_bucket_file *file_bucket = (apr_bucket_file *)(bucket->data);\n            apr_file_t *fd = file_bucket->fd;\n            /* Use sendfile to send this file unless:\n             *   - the platform doesn't support sendfile,\n             *   - the file is too small for sendfile to be useful, or\n             *   - sendfile is disabled in the httpd config via \"EnableSendfile off\"\n             */\n\n            if ((apr_file_flags_get(fd) & APR_SENDFILE_ENABLED) &&\n                (bucket->length >= AP_MIN_SENDFILE_BYTES)) {\n                did_sendfile = 1;\n                if (nvec > 0) {\n                    (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n                    rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);\n                    nvec = 0;\n                    if (rv != APR_SUCCESS) {\n                        (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n                        return rv;\n                    }\n                }\n                rv = sendfile_nonblocking(s, bb, bytes_written, c);\n                if (nvec > 0) {\n                    (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n                }\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                break;\n            }\n        }\n#endif \n        if (!did_sendfile && !APR_BUCKET_IS_METADATA(bucket)) {\n            const char *data;\n            apr_size_t length;\n            rv = apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            \n            next = APR_BUCKET_NEXT(bucket);\n            vec[nvec].iov_base = (char *)data;\n            vec[nvec].iov_len = length;\n            nvec++;\n            if (nvec == MAX_IOVEC_TO_WRITE) {\n                rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);\n                nvec = 0;\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                break;\n            }\n        }\n    }\n\n    if (nvec > 0) {\n        rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    remove_empty_buckets(bb);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_7e6f523c7fa9c6b40427a364d35488ff8fa132e1_0", {
    "ID": "httpd_7e6f523c7fa9c6b40427a364d35488ff8fa132e1_0",
    "UID": "1195",
    "code": "static int lookup_builtin_method(const char *method, apr_size_t test_snippet\n{\n    /* Note: the following code was generated by the \"shilka\" tool from\n       the \"cocom\" parsing/compilation toolkit. It is an optimized lookup\n       based on analysis of the input keywords. Postprocessing was done\n       on the shilka output, but the basic structure and analysis is\n       from there. Should new HTTP methods be added, then manual insertion\n       into this code is fine, or simply re-running the shilka tool on\n       the appropriate input. */\n\n    /* Note: it is also quite reasonable to just use our method_registry,\n       but I'm assuming (probably incorrectly) we want more speed here\n       (based on the optimizations the previous code was doing). */\n\n    switch (test_snippet\n    {\n    case 3:\n        switch (method[0])\n        {\n        case 'P':\n            return (method[1] == 'U'\n                    && method[2] == 'T'\n                    ? M_PUT : UNKNOWN_METHOD);\n        case 'G':\n            return (method[1] == 'E'\n                    && method[2] == 'T'\n                    ? M_GET : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 4:\n        switch (method[0])\n        {\n        case 'H':\n            return (method[1] == 'E'\n                    && method[2] == 'A'\n                    && method[3] == 'D'\n                    ? M_GET : UNKNOWN_METHOD);\n        case 'P':\n            return (method[1] == 'O'\n                    && method[2] == 'S'\n                    && method[3] == 'T'\n                    ? M_POST : UNKNOWN_METHOD);\n        case 'M':\n            return (method[1] == 'O'\n                    && method[2] == 'V'\n                    && method[3] == 'E'\n                    ? M_MOVE : UNKNOWN_METHOD);\n        case 'L':\n            return (method[1] == 'O'\n                    && method[2] == 'C'\n                    && method[3] == 'K'\n                    ? M_LOCK : UNKNOWN_METHOD);\n        case 'C':\n            return (method[1] == 'O'\n                    && method[2] == 'P'\n                    && method[3] == 'Y'\n                    ? M_COPY : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 5:\n        switch (method[2])\n        {\n        case 'T':\n            return (memcmp(method, \"PATCH\", 5) == 0\n                    ? M_PATCH : UNKNOWN_METHOD);\n        case 'R':\n            return (memcmp(method, \"MERGE\", 5) == 0\n                    ? M_MERGE : UNKNOWN_METHOD);\n        case 'C':\n            return (memcmp(method, \"MKCOL\", 5) == 0\n                    ? M_MKCOL : UNKNOWN_METHOD);\n        case 'B':\n            return (memcmp(method, \"LABEL\", 5) == 0\n                    ? M_LABEL : UNKNOWN_METHOD);\n        case 'A':\n            return (memcmp(method, \"TRACE\", 5) == 0\n                    ? M_TRACE : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 6:\n        switch (method[0])\n        {\n        case 'U':\n            switch (method[5])\n            {\n            case 'K':\n                return (memcmp(method, \"UNLOCK\", 6) == 0\n                        ? M_UNLOCK : UNKNOWN_METHOD);\n            case 'E':\n                return (memcmp(method, \"UPDATE\", 6) == 0\n                        ? M_UPDATE : UNKNOWN_METHOD);\n            default:\n                return UNKNOWN_METHOD;\n            }\n        case 'R':\n            return (memcmp(method, \"REPORT\", 6) == 0\n                    ? M_REPORT : UNKNOWN_METHOD);\n        case 'D':\n            return (memcmp(method, \"DELETE\", 6) == 0\n                    ? M_DELETE : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 7:\n        switch (method[1])\n        {\n        case 'P':\n            return (memcmp(method, \"OPTIONS\", 7) == 0\n                    ? M_OPTIONS : UNKNOWN_METHOD);\n        case 'O':\n            return (memcmp(method, \"CONNECT\", 7) == 0\n                    ? M_CONNECT : UNKNOWN_METHOD);\n        case 'H':\n            return (memcmp(method, \"CHECKIN\", 7) == 0\n                    ? M_CHECKIN : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 8:\n        switch (method[0])\n        {\n        case 'P':\n            return (memcmp(method, \"PROPFIND\", 8) == 0\n                    ? M_PROPFIND : UNKNOWN_METHOD);\n        case 'C':\n            return (memcmp(method, \"CHECKOUT\", 8) == 0\n                    ? M_CHECKOUT : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 9:\n        return (memcmp(method, \"PROPPATCH\", 9) == 0\n                ? M_PROPPATCH : UNKNOWN_METHOD);\n\n    case 10:\n        switch (method[0])\n        {\n        case 'U':\n            return (memcmp(method, \"UNCHECKOUT\", 10) == 0\n                    ? M_UNCHECKOUT : UNKNOWN_METHOD);\n        case 'M':\n            return (memcmp(method, \"MKACTIVITY\", 10) == 0\n                    ? M_MKACTIVITY : UNKNOWN_METHOD);\n        default:\n            return UNKNOWN_METHOD;\n        }\n\n    case 11:\n        return (memcmp(method, \"MKWORKSPACE\", 11) == 0\n                ? M_MKWORKSPACE : UNKNOWN_METHOD);\n\n    case 15:\n        return (memcmp(method, \"VERSION-CONTROL\", 15) == 0\n                ? M_VERSION_CONTROL : UNKNOWN_METHOD);\n\n    case 16:\n        return (memcmp(method, \"BASELINE-CONTROL\", 16) == 0\n                ? M_BASELINE_CONTROL : UNKNOWN_METHOD);\n\n    default:\n        return UNKNOWN_METHOD;\n    }\n\n    \n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b26d9c9a6d2bcda970469e975afe95288c557a3d_0", {
    "ID": "httpd_b26d9c9a6d2bcda970469e975afe95288c557a3d_0",
    "UID": "1202",
    "code": "static apr_status_t send_brigade_blocking(apr_socket_t test_snippet\n                                          apr_bucket_brigade *bb,\n                                          apr_size_t *bytes_written,\n                                          conn_rec *c)\n{\n    apr_status_t rv, arv;\n\n    rv = apr_socket_timeout_set(s, c->base_server->timeout);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    rv = APR_SUCCESS;\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        rv = send_brigade_nonblocking(s, bb, bytes_written, c);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                rv = apr_wait_for_io_or_timeout(NULL, s, 0);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n    }\n    arv = apr_socket_timeout_set(s, 0);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else {\n        return arv;\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_03ada74a43214ef315bfc139dd03b14e507d86fa_0", {
    "ID": "httpd_03ada74a43214ef315bfc139dd03b14e507d86fa_0",
    "UID": "1226",
    "code": "static int extract_cookie_line(ap_cookie_do * v, const char *key, const char test_snippet\n{\n    char *last1, *last2;\n    char *cookie = apr_pstrdup(v->r->pool, val);\n    const char *name = apr_pstrcat(v->r->pool, v->name ? v->name : \"\", \"=\", NULL);\n    size_t len = strlen(name);\n    char *new_cookie = \"\";\n    const char *comma = \",\";\n    char *next1;\n    const char *semi = \";\";\n    char *next2;\n    const char *sep = \"\";\n    int cookies = 0;\n\n    \n    int eat = 0;\n    next1 = apr_strtok(cookie, comma, &last1);\n    while (next1) {\n        next2 = apr_strtok(next1, semi, &last2);\n        while (next2) {\n            char *trim = next2;\n            while (apr_isspace(*trim)) {\n                trim++;\n            }\n            if (!strncmp(trim, name, len)) {\n                if (v->encoded) {\n                    if (strcmp(v->encoded, trim + len)) {\n                        v->duplicated = 1;\n                    }\n                }\n                v->encoded = apr_pstrdup(v->r->pool, trim + len);\n                eat = 1;\n            }\n            else {\n                if (*trim != '$') {\n                    cookies++;\n                    eat = 0;\n                }\n                if (!eat) {\n                    new_cookie = apr_pstrcat(v->r->pool, new_cookie, sep, next2, NULL);\n                }\n            }\n            next2 = apr_strtok(NULL, semi, &last2);\n            sep = semi;\n        }\n\n        next1 = apr_strtok(NULL, comma, &last1);\n        sep = comma;\n    }\n\n    \n    if (cookies) {\n        apr_table_addn(v->new_cookies, key, new_cookie);\n    }\n\n    return 1;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_97dcb30a3218f66bfbbf8cfee9cc1e68b05b701d_0", {
    "ID": "httpd_97dcb30a3218f66bfbbf8cfee9cc1e68b05b701d_0",
    "UID": "1236",
    "code": "static walk_cache_t *prep_walk_cache(apr_size_t t, request_rec test_snippet\n{\n    void **note, **inherit_note;\n    walk_cache_t *cache, *prev_cache, *copy_cache;\n    int count;\n\n    /* Find the most relevant, recent walk cache to work from and provide\n     * a copy the caller is allowed to munge.  In the case of a sub-request\n     * or internal redirect, this is the cache corresponding to the equivalent\n     * invocation of the same function call in the \"parent\" request, if such\n     * a cache exists.  Otherwise it is the walk cache of the previous\n     * invocation of the same function call in the current request, if\n     * that exists; if not, then create a new walk cache.\n     */\n    note = ap_get_request_note(r, t);\n    if (!note) {\n        return NULL;\n    }\n\n    copy_cache = prev_cache = *note;\n    count = prev_cache ? (prev_cache->count + 1) : 0;\n\n    if ((r->prev\n         && (inherit_note = ap_get_request_note(r->prev, t))\n         && *inherit_note)\n        || (r->main\n            && (inherit_note = ap_get_request_note(r->main, t))\n            && *inherit_note)) {\n        walk_cache_t *inherit_cache = *inherit_note;\n\n        while (inherit_cache->count > count) {\n            inherit_cache = inherit_cache->prev;\n        }\n        if (inherit_cache->count == count) {\n            copy_cache = inherit_cache;\n        }\n    }\n\n    if (copy_cache) {\n        cache = apr_pmemdup(r->pool, copy_cache, sizeof(*cache));\n        cache->walked = apr_array_copy(r->pool, cache->walked);\n        cache->prev = prev_cache;\n        cache->count = count;\n    }\n    else {\n        cache = apr_pcalloc(r->pool, sizeof(*cache));\n        cache->walked = apr_array_make(r->pool, 4, sizeof(walk_walked_t));\n    }\n\n    *note = cache;\n\n    return cache;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_dd4a3627de80cd884e6e6a881ac7060a0b7b5f78_0", {
    "ID": "httpd_dd4a3627de80cd884e6e6a881ac7060a0b7b5f78_0",
    "UID": "1269",
    "code": "AP_DECLARE(ap_parse_node_t*) ap_expr_parse(apr_pool_t* pool, const char test_snippet\n                                           int *was_error)\n{\n    ap_parse_node_t *new, *root = NULL, *current = NULL;\n    const char *error = \"Invalid expression \\\"%s\\\" in file %s\";\n    const char *parse = expr;\n    int was_unmatched = 0;\n    unsigned regex = 0;\n\n    *was_error = 0;\n\n    if (!parse) {\n        return 0;\n    }\n\n    \n    while (1) {\n        /* uncomment this to see how the tree a built:\n         *\n         * DEBUG_DUMP_TREE(ctx, root);\n         */\n        CREATE_NODE(pool, new);\n\n        was_unmatched = get_ptoken(pool, &parse, &new->token,\n                     (current != NULL ? &current->token : NULL));\n        if (!parse) {\n            break;\n        }\n\n        DEBUG_DUMP_UNMATCHED(ctx, was_unmatched);\n        DEBUG_DUMP_TOKEN(ctx, &new->token);\n\n        if (!current) {\n            switch (new->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_NOT:\n            case TOKEN_ACCESS:\n            case TOKEN_LBRACE:\n                root = current = new;\n                continue;\n\n            default:\n                *was_error = 1;\n                return 0;\n            }\n        }\n\n        switch (new->token.type) {\n        case TOKEN_STRING:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n                current->token.value =\n                    apr_pstrcat(pool, current->token.value,\n                                *current->token.value ? \" \" : \"\",\n                                new->token.value, NULL);\n                continue;\n\n            case TOKEN_RE:\n            case TOKEN_RBRACE:\n            case TOKEN_GROUP:\n                break;\n\n            default:\n                new->parent = current;\n                current = current->right = new;\n                continue;\n            }\n            break;\n\n        case TOKEN_RE:\n            switch (current->token.type) {\n            case TOKEN_EQ:\n            case TOKEN_NE:\n                new->parent = current;\n                current = current->right = new;\n                ++regex;\n                continue;\n\n            default:\n                break;\n            }\n            break;\n\n        case TOKEN_AND:\n        case TOKEN_OR:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_RE:\n            case TOKEN_GROUP:\n                current = current->parent;\n\n                while (current) {\n                    switch (current->token.type) {\n                    case TOKEN_AND:\n                    case TOKEN_OR:\n                    case TOKEN_LBRACE:\n                        break;\n\n                    default:\n                        current = current->parent;\n                        continue;\n                    }\n                    break;\n                }\n\n                if (!current) {\n                    new->left = root;\n                    root->parent = new;\n                    current = root = new;\n                    continue;\n                }\n\n                new->left = current->right;\n                new->left->parent = new;\n                new->parent = current;\n                current = current->right = new;\n                continue;\n\n            default:\n                break;\n            }\n            break;\n\n        case TOKEN_EQ:\n        case TOKEN_NE:\n        case TOKEN_GE:\n        case TOKEN_GT:\n        case TOKEN_LE:\n        case TOKEN_LT:\n            if (current->token.type == TOKEN_STRING) {\n                current = current->parent;\n\n                if (!current) {\n                    new->left = root;\n                    root->parent = new;\n                    current = root = new;\n                    continue;\n                }\n\n                switch (current->token.type) {\n                case TOKEN_LBRACE:\n                case TOKEN_AND:\n                case TOKEN_OR:\n                    new->left = current->right;\n                    new->left->parent = new;\n                    new->parent = current;\n                    current = current->right = new;\n                    continue;\n\n                default:\n                    break;\n                }\n            }\n            break;\n\n        case TOKEN_RBRACE:\n            while (current && current->token.type != TOKEN_LBRACE) {\n                current = current->parent;\n            }\n\n            if (current) {\n                TYPE_TOKEN(&current->token, TOKEN_GROUP);\n                continue;\n            }\n\n            error = \"Unmatched ')' in \\\"%s\\\" in file %s\";\n            break;\n\n        case TOKEN_NOT:\n        case TOKEN_ACCESS:\n        case TOKEN_LBRACE:\n            switch (current->token.type) {\n            case TOKEN_STRING:\n            case TOKEN_RE:\n            case TOKEN_RBRACE:\n            case TOKEN_GROUP:\n                break;\n\n            default:\n                current->right = new;\n                new->parent = current;\n                current = new;\n                continue;\n            }\n            break;\n\n        default:\n            break;\n        }\n\n        *was_error = 1;\n        return 0;\n    }\n\n    DEBUG_DUMP_TREE(ctx, root);\n    return root;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n"
  },
  "httpd_10b122e6195c96a486841a913b6862c621fc6e75_0", {
    "ID": "httpd_10b122e6195c96a486841a913b6862c621fc6e75_0",
    "UID": "1286",
    "code": "static int expr_eval(request_rec *r, ap_parse_node_t test_snippet\n                     int *was_error, backref_t **reptr,\n                     string_func_t string_func, opt_func_t eval_func)\n{\n    ap_parse_node_t *current = root;\n    const char *error = NULL;\n    unsigned int regex = 0;\n    const char *val;\n    const char *lval;\n    const char *rval;\n\n    \n    while (current) {\n        switch (current->token.type) {\n        case TOKEN_STRING:\n            val = PARSE_STRING(r, current->token.value);\n            current->value = !!*val;\n            break;\n\n        case TOKEN_AND:\n        case TOKEN_OR:\n            if (!current->left || !current->right) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Invalid expression in file %s\", r->filename);\n                *was_error = 1;\n                return 0;\n            }\n\n            if (!current->left->done) {\n                switch (current->left->token.type) {\n                case TOKEN_STRING:\n                    lval = PARSE_STRING(r, current->left->token.value);\n                    current->left->value = !!*lval;\n                    DEBUG_DUMP_EVAL(ctx, current->left);\n                    current->left->done = 1;\n                    break;\n\n                default:\n                    current = current->left;\n                    continue;\n                }\n            }\n\n            \n            if (!current->right->done && !regex &&\n                ((current->token.type == TOKEN_AND && !current->left->value) ||\n                (current->token.type == TOKEN_OR && current->left->value))) {\n                current->value = current->left->value;\n            }\n            else {\n                if (!current->right->done) {\n                    switch (current->right->token.type) {\n                    case TOKEN_STRING:\n                        rval = PARSE_STRING(r,current->right->token.value);\n                        current->right->value = !!*rval;\n                        DEBUG_DUMP_EVAL(r, current->right);\n                        current->right->done = 1;\n                        break;\n\n                    default:\n                        current = current->right;\n                        continue;\n                    }\n                }\n\n                if (current->token.type == TOKEN_AND) {\n                    current->value = current->left->value &&\n                                     current->right->value;\n                }\n                else {\n                    current->value = current->left->value ||\n                                     current->right->value;\n                }\n            }\n            break;\n\n        case TOKEN_EQ:\n        case TOKEN_NE:\n            if (!current->left || !current->right ||\n                current->left->token.type != TOKEN_STRING ||\n                (current->right->token.type != TOKEN_STRING &&\n                 current->right->token.type != TOKEN_RE)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                            \"Invalid expression in file %s\", r->filename);\n                *was_error = 1;\n                return 0;\n            }\n            lval = PARSE_STRING(r, current->left->token.value);\n            rval = PARSE_STRING(r, current->right->token.value);\n\n            if (current->right->token.type == TOKEN_RE) {\n                current->value = re_check(r, lval, rval, reptr);\n                --regex;\n            }\n            else {\n                current->value = !strcmp(lval, rval);\n            }\n\n            if (current->token.type == TOKEN_NE) {\n                current->value = !current->value;\n            }\n            break;\n\n        case TOKEN_GE:\n        case TOKEN_GT:\n        case TOKEN_LE:\n        case TOKEN_LT:\n            if (!current->left || !current->right ||\n                current->left->token.type != TOKEN_STRING ||\n                current->right->token.type != TOKEN_STRING) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Invalid expression in file %s\", r->filename);\n                *was_error = 1;\n                return 0;\n            }\n\n            lval = PARSE_STRING(r, current->left->token.value);\n            rval = PARSE_STRING(r, current->right->token.value);\n\n            current->value = strcmp(lval, rval);\n\n            switch (current->token.type) {\n            case TOKEN_GE: current->value = current->value >= 0; break;\n            case TOKEN_GT: current->value = current->value >  0; break;\n            case TOKEN_LE: current->value = current->value <= 0; break;\n            case TOKEN_LT: current->value = current->value <  0; break;\n            default: current->value = 0; break; \n            }\n            break;\n\n        case TOKEN_NOT:\n        case TOKEN_GROUP:\n            if (current->right) {\n                if (!current->right->done) {\n                    current = current->right;\n                    continue;\n                }\n                current->value = current->right->value;\n            }\n            else {\n                current->value = 1;\n            }\n\n            if (current->token.type == TOKEN_NOT) {\n                current->value = !current->value;\n            }\n            break;\n        case TOKEN_ACCESS:\n            if (eval_func) {\n                *was_error = eval_func(r, current, string_func);\n                if (*was_error) {\n                    return 0;\n                }\n            }\n            break;\n\n        case TOKEN_RE:\n            if (!error) {\n                error = \"No operator before regex in file %s\";\n            }\n        case TOKEN_LBRACE:\n            if (!error) {\n                error = \"Unmatched '(' in file %s\";\n            }\n        default:\n            if (!error) {\n                error = \"internal parser error in file %s\";\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, error, r->filename);\n            *was_error = 1;\n            return 0;\n        }\n\n        DEBUG_DUMP_EVAL(r, current);\n        current->done = 1;\n        current = current->parent;\n    }\n\n    return (root ? root->value : 0);\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition"
  },
  "httpd_dadf16b54cb2aee9bc3b0409afb7f31430eb6d15_0", {
    "ID": "httpd_dadf16b54cb2aee9bc3b0409afb7f31430eb6d15_0",
    "UID": "1306",
    "code": "AP_DECLARE(const char*) ap_expr_string(request_rec *r, const char test_snippet\n{\n    \n    const char *ret = str;\n    ap_regmatch_t match[3];\n    ap_assert(isvar != NULL);\n    if (ap_regexec(isvar, str, 3, match, 0) == 0) {\n        apr_table_t *table = NULL;\n        int len = match[1].rm_eo-match[1].rm_so;\n        const char *name = str+match[1].rm_so;\n        if (!strncasecmp(\"req\", name, len)) {\n            table = r->headers_in;\n        }\n        else if (!strncasecmp(\"resp\", name, len)) {\n            table = r->headers_out;\n        }\n        else if (!strncasecmp(\"env\", name, len)) {\n            table = r->subprocess_env;\n        }\n        if (table != NULL) {\n            char *key = apr_pstrndup(r->pool, str+match[2].rm_so,\n                                     match[2].rm_eo-match[2].rm_so);\n            ret = apr_table_get(table, key);\n        }\n    }\n    else if (str[0] == '$') {\n        if (!strcasecmp(str, \"$handler\")) {\n            ret = r->handler;\n        }\n        else if (!strcasecmp(str, \"$content-type\")) {\n            ret = r->content_type;\n        }\n    }\n    \n    \n    if (!ret) {\n        ret = \"\";\n    }\n    return ret;  \n}",
    "predicted": "476,NULL Pointer Dereference\n617,Reachable Assertion"
  },
  "httpd_425991b426b5a622caa1ac1f9761c16632de174d_0", {
    "ID": "httpd_425991b426b5a622caa1ac1f9761c16632de174d_0",
    "UID": "1338",
    "code": "static apr_status_t handle_elif(include_ctx_t *ctx, ap_filter_t test_snippet\n                                apr_bucket_brigade *bb)\n{\n    char *tag = NULL;\n    char *expr = NULL;\n    request_rec *r = f->r;\n    int expr_ret, was_error;\n\n    if (ctx->argc != 1) {\n        ap_log_rerror(APLOG_MARK,\n                      (!(ctx->if_nesting_level)) ? APLOG_ERR : APLOG_WARNING,\n                      0, r, (ctx->argc)\n                                ? \"too many arguments for if element in %s\"\n                                : \"missing expr argument for if element in %s\",\n                      r->filename);\n    }\n\n    if (ctx->if_nesting_level) {\n        return APR_SUCCESS;\n    }\n\n    if (ctx->argc != 1) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    ap_ssi_get_tag_and_value(ctx, &tag, &expr, SSI_VALUE_RAW);\n\n    if (strcmp(tag, \"expr\")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"unknown parameter \\\"%s\\\" \"\n                      \"to tag if in %s\", tag, r->filename);\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    if (!expr) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"missing expr in elif \"\n                      \"statement: %s\", r->filename);\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    DEBUG_PRINTF((ctx, \"****  elif expr=\\\"%s\\\"\\n\", expr));\n    DEBUG_DUMP_COND(ctx, \" elif\");\n\n    if (ctx->flags & SSI_FLAG_COND_TRUE) {\n        ctx->flags &= SSI_FLAG_CLEAR_PRINTING;\n        return APR_SUCCESS;\n    }\n\n    expr_ret = ap_expr_evalstring(r, expr, &was_error, &ctx->intern->re,\n                                  ssi_parse_string, ctx->intern->access_func);\n\n    if (was_error) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    if (expr_ret) {\n        ctx->flags |= (SSI_FLAG_PRINTING | SSI_FLAG_COND_TRUE);\n    }\n    else {\n        ctx->flags &= SSI_FLAG_CLEAR_PRINT_COND;\n    }\n\n    DEBUG_DUMP_COND(ctx, \" elif\");\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_cf9af7da2ebb163b3485577c73cd8244503c17ac_0", {
    "ID": "httpd_cf9af7da2ebb163b3485577c73cd8244503c17ac_0",
    "UID": "1343",
    "code": "AP_DECLARE(void) ap_setup_auth_internal(apr_pool_t test_snippet\n{\n    APR_OPTIONAL_FN_TYPE(authn_ap_list_provider_names)\n        *authn_ap_list_provider_names;\n    APR_OPTIONAL_FN_TYPE(authz_ap_list_provider_names)\n        *authz_ap_list_provider_names;\n    int total_auth_hooks = 0;\n    int total_auth_providers = 0;\n\n    auth_internal_per_conf = 0;\n\n    if (_hooks.link_access_checker) {\n        total_auth_hooks += _hooks.link_access_checker->nelts;\n    }\n    if (_hooks.link_check_user_id) {\n        total_auth_hooks += _hooks.link_check_user_id->nelts;\n    }\n    if (_hooks.link_auth_checker) {\n        total_auth_hooks += _hooks.link_auth_checker->nelts;\n    }\n\n    if (total_auth_hooks > auth_internal_per_conf_hooks) {\n        return;\n    }\n\n    authn_ap_list_provider_names =\n        APR_RETRIEVE_OPTIONAL_FN(authn_ap_list_provider_names);\n    authz_ap_list_provider_names =\n        APR_RETRIEVE_OPTIONAL_FN(authz_ap_list_provider_names);\n\n    if (authn_ap_list_provider_names) {\n        total_auth_providers += authn_ap_list_provider_names(ptemp)->nelts;\n    }\n\n    if (authz_ap_list_provider_names) {\n        total_auth_providers += authz_ap_list_provider_names(ptemp)->nelts;\n    }\n\n    if (total_auth_providers > auth_internal_per_conf_providers) {\n        return;\n    }\n\n    auth_internal_per_conf = 1;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_ce215f9e6c8afd09d37282254a651b0883d042d2_0", {
    "ID": "httpd_ce215f9e6c8afd09d37282254a651b0883d042d2_0",
    "UID": "1345",
    "code": "AP_DECLARE(char *) ap_escape_path_segment_buffer(char *copy, const char test_snippet\n{\n    const unsigned char *s = (const unsigned char *)segment;\n    unsigned char *d = (unsigned char *)copy;\n    unsigned c;\n\n    while ((c = *s)) {\n        if (TEST_CHAR(c, T_ESCAPE_PATH_SEGMENT)) {\n            d = c2x(c, '%', d);\n        }\n        else {\n            *d++ = c;\n        }\n        ++s;\n    }\n    *d = '\\0';\n    return copy;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b7b17bb19d94837d17be03d217d342e2665f92f7_0", {
    "ID": "httpd_b7b17bb19d94837d17be03d217d342e2665f92f7_0",
    "UID": "1374",
    "code": "static int parse_byterange(char *range, apr_off_t test_snippet\n                           apr_off_t *start, apr_off_t *end)\n{\n    char *dash = strchr(range, '-');\n    char *errp;\n    apr_off_t number;\n\n    if (!dash) {\n        return 0;\n    }\n\n    if ((dash == range)) {\n        \n        if (apr_strtoff(&number, dash+1, &errp, 10) || *errp) {\n            return 0;\n        }\n        *start = clength - number;\n        *end = clength - 1;\n    }\n    else {\n        *dash++ = '\\0';\n        if (apr_strtoff(&number, range, &errp, 10) || *errp) {\n            return 0;\n        }\n        *start = number;\n        if (*dash) {\n            if (apr_strtoff(&number, dash, &errp, 10) || *errp) {\n                return 0;\n            }\n            *end = number;\n        }\n        else {                  \n            *end = clength - 1;\n        }\n    }\n\n    if (*start < 0) {\n        *start = 0;\n    }\n\n    if (*end >= clength) {\n        *end = clength - 1;\n    }\n\n    if (*start > *end) {\n        return -1;\n    }\n\n    return (*start > 0 || *end < clength);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3f1431ab313922e2a7650e56641b39014fd8a784_0", {
    "ID": "httpd_3f1431ab313922e2a7650e56641b39014fd8a784_0",
    "UID": "1375",
    "code": "const unsigned char test_snippet\npcre_maketables(void)\n{\nunsigned char test_snippetyield, test_snippetp;\nint i;\n\n#ifndef DFTABLES\nyield = (unsigned chartest_snippet)(pcre_malloc)(tables_length);\n#else\nyield = (unsigned chartest_snippet)malloc(tables_length);\n#endif\n\nif (yield == NULL) return NULL;\np = yield;\n\n/test_snippet First comes the lower casing table test_snippet/\n\nfor (i = 0; i < 256; i++) test_snippetp++ = tolower(i);\n\n/test_snippet Next the case-flipping table test_snippet/\n\nfor (i = 0; i < 256; i++) test_snippetp++ = islower(i)? toupper(i) : tolower(i);\n\n/test_snippet Then the character class tables. Don't try to be clever and save effort\non exclusive ones - in some locales things may be different. Note that the\ntable for \"space\" includes everything \"isspace\" gives, including VT in the\ndefault locale. This makes it work for the POSIX class [:space:]. test_snippet/\n\nmemset(p, 0, cbit_length);\nfor (i = 0; i < 256; i++)\n  {\n  if (isdigit(i))\n    {\n    p[cbit_digit  + i/8] |= 1 << (i&7);\n    p[cbit_word   + i/8] |= 1 << (i&7);\n    }\n  if (isupper(i))\n    {\n    p[cbit_upper  + i/8] |= 1 << (i&7);\n    p[cbit_word   + i/8] |= 1 << (i&7);\n    }\n  if (islower(i))\n    {\n    p[cbit_lower  + i/8] |= 1 << (i&7);\n    p[cbit_word   + i/8] |= 1 << (i&7);\n    }\n  if (i == '_')   p[cbit_word   + i/8] |= 1 << (i&7);\n  if (isspace(i)) p[cbit_space  + i/8] |= 1 << (i&7);\n  if (isxdigit(i))p[cbit_xdigit + i/8] |= 1 << (i&7);\n  if (isgraph(i)) p[cbit_graph  + i/8] |= 1 << (i&7);\n  if (isprint(i)) p[cbit_print  + i/8] |= 1 << (i&7);\n  if (ispunct(i)) p[cbit_punct  + i/8] |= 1 << (i&7);\n  if (iscntrl(i)) p[cbit_cntrl  + i/8] |= 1 << (i&7);\n  }\np += cbit_length;\n\n/test_snippet Finally, the character type table. In this, we exclude VT from the white\nspace chars, because Perl doesn't recognize it as such for \\s and for comments\nwithin regexes. test_snippet/\n\nfor (i = 0; i < 256; i++)\n  {\n  int x = 0;\n  if (i != 0x0b && isspace(i)) x += ctype_space;\n  if (isalpha(i)) x += ctype_letter;\n  if (isdigit(i)) x += ctype_digit;\n  if (isxdigit(i)) x += ctype_xdigit;\n  if (isalnum(i) || i == '_') x += ctype_word;\n\n  /test_snippet Note: strchr includes the terminating zero in the characters it considers.\n  In this instance, that is ok because we want binary zero to be flagged as a\n  meta-character, which in this sense is any character that terminates a run\n  of data characters. test_snippet/\n\n  if (strchr(\"test_snippet+?{^.$|()[\", i) != 0) x += ctype_meta; test_snippetp++ = x; }\n\nreturn yield;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f335f4de8eea0540eb6e05c76fd966b1c4d0fa21_0", {
    "ID": "httpd_f335f4de8eea0540eb6e05c76fd966b1c4d0fa21_0",
    "UID": "1377",
    "code": "test_snippet\npcre_get_stringnumber(const pcre *code, const char *stringname)\n{\ntest_snippet rc;\ntest_snippet entrysize;\ntest_snippet top, bot;\nuschar *nametable;\n\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMECOUNT, &top)) != 0)\n  return rc;\nif (top <= 0) return PCRE_ERROR_NOSUBSTRING;\n\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMEENTRYSIZE, &entrysize)) != 0)\n  return rc;\nif ((rc = pcre_fullinfo(code, NULL, PCRE_INFO_NAMETABLE, &nametable)) != 0)\n  return rc;\n\nbot = 0;\nwhile (top > bot)\n  {\n  test_snippet mid = (top + bot) / 2;\n  uschar *entry = nametable + entrysize*mid;\n  test_snippet c = strcmp(stringname, (char *)(entry + 2));\n  if (c == 0) return (entry[0] << 8) + entry[1];\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn PCRE_ERROR_NOSUBSTRING;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n369,Divide By Zero"
  },
  "httpd_46a80a0819ab279b393d8e8e0171f520f3f27aec_0", {
    "ID": "httpd_46a80a0819ab279b393d8e8e0171f520f3f27aec_0",
    "UID": "1404",
    "code": "test_snippet\nregexec(const regex_t *preg, const char *string, size_t nmatch,\n  regmatch_t pmatch[], test_snippet eflags)\n{\ntest_snippet rc;\ntest_snippet options = 0;\ntest_snippet *ovector = NULL;\ntest_snippet small_ovector[POSIX_MALLOC_THRESHOLD * 3];\nBOOL allocated_ovector = FALSE;\n\nif ((eflags & REG_NOTBOL) != 0) options |= PCRE_NOTBOL;\nif ((eflags & REG_NOTEOL) != 0) options |= PCRE_NOTEOL;\n\n((regex_t *)preg)->re_erroffset = (size_t)(-1);  \n\nif (nmatch > 0)\n  {\n  if (nmatch <= POSIX_MALLOC_THRESHOLD)\n    {\n    ovector = &(small_ovector[0]);\n    }\n  else\n    {\n    ovector = (test_snippet *)malloc(sizeof(test_snippet) * nmatch * 3);\n    if (ovector == NULL) return REG_ESPACE;\n    allocated_ovector = TRUE;\n    }\n  }\n\nrc = pcre_exec((const pcre *)preg->re_pcre, NULL, string, (test_snippet)strlen(string),\n  0, options, ovector, nmatch * 3);\n\nif (rc == 0) rc = nmatch;    \n\nif (rc >= 0)\n  {\n  size_t i;\n  for (i = 0; i < (size_t)rc; i++)\n    {\n    pmatch[i].rm_so = ovector[i*2];\n    pmatch[i].rm_eo = ovector[i*2+1];\n    }\n  if (allocated_ovector) free(ovector);\n  for (; i < nmatch; i++) pmatch[i].rm_so = pmatch[i].rm_eo = -1;\n  return 0;\n  }\n\nelse\n  {\n  if (allocated_ovector) free(ovector);\n  switch(rc)\n    {\n    case PCRE_ERROR_NOMATCH: return REG_NOMATCH;\n    case PCRE_ERROR_NULL: return REG_INVARG;\n    case PCRE_ERROR_BADOPTION: return REG_INVARG;\n    case PCRE_ERROR_BADMAGIC: return REG_INVARG;\n    case PCRE_ERROR_UNKNOWN_NODE: return REG_ASSERT;\n    case PCRE_ERROR_NOMEMORY: return REG_ESPACE;\n    case PCRE_ERROR_MATCHLIMIT: return REG_ESPACE;\n    case PCRE_ERROR_BADUTF8: return REG_INVARG;\n    case PCRE_ERROR_BADUTF8_OFFSET: return REG_INVARG;\n    default: return REG_ASSERT;\n    }\n  }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a75e8836b981c96654188475c14c67e2ce7e7664_0", {
    "ID": "httpd_a75e8836b981c96654188475c14c67e2ce7e7664_0",
    "UID": "1425",
    "code": "static int cgi_handler(request_rec test_snippet\n{\n    int nph;\n    apr_size_t dbpos = 0;\n    const char *argv0;\n    const char *command;\n    const char **argv;\n    char *dbuf = NULL;\n    apr_file_t *script_out = NULL, *script_in = NULL, *script_err = NULL;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    int is_included;\n    int seen_eos, child_stopped_reading;\n    apr_pool_t *p;\n    cgi_server_conf *conf;\n    apr_status_t rv;\n    cgi_exec_info_t e_info;\n    conn_rec *c = r->connection;\n\n    if(strcmp(r->handler, CGI_MAGIC_TYPE) && strcmp(r->handler, \"cgi-script\"))\n        return DECLINED;\n\n    is_included = !strcmp(r->protocol, \"INCLUDED\");\n\n    p = r->main ? r->main->pool : r->pool;\n\n    if (r->method_number == M_OPTIONS) {\n        \n        r->allowed |= (AP_METHOD_BIT << M_GET);\n        r->allowed |= (AP_METHOD_BIT << M_POST);\n        return DECLINED;\n    }\n\n    argv0 = apr_filepath_name_get(r->filename);\n    nph = !(strncmp(argv0, \"nph-\", 4));\n    conf = ap_get_module_config(r->server->module_config, &cgi_module);\n\n    if (!(ap_allow_options(r) & OPT_EXECCGI) && !is_scriptaliased(r))\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,\n                               \"Options ExecCGI is off in this directory\");\n    if (nph && is_included)\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,\n                               \"attempt to include NPH CGI script\");\n\n    if (r->finfo.filetype == 0)\n        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,\n                               \"script not found or unable to stat\");\n    if (r->finfo.filetype == APR_DIR)\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,\n                               \"attempt to invoke directory as script\");\n\n    if ((r->used_path_info == AP_REQ_REJECT_PATH_INFO) &&\n        r->path_info && *r->path_info)\n    {\n        \n        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,\n                               \"AcceptPathInfo off disallows user's path\");\n    }\n/*\n    if (!ap_suexec_enabled) {\n        if (!ap_can_exec(&r->finfo))\n            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,\n                                   \"file permissions deny server execution\");\n    }\n\n*/\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    e_info.process_cgi = 1;\n    e_info.cmd_type    = APR_PROGRAM;\n    e_info.detached    = 0;\n    e_info.in_pipe     = APR_CHILD_BLOCK;\n    e_info.out_pipe    = APR_CHILD_BLOCK;\n    e_info.err_pipe    = APR_CHILD_BLOCK;\n    e_info.prog_type   = RUN_AS_CGI;\n    e_info.bb          = NULL;\n    e_info.ctx         = NULL;\n    e_info.next        = NULL;\n    e_info.addrspace   = 0;\n\n    \n    if ((rv = cgi_build_command(&command, &argv, r, p, &e_info)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                      \"don't know how to spawn child process: %s\", \n                      r->filename);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    \n    if ((rv = run_cgi_child(&script_out, &script_in, &script_err,\n                            command, argv, r, p, &e_info)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                      \"couldn't spawn child process: %s\", r->filename);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* Transfer any put/post args, CERN style...\n     * Note that we already ignore SIGPIPE in the core server.\n     */\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    seen_eos = 0;\n    child_stopped_reading = 0;\n    if (conf->logname) {\n        dbuf = apr_palloc(r->pool, conf->bufbytes + 1);\n        dbpos = 0;\n    }\n    do {\n        apr_bucket *bucket;\n\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, HUGE_STRING_LEN);\n       \n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        for (bucket = APR_BRIGADE_FIRST(bb);\n             bucket != APR_BRIGADE_SENTINEL(bb);\n             bucket = APR_BUCKET_NEXT(bucket))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bucket)) {\n                seen_eos = 1;\n                break;\n            }\n\n            \n            if (APR_BUCKET_IS_FLUSH(bucket)) {\n                continue;\n            }\n\n            \n            if (child_stopped_reading) {\n                continue;\n            } \n\n            \n            apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\n            \n            if (conf->logname && dbpos < conf->bufbytes) {\n                int cursize;\n\n                if ((dbpos + len) > conf->bufbytes) {\n                    cursize = conf->bufbytes - dbpos;\n                }\n                else {\n                    cursize = len;\n                }\n                memcpy(dbuf + dbpos, data, cursize);\n                dbpos += cursize;\n            }\n\n            /* Keep writing data to the child until done or too much time\n             * elapses with no progress or an error occurs.\n             */\n            rv = apr_file_write_full(script_out, data, len, NULL);\n\n            if (rv != APR_SUCCESS) {\n                \n                child_stopped_reading = 1;\n            }\n        }\n        apr_brigade_cleanup(bb);\n    }\n    while (!seen_eos);\n\n    if (conf->logname) {\n        dbuf[dbpos] = '\\0';\n    }\n    \n    apr_file_flush(script_out);\n    apr_file_close(script_out);\n\n    AP_DEBUG_ASSERT(script_in != NULL);\n\n    apr_brigade_cleanup(bb);\n\n#if APR_FILES_AS_SOCKETS\n    apr_file_pipe_timeout_set(script_in, 0);\n    apr_file_pipe_timeout_set(script_err, 0);\n    \n    b = cgi_bucket_create(r, script_in, script_err, c->bucket_alloc);\n#else\n    b = apr_bucket_pipe_create(script_in, c->bucket_alloc);\n#endif\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    \n    if (!nph) {\n        const char *location;\n        char sbuf[MAX_STRING_LEN];\n        int ret;\n\n        if ((ret = ap_scan_script_header_err_brigade(r, bb, sbuf))) {\n            return log_script(r, conf, ret, dbuf, sbuf, bb, script_err);\n        }\n\n        location = apr_table_get(r->headers_out, \"Location\");\n\n        if (location && r->status == 200) {\n            /* For a redirect whether internal or not, discard any\n             * remaining stdout from the script, and log any remaining\n             * stderr output, as normal. */\n            discard_script_output(bb);\n            apr_brigade_destroy(bb);\n            apr_file_pipe_timeout_set(script_err, r->server->timeout);\n            log_script_err(r, script_err);\n        }\n\n        if (location && location[0] == '/' && r->status == 200) {\n            /* This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            r->method = apr_pstrdup(r->pool, \"GET\");\n            r->method_number = M_GET;\n\n            /* We already read the message body (if any), so don't allow\n             * the redirected request to think it has one.  We can ignore \n             * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR.\n             */\n            apr_table_unset(r->headers_in, \"Content-Length\");\n\n            ap_internal_redirect_handler(location, r);\n            return OK;\n        }\n        else if (location && r->status == 200) {\n            /* XX Note that if a script wants to produce its own Redirect\n             * body, it now has to explicitly *say* \"Status: 302\"\n             */\n            return HTTP_MOVED_TEMPORARILY;\n        }\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n    }\n    else  {\n        struct ap_filter_t *cur;\n        \n        /* get rid of all filters up through protocol...  since we\n         * haven't parsed off the headers, there is no way they can\n         * work\n         */\n\n        cur = r->proto_output_filters;\n        while (cur && cur->frec->ftype < AP_FTYPE_CONNECTION) {\n            cur = cur->next;\n        }\n        r->output_filters = r->proto_output_filters = cur;\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n    }\n\n    /* don't soak up script output if errors occurred writing it\n     * out...  otherwise, we prolong the life of the script when the\n     * connection drops or we stopped sending output for some other\n     * reason */\n    if (rv == APR_SUCCESS && !r->connection->aborted) {\n        apr_file_pipe_timeout_set(script_err, r->server->timeout);\n        log_script_err(r, script_err);\n    }\n    \n    apr_file_close(script_err);\n\n    return OK;                      \n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_53e84a4ad5a44e4c0717f7a85ffe98cba94c4c4c_0", {
    "ID": "httpd_53e84a4ad5a44e4c0717f7a85ffe98cba94c4c4c_0",
    "UID": "1458",
    "code": "static test_snippet\nfind_fixedlength(uschar *code, test_snippet options)\n{\ntest_snippet length = -1;\n\nregister test_snippet branchlength = 0;\nregister uschar *cc = code + 1 + LINK_SIZE;\n\n/* Scan along the opcodes for this branch. If we get to the end of the\nbranch, check the length against that of the other branches. */\n\nfor (;;)\n  {\n  test_snippet d;\n  register test_snippet op = *cc;\n  if (op >= OP_BRA) op = OP_BRA;\n\n  switch (op)\n    {\n    case OP_BRA:\n    case OP_ONCE:\n    case OP_COND:\n    d = find_fixedlength(cc, options);\n    if (d < 0) return d;\n    branchlength += d;\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    /* Reached end of a branch; if it's a ket it is the end of a nested\n    call. If it's ALT it is an alternation in a nested call. If it is\n    END it's the end of the outer call. All can be handled by the same code. */\n\n    case OP_ALT:\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_END:\n    if (length < 0) length = branchlength;\n      else if (length != branchlength) return -1;\n    if (*cc != OP_ALT) return length;\n    cc += 1 + LINK_SIZE;\n    branchlength = 0;\n    break;\n\n    \n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    \n\n    \n\n    case OP_REVERSE:\n    case OP_BRANUMBER:\n    case OP_CREF:\n    case OP_OPT:\n    case OP_CALLOUT:\n    case OP_SOD:\n    case OP_SOM:\n    case OP_EOD:\n    case OP_EODN:\n    case OP_CIRC:\n    case OP_DOLL:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    cc += OP_lengths[*cc];\n    break;\n\n    \n\n    case OP_CHAR:\n    case OP_CHARNC:\n    branchlength++;\n    cc += 2;\n#ifdef SUPPORT_UTF8\n    if ((options & PCRE_UTF8) != 0)\n      {\n      while ((*cc & 0xc0) == 0x80) cc++;\n      }\n#endif\n    break;\n\n    /* Handle exact repetitions. The count is already in characters, but we\n    need to skip over a multibyte character in UTF8 mode.  */\n\n    case OP_EXACT:\n    branchlength += GET2(cc,1);\n    cc += 4;\n#ifdef SUPPORT_UTF8\n    if ((options & PCRE_UTF8) != 0)\n      {\n      while((*cc & 0x80) == 0x80) cc++;\n      }\n#endif\n    break;\n\n    case OP_TYPEEXACT:\n    branchlength += GET2(cc,1);\n    cc += 4;\n    break;\n\n    \n\n    case OP_PROP:\n    case OP_NOTPROP:\n    cc++;\n    \n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    branchlength++;\n    cc++;\n    break;\n\n    \n\n    case OP_ANYBYTE:\n    return -2;\n\n    \n\n#ifdef SUPPORT_UTF8\n    case OP_XCLASS:\n    cc += GET(cc, 1) - 33;\n    \n#endif\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    cc += 33;\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      return -1;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      if (GET2(cc,1) != GET2(cc,3)) return -1;\n      branchlength += GET2(cc,1);\n      cc += 5;\n      break;\n\n      default:\n      branchlength++;\n      }\n    break;\n\n    \n\n    default:\n    return -1;\n    }\n  }\n\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n457,Use of Uninitialized Variable\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition\n122,Heap-based Buffer Overflow\n121,Stack-based Buffer Overflow\n"
  },
  "httpd_b8af2d25f8faacaa181ebcfae0eeaa4a57589b7a_0", {
    "ID": "httpd_b8af2d25f8faacaa181ebcfae0eeaa4a57589b7a_0",
    "UID": "1465",
    "code": "static const uschar test_snippet\nfind_bracket(const uschar test_snippetcode, BOOL utf8, int number)\n{\n#ifndef SUPPORT_UTF8\nutf8 = utf8;               /test_snippet Stop pedantic compilers complaining test_snippet/\n#endif\n\nfor (;;)\n  {\n  register int c = test_snippetcode;\n  if (c == OP_END) return NULL;\n  else if (c > OP_BRA)\n    {\n    int n = c - OP_BRA;\n    if (n > EXTRACT_BASIC_MAX) n = GET2(code, 2+LINK_SIZE);\n    if (n == number) return (uschar test_snippet)code;\n    code += OP_lengths[OP_BRA];\n    }\n  else\n    {\n    code += OP_lengths[c];\n\n#ifdef SUPPORT_UTF8\n\n    /test_snippet In UTF-8 mode, opcodes that are followed by a character may be followed\n    by a multi-byte character. The length in the table is a minimum, so we have\n    to scan along to skip the extra bytes. All opcodes are less than 128, so we\n    can use relatively efficient code. test_snippet/\n\n    if (utf8) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARNC:\n      case OP_EXACT:\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      while ((test_snippetcode & 0xc0) == 0x80) code++;\n      break;\n\n      /test_snippet XCLASS is used for classes that cannot be represented just by a bit\n      map. This includes negated single high-valued characters. The length in\n      the table is zero; the actual length is stored in the compiled code. test_snippet/\n\n      case OP_XCLASS:\n      code += GET(code, 1) + 1;\n      break;\n      }\n#endif\n    }\n  }\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_4d1b7db5b9b45787f2afc95e94f6c12ed26d7b5f_0", {
    "ID": "httpd_4d1b7db5b9b45787f2afc95e94f6c12ed26d7b5f_0",
    "UID": "1467",
    "code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms test_snippet\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    const char *errmsg;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->pool, &limited_methods);\n        int methnum;\n\n        \n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resorce restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool, method);\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    cmd->limited = tog ? ~limited : limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = -1;\n\n    return errmsg;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_bb89e40bd0cfe867dd2122be0ec4d71fdd5f6457_0", {
    "ID": "httpd_bb89e40bd0cfe867dd2122be0ec4d71fdd5f6457_0",
    "UID": "1477",
    "code": "static const char *dirsection(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_conf_vector_t *new_dir_conf = ap_create_per_dir_config(cmd->pool);\n    regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    if (!arg) {\n        if (thiscmd->cmd_data)\n            return \"<DirectoryMatch > block must specify a path\";\n        else\n            return \"<Directory > block must specify a path\";\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        if (!cmd->path)\n            return \"<Directory ~ > block must specify a path\";\n        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (thiscmd->cmd_data) { \n        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (!strcmp(cmd->path, \"/\") == 0)\n    {\n        char *newpath;\n\n        /*\n         * Ensure that the pathname is canonical, and append the trailing /\n         */\n        apr_status_t rv = apr_filepath_merge(&newpath, NULL, cmd->path,\n                                             APR_FILEPATH_TRUENAME, cmd->pool);\n        if (rv != APR_SUCCESS && rv != APR_EPATHWILD) {\n            return apr_pstrcat(cmd->pool, \"<Directory \\\"\", cmd->path,\n                               \"\\\"> path is invalid.\", NULL);\n        }\n\n        cmd->path = newpath;\n        if (cmd->path[strlen(cmd->path) - 1] != '/')\n            cmd->path = apr_pstrcat(cmd->pool, cmd->path, \"/\", NULL);\n    }\n\n    \n    conf = ap_set_config_vectors(cmd->server, new_dir_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_dir_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->r = r;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = (apr_fnmatch_test(conf->d) != 0);\n\n    /* Make this explicit - the \"/\" root has 0 elements, that is, we\n     * will always merge it, and it will always sort and merge first.\n     * All others are sorted and tested by the number of slashes.\n     */\n    if (strcmp(conf->d, \"/\") == 0)\n        conf->d_components = 0;\n    else\n        conf->d_components = ap_count_dirs(conf->d);\n\n    ap_add_per_dir_conf(cmd->server, new_dir_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n427,Uncontrolled Search Path Element\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_826f9b52aafd813646ef8b126178bd4422e54b08_0", {
    "ID": "httpd_826f9b52aafd813646ef8b126178bd4422e54b08_0",
    "UID": "1481",
    "code": "static test_snippet\ncould_be_empty_branch(const uschar *code, const uschar *endcode, test_snippet utf8)\n{\nregister int c;\nfor (code = first_significant_code(code + 1 + LINK_SIZE, NULL, 0, TRUE);\n     code < endcode;\n     code = first_significant_code(code + OP_lengths[c], NULL, 0, TRUE))\n  {\n  const uschar *ccode;\n\n  c = *code;\n\n  if (c >= OP_BRA)\n    {\n    test_snippet empty_branch;\n    if (GET(code, 1) == 0) return TRUE;    \n\n    \n\n    empty_branch = FALSE;\n    do\n      {\n      if (!empty_branch && could_be_empty_branch(code, endcode, utf8))\n        empty_branch = TRUE;\n      code += GET(code, 1);\n      }\n    while (*code == OP_ALT);\n    if (!empty_branch) return FALSE;   \n    code += 1 + LINK_SIZE;\n    c = *code;\n    }\n\n  else switch (c)\n    {\n    \n\n#ifdef SUPPORT_UTF8\n    case OP_XCLASS:\n    ccode = code + GET(code, 1);\n    goto CHECK_CLASS_REPEAT;\n#endif\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    ccode = code + 33;\n\n#ifdef SUPPORT_UTF8\n    CHECK_CLASS_REPEAT:\n#endif\n\n    switch (*ccode)\n      {\n      case OP_CRSTAR:            \n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      break;\n\n      default:                   \n      case OP_CRPLUS:            \n      case OP_CRMINPLUS:\n      return FALSE;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      if (GET2(ccode, 1) > 0) return FALSE;  \n      break;\n      }\n    break;\n\n    \n\n    case OP_PROP:\n    case OP_NOTPROP:\n    case OP_EXTUNI:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ANYBYTE:\n    case OP_CHAR:\n    case OP_CHARNC:\n    case OP_NOT:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_EXACT:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTEXACT:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEEXACT:\n    return FALSE;\n\n    \n\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_ALT:\n    return TRUE;\n\n    /* In UTF-8 mode, STAR, MINSTAR, QUERY, MINQUERY, UPTO, and MINUPTO  may be\n    followed by a multibyte character */\n\n#ifdef SUPPORT_UTF8\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    if (utf8) while ((code[2] & 0xc0) == 0x80) code++;\n    break;\n#endif\n    }\n  }\n\nreturn TRUE;\n}",
    "predicted": "476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_262b738415804d69d93ae94c386626c208a672d6_0", {
    "ID": "httpd_262b738415804d69d93ae94c386626c208a672d6_0",
    "UID": "1490",
    "code": "static test_snippet\ncheck_posix_name(const uschar *ptr, test_snippet len)\n{\nregister test_snippet yield = 0;\nwhile (posix_name_lengths[yield] != 0)\n  {\n  if (len == posix_name_lengths[yield] &&\n    strncmp((const char *)ptr, posix_names[yield], len) == 0) return yield;\n  yield++;\n  }\nreturn -1;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_60f756d692d57983b27dcff36568aeed9b3870e9_0", {
    "ID": "httpd_60f756d692d57983b27dcff36568aeed9b3870e9_0",
    "UID": "1501",
    "code": "static test_snippet\nadjust_recurse(uschar *group, int adjust, BOOL utf8, compile_data *cd)\n{\nuschar *ptr = group;\nwhile ((ptr = (uschar *)find_recurse(ptr, utf8)) != NULL)\n  {\n  int offset = GET(ptr, 1);\n  if (cd->start_code + offset >= group) PUT(ptr, 1, offset + adjust);\n  ptr += 1 + LINK_SIZE;\n  }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_338d974035ad757ec6b1c0f6e3190046214b5494_0", {
    "ID": "httpd_338d974035ad757ec6b1c0f6e3190046214b5494_0",
    "UID": "1502",
    "code": "static const char *start_ifmod(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    int not = (arg[0] == '!');\n    module *found;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (not) {\n        arg++;\n    }\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    found = ap_find_linked_module(arg);\n\n    \n    if (!found) {\n        ap_module_symbol_t *current = ap_prelinked_module_symbols;\n\n        for (; current->name; ++current) {\n            if (!strcmp(current->name, arg)) {\n                found = current->modp;\n                break;\n            }\n        }\n    }\n\n    \n    if (!found) {\n        APR_OPTIONAL_FN_TYPE(ap_find_loaded_module_symbol) *check_symbol =\n            APR_RETRIEVE_OPTIONAL_FN(ap_find_loaded_module_symbol);\n\n        if (check_symbol) {\n            found = check_symbol(cmd->server, arg);\n        }\n    }\n\n    if ((!not && found) || (not && !found)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, \"<IfModule\");\n        *(ap_directive_t **)mconfig = current;\n        return retval;\n    }\n    else {\n        *(ap_directive_t **)mconfig = NULL;\n        return ap_soak_end_container(cmd, \"<IfModule\");\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_51ba085a26802030d85b923071ff0794fe6edf78_0", {
    "ID": "httpd_51ba085a26802030d85b923071ff0794fe6edf78_0",
    "UID": "1531",
    "code": "static const test_snippet\nfirst_significant_code(const uschar *code, int *options, int optbit,\n  BOOL skipassert)\n{\nfor (;;)\n  {\n  switch ((int)*code)\n    {\n    case OP_OPT:\n    if (optbit > 0 && ((int)code[1] & optbit) != (*options & optbit))\n      *options = (int)code[1];\n    code += 2;\n    break;\n\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    if (!skipassert) return code;\n    do code += GET(code, 1); while (*code == OP_ALT);\n    code += OP_lengths[*code];\n    break;\n\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_WORD_BOUNDARY:\n    if (!skipassert) return code;\n    \n\n    case OP_CALLOUT:\n    case OP_CREF:\n    case OP_BRANUMBER:\n    code += OP_lengths[*code];\n    break;\n\n    default:\n    return code;\n    }\n  }\n\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_2bfba66fb87ed64dc629d7b5c748ec98ff56d490_0", {
    "ID": "httpd_2bfba66fb87ed64dc629d7b5c748ec98ff56d490_0",
    "UID": "1587",
    "code": "static void walk_merge_provider_list(apr_pool_t *a, authz_core_dir_conf *conf, authz_provider_list test_snippet\n{\n    authz_provider_list *newp = (authz_provider_list *)apr_palloc(a, sizeof(authz_provider_list));\n    memcpy(newp, providers, sizeof(authz_provider_list));\n\n    /* Since the merge is being done at a later time rather than\n        at configuration time, we need to fake the current\n        state of the list so that the new element get merged\n        into the correct location. The current state is \n        derived from the state of the object to be merged. */\n    conf->req_state = newp->req_state;\n    conf->req_state_level = newp->req_state_level;\n    newp->one_next = NULL;\n    newp->all_next = NULL;\n\n    /* If the merging element is a reject then merge it into \n        the reject list.  Otherwise merge it into the existing\n        provider logic. */\n    if (newp->is_reject) {\n        merge_authz_reject (conf, newp);\n    }\n    else {\n        merge_authz_provider(conf, newp);\n    }\n\n    /* Walk all of the elements recursively to allow each existing\n        element to be copied and merged into the final configuration.*/\n    if (providers->all_next) {\n        walk_merge_provider_list (a, conf, providers->all_next);\n    }\n    if (providers->one_next) {\n        walk_merge_provider_list (a, conf, providers->one_next);\n    }\n\n    return;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_90b12ae2baeebc0cc19151a0ddf7f7b1b2818779_0", {
    "ID": "httpd_90b12ae2baeebc0cc19151a0ddf7f7b1b2818779_0",
    "UID": "1620",
    "code": "static void fake_basic_authentication(request_rec *r, auth_form_config_rec test_snippet\n                                      const char *user, const char *pw)\n{\n    if (conf->fakebasicauth) {\n        char *basic = apr_pstrcat(r->pool, user, \":\", pw, NULL);\n        apr_size_t size = (apr_size_t) strlen(basic);\n        char *base64 = apr_palloc(r->pool,\n                                  apr_base64_encode_len(size + 1) * sizeof(char));\n        apr_base64_encode(base64, basic, size);\n        apr_table_set(r->headers_in, \"Authorization\",\n                      apr_pstrcat(r->pool, \"Basic \", base64, NULL));\n    }\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n526,Cleartext Storage of Sensitive Information in an Environment Variable"
  },
  "httpd_983a4ad5997709dda318fdcaa61207282ecfe8cd_0", {
    "ID": "httpd_983a4ad5997709dda318fdcaa61207282ecfe8cd_0",
    "UID": "1628",
    "code": "static apr_status_t unixd_set_shm_perms(const char test_snippet\n{\n#ifdef AP_NEED_SET_MUTEX_PERMS\n#if APR_USE_SHMEM_SHMGET || APR_USE_SHMEM_SHMGET_ANON\n    struct shmid_ds shmbuf = { { 0 } };\n    key_t shmkey;\n    int shmid;\n\n    shmkey = ftok(fname, 1);\n    if (shmkey == (key_t)-1) {\n        return errno;\n    }\n    if ((shmid = shmget(shmkey, 0, SHM_R | SHM_W)) == -1) {\n        return errno;\n    }\n#if MODULE_MAGIC_NUMBER_MAJOR <= 20081212\n#define ap_unixd_config unixd_config\n#endif\n    shmbuf.shm_perm.uid  = ap_unixd_config.user_id;\n    shmbuf.shm_perm.gid  = ap_unixd_config.group_id;\n    shmbuf.shm_perm.mode = 0600;\n    if (shmctl(shmid, IPC_SET, &shmbuf) == -1) {\n        return errno;\n    }\n    return APR_SUCCESS;\n#else\n    return APR_ENOTIMPL;\n#endif\n#else\n    return APR_ENOTIMPL;\n#endif\n}",
    "predicted": "272,Least Privilege Violation"
  },
  "httpd_6afb82acb4a979be670454c7ea2c853c6b63dcde_0", {
    "ID": "httpd_6afb82acb4a979be670454c7ea2c853c6b63dcde_0",
    "UID": "1629",
    "code": "AP_DECLARE(int) ap_rxplus_exec(apr_pool_t *pool, ap_rxplus_t test_snippet\n                               const char *pattern, char **newpattern)\n{\n    int ret = 1;\n    int startl, oldl, newl, diffsz;\n    const char *remainder;\n    char *subs;\n\n    if (ap_regexec(&rx->rx, pattern, rx->nmatch, rx->pmatch, rx->flags) != 0) {\n        rx->match = NULL;\n        return 0; \n    }\n    rx->match = pattern;\n    if (rx->subs) {\n        *newpattern = ap_pregsub(pool, rx->subs, pattern,\n                                 rx->nmatch, rx->pmatch);\n        if (!*newpattern) {\n            return 0; \n        }\n        startl = rx->pmatch[0].rm_so;\n        oldl = rx->pmatch[0].rm_eo - startl;\n        newl = strlen(*newpattern);\n        diffsz = newl - oldl;\n        remainder = pattern + startl + oldl;\n        if (rx->flags & AP_REG_MULTI) {\n            \n            ret += ap_rxplus_exec(pool, rx, remainder, &subs);\n            if (ret > 1) {\n                \n                diffsz += strlen(subs) - strlen(remainder);\n                remainder = subs;\n            }\n        }\n        subs  = apr_palloc(pool, strlen(pattern) + 1 + diffsz);\n        memcpy(subs, pattern, startl);\n        memcpy(subs+startl, *newpattern, newl);\n        strcpy(subs+startl+newl, remainder);\n        *newpattern = subs;\n    }\n    return ret;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a94c217093bf71057f2bde3bd82cfe0a30726a41_0", {
    "ID": "httpd_a94c217093bf71057f2bde3bd82cfe0a30726a41_0",
    "UID": "1630",
    "code": "PROXY_DECLARE(char *)ap_proxy_canonenc(apr_pool_t *p, const char *x, int test_snippet\n                                       enum enctype t, int forcedec,\n                                       int proxyreq)\n{\n    int i, j, ch;\n    char *y;\n    char *allowed;  \n    char *reserved; \n\n/*\n * N.B. in addition to :@&=, this allows ';' in an http path\n * and '?' in an ftp path -- this may be revised\n *\n * Also, it makes a '+' character in a search string reserved, as\n * it may be form-encoded. (Although RFC 1738 doesn't allow this -\n * it only permits ; / ? : @ = & as reserved chars.)\n */\n    if (t == enc_path) {\n        allowed = \"~$-_.+!*'(),;:@&=\";\n    }\n    else if (t == enc_search) {\n        allowed = \"$-_.!*'(),;:@&=\";\n    }\n    else if (t == enc_user) {\n        allowed = \"$-_.+!*'(),;@&=\";\n    }\n    else if (t == enc_fpath) {\n        allowed = \"$-_.+!*'(),?:@&=\";\n    }\n    else {            \n        allowed = \"$-_.+!*'(),?/:@&=\";\n    }\n\n    if (t == enc_path) {\n        reserved = \"/\";\n    }\n    else if (t == enc_search) {\n        reserved = \"+\";\n    }\n    else {\n        reserved = \"\";\n    }\n\n    y = apr_palloc(p, 3 * len + 1);\n\n    for (i = 0, j = 0; i < len; i++, j++) {\n\n        ch = x[i];\n        if (strchr(reserved, ch)) {\n            y[j] = ch;\n            continue;\n        }\n/*\n * decode it if not already done. do not decode reverse proxied URLs\n * unless specifically forced\n */\n        if ((forcedec || (proxyreq && proxyreq != PROXYREQ_REVERSE)) && ch == '%') {\n            if (!apr_isxdigit(x[i + 1]) || !apr_isxdigit(x[i + 2])) {\n                return NULL;\n            }\n            ch = ap_proxy_hex2c(&x[i + 1]);\n            i += 2;\n            if (ch != 0 && strchr(reserved, ch)) {  \n                ap_proxy_c2hex(ch, &y[j]);\n                j += 2;\n                continue;\n            }\n        }\n\n        if (!apr_isalnum(ch) && !strchr(allowed, ch)) {\n            ap_proxy_c2hex(ch, &y[j]);\n            j += 2;\n        }\n        else {\n            y[j] = ch;\n        }\n    }\n    y[j] = '\\0';\n    return y;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_3dff81c8f2de56a588942005a3763ae131fbc6b5_0", {
    "ID": "httpd_3dff81c8f2de56a588942005a3763ae131fbc6b5_0",
    "UID": "1635",
    "code": "static int ap_proxy_wstunnel_request(apr_pool_t *p, request_rec test_snippet\n                                proxy_conn_rec *conn,\n                                proxy_worker *worker,\n                                proxy_server_conf *conf,\n                                apr_uri_t *uri,\n                                char *url, char *server_portstr)\n{\n    apr_status_t rv = APR_SUCCESS;\n    apr_pollset_t *pollset;\n    apr_pollfd_t pollfd;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    conn_rec *c = r->connection;\n    apr_socket_t *sock = conn->sock;\n    conn_rec *backconn = conn->connection;\n    int client_error = 0;\n    char *buf;\n    apr_bucket_brigade *header_brigade;\n    apr_bucket *e;\n    char *old_cl_val = NULL;\n    char *old_te_val = NULL;\n    apr_bucket_brigade *bb = apr_brigade_create(p, c->bucket_alloc);\n    apr_socket_t *client_socket = ap_get_conn_socket(c);\n\n    header_brigade = apr_brigade_create(p, backconn->bucket_alloc);\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"sending request\");\n\n    rv = ap_proxy_create_hdrbrgd(p, header_brigade, r, conn,\n                                 worker, conf, uri, url, server_portstr,\n                                 &old_cl_val, &old_te_val);\n    if (rv != OK) {\n        return rv;\n    }\n\n    buf = apr_pstrcat(p, \"Upgrade: WebSocket\", CRLF, \"Connection: Upgrade\", CRLF, CRLF, NULL);\n    ap_xlate_proto_to_ascii(buf, strlen(buf));\n    e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n\n    if ((rv = ap_proxy_pass_brigade(c->bucket_alloc, r, conn, backconn,\n                                    header_brigade, 1)) != OK)\n        return rv;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"setting up poll()\");\n\n    if ((rv = apr_pollset_create(&pollset, 2, p, 0)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02443)\n                      \"error apr_pollset_create()\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n#if 0\n    apr_socket_opt_set(sock, APR_SO_NONBLOCK, 1);\n    apr_socket_opt_set(sock, APR_SO_KEEPALIVE, 1);\n    apr_socket_opt_set(client_socket, APR_SO_NONBLOCK, 1);\n    apr_socket_opt_set(client_socket, APR_SO_KEEPALIVE, 1);\n#endif\n\n    pollfd.p = p;\n    pollfd.desc_type = APR_POLL_SOCKET;\n    pollfd.reqevents = APR_POLLIN;\n    pollfd.desc.s = sock;\n    pollfd.client_data = NULL;\n    apr_pollset_add(pollset, &pollfd);\n\n    pollfd.desc.s = client_socket;\n    apr_pollset_add(pollset, &pollfd);\n\n\n    r->output_filters = c->output_filters;\n    r->proto_output_filters = c->output_filters;\n    r->input_filters = c->input_filters;\n    r->proto_input_filters = c->input_filters;\n\n    remove_reqtimeout(r->input_filters);\n\n    while (1) { \n        if ((rv = apr_pollset_poll(pollset, -1, &pollcnt, &signalled))\n            != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) \"error apr_poll()\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02445)\n                      \"woke from poll(), i=%d\", pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) {\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02446)\n                                  \"sock was readable\");\n                    rv = proxy_wstunnel_transfer(r, backconn, c, bb, \"sock\");\n                    }\n                else if ((pollevent & APR_POLLERR)\n                         || (pollevent & APR_POLLHUP)) {\n                         rv = APR_EPIPE;\n                         ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447)\n                                       \"err/hup on backconn\");\n                }\n                if (rv != APR_SUCCESS)\n                    client_error = 1;\n            }\n            else if (cur->desc.s == client_socket) {\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02448)\n                                  \"client was readable\");\n                    rv = proxy_wstunnel_transfer(r, c, backconn, bb, \"client\");\n                }\n            }\n            else {\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449)\n                              \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  \"finished with poll() - cleaning up\");\n\n    if (client_error) {\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    return OK;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_89b827bab8ff8b1fe46a7c5fd3a94291c29f942e_0", {
    "ID": "httpd_89b827bab8ff8b1fe46a7c5fd3a94291c29f942e_0",
    "UID": "1636",
    "code": "static ap_filter_rec_t *get_filter_handle(const char test_snippet\n                                          const filter_trie_node *filter_set)\n{\n    if (filter_set) {\n        const char *n;\n        const filter_trie_node *node;\n\n        node = filter_set;\n        for (n = name; *n; n++) {\n            int start, end;\n            start = 0;\n            end = node->nchildren - 1;\n            while (end >= start) {\n                int middle = (end + start) / 2;\n                char ch = node->children[middle].c;\n                if (*n == ch) {\n                    node = node->children[middle].child;\n                    break;\n                }\n                else if (*n < ch) {\n                    end = middle - 1;\n                }\n                else {\n                    start = middle + 1;\n                }\n            }\n            if (end < start) {\n                node = NULL;\n                break;\n            }\n        }\n\n        if (node && node->frec) {\n            return node->frec;\n        }\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_64ca5b2e8019b3b44387eed057a4fcaf20dce903_0", {
    "ID": "httpd_64ca5b2e8019b3b44387eed057a4fcaf20dce903_0",
    "UID": "1637",
    "code": "void ap_expr_yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t test_snippet\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_7ccdd5c884fc501c32ba43a3c6c1666fb0c90391_0", {
    "ID": "httpd_7ccdd5c884fc501c32ba43a3c6c1666fb0c90391_0",
    "UID": "1638",
    "code": "static float atoq(const char test_snippet\n{\n    if (!string || !test_snippet {\n        return  1.0f;\n    }\n\n    while (apr_isspace(test_snippet) {\n        ++string;\n    }\n\n    /* be tolerant and accept qvalues without leading zero\n     * (also for backwards compat, where atof() was in use)\n     */\n    if (*string != '.' && *string++ != '0') {\n        return 1.0f;\n    }\n\n    if (*string == '.') {\n        /* better only one division later, than dealing with fscking\n         * IEEE format 0.1 factors ...\n         */\n        int i = 0;\n\n        if (*++string >= '0' && *string <= '9') {\n            i += (*string - '0') * 100;\n\n            if (*++string >= '0' && *string <= '9') {\n                i += (*string - '0') * 10;\n\n                if (*++string > '0' && *string <= '9') {\n                    i += (*string - '0');\n                }\n            }\n        }\n\n        return (float)i / 1000.0f;\n    }\n\n    return 0.0f;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable"
  },
  "httpd_604444a8a35a90bd9f5038c857bb1638db55c21e_0", {
    "ID": "httpd_604444a8a35a90bd9f5038c857bb1638db55c21e_0",
    "UID": "1639",
    "code": "AP_DECLARE(apr_status_t) ap_recent_ctime_ex(char *date_str, apr_time_t test_snippet\n                                            int option, int *len)\n{\n    /* ### This code is a clone of apr_ctime(), except that it\n     * uses ap_explode_recent_localtime() instead of apr_time_exp_lt().\n     */\n    apr_time_exp_t xt;\n    const char *s;\n    int real_year;\n    int needed;\n\n\n    \n    if (option & AP_CTIME_OPTION_COMPACT)\n        needed = AP_CTIME_COMPACT_LEN;\n    else\n        needed = APR_CTIME_LEN;\n\n    if (option & AP_CTIME_OPTION_USEC) {\n        needed += AP_CTIME_USEC_LENGTH;\n    }\n\n    \n    if (len && *len >= needed) {\n        *len = needed;\n    }\n    else {\n        if (len != NULL) {\n            *len = 0;\n        }\n        return APR_ENOMEM;\n    }\n\n    \n    \n    \n    \n\n    ap_explode_recent_localtime(&xtest_snippet t);\n    real_year = 1900 + xt.tm_year;\n    if (option & AP_CTIME_OPTION_COMPACT) {\n        int real_month = xt.tm_mon + 1;\n        *date_str++ = real_year / 1000 + '0';\n        *date_str++ = real_year % 1000 / 100 + '0';\n        *date_str++ = real_year % 100 / 10 + '0';\n        *date_str++ = real_year % 10 + '0';\n        *date_str++ = '-';\n        *date_str++ = real_month / 10 + '0';\n        *date_str++ = real_month % 10 + '0';\n        *date_str++ = '-';\n    }\n    else {\n        s = &apr_day_snames[xt.tm_wday][0];\n        *date_str++ = *s++;\n        *date_str++ = *s++;\n        *date_str++ = *s++;\n        *date_str++ = ' ';\n        s = &apr_month_snames[xt.tm_mon][0];\n        *date_str++ = *s++;\n        *date_str++ = *s++;\n        *date_str++ = *s++;\n        *date_str++ = ' ';\n    }\n    *date_str++ = xt.tm_mday / 10 + '0';\n    *date_str++ = xt.tm_mday % 10 + '0';\n    *date_str++ = ' ';\n    *date_str++ = xt.tm_hour / 10 + '0';\n    *date_str++ = xt.tm_hour % 10 + '0';\n    *date_str++ = ':';\n    *date_str++ = xt.tm_min / 10 + '0';\n    *date_str++ = xt.tm_min % 10 + '0';\n    *date_str++ = ':';\n    *date_str++ = xt.tm_sec / 10 + '0';\n    *date_str++ = xt.tm_sec % 10 + '0';\n    if (option & AP_CTIME_OPTION_USEC) {\n        int div;\n        int usec = (int)xt.tm_usec;\n        *date_str++ = '.';\n        for (div=100000; div>0; div=div/10) {\n            *date_str++ = usec / div + '0';\n            usec = usec % div;\n        }\n    }\n    if (!(option & AP_CTIME_OPTION_COMPACT)) {\n        *date_str++ = ' ';\n        *date_str++ = real_year / 1000 + '0';\n        *date_str++ = real_year % 1000 / 100 + '0';\n        *date_str++ = real_year % 100 / 10 + '0';\n        *date_str++ = real_year % 10 + '0';\n    }\n    *date_str++ = 0;\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_fd47f105ad04c064ef816179846adf19448d227d_0", {
    "ID": "httpd_fd47f105ad04c064ef816179846adf19448d227d_0",
    "UID": "1640",
    "code": "static int file_cache_recall_mydata(apr_file_t *fd, cache_info test_snippet\n                                    disk_cache_object_t *dobj, request_rec *r)\n{\n    apr_status_t rv;\n    char *urlbuff;\n    apr_size_t len;\n\n    \n    len = sizeof(disk_cache_info_t);\n    rv = apr_file_read_full(fd, &dobj->disk_info, len, &len);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \n    info->status = dobj->disk_info.status;\n    info->date = dobj->disk_info.date;\n    info->expire = dobj->disk_info.expire;\n    info->request_time = dobj->disk_info.request_time;\n    info->response_time = dobj->disk_info.response_time;\n\n    memcpy(&info->control, &dobj->disk_info.control, sizeof(cache_control_t));\n\n    /* Note that we could optimize this by conditionally doing the palloc\n     * depending upon the size. */\n    urlbuff = apr_palloc(r->pool, dobj->disk_info.name_len + 1);\n    len = dobj->disk_info.name_len;\n    rv = apr_file_read_full(fd, urlbuff, len, &len);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    urlbuff[dobj->disk_info.name_len] = '\\0';\n\n    \n    \n    if (strcmp(urlbuff, dobj->name) != 0) {\n        return APR_EGENERAL;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2da1820a3592ec9d7b335e5846ada70900ca6e59_0", {
    "ID": "httpd_2da1820a3592ec9d7b335e5846ada70900ca6e59_0",
    "UID": "1643",
    "code": "static const char *get_entry(apr_pool_t *p, accept_rec test_snippet\n                             const char *accept_line)\n{\n    result->quality = 1.0f;\n    result->level = 0.0f;\n    result->charset = \"\";\n\n    /*\n     * Note that this handles what I gather is the \"old format\",\n     *\n     *    Accept: text/html text/plain moo/zot\n     *\n     * without any compatibility kludges --- if the token after the\n     * MIME type begins with a semicolon, we know we're looking at parms,\n     * otherwise, we know we aren't.  (So why all the pissing and moaning\n     * in the CERN server code?  I must be missing something).\n     */\n\n    result->name = ap_get_token(p, &accept_line, 0);\n    ap_str_tolower(result->name);     /* You want case insensitive,\n                                       * you'll *get* case insensitive.\n                                       */\n\n    /* KLUDGE!!! Default HTML to level 2.0 unless the browser\n     * *explicitly* says something else.\n     */\n\n    if (!strcmp(result->name, \"text/html\") && (result->level == 0.0)) {\n        result->level = 2.0f;\n    }\n    else if (!strcmp(result->name, INCLUDES_MAGIC_TYPE)) {\n        result->level = 2.0f;\n    }\n    else if (!strcmp(result->name, INCLUDES_MAGIC_TYPE3)) {\n        result->level = 3.0f;\n    }\n\n    while (*accept_line == ';') {\n        \n\n        char *parm;\n        char *cp;\n        char *end;\n\n        ++accept_line;\n        parm = ap_get_token(p, &accept_line, 1);\n\n        \n\n        for (cp = parm; (*cp && !apr_isspace(*cp) && *cp != '='); ++cp) {\n            *cp = apr_tolower(*cp);\n        }\n\n        if (!*cp) {\n            continue;           \n        }\n\n        *cp++ = '\\0';           \n        while (apr_isspace(*cp) || *cp == '=') {\n            ++cp;\n        }\n\n        if (*cp == '\"') {\n            ++cp;\n            for (end = cp;\n                 (*end && *end != '\\n' && *end != '\\r' && *end != '\\\"');\n                 end++);\n        }\n        else {\n            for (end = cp; (*end && !apr_isspace(*end)); end++);\n        }\n        if (*end) {\n            *end = '\\0';        \n        }\n        ap_str_tolower(cp);\n\n        if (parm[0] == 'q'\n            && (parm[1] == '\\0' || (parm[1] == 's' && parm[2] == '\\0'))) {\n            result->quality = atoq(cp);\n        }\n        else if (parm[0] == 'l' && !strcmp(&parm[1], \"evel\")) {\n            result->level = (float)atoi(cp);\n        }\n        else if (!strcmp(parm, \"charset\")) {\n            result->charset = cp;\n        }\n    }\n\n    if (*accept_line == ',') {\n        ++accept_line;\n    }\n\n    return accept_line;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_13f38db83f1e67a2c3c4da2c9f4eebe83f074288_0", {
    "ID": "httpd_13f38db83f1e67a2c3c4da2c9f4eebe83f074288_0",
    "UID": "1645",
    "code": "AP_DECLARE(int) ap_scan_script_header_err_core_ex(request_rec *r, char test_snippet\n                                       int (*getsfunc) (char *, int, void *),\n                                       void *getsfunc_data,\n                                       int module_index)\n{\n    char x[MAX_STRING_LEN];\n    char *w, *l;\n    int p;\n    int cgi_status = HTTP_UNSET;\n    apr_table_t *merge;\n    apr_table_t *cookie_table;\n    int trace_log = APLOG_R_MODULE_IS_LEVEL(r, module_index, APLOG_TRACE1);\n    int first_header = 1;\n\n    if (buffer) {\n        *buffer = '\\0';\n    }\n    w = buffer ? buffer : x;\n\n    \n    merge = apr_table_make(r->pool, 10);\n\n    /* The HTTP specification says that it is legal to merge duplicate\n     * headers into one.  Some browsers that support Cookies don't like\n     * merged headers and prefer that each Set-Cookie header is sent\n     * separately.  Lets humour those browsers by not merging.\n     * Oh what a pain it is.\n     */\n    cookie_table = apr_table_make(r->pool, 2);\n    apr_table_do(set_cookie_doo_doo, cookie_table, r->err_headers_out, \"Set-Cookie\", NULL);\n\n    while (1) {\n\n        int rv = (*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data);\n        if (rv == 0) {\n            const char *msg = \"Premature end of script headers\";\n            if (first_header)\n                msg = \"End of script output before headers\";\n            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                          \"%s: %s\", msg,\n                          apr_filepath_name_get(r->filename));\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        else if (rv == -1) {\n            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                          \"Script timed out before returning headers: %s\",\n                          apr_filepath_name_get(r->filename));\n            return HTTP_GATEWAY_TIME_OUT;\n        }\n\n        \n\n        p = strlen(w);\n             /* Indeed, the host's '\\n':\n                '\\012' for UNIX; '\\015' for MacOS; '\\025' for OS/390\n                 -- whatever the script generates.\n             */\n        if (p > 0 && w[p - 1] == '\\n') {\n            if (p > 1 && w[p - 2] == CR) {\n                w[p - 2] = '\\0';\n            }\n            else {\n                w[p - 1] = '\\0';\n            }\n        }\n\n        /*\n         * If we've finished reading the headers, check to make sure any\n         * HTTP/1.1 conditions are met.  If so, we're done; normal processing\n         * will handle the script's output.  If not, just return the error.\n         * The appropriate thing to do would be to send the script process a\n         * SIGPIPE to let it know we're ignoring it, close the channel to the\n         * script process, and *then* return the failed-to-meet-condition\n         * error.  Otherwise we'd be waiting for the script to finish\n         * blithering before telling the client the output was no good.\n         * However, we don't have the information to do that, so we have to\n         * leave it to an upper layer.\n         */\n        if (w[0] == '\\0') {\n            int cond_status = OK;\n\n            /* PR#38070: This fails because it gets confused when a\n             * CGI Status header overrides ap_meets_conditions.\n             *\n             * We can fix that by dropping ap_meets_conditions when\n             * Status has been set.  Since this is the only place\n             * cgi_status gets used, let's test it explicitly.\n             *\n             * The alternative would be to ignore CGI Status when\n             * ap_meets_conditions returns anything interesting.\n             * That would be safer wrt HTTP, but would break CGI.\n             */\n            if ((cgi_status == HTTP_UNSET) && (r->method_number == M_GET)) {\n                cond_status = ap_meets_conditions(r);\n            }\n            apr_table_overlap(r->err_headers_out, merge,\n                APR_OVERLAP_TABLES_MERGE);\n            if (!apr_is_empty_table(cookie_table)) {\n                \n                apr_table_unset(r->err_headers_out, \"Set-Cookie\");\n                r->err_headers_out = apr_table_overlay(r->pool,\n                    r->err_headers_out, cookie_table);\n            }\n            return cond_status;\n        }\n\n        if (trace_log) {\n            if (first_header)\n                ap_log_rerror(SCRIPT_LOG_MARK, APLOG_TRACE4, 0, r,\n                              \"Headers from script '%s':\",\n                              apr_filepath_name_get(r->filename));\n            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_TRACE4, 0, r, \"  %s\", w);\n        }\n\n        \n\n#if APR_CHARSET_EBCDIC\n            /* Chances are that we received an ASCII header text instead of\n             * the expected EBCDIC header lines. Try to auto-detect:\n             */\n        if (!(l = strchr(w, ':'))) {\n            int maybeASCII = 0, maybeEBCDIC = 0;\n            unsigned char *cp, native;\n            apr_size_t inbytes_left, outbytes_left;\n\n            for (cp = w; *cp != '\\0'; ++cp) {\n                native = apr_xlate_conv_byte(ap_hdrs_from_ascii, *cp);\n                if (apr_isprint(*cp) && !apr_isprint(native))\n                    ++maybeEBCDIC;\n                if (!apr_isprint(*cp) && apr_isprint(native))\n                    ++maybeASCII;\n            }\n            if (maybeASCII > maybeEBCDIC) {\n                ap_log_error(SCRIPT_LOG_MARK, APLOG_ERR, 0, r->server,\n                             \"CGI Interface Error: Script headers apparently ASCII: (CGI = %s)\",\n                             r->filename);\n                inbytes_left = outbytes_left = cp - w;\n                apr_xlate_conv_buffer(ap_hdrs_from_ascii,\n                                      w, &inbytes_left, w, &outbytes_left);\n            }\n        }\n#endif \n        if (!(l = strchr(w, ':'))) {\n            if (!buffer) {\n                \n                while ((*getsfunc)(w, MAX_STRING_LEN - 1, getsfunc_data) > 0) {\n                    continue;\n                }\n            }\n\n            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                          \"malformed header from script '%s': Bad header: %.30s\",\n                          apr_filepath_name_get(r->filename), w);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        *l++ = '\\0';\n        while (apr_isspace(*l)) {\n            ++l;\n        }\n\n        if (!strcasecmp(w, \"Content-type\")) {\n            char *tmp;\n\n            \n\n            char *endp = l + strlen(l) - 1;\n            while (endp > l && apr_isspace(*endp)) {\n                *endp-- = '\\0';\n            }\n\n            tmp = apr_pstrdup(r->pool, l);\n            ap_content_type_tolower(tmp);\n            ap_set_content_type(r, tmp);\n        }\n        /*\n         * If the script returned a specific status, that's what\n         * we'll use - otherwise we assume 200 OK.\n         */\n        else if (!strcasecmp(w, \"Status\")) {\n            r->status = cgi_status = atoi(l);\n            if (!ap_is_HTTP_VALID_RESPONSE(cgi_status))\n                ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,\n                              \"Invalid status line from script '%s': %.30s\",\n                              apr_filepath_name_get(r->filename), l);\n            else\n                if (APLOGrtrace1(r))\n                   ap_log_rerror(SCRIPT_LOG_MARK, APLOG_TRACE1, 0, r,\n                                 \"Status line from script '%s': %.30s\",\n                                 apr_filepath_name_get(r->filename), l);\n            r->status_line = apr_pstrdup(r->pool, l);\n        }\n        else if (!strcasecmp(w, \"Location\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Content-Length\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Content-Range\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"Transfer-Encoding\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        else if (!strcasecmp(w, \"ETag\")) {\n            apr_table_set(r->headers_out, w, l);\n        }\n        /*\n         * If the script gave us a Last-Modified header, we can't just\n         * pass it on blindly because of restrictions on future values.\n         */\n        else if (!strcasecmp(w, \"Last-Modified\")) {\n            ap_update_mtime(r, apr_date_parse_http(l));\n            ap_set_last_modified(r);\n        }\n        else if (!strcasecmp(w, \"Set-Cookie\")) {\n            apr_table_add(cookie_table, w, l);\n        }\n        else {\n            apr_table_add(merge, w, l);\n        }\n        first_header = 0;\n    }\n    \n    return OK;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n20,Improper Input Validation\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_0c20e9e358baf3c25b53e14c1155bc34263948e4_0", {
    "ID": "httpd_0c20e9e358baf3c25b53e14c1155bc34263948e4_0",
    "UID": "1647",
    "code": "static int skiplisti_find_compare(ap_skiplist *sl, void test_snippet\n                           ap_skiplistnode **ret,\n                           ap_skiplist_compare comp)\n{\n    ap_skiplistnode *m = NULL;\n    int count = 0;\n    m = sl->top;\n    while (m) {\n        int compared;\n        compared = (m->next) ? comp(data, m->next->data) : -1;\n        if (compared == 0) {\n            m = m->next;\n            while (m->down) {\n                m = m->down;\n            }\n            *ret = m;\n            return count;\n        }\n        if ((m->next == NULL) || (compared < 0)) {\n            m = m->down;\n            count++;\n        }\n        else {\n            m = m->next;\n            count++;\n        }\n    }\n    *ret = NULL;\n    return count;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3c8afa3ccf45459566edefd2ac1488a92b34ae24_0", {
    "ID": "httpd_3c8afa3ccf45459566edefd2ac1488a92b34ae24_0",
    "UID": "1648",
    "code": "static apr_status_t demux(file_rec test_snippet\n{\n    apr_size_t len = 0;\n    apr_status_t status = APR_SUCCESS;\n    apr_bucket *b, *e;\n    apr_bucket_brigade *bb, *obb;\n    int footer = 0;\n    const char *buf;\n\n    bb = apr_brigade_create(file->pool, file->alloc);\n    obb = apr_brigade_create(file->pool, file->alloc);\n    b = apr_bucket_pipe_create(file->file_in, file->alloc);\n\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    do {\n\n        \n        if (APR_BRIGADE_EMPTY(bb)) {\n            break;\n        }\n\n        status = apr_brigade_split_line(obb, bb, APR_BLOCK_READ,\n                HUGE_STRING_LEN);\n\n        if (APR_SUCCESS == status || APR_EOF == status) {\n            char str[HUGE_STRING_LEN];\n            len = HUGE_STRING_LEN;\n\n            apr_brigade_flatten(obb, str, &len);\n\n            apr_brigade_cleanup(obb);\n\n            if (len == HUGE_STRING_LEN) {\n                file->skipped_bytes += len;\n                continue;\n            }\n            else if (footer) {\n                if (len == 2 && str[0] == '\\r' && str[1] == '\\n') {\n                    footer = 0;\n                    continue;\n                }\n                file->skipped_bytes += len;\n            }\n            else if (len > 0) {\n                header_rec header;\n                status = process_header(file, &header, str, len);\n                if (APR_SUCCESS != status) {\n                    file->skipped_bytes += len;\n                    continue;\n                }\n                else {\n                    int ignore = 0;\n\n                    header.rec = NULL;\n                    if (header.direction == '>') {\n                        header.rec = apr_hash_get(file->response_uuids,\n                                header.uuid, APR_HASH_KEY_STRING);\n                    }\n                    if (header.direction == '<') {\n                        header.rec = apr_hash_get(file->request_uuids,\n                                header.uuid, APR_HASH_KEY_STRING);\n                    }\n                    if (header.rec) {\n                        \n                        if (header.count != header.rec->count) {\n                            file->dropped_fragments++;\n                            ignore = 1;\n                        }\n                    }\n                    else {\n                        \n                        if (file->limit) {\n                            ignore = 1;\n                        }\n\n                        \n                        else if (header.count != 0) {\n                            file->skipped_bytes += len;\n                            ignore = 1;\n                        }\n\n                        \n                        else {\n                            make_uuid_rec(file, &header, &header.rec);\n                        }\n                    }\n\n                    if (header.len) {\n                        if (APR_SUCCESS != (status = apr_brigade_partition(bb,\n                                header.len, &e))) {\n                            apr_file_printf(\n                                    file->file_err,\n                                    \"Could not read fragment body from input file: %pm\\n\", &status);\n                            break;\n                        }\n                        while ((b = APR_BRIGADE_FIRST(bb)) && e != b) {\n                            apr_bucket_read(b, &buf, &len, APR_READ_BLOCK);\n                            if (!ignore && !header.count && !check_prefix(file,\n                                    &header, buf, len)) {\n                                ignore = 1;\n                            }\n                            if (!ignore) {\n                                status = process_body(file, &header, buf, len);\n                                header.rec->offset += len;\n                            }\n                            if (ignore || APR_SUCCESS != status) {\n                                apr_bucket_delete(b);\n                                file->skipped_bytes += len;\n                                continue;\n                            }\n                            apr_bucket_delete(b);\n                        }\n                        if (!ignore) {\n                            header.rec->count++;\n                        }\n                        footer = 1;\n                        continue;\n                    }\n                    else {\n                        \n                        if (header.rec) {\n                            if (!ignore) {\n                                if (!header.count) {\n                                    status = process_body(file, &header, \"\", 0);\n                                }\n                                status = finalise_body(file, &header);\n                            }\n                            apr_pool_destroy(header.rec->pool);\n                        }\n                    }\n\n                }\n            }\n\n        }\n        else {\n            apr_file_printf(file->file_err,\n                    \"Could not read fragment header from input file: %pm\\n\", &status);\n            break;\n        }\n\n    } while (1);\n\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_7ae4b2472d4bd68b96d22a201e109ee19b36dc3c_0", {
    "ID": "httpd_7ae4b2472d4bd68b96d22a201e109ee19b36dc3c_0",
    "UID": "1650",
    "code": "static const char *set_qop(cmd_parms *cmd, void *config, const char test_snippet\n{\n    digest_config_rec *conf = (digest_config_rec *) config;\n\n    if (!strcasecmp(op, \"none\")) {\n        apr_array_clear(conf->qop_list);\n        *(const char **)apr_array_push(conf->qop_list) = \"none\";\n        return NULL;\n    }\n\n    if (!strcasecmp(op, \"auth-int\")) {\n        return \"AuthDigestQop auth-int is not implemented\";\n    }\n    else if (strcasecmp(op, \"auth\")) {\n        return apr_pstrcat(cmd->pool, \"Unrecognized qop: \", op, NULL);\n    }\n\n    *(const char **)apr_array_push(conf->qop_list) = op;\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_10b421b137d6a8ebf0abf371fedce3b2e7b8f145_0", {
    "ID": "httpd_10b421b137d6a8ebf0abf371fedce3b2e7b8f145_0",
    "UID": "1656",
    "code": "static apr_status_t drain_available_output(ap_filter_t test_snippet\n                                           apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    ef_ctx_t *ctx = f->ctx;\n    apr_size_t len;\n    char buf[4096];\n    apr_status_t rv;\n    apr_bucket *b;\n\n    while (1) {\n        int lvl = APLOG_TRACE5;\n        len = sizeof(buf);\n        rv = apr_file_read(ctx->proc->out, buf, &len);\n        if (rv && !APR_STATUS_IS_EAGAIN(rv))\n           lvl = APLOG_DEBUG;\n        ap_log_rerror(APLOG_MARK, lvl, rv, r, APLOGNO(01460)\n                      \"apr_file_read(child output), len %\" APR_SIZE_T_FMT,\n                      !rv ? len : -1);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        b = apr_bucket_heap_create(buf, len, NULL, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        return APR_SUCCESS;\n    }\n    /* we should never get here; if we do, a bogus error message would be\n     * the least of our problems\n     */\n    return APR_ANONYMOUS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_c4b81f5e433f8d948e92d0c85f96b206da1d9da7_0", {
    "ID": "httpd_c4b81f5e433f8d948e92d0c85f96b206da1d9da7_0",
    "UID": "1657",
    "code": "static int getsfunc_BRIGADE(char *buf, int len, void test_snippet\n{\n    apr_bucket_brigade *bb = (apr_bucket_brigade *)arg;\n    const char *dst_end = buf + len - 1; \n    char *dst = buf;\n    apr_bucket *e = APR_BRIGADE_FIRST(bb);\n    apr_status_t rv;\n    int done = 0;\n\n    while ((dst < dst_end) && !done && e != APR_BRIGADE_SENTINEL(bb)\n           && !APR_BUCKET_IS_EOS(e)) {\n        const char *bucket_data;\n        apr_size_t bucket_data_len;\n        const char *src;\n        const char *src_end;\n        apr_bucket * next;\n\n        rv = apr_bucket_read(e, &bucket_data, &bucket_data_len,\n                             APR_BLOCK_READ);\n        if (rv != APR_SUCCESS || (bucket_data_len == 0)) {\n            *dst = '\\0';\n            return APR_STATUS_IS_TIMEUP(rv) ? -1 : 0;\n        }\n        src = bucket_data;\n        src_end = bucket_data + bucket_data_len;\n        while ((src < src_end) && (dst < dst_end) && !done) {\n            if (*src == '\\n') {\n                done = 1;\n            }\n            else if (*src != '\\r') {\n                *dst++ = *src;\n            }\n            src++;\n        }\n\n        if (src < src_end) {\n            apr_bucket_split(e, src - bucket_data);\n        }\n        next = APR_BUCKET_NEXT(e);\n        APR_BUCKET_REMOVE(e);\n        apr_bucket_destroy(e);\n        e = next;\n    }\n    *dst = 0;\n    return done;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_5c1f141a54762c30d6e1492a7b82cc728f357f5e_0", {
    "ID": "httpd_5c1f141a54762c30d6e1492a7b82cc728f357f5e_0",
    "UID": "1659",
    "code": "static int proxy_wstunnel_transfer(request_rec *r, conn_rec *c_i, conn_rec test_snippet\n                                     apr_bucket_brigade *bb, char *name)\n{\n    int rv;\n#ifdef DEBUGGING\n    apr_off_t len;\n#endif\n\n    do {\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c_i->input_filters, bb, AP_MODE_READBYTES,\n                            APR_NONBLOCK_READ, AP_IOBUFSIZE);\n        if (rv == APR_SUCCESS) {\n            if (c_o->aborted)\n                return APR_EPIPE;\n            if (APR_BRIGADE_EMPTY(bb))\n                break;\n#ifdef DEBUGGING\n            len = -1;\n            apr_brigade_length(bb, 0, &len);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02440)\n                          \"read %\" APR_OFF_T_FMT\n                          \" bytes from %s\", len, name);\n#endif\n            rv = ap_pass_brigade(c_o->output_filters, bb);\n            if (rv == APR_SUCCESS) {\n                ap_fflush(c_o->output_filters, bb);\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02441)\n                              \"error on %s - ap_pass_brigade\",\n                              name);\n            }\n        } else if (!APR_STATUS_IS_EAGAIN(rv) && !APR_STATUS_IS_EOF(rv)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(02442)\n                          \"error on %s - ap_get_brigade\",\n                          name);\n        }\n    } while (rv == APR_SUCCESS);\n\n    if (APR_STATUS_IS_EAGAIN(rv)) {\n        rv = APR_SUCCESS;\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_ac67d710883803af634fe773f7e600e60759e3fd_0", {
    "ID": "httpd_ac67d710883803af634fe773f7e600e60759e3fd_0",
    "UID": "1660",
    "code": "apr_status_t ajp_msg_append_string_ex(ajp_msg_t *msg, const char test_snippet\n                                      int convert)\n{\n    apr_size_t len;\n\n    if (value == NULL) {\n        return(ajp_msg_append_uint16(msg, 0xFFFF));\n    }\n\n    len = strlen(value);\n    if ((msg->len + len + 3) > msg->max_size) {\n        return ajp_log_overflow(msg, \"ajp_msg_append_cvt_string\");\n    }\n\n    \n    ajp_msg_append_uint16(msg, (apr_uint16_t)len);\n\n    \n    memcpy(msg->buf + msg->len, value, len + 1); \n\n    if (convert) {\n        \n        ap_xlate_proto_to_ascii((char *)msg->buf + msg->len, len + 1);\n    }\n\n    msg->len += len + 1;\n\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_411c5204d0aeb0cca74a8f9560591102cac4cb4a_0", {
    "ID": "httpd_411c5204d0aeb0cca74a8f9560591102cac4cb4a_0",
    "UID": "1661",
    "code": "PROXY_DECLARE(const char *) ap_proxy_location_reverse_map(request_rec test_snippet\n                              proxy_dir_conf *conf, const char *url)\n{\n    proxy_req_conf *rconf;\n    struct proxy_alias *ent;\n    int i, l1, l2;\n    char *u;\n\n    /*\n     * XXX FIXME: Make sure this handled the ambiguous case of the :<PORT>\n     * after the hostname\n     * XXX FIXME: Ensure the /uri component is a case sensitive match\n     */\n    if (r->proxyreq != PROXYREQ_REVERSE) {\n        return url;\n    }\n\n    l1 = strlen(url);\n    if (conf->interpolate_env == 1) {\n        rconf = ap_get_module_config(r->request_config, &proxy_module);\n        ent = (struct proxy_alias *)rconf->raliases->elts;\n    }\n    else {\n        ent = (struct proxy_alias *)conf->raliases->elts;\n    }\n    for (i = 0; i < conf->raliases->nelts; i++) {\n        proxy_server_conf *sconf = (proxy_server_conf *)\n            ap_get_module_config(r->server->module_config, &proxy_module);\n        proxy_balancer *balancer;\n        const char *real = ent[i].real;\n        /*\n         * First check if mapping against a balancer and see\n         * if we have such a entity. If so, then we need to\n         * find the particulars of the actual worker which may\n         * or may not be the right one... basically, we need\n         * to find which member actually handled this request.\n         */\n        if (ap_proxy_valid_balancer_name((char *)real, 0) &&\n            (balancer = ap_proxy_get_balancer(r->pool, sconf, real, 1))) {\n            int n, l3 = 0;\n            proxy_worker **worker = (proxy_worker **)balancer->workers->elts;\n            const char *urlpart = ap_strchr_c(real + sizeof(BALANCER_PREFIX) - 1, '/');\n            if (urlpart) {\n                if (!urlpart[1])\n                    urlpart = NULL;\n                else\n                    l3 = strlen(urlpart);\n            }\n            /* The balancer comparison is a bit trickier.  Given the context\n             *   BalancerMember balancer://alias http://example.com/foo\n             *   ProxyPassReverse /bash balancer://alias/bar\n             * translate url http://example.com/foo/bar/that to /bash/that\n             */\n            for (n = 0; n < balancer->workers->nelts; n++) {\n                l2 = strlen((*worker)->s->name);\n                if (urlpart) {\n                    \n                    if ((*worker)->s->name[l2 - 1] == '/')\n                        --l2;\n                    if (l1 >= l2 + l3\n                            && strncasecmp((*worker)->s->name, url, l2) == 0\n                            && strncmp(urlpart, url + l2, l3) == 0) {\n                        u = apr_pstrcat(r->pool, ent[i].fake, &url[l2 + l3],\n                                        NULL);\n                        return ap_is_url(u) ? u : ap_construct_url(r->pool, u, r);\n                    }\n                }\n                else if (l1 >= l2 && strncasecmp((*worker)->s->name, url, l2) == 0) {\n                    \n                    if ((ent[i].fake[0] == '/') && (ent[i].fake[1] == 0) && (url[l2] == '/')) {\n                        u = apr_pstrdup(r->pool, &url[l2]);\n                    } else {\n                        u = apr_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);\n                    }\n                    return ap_is_url(u) ? u : ap_construct_url(r->pool, u, r);\n                }\n                worker++;\n            }\n        }\n        else {\n            const char *part = url;\n            l2 = strlen(real);\n            if (real[0] == '/') {\n                part = ap_strstr_c(url, \"://\");\n                if (part) {\n                    part = ap_strchr_c(part+3, '/');\n                    if (part) {\n                        l1 = strlen(part);\n                    }\n                    else {\n                        part = url;\n                    }\n                }\n                else {\n                    part = url;\n                }\n            }\n            if (l1 >= l2 && strncasecmp(real, part, l2) == 0) {\n                u = apr_pstrcat(r->pool, ent[i].fake, &part[l2], NULL);\n                return ap_is_url(u) ? u : ap_construct_url(r->pool, u, r);\n            }\n        }\n    }\n\n    return url;\n}",
    "predicted": "546,Suspicious Comment"
  },
  "httpd_1d36f1e74325278a1c4074ce06ff65bfd372b109_0", {
    "ID": "httpd_1d36f1e74325278a1c4074ce06ff65bfd372b109_0",
    "UID": "1662",
    "code": "PROXY_DECLARE(const char *) ap_proxy_cookie_reverse_map(request_rec test_snippet\n                              proxy_dir_conf *conf, const char *str)\n{\n    proxy_req_conf *rconf = ap_get_module_config(r->request_config,\n                                                 &proxy_module);\n    struct proxy_alias *ent;\n    apr_size_t len = strlen(str);\n    const char *newpath = NULL;\n    const char *newdomain = NULL;\n    const char *pathp;\n    const char *domainp;\n    const char *pathe = NULL;\n    const char *domaine = NULL;\n    apr_size_t l1, l2, poffs = 0, doffs = 0;\n    int i;\n    int ddiff = 0;\n    int pdiff = 0;\n    char *ret;\n\n    if (r->proxyreq != PROXYREQ_REVERSE) {\n        return str;\n    }\n\n   /*\n    * Find the match and replacement, but save replacing until we've done\n    * both path and domain so we know the new strlen\n    */\n    if ((pathp = apr_strmatch(ap_proxy_strmatch_path, str, len)) != NULL) {\n        pathp += 5;\n        poffs = pathp - str;\n        pathe = ap_strchr_c(pathp, ';');\n        l1 = pathe ? (pathe - pathp) : strlen(pathp);\n        pathe = pathp + l1 ;\n        if (conf->interpolate_env == 1) {\n            ent = (struct proxy_alias *)rconf->cookie_paths->elts;\n        }\n        else {\n            ent = (struct proxy_alias *)conf->cookie_paths->elts;\n        }\n        for (i = 0; i < conf->cookie_paths->nelts; i++) {\n            l2 = strlen(ent[i].fake);\n            if (l1 >= l2 && strncmp(ent[i].fake, pathp, l2) == 0) {\n                newpath = ent[i].real;\n                pdiff = strlen(newpath) - l1;\n                break;\n            }\n        }\n    }\n\n    if ((domainp = apr_strmatch(ap_proxy_strmatch_domain, str, len)) != NULL) {\n        domainp += 7;\n        doffs = domainp - str;\n        domaine = ap_strchr_c(domainp, ';');\n        l1 = domaine ? (domaine - domainp) : strlen(domainp);\n        domaine = domainp + l1;\n        if (conf->interpolate_env == 1) {\n            ent = (struct proxy_alias *)rconf->cookie_domains->elts;\n        }\n        else {\n            ent = (struct proxy_alias *)conf->cookie_domains->elts;\n        }\n        for (i = 0; i < conf->cookie_domains->nelts; i++) {\n            l2 = strlen(ent[i].fake);\n            if (l1 >= l2 && strncasecmp(ent[i].fake, domainp, l2) == 0) {\n                newdomain = ent[i].real;\n                ddiff = strlen(newdomain) - l1;\n                break;\n            }\n        }\n    }\n\n    if (newpath) {\n        ret = apr_palloc(r->pool, len + pdiff + ddiff + 1);\n        l1 = strlen(newpath);\n        if (newdomain) {\n            l2 = strlen(newdomain);\n            if (doffs > poffs) {\n                memcpy(ret, str, poffs);\n                memcpy(ret + poffs, newpath, l1);\n                memcpy(ret + poffs + l1, pathe, domainp - pathe);\n                memcpy(ret + doffs + pdiff, newdomain, l2);\n                strcpy(ret + doffs + pdiff + l2, domaine);\n            }\n            else {\n                memcpy(ret, str, doffs) ;\n                memcpy(ret + doffs, newdomain, l2);\n                memcpy(ret + doffs + l2, domaine, pathp - domaine);\n                memcpy(ret + poffs + ddiff, newpath, l1);\n                strcpy(ret + poffs + ddiff + l1, pathe);\n            }\n        }\n        else {\n            memcpy(ret, str, poffs);\n            memcpy(ret + poffs, newpath, l1);\n            strcpy(ret + poffs + l1, pathe);\n        }\n    }\n    else {\n        if (newdomain) {\n            ret = apr_palloc(r->pool, len + pdiff + ddiff + 1);\n            l2 = strlen(newdomain);\n            memcpy(ret, str, doffs);\n            memcpy(ret + doffs, newdomain, l2);\n            strcpy(ret + doffs+l2, domaine);\n        }\n        else {\n            ret = (char *)str; \n        }\n    }\n\n    return ret;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a94061c3345cd86d718032f814d8fe228b6f309c_0", {
    "ID": "httpd_a94061c3345cd86d718032f814d8fe228b6f309c_0",
    "UID": "1666",
    "code": "static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    ef_ctx_t *ctx = f->ctx;\n    apr_bucket *b;\n    apr_size_t len;\n    const char *data;\n    apr_status_t rv;\n    char buf[4096];\n    apr_bucket *eos = NULL;\n    apr_bucket_brigade *bb_tmp;\n\n    bb_tmp = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    for (b = APR_BRIGADE_FIRST(bb);\n         b != APR_BRIGADE_SENTINEL(bb);\n         b = APR_BUCKET_NEXT(b))\n    {\n        if (APR_BUCKET_IS_EOS(b)) {\n            eos = b;\n            break;\n        }\n\n        rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01463) \"apr_bucket_read()\");\n            return rv;\n        }\n\n        \n        if (len > 0 &&\n            (rv = pass_data_to_filter(f, data, (apr_size_t)len, bb_tmp))\n                != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    apr_brigade_cleanup(bb);\n    APR_BRIGADE_CONCAT(bb, bb_tmp);\n    apr_brigade_destroy(bb_tmp);\n\n    if (eos) {\n        /* close the child's stdin to signal that no more data is coming;\n         * that will cause the child to finish generating output\n         */\n        if ((rv = apr_file_close(ctx->proc->in)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01464)\n                          \"apr_file_close(child input)\");\n            return rv;\n        }\n        /* since we've seen eos and closed the child's stdin, set the proper pipe\n         * timeout; we don't care if we don't return from apr_file_read() for a while...\n         */\n        rv = apr_file_pipe_timeout_set(ctx->proc->out,\n                                       r->server->timeout);\n        if (rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01465)\n                          \"apr_file_pipe_timeout_set(child output)\");\n            return rv;\n        }\n    }\n\n    do {\n        int lvl = APLOG_TRACE6;\n        len = sizeof(buf);\n        rv = apr_file_read(ctx->proc->out, buf, &len);\n        if (rv && !APR_STATUS_IS_EOF(rv) && !APR_STATUS_IS_EAGAIN(rv))\n            lvl = APLOG_ERR;\n        ap_log_rerror(APLOG_MARK, lvl, rv, r, APLOGNO(01466)\n                      \"apr_file_read(child output), len %\" APR_SIZE_T_FMT,\n                      !rv ? len : -1);\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            if (eos) {\n                \n                AP_DEBUG_ASSERT(1 != 1);\n            }\n            return APR_SUCCESS;\n        }\n\n        if (rv == APR_SUCCESS) {\n            b = apr_bucket_heap_create(buf, len, NULL, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, b);\n        }\n    } while (rv == APR_SUCCESS);\n\n    if (!APR_STATUS_IS_EOF(rv)) {\n        return rv;\n    }\n\n    if (eos) {\n        b = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        ctx->hit_eos = 1;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_5d474b04f674feb214b4473ce9e35174d0b2b893_0", {
    "ID": "httpd_5d474b04f674feb214b4473ce9e35174d0b2b893_0",
    "UID": "1667",
    "code": "static enum header_state get_header_line(char *buffer, int len, apr_file_t test_snippet\n{\n    char *buf_end = buffer + len;\n    char *cp;\n    char c;\n\n    \n\n    do {\n        if (apr_file_gets(buffer, MAX_STRING_LEN, map) != APR_SUCCESS) {\n            return header_eof;\n        }\n    } while (buffer[0] == '#');\n\n    \n\n    for (cp = buffer; apr_isspace(*cp); ++cp) {\n        continue;\n    }\n\n    if (*cp == '\\0') {\n        return header_sep;\n    }\n\n    /* If non-blank, go looking for header lines, but note that we still\n     * have to treat comments specially...\n     */\n\n    cp += strlen(cp);\n\n    /* We need to shortcut the rest of this block following the Body:\n     * tag - we will not look for continutation after this line.\n     */\n    if (!strncasecmp(buffer, \"Body:\", 5))\n        return header_seen;\n\n    while (apr_file_getc(&c, map) != APR_EOF) {\n        if (c == '#') {\n            \n            while (apr_file_getc(&c, map) != APR_EOF && c != '\\n') {\n                continue;\n            }\n        }\n        else if (apr_isspace(c)) {\n            /* Leading whitespace.  POSSIBLE continuation line\n             * Also, possibly blank --- if so, we ungetc() the final newline\n             * so that we will pick up the blank line the next time 'round.\n             */\n\n            while (c != '\\n' && apr_isspace(c)) {\n                if(apr_file_getc(&c, map) != APR_SUCCESS)\n                    break;\n            }\n\n            apr_file_ungetc(c, map);\n\n            if (c == '\\n') {\n                return header_seen;     \n            }\n\n            \n\n            while (   cp < buf_end - 2\n                   && (apr_file_getc(&c, map)) != APR_EOF\n                   && c != '\\n') {\n                *cp++ = c;\n            }\n\n            *cp++ = '\\n';\n            *cp = '\\0';\n        }\n        else {\n\n            \n\n            apr_file_ungetc(c, map);\n            return header_seen;\n        }\n    }\n\n    return header_seen;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_b9c16a951f44d0820a99df12d970f1bf01acb5e0_0", {
    "ID": "httpd_b9c16a951f44d0820a99df12d970f1bf01acb5e0_0",
    "UID": "1669",
    "code": "AP_DECLARE(void) ap_skiplist_add_index(ap_skiplist test_snippet\n                        ap_skiplist_compare comp,\n                        ap_skiplist_compare compk)\n{\n    ap_skiplistnode *m;\n    ap_skiplist *ni;\n    int icount = 0;\n    ap_skiplist_find(sl->index, (void *)comp, &m);\n    if (m) {\n        return;                 \n    }\n    skiplisti_init(&ni, sl->pool);\n    ap_skiplist_set_compare(ni, comp, compk);\n    \n    m = ap_skiplist_insert(sl->index, ni);\n    while (m->prev) {\n        m = m->prev;\n        icount++;\n    }\n    for (m = ap_skiplist_getlist(sl); m; ap_skiplist_next(sl, &m)) {\n        int j = icount - 1;\n        ap_skiplistnode *nsln;\n        nsln = ap_skiplist_insert(ni, m->data);\n        \n        while (j > 0) {\n            m = m->nextindex;\n            j--;\n        }\n        \n        nsln->nextindex = m->nextindex;\n        if (m->nextindex) {\n            m->nextindex->previndex = nsln;\n        }\n        nsln->previndex = m;\n        m->nextindex = nsln;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_84d27bce53c16134fcd57d78cedd0984d80fb445_0", {
    "ID": "httpd_84d27bce53c16134fcd57d78cedd0984d80fb445_0",
    "UID": "1672",
    "code": "static apr_status_t read_table(cache_handle_t *handle, request_rec test_snippet\n                               apr_table_t *table, apr_file_t *file)\n{\n    char w[MAX_STRING_LEN];\n    char *l;\n    int p;\n    apr_status_t rv;\n\n    while (1) {\n\n        \n        rv = apr_file_gets(w, MAX_STRING_LEN - 1, file);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00717)\n                          \"Premature end of cache headers.\");\n            return rv;\n        }\n\n        \n\n        p = strlen(w);\n        /* Indeed, the host's '\\n':\n           '\\012' for UNIX; '\\015' for MacOS; '\\025' for OS/390\n           -- whatever the script generates.\n        */\n        if (p > 0 && w[p - 1] == '\\n') {\n            if (p > 1 && w[p - 2] == CR) {\n                w[p - 2] = '\\0';\n            }\n            else {\n                w[p - 1] = '\\0';\n            }\n        }\n\n        \n        if (w[0] == '\\0') {\n            break;\n        }\n\n#if APR_CHARSET_EBCDIC\n        /* Chances are that we received an ASCII header text instead of\n         * the expected EBCDIC header lines. Try to auto-detect:\n         */\n        if (!(l = strchr(w, ':'))) {\n            int maybeASCII = 0, maybeEBCDIC = 0;\n            unsigned char *cp, native;\n            apr_size_t inbytes_left, outbytes_left;\n\n            for (cp = w; *cp != '\\0'; ++cp) {\n                native = apr_xlate_conv_byte(ap_hdrs_from_ascii, *cp);\n                if (apr_isprint(*cp) && !apr_isprint(native))\n                    ++maybeEBCDIC;\n                if (!apr_isprint(*cp) && apr_isprint(native))\n                    ++maybeASCII;\n            }\n            if (maybeASCII > maybeEBCDIC) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00718)\n                        \"CGI Interface Error: Script headers apparently ASCII: (CGI = %s)\",\n                        r->filename);\n                inbytes_left = outbytes_left = cp - w;\n                apr_xlate_conv_buffer(ap_hdrs_from_ascii,\n                                      w, &inbytes_left, w, &outbytes_left);\n            }\n        }\n#endif \n\n        \n        if (!(l = strchr(w, ':'))) {\n            return APR_EGENERAL;\n        }\n\n        *l++ = '\\0';\n        while (apr_isspace(*l)) {\n            ++l;\n        }\n\n        apr_table_add(table, w, l);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_da6818afa8df01a457e415434266e447ef0581da_0", {
    "ID": "httpd_da6818afa8df01a457e415434266e447ef0581da_0",
    "UID": "1677",
    "code": "static client_entry *add_client(unsigned long key, client_entry test_snippet\n                                server_rec *s)\n{\n    int bucket;\n    client_entry *entry;\n\n\n    if (!key || !client_shm) {\n        return NULL;\n    }\n\n    bucket = key % client_list->tbl_len;\n\n    apr_global_mutex_lock(client_lock);\n\n    \n\n    entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));\n    if (!entry) {\n        long num_removed = gc();\n        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01766)\n                     \"gc'd %ld client entries. Total new clients: \"\n                     \"%ld; Total removed clients: %ld; Total renewed clients: \"\n                     \"%ld\", num_removed,\n                     client_list->num_created - client_list->num_renewed,\n                     client_list->num_removed, client_list->num_renewed);\n        entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));\n        if (!entry) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01767)\n                         \"unable to allocate new auth_digest client\");\n            apr_global_mutex_unlock(client_lock);\n            return NULL;       \n        }\n    }\n\n    \n\n    memcpy(entry, info, sizeof(client_entry));\n    entry->key  = key;\n    entry->next = client_list->table[bucket];\n    client_list->table[bucket] = entry;\n    client_list->num_created++;\n    client_list->num_entries++;\n\n    apr_global_mutex_unlock(client_lock);\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01768)\n                 \"allocated new client %lu\", key);\n\n    return entry;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_2fcc0bb5ccecb15babf9a5d1c05f2eaf8f0250af_0", {
    "ID": "httpd_2fcc0bb5ccecb15babf9a5d1c05f2eaf8f0250af_0",
    "UID": "1678",
    "code": "AP_DECLARE(ap_skiplistnode *) ap_skiplist_insert_compare(ap_skiplist *sl, void test_snippet\n                                      ap_skiplist_compare comp)\n{\n    ap_skiplistnode *m, *p, *tmp, *ret = NULL, **stack;\n    int nh = 1, ch, stacki;\n    if (!sl->top) {\n        sl->height = 1;\n        sl->topend = sl->bottomend = sl->top = sl->bottom =\n            (ap_skiplistnode *)ap_skiplist_alloc(sl, sizeof(ap_skiplistnode));\n        AP_DEBUG_ASSERT(sl->top);\n#if 0\n        sl->top->next = (ap_skiplistnode *)NULL;\n        sl->top->data = (ap_skiplistnode *)NULL;\n        sl->top->prev = (ap_skiplistnode *)NULL;\n        sl->top->up = (ap_skiplistnode *)NULL;\n        sl->top->down = (ap_skiplistnode *)NULL;\n        sl->top->nextindex = (ap_skiplistnode *)NULL;\n        sl->top->previndex = (ap_skiplistnode *)NULL;\n#endif\n        sl->top->sl = sl;\n    }\n    if (sl->preheight) {\n        while (nh < sl->preheight && get_b_rand()) {\n            nh++;\n        }\n    }\n    else {\n        while (nh <= sl->height && get_b_rand()) {\n            nh++;\n        }\n    }\n    \n    /*\n     * Let us make sure that our tree is a least that tall (grow if\n     * necessary)\n     */\n    for (; sl->height < nh; sl->height++) {\n        sl->top->up =\n            (ap_skiplistnode *)ap_skiplist_alloc(sl, sizeof(ap_skiplistnode));\n        AP_DEBUG_ASSERT(sl->top->up);\n        sl->top->up->down = sl->top;\n        sl->top = sl->topend = sl->top->up;\n#if 0\n        sl->top->prev = sl->top->next = sl->top->nextindex =\n            sl->top->previndex = sl->top->up = NULL;\n        sl->top->data = NULL;\n#endif\n        sl->top->sl = sl;\n    }\n    ch = sl->height;\n    \n    \n    \n    m = sl->top;\n    stack = (ap_skiplistnode **)ap_malloc(sizeof(ap_skiplistnode *) * (nh));\n    stacki = 0;\n    while (m) {\n        int compared = -1;\n        if (m->next) {\n            compared = comp(data, m->next->data);\n        }\n        if (compared == 0) {\n            free(stack);    \n            return 0;\n        }\n        if ((m->next == NULL) || (compared < 0)) {\n            if (ch <= nh) {\n                \n                stack[stacki++] = m;\n            }\n            m = m->down;\n            ch--;\n        }\n        else {\n            m = m->next;\n        }\n    }\n    \n    p = NULL;\n    for (; stacki > 0; stacki--) {\n        m = stack[stacki - 1];\n        tmp = (ap_skiplistnode *)ap_skiplist_alloc(sl, sizeof(ap_skiplistnode));\n        tmp->next = m->next;\n        if (m->next) {\n            m->next->prev = tmp;\n        }\n        tmp->prev = m;\n        tmp->up = NULL;\n        tmp->nextindex = tmp->previndex = NULL;\n        tmp->down = p;\n        if (p) {\n            p->up = tmp;\n        }\n        tmp->data = data;\n        tmp->sl = sl;\n        m->next = tmp;\n        \n        if (!p) {\n            ret = tmp;\n            sl->size++; \n        }\n        p = tmp;\n    }\n    free(stack); \n    if (sl->index != NULL) {\n        /*\n         * this is a external insertion, we must insert into each index as\n         * well\n         */\n        ap_skiplistnode *ni, *li;\n        li = ret;\n        for (p = ap_skiplist_getlist(sl->index); p; ap_skiplist_next(sl->index, &p)) {\n            ni = ap_skiplist_insert((ap_skiplist *) p->data, ret->data);\n            AP_DEBUG_ASSERT(ni);\n            li->nextindex = ni;\n            ni->previndex = li;\n            li = ni;\n        }\n    }\n    else {\n        \n    }\n    sl->size++;\n    return ret;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_d9abc2a3148c6920cb2964aeedceea10e00b05a2_0", {
    "ID": "httpd_d9abc2a3148c6920cb2964aeedceea10e00b05a2_0",
    "UID": "1679",
    "code": "static apr_status_t ef_input_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                                    ap_input_mode_t mode, apr_read_type_e block,\n                                    apr_off_t readbytes)\n{\n    ef_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n\n    if (!ctx) {\n        if ((rv = init_filter_instance(f)) != APR_SUCCESS) {\n            ctx = f->ctx;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01470)\n                          \"can't initialise input filter %s: %s\",\n                          f->frec->name,\n                          (ctx->dc->onfail == 1) ? \"removing\" : \"aborting\");\n            ap_remove_input_filter(f);\n            if (ctx->dc->onfail == 1) {\n                return ap_get_brigade(f->next, bb, mode, block, readbytes);\n            }\n            else {\n                f->r->status = HTTP_INTERNAL_SERVER_ERROR;\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n        ctx = f->ctx;\n    }\n\n    if (ctx->hit_eos) {\n        /* Match behaviour of HTTP_IN if filter is re-invoked after\n         * hitting EOS: give back another EOS. */\n        apr_bucket *e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        return APR_SUCCESS;\n    }\n\n    if (ctx->noop) {\n        ap_remove_input_filter(f);\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    rv = ef_unified_filter(f, bb);\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_ec0c819f641df06e9a55fa7246b908feda4b6ded_0", {
    "ID": "httpd_ec0c819f641df06e9a55fa7246b908feda4b6ded_0",
    "UID": "1680",
    "code": "static char *lcase_header_name_return_body(char *header, request_rec test_snippet\n{\n    char *cp = header;\n\n    for ( ; *cp && *cp != ':' ; ++cp) {\n        *cp = apr_tolower(*cp);\n    }\n\n    if (!*cp) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00681)\n                      \"Syntax error in type map, no ':' in %s for header %s\",\n                      r->filename, header);\n        return NULL;\n    }\n\n    do {\n        ++cp;\n    } while (apr_isspace(*cp));\n\n    if (!*cp) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00682)\n                      \"Syntax error in type map --- no header body: %s for %s\",\n                      r->filename, header);\n        return NULL;\n    }\n\n    return cp;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e94bfec0dd21e4a67f6b3ad35ff5b3a8d5d803e4_0", {
    "ID": "httpd_e94bfec0dd21e4a67f6b3ad35ff5b3a8d5d803e4_0",
    "UID": "1683",
    "code": "AP_DECLARE(void) ap_bin2hex(const void *src, apr_size_t srclen, char test_snippet\n{\n    const unsigned char *in = src;\n    apr_size_t i;\n\n    for (i = 0; i < srclen; i++) {\n        *dest++ = c2x_table[in[i] >> 4];\n        *dest++ = c2x_table[in[i] & 0xf];\n    }\n    *dest = '\\0';\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_744ff914008c2914d1f3ead81348abde3487b72d_0", {
    "ID": "httpd_744ff914008c2914d1f3ead81348abde3487b72d_0",
    "UID": "1687",
    "code": "static char *lookup_map_txtfile(request_rec *r, const char *file, char test_snippet\n{\n    apr_file_t *fp = NULL;\n    char line[REWRITE_MAX_TXT_MAP_LINE + 1]; \n    char *value, *keylast;\n    apr_status_t rv;\n\n    if ((rv = apr_file_open(&fp, file, APR_READ|APR_BUFFERED, APR_OS_DEFAULT,\n                            r->pool)) != APR_SUCCESS)\n    {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00655)\n                      \"mod_rewrite: can't open text RewriteMap file %s\", file);\n        return NULL;\n    }\n\n    keylast = key + strlen(key);\n    value = NULL;\n    while (apr_file_gets(line, sizeof(line), fp) == APR_SUCCESS) {\n        char *p, *c;\n\n        \n        if (*line == '#' || apr_isspace(*line)) {\n            continue;\n        }\n\n        p = line;\n        c = key;\n        while (c < keylast && *p == *c && !apr_isspace(*p)) {\n            ++p;\n            ++c;\n        }\n\n        \n        if (c != keylast || !apr_isspace(*p)) {\n            continue;\n        }\n\n        \n        while (apr_isspace(*p)) {\n            ++p;\n        }\n\n        \n        if (!*p) {\n            continue;\n        }\n\n        \n        c = p;\n        while (*p && !apr_isspace(*p)) {\n            ++p;\n        }\n        value = apr_pstrmemdup(r->pool, c, p - c);\n        break;\n    }\n    apr_file_close(fp);\n\n    return value;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_63015b232d3151a3d3d5b0e68b0c498019450b3d_0", {
    "ID": "httpd_63015b232d3151a3d3d5b0e68b0c498019450b3d_0",
    "UID": "1693",
    "code": "AP_DECLARE(char *) ap_get_token(apr_pool_t *p, const char test_snippet\n                                int accept_white)\n{\n    const char *ptr = *accept_line;\n    const char *tok_start;\n    char *token;\n    int tok_len;\n\n    \n\n    while (apr_isspace(*ptr))\n        ++ptr;\n\n    tok_start = ptr;\n\n    /* find token end, skipping over quoted strings.\n     * (comments are already gone).\n     */\n\n    while (*ptr && (accept_white || !apr_isspace(*ptr))\n           && *ptr != ';' && *ptr != ',') {\n        if (*ptr++ == '\"')\n            while (*ptr)\n                if (*ptr++ == '\"')\n                    break;\n    }\n\n    tok_len = ptr - tok_start;\n    token = apr_pstrndup(p, tok_start, tok_len);\n\n    \n\n    while (apr_isspace(*ptr))\n        ++ptr;\n\n    *accept_line = ptr;\n    return token;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b456bc5ce1886a1975261382236aa23c06c6b8d0_0", {
    "ID": "httpd_b456bc5ce1886a1975261382236aa23c06c6b8d0_0",
    "UID": "1694",
    "code": "static int authenticate_digest_user(request_rec test_snippet\n{\n    digest_config_rec *conf;\n    digest_header_rec *resp;\n    request_rec       *mainreq;\n    const char        *t;\n    int                res;\n    authn_status       return_code;\n\n    \n\n    if (!(t = ap_auth_type(r)) || strcasecmp(t, \"Digest\")) {\n        return DECLINED;\n    }\n\n    if (!ap_auth_name(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01780)\n                      \"need AuthName: %s\", r->uri);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n\n    \n\n    mainreq = r;\n    while (mainreq->main != NULL) {\n        mainreq = mainreq->main;\n    }\n    while (mainreq->prev != NULL) {\n        mainreq = mainreq->prev;\n    }\n    resp = (digest_header_rec *) ap_get_module_config(mainreq->request_config,\n                                                      &auth_digest_module);\n    resp->needed_auth = 1;\n\n\n    \n\n    conf = (digest_config_rec *) ap_get_module_config(r->per_dir_config,\n                                                      &auth_digest_module);\n\n\n    \n\n    if (resp->auth_hdr_sts != VALID) {\n        if (resp->auth_hdr_sts == NOT_DIGEST) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01781)\n                          \"client used wrong authentication scheme `%s': %s\",\n                          resp->scheme, r->uri);\n        }\n        else if (resp->auth_hdr_sts == INVALID) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01782)\n                          \"missing user, realm, nonce, uri, digest, \"\n                          \"cnonce, or nonce_count in authorization header: %s\",\n                          r->uri);\n        }\n        \n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    r->user         = (char *) resp->username;\n    r->ap_auth_type = (char *) \"Digest\";\n\n    \n\n    if (strcmp(resp->uri, resp->raw_request_uri)) {\n        /* Hmm, the simple match didn't work (probably a proxy modified the\n         * request-uri), so lets do a more sophisticated match\n         */\n        apr_uri_t r_uri, d_uri;\n\n        copy_uri_components(&r_uri, resp->psd_request_uri, r);\n        if (apr_uri_parse(r->pool, resp->uri, &d_uri) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01783)\n                          \"invalid uri <%s> in Authorization header\",\n                          resp->uri);\n            return HTTP_BAD_REQUEST;\n        }\n\n        if (d_uri.hostname) {\n            ap_unescape_url(d_uri.hostname);\n        }\n        if (d_uri.path) {\n            ap_unescape_url(d_uri.path);\n        }\n\n        if (d_uri.query) {\n            ap_unescape_url(d_uri.query);\n        }\n        else if (r_uri.query) {\n            /* MSIE compatibility hack.  MSIE has some RFC issues - doesn't\n             * include the query string in the uri Authorization component\n             * or when computing the response component.  the second part\n             * works out ok, since we can hash the header and get the same\n             * result.  however, the uri from the request line won't match\n             * the uri Authorization component since the header lacks the\n             * query string, leaving us incompatable with a (broken) MSIE.\n             *\n             * the workaround is to fake a query string match if in the proper\n             * environment - BrowserMatch MSIE, for example.  the cool thing\n             * is that if MSIE ever fixes itself the simple match ought to\n             * work and this code won't be reached anyway, even if the\n             * environment is set.\n             */\n\n            if (apr_table_get(r->subprocess_env,\n                              \"AuthDigestEnableQueryStringHack\")) {\n\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01784)\n                              \"applying AuthDigestEnableQueryStringHack \"\n                              \"to uri <%s>\", resp->raw_request_uri);\n\n               d_uri.query = r_uri.query;\n            }\n        }\n\n        if (r->method_number == M_CONNECT) {\n            if (!r_uri.hostinfo || strcmp(resp->uri, r_uri.hostinfo)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01785)\n                              \"uri mismatch - <%s> does not match \"\n                              \"request-uri <%s>\", resp->uri, r_uri.hostinfo);\n                return HTTP_BAD_REQUEST;\n            }\n        }\n        else if (\n            \n            (d_uri.hostname && d_uri.hostname[0] != '\\0'\n              && strcasecmp(d_uri.hostname, r_uri.hostname))\n            \n            || (d_uri.port_str && d_uri.port != r_uri.port)\n            \n            || (d_uri.hostname && d_uri.hostname[0] != '\\0'\n                && !d_uri.port_str && r_uri.port != ap_default_port(r))\n            \n            || (d_uri.path != r_uri.path\n                \n                && (!d_uri.path || !r_uri.path\n                    || strcmp(d_uri.path, r_uri.path))\n                \n                && !(d_uri.path && !r_uri.path && resp->psd_request_uri->hostname\n                    && d_uri.path[0] == '*' && d_uri.path[1] == '\\0'))\n            \n            || (d_uri.query != r_uri.query\n                && (!d_uri.query || !r_uri.query\n                    || strcmp(d_uri.query, r_uri.query)))\n            ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01786)\n                          \"uri mismatch - <%s> does not match \"\n                          \"request-uri <%s>\", resp->uri, resp->raw_request_uri);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (resp->opaque && resp->opaque_num == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01787)\n                      \"received invalid opaque - got `%s'\",\n                      resp->opaque);\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (strcmp(resp->realm, conf->realm)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01788)\n                      \"realm mismatch - got `%s' but expected `%s'\",\n                      resp->realm, conf->realm);\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (resp->algorithm != NULL\n        && strcasecmp(resp->algorithm, \"MD5\")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01789)\n                      \"unknown algorithm `%s' received: %s\",\n                      resp->algorithm, r->uri);\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    return_code = get_hash(r, r->user, conf);\n\n    if (return_code == AUTH_USER_NOT_FOUND) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01790)\n                      \"user `%s' in realm `%s' not found: %s\",\n                      r->user, conf->realm, r->uri);\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n    else if (return_code == AUTH_USER_FOUND) {\n        \n    }\n    else if (return_code == AUTH_DENIED) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01791)\n                      \"user `%s' in realm `%s' denied by provider: %s\",\n                      r->user, conf->realm, r->uri);\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n    else {\n        /* AUTH_GENERAL_ERROR (or worse)\n         * We'll assume that the module has already said what its error\n         * was in the logs.\n         */\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (resp->message_qop == NULL) {\n        \n        if (strcmp(resp->digest, old_digest(r, resp, conf->ha1))) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01792)\n                          \"user %s: password mismatch: %s\", r->user,\n                          r->uri);\n            note_digest_auth_failure(r, conf, resp, 0);\n            return HTTP_UNAUTHORIZED;\n        }\n    }\n    else {\n        const char *exp_digest;\n        int match = 0, idx;\n        const char **tmp = (const char **)(conf->qop_list->elts);\n        for (idx = 0; idx < conf->qop_list->nelts; idx++) {\n            if (!strcasecmp(*tmp, resp->message_qop)) {\n                match = 1;\n                break;\n            }\n            ++tmp;\n        }\n\n        if (!match\n            && !(apr_is_empty_array(conf->qop_list)\n                 && !strcasecmp(resp->message_qop, \"auth\"))) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01793)\n                          \"invalid qop `%s' received: %s\",\n                          resp->message_qop, r->uri);\n            note_digest_auth_failure(r, conf, resp, 0);\n            return HTTP_UNAUTHORIZED;\n        }\n\n        exp_digest = new_digest(r, resp, conf);\n        if (!exp_digest) {\n            \n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        if (strcmp(resp->digest, exp_digest)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01794)\n                          \"user %s: password mismatch: %s\", r->user,\n                          r->uri);\n            note_digest_auth_failure(r, conf, resp, 0);\n            return HTTP_UNAUTHORIZED;\n        }\n    }\n\n    if (check_nc(r, resp, conf) != OK) {\n        note_digest_auth_failure(r, conf, resp, 0);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    /* Note: this check is done last so that a \"stale=true\" can be\n       generated if the nonce is old */\n    if ((res = check_nonce(r, resp, conf))) {\n        return res;\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value\n252,Unchecked Return Value"
  },
  "httpd_c39d4fe5a71099028a9c71727291d851cc764d87_0", {
    "ID": "httpd_c39d4fe5a71099028a9c71727291d851cc764d87_0",
    "UID": "1696",
    "code": "static void test_snippet\n{\n    double timetaken = (double) (lasttime - start) / APR_USEC_PER_SEC;\n\n    printf(\"\\n\\n<table %s>\\n\", tablestring);\n    printf(\"<tr %s><th colspan=2 %s>Server Software:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, servername);\n    printf(\"<tr %s><th colspan=2 %s>Server Hostname:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, hostname);\n    printf(\"<tr %s><th colspan=2 %s>Server Port:</th>\"\n       \"<td colspan=2 %s>%hu</td></tr>\\n\",\n       trstring, tdstring, tdstring, port);\n    printf(\"<tr %s><th colspan=2 %s>Document Path:</th>\"\n       \"<td colspan=2 %s>%s</td></tr>\\n\",\n       trstring, tdstring, tdstring, path);\n    printf(\"<tr %s><th colspan=2 %s>Document Length:</th>\"\n       \"<td colspan=2 %s>%\" APR_SIZE_T_FMT \" bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, doclen);\n    printf(\"<tr %s><th colspan=2 %s>Concurrency Level:</th>\"\n       \"<td colspan=2 %s>%d</td></tr>\\n\",\n       trstring, tdstring, tdstring, concurrency);\n    printf(\"<tr %s><th colspan=2 %s>Time taken for tests:</th>\"\n       \"<td colspan=2 %s>%.3f seconds</td></tr>\\n\",\n       trstring, tdstring, tdstring, timetaken);\n    printf(\"<tr %s><th colspan=2 %s>Complete requests:</th>\"\n       \"<td colspan=2 %s>%d</td></tr>\\n\",\n       trstring, tdstring, tdstring, done);\n    printf(\"<tr %s><th colspan=2 %s>Failed requests:</th>\"\n       \"<td colspan=2 %s>%d</td></tr>\\n\",\n       trstring, tdstring, tdstring, bad);\n    if (bad)\n        printf(\"<tr %s><td colspan=4 %s >   (Connect: %d, Length: %d, Exceptions: %d)</td></tr>\\n\",\n           trstring, tdstring, err_conn, err_length, err_except);\n    if (err_response)\n        printf(\"<tr %s><th colspan=2 %s>Non-2xx responses:</th>\"\n           \"<td colspan=2 %s>%d</td></tr>\\n\",\n           trstring, tdstring, tdstring, err_response);\n    if (keepalive)\n        printf(\"<tr %s><th colspan=2 %s>Keep-Alive requests:</th>\"\n           \"<td colspan=2 %s>%d</td></tr>\\n\",\n           trstring, tdstring, tdstring, doneka);\n    printf(\"<tr %s><th colspan=2 %s>Total transferred:</th>\"\n       \"<td colspan=2 %s>%\" APR_INT64_T_FMT \" bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, totalread);\n    if (send_body)\n        printf(\"<tr %s><th colspan=2 %s>Total body sent:</th>\"\n           \"<td colspan=2 %s>%\" APR_INT64_T_FMT \"</td></tr>\\n\",\n           trstring, tdstring,\n           tdstring, totalposted);\n    printf(\"<tr %s><th colspan=2 %s>HTML transferred:</th>\"\n       \"<td colspan=2 %s>%\" APR_INT64_T_FMT \" bytes</td></tr>\\n\",\n       trstring, tdstring, tdstring, totalbread);\n\n    \n    if (timetaken) {\n        printf(\"<tr %s><th colspan=2 %s>Requests per second:</th>\"\n           \"<td colspan=2 %s>%.2f</td></tr>\\n\",\n           trstring, tdstring, tdstring, (double) done / timetaken);\n        printf(\"<tr %s><th colspan=2 %s>Transfer rate:</th>\"\n           \"<td colspan=2 %s>%.2f kb/s received</td></tr>\\n\",\n           trstring, tdstring, tdstring, (double) totalread / 1024 / timetaken);\n        if (send_body) {\n            printf(\"<tr %s><td colspan=2 %s>&nbsp;</td>\"\n               \"<td colspan=2 %s>%.2f kb/s sent</td></tr>\\n\",\n               trstring, tdstring, tdstring,\n               (double) totalposted / 1024 / timetaken);\n            printf(\"<tr %s><td colspan=2 %s>&nbsp;</td>\"\n               \"<td colspan=2 %s>%.2f kb/s total</td></tr>\\n\",\n               trstring, tdstring, tdstring,\n               (double) (totalread + totalposted) / 1024 / timetaken);\n        }\n    }\n    {\n        \n        int i;\n        apr_interval_time_t totalcon = 0, total = 0;\n        apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX;\n        apr_interval_time_t maxcon = 0, maxtot = 0;\n\n        for (i = 0; i < done; i++) {\n            struct data *s = &stats[i];\n            mincon = ap_min(mincon, s->ctime);\n            mintot = ap_min(mintot, s->time);\n            maxcon = ap_max(maxcon, s->ctime);\n            maxtot = ap_max(maxtot, s->time);\n            totalcon += s->ctime;\n            total    += s->time;\n        }\n        /*\n         * Reduce stats from apr time to milliseconds\n         */\n        mincon   = ap_round_ms(mincon);\n        mintot   = ap_round_ms(mintot);\n        maxcon   = ap_round_ms(maxcon);\n        maxtot   = ap_round_ms(maxtot);\n        totalcon = ap_round_ms(totalcon);\n        total    = ap_round_ms(total);\n\n        if (done > 0) { \n            printf(\"<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\\n\",\n               trstring, tdstring);\n            printf(\"<tr %s><th %s>&nbsp;</th> <th %s>min</th>   <th %s>avg</th>   <th %s>max</th></tr>\\n\",\n               trstring, tdstring, tdstring, tdstring, tdstring);\n            printf(\"<tr %s><th %s>Connect:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mincon, tdstring, totalcon / done, tdstring, maxcon);\n            printf(\"<tr %s><th %s>Processing:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mintot - mincon, tdstring,\n               (total / done) - (totalcon / done), tdstring, maxtot - maxcon);\n            printf(\"<tr %s><th %s>Total:</th>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td>\"\n               \"<td %s>%5\" APR_TIME_T_FMT \"</td></tr>\\n\",\n               trstring, tdstring, tdstring, mintot, tdstring, total / done, tdstring, maxtot);\n        }\n        printf(\"</table>\\n\");\n    }\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_08818b9af46c544277e857d0b5bc74f076820757_0", {
    "ID": "httpd_08818b9af46c544277e857d0b5bc74f076820757_0",
    "UID": "1699",
    "code": "PROXY_DECLARE(int) ap_proxy_is_domainname(struct dirconn_entry *This, apr_pool_t test_snippet\n{\n    char *addr = This->name;\n    int i;\n\n    \n    if (addr[0] != '.') {\n        return 0;\n    }\n\n    \n    for (i = 0; apr_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i) {\n        continue;\n    }\n\n#if 0\n    if (addr[i] == ':') {\n    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n                     \"@@@@ handle optional port in proxy_is_domainname()\");\n    \n    }\n#endif\n\n    if (addr[i] != '\\0') {\n        return 0;\n    }\n\n    \n    for (i = strlen(addr) - 1; i > 0 && addr[i] == '.'; --i) {\n        addr[i] = '\\0';\n    }\n\n    This->matcher = proxy_match_domainname;\n    return 1;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable"
  },
  "httpd_dd35da75b978d47a4a814fc1720e9084a818daa2_0", {
    "ID": "httpd_dd35da75b978d47a4a814fc1720e9084a818daa2_0",
    "UID": "1700",
    "code": "AP_DECLARE(int) ap_skiplist_remove_compare(ap_skiplist test_snippet\n                            void *data,\n                            ap_skiplist_freefunc myfree, ap_skiplist_compare comp)\n{\n    ap_skiplistnode *m;\n    ap_skiplist *sl;\n    if (comp == sli->comparek || !sli->index) {\n        sl = sli;\n    }\n    else {\n        ap_skiplist_find(sli->index, (void *)comp, &m);\n        AP_DEBUG_ASSERT(m);\n        sl = (ap_skiplist *) m->data;\n    }\n    skiplisti_find_compare(sl, data, &m, comp);\n    if (!m) {\n        return 0;\n    }\n    while (m->previndex) {\n        m = m->previndex;\n    }\n    return skiplisti_remove(sl, m, myfree);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3230bfea89d32dc73feabae4611c247dda1f93fb_0", {
    "ID": "httpd_3230bfea89d32dc73feabae4611c247dda1f93fb_0",
    "UID": "1702",
    "code": "AP_DECLARE(void) ap_skiplist_remove_all(ap_skiplist *sl, ap_skiplist_freefunc test_snippet\n{\n    /*\n     * This must remove even the place holder nodes (bottom though top)\n     * because we specify in the API that one can free the Skiplist after\n     * making this call without memory leaks\n     */\n    ap_skiplistnode *m, *p, *u;\n    m = sl->bottom;\n    while (m) {\n        p = m->next;\n        if (p && myfree && p->data)\n            myfree(p->data);\n        while (m) {\n            u = m->up;\n            ap_skiplist_free(sl, p);\n            m = u;\n        }\n        m = p;\n    }\n    sl->top = sl->bottom = NULL;\n    sl->height = 0;\n    sl->size = 0;\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a639792208f169e3e6f37ad40a1e157ee204d083_0", {
    "ID": "httpd_a639792208f169e3e6f37ad40a1e157ee204d083_0",
    "UID": "1706",
    "code": "int main (int argc, const char * const test_snippet\n{\n    char buf[BUFSIZE];\n    apr_size_t nRead, nWrite;\n    apr_file_t *f_stdin;\n    apr_file_t *f_stdout;\n    apr_getopt_t *opt;\n    apr_status_t rv;\n    char c;\n    const char *opt_arg;\n    const char *err = NULL;\n#if APR_FILES_AS_SOCKETS\n    apr_pollfd_t pollfd = { 0 };\n    apr_status_t pollret = APR_SUCCESS;\n    int polltimeout;\n#endif\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    memset(&config, 0, sizeof config);\n    memset(&status, 0, sizeof status);\n    status.rotateReason = ROTATE_NONE;\n\n    apr_pool_create(&status.pool, NULL);\n    apr_getopt_init(&opt, status.pool, argc, argv);\n#if APR_FILES_AS_SOCKETS\n    while ((rv = apr_getopt(opt, \"lL:p:ftvec\", &c, &opt_arg)) == APR_SUCCESS) {\n#else\n    while ((rv = apr_getopt(opt, \"lL:p:ftve\", &c, &opt_arg)) == APR_SUCCESS) {\n#endif\n        switch (c) {\n        case 'l':\n            config.use_localtime = 1;\n            break;\n        case 'L':\n            config.linkfile = opt_arg;\n            break;\n        case 'p':\n            config.postrotate_prog = opt_arg;\n            break;\n        case 'f':\n            config.force_open = 1;\n            break;\n        case 't':\n            config.truncate = 1;\n            break;\n        case 'v':\n            config.verbose = 1;\n            break;\n        case 'e':\n            config.echo = 1;\n            break;\n#if APR_FILES_AS_SOCKETS\n        case 'c':\n            config.create_empty = 1;\n            break;\n#endif\n        }\n    }\n\n    if (rv != APR_EOF) {\n        usage(argv[0], NULL  );\n    }\n\n    /*\n     * After the initial flags we need 2 to 4 arguments,\n     * the file name, either the rotation interval time or size\n     * or both of them, and optionally the UTC offset.\n     */\n    if ((argc - opt->ind < 2) || (argc - opt->ind > 4) ) {\n        usage(argv[0], \"Incorrect number of arguments\");\n    }\n\n    config.szLogRoot = argv[opt->ind++];\n\n    \n    for(; opt->ind < argc; opt->ind++) {\n        if ((err = get_time_or_size(&config, argv[opt->ind],\n                                    opt->ind < argc - 1 ? 0 : 1)) != NULL) {\n            usage(argv[0], err);\n        }\n    }\n\n    config.use_strftime = (strchr(config.szLogRoot, '%') != NULL);\n\n    if (apr_file_open_stdin(&f_stdin, status.pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    if (apr_file_open_stdout(&f_stdout, status.pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdout\\n\");\n        exit(1);\n    }\n\n    /*\n     * Write out result of config parsing if verbose is set.\n     */\n    if (config.verbose) {\n        dumpConfig(&config);\n    }\n\n#if APR_FILES_AS_SOCKETS\n    if (config.create_empty && config.tRotation) {\n        pollfd.p = status.pool;\n        pollfd.desc_type = APR_POLL_FILE;\n        pollfd.reqevents = APR_POLLIN;\n        pollfd.desc.f = f_stdin;\n    }\n#endif\n\n    /*\n     * Immediately open the logfile as we start, if we were forced\n     * to do so via '-f'.\n     */\n    if (config.force_open) {\n        doRotate(&config, &status);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n#if APR_FILES_AS_SOCKETS\n        if (config.create_empty && config.tRotation) {\n            polltimeout = status.tLogEnd ? status.tLogEnd - get_now(&config) : config.tRotation;\n            if (polltimeout <= 0) {\n                pollret = APR_TIMEUP;\n            }\n            else {\n                pollret = apr_poll(&pollfd, 1, &pollret, apr_time_from_sec(polltimeout));\n            }\n        }\n        if (pollret == APR_SUCCESS) {\n            rv = apr_file_read(f_stdin, buf, &nRead);\n            if (APR_STATUS_IS_EOF(rv)) {\n                break;\n            }\n            else if (rv != APR_SUCCESS) {\n                exit(3);\n            }\n        }\n        else if (pollret == APR_TIMEUP) {\n            *buf = 0;\n            nRead = 0;\n        }\n        else {\n            fprintf(stderr, \"Unable to poll stdin\\n\");\n            exit(5);\n        }\n#else \n        rv = apr_file_read(f_stdin, buf, &nRead);\n        if (APR_STATUS_IS_EOF(rv)) {\n            break;\n        }\n        else if (rv != APR_SUCCESS) {\n            exit(3);\n        }\n#endif \n        checkRotate(&config, &status);\n        if (status.rotateReason != ROTATE_NONE) {\n            doRotate(&config, &status);\n        }\n\n        nWrite = nRead;\n        rv = apr_file_write_full(status.current.fd, buf, nWrite, &nWrite);\n        if (nWrite != nRead) {\n            apr_off_t cur_offset;\n\n            cur_offset = 0;\n            if (apr_file_seek(status.current.fd, APR_CUR, &cur_offset) != APR_SUCCESS) {\n                cur_offset = -1;\n            }\n            status.nMessCount++;\n            apr_snprintf(status.errbuf, sizeof status.errbuf,\n                         \"Error %d writing to log file at offset %\" APR_OFF_T_FMT \". \"\n                         \"%10d messages lost (%pm)\\n\",\n                         rv, cur_offset, status.nMessCount, &rv);\n\n            truncate_and_write_error(&status);\n        }\n        else {\n            status.nMessCount++;\n        }\n        if (config.echo) {\n            if (apr_file_write_full(f_stdout, buf, nRead, &nWrite)) {\n                fprintf(stderr, \"Unable to write to stdout\\n\");\n                exit(4);\n            }\n        }\n    }\n\n    return 0; \n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_3a8cbeacf6f32ae83a150500b2d2e49bd2659335_0", {
    "ID": "httpd_3a8cbeacf6f32ae83a150500b2d2e49bd2659335_0",
    "UID": "1707",
    "code": "static int spool_reqbody_cl(apr_pool_t test_snippet\n                                     request_rec *r,\n                                     proxy_conn_rec *p_conn,\n                                     conn_rec *origin,\n                                     apr_bucket_brigade *header_brigade,\n                                     apr_bucket_brigade *input_brigade,\n                                     int force_cl)\n{\n    int seen_eos = 0;\n    apr_status_t status;\n    apr_bucket_alloc_t *bucket_alloc = r->connection->bucket_alloc;\n    apr_bucket_brigade *body_brigade;\n    apr_bucket *e;\n    apr_off_t bytes, bytes_spooled = 0, fsize = 0;\n    apr_file_t *tmpfile = NULL;\n    apr_off_t limit;\n\n    body_brigade = apr_brigade_create(p, bucket_alloc);\n\n    limit = ap_get_limit_req_body(r);\n\n    while (!APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(input_brigade)))\n    {\n        \n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n            seen_eos = 1;\n\n            \n            e = APR_BRIGADE_LAST(input_brigade);\n            apr_bucket_delete(e);\n        }\n\n        apr_brigade_length(input_brigade, 1, &bytes);\n\n        if (bytes_spooled + bytes > MAX_MEM_SPOOL) {\n            /*\n             * LimitRequestBody does not affect Proxy requests (Should it?).\n             * Let it take effect if we decide to store the body in a\n             * temporary file on disk.\n             */\n            if (limit && (bytes_spooled + bytes > limit)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01088)\n                              \"Request body is larger than the configured \"\n                              \"limit of %\" APR_OFF_T_FMT, limit);\n                return HTTP_REQUEST_ENTITY_TOO_LARGE;\n            }\n            \n            if (tmpfile == NULL) {\n                const char *temp_dir;\n                char *template;\n\n                status = apr_temp_dir_get(&temp_dir, p);\n                if (status != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01089)\n                                  \"search for temporary directory failed\");\n                    return HTTP_INTERNAL_SERVER_ERROR;\n                }\n                apr_filepath_merge(&template, temp_dir,\n                                   \"modproxy.tmp.XXXXXX\",\n                                   APR_FILEPATH_NATIVE, p);\n                status = apr_file_mktemp(&tmpfile, template, 0, p);\n                if (status != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01090)\n                                  \"creation of temporary file in directory \"\n                                  \"%s failed\", temp_dir);\n                    return HTTP_INTERNAL_SERVER_ERROR;\n                }\n            }\n            for (e = APR_BRIGADE_FIRST(input_brigade);\n                 e != APR_BRIGADE_SENTINEL(input_brigade);\n                 e = APR_BUCKET_NEXT(e)) {\n                const char *data;\n                apr_size_t bytes_read, bytes_written;\n\n                apr_bucket_read(e, &data, &bytes_read, APR_BLOCK_READ);\n                status = apr_file_write_full(tmpfile, data, bytes_read, &bytes_written);\n                if (status != APR_SUCCESS) {\n                    const char *tmpfile_name;\n\n                    if (apr_file_name_get(&tmpfile_name, tmpfile) != APR_SUCCESS) {\n                        tmpfile_name = \"(unknown)\";\n                    }\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01091)\n                                  \"write to temporary file %s failed\",\n                                  tmpfile_name);\n                    return HTTP_INTERNAL_SERVER_ERROR;\n                }\n                AP_DEBUG_ASSERT(bytes_read == bytes_written);\n                fsize += bytes_written;\n            }\n            apr_brigade_cleanup(input_brigade);\n        }\n        else {\n\n            /*\n             * Save input_brigade in body_brigade. (At least) in the SSL case\n             * input_brigade contains transient buckets whose data would get\n             * overwritten during the next call of ap_get_brigade in the loop.\n             * ap_save_brigade ensures these buckets to be set aside.\n             * Calling ap_save_brigade with NULL as filter is OK, because\n             * body_brigade already has been created and does not need to get\n             * created by ap_save_brigade.\n             */\n            status = ap_save_brigade(NULL, &body_brigade, &input_brigade, p);\n            if (status != APR_SUCCESS) {\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n        }\n\n        bytes_spooled += bytes;\n\n        if (seen_eos) {\n            break;\n        }\n\n        status = ap_get_brigade(r->input_filters, input_brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                HUGE_STRING_LEN);\n\n        if (status != APR_SUCCESS) {\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (bytes_spooled || force_cl) {\n        add_cl(p, bucket_alloc, header_brigade, apr_off_t_toa(p, bytes_spooled));\n    }\n    terminate_headers(bucket_alloc, header_brigade);\n    APR_BRIGADE_CONCAT(header_brigade, body_brigade);\n    if (tmpfile) {\n        apr_brigade_insert_file(header_brigade, tmpfile, 0, fsize, p);\n    }\n    if (apr_table_get(r->subprocess_env, \"proxy-sendextracrlf\")) {\n        e = apr_bucket_immortal_create(ASCII_CRLF, 2, bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n    }\n    \n    return(ap_proxy_pass_brigade(bucket_alloc, r, p_conn, origin, header_brigade, 1));\n}",
    "predicted": "377,Insecure Temporary File"
  },
  "httpd_4e2709bf709387b6d678f120f5571fb11803a8a2_0", {
    "ID": "httpd_4e2709bf709387b6d678f120f5571fb11803a8a2_0",
    "UID": "1713",
    "code": "AP_DECLARE(void) ap_skiplist_free(ap_skiplist *sl, void test_snippet\n{\n    if (!sl->pool) {\n        free(mem);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_40cda893af0725c8bed49bf65c397d3ea94b7d4e_0", {
    "ID": "httpd_40cda893af0725c8bed49bf65c397d3ea94b7d4e_0",
    "UID": "1714",
    "code": "static void * APR_THREAD_FUNC listener_thread(apr_thread_t * thd, void test_snippet\n{\n    timer_event_t *ep;\n    timer_event_t *te;\n    apr_status_t rc;\n    proc_info *ti = dummy;\n    int process_slot = ti->pid;\n    apr_pool_t *tpool = apr_thread_pool_get(thd);\n    void *csd = NULL;\n    apr_pool_t *ptrans;         \n    ap_listen_rec *lr;\n    int have_idle_worker = 0;\n    event_conn_state_t *cs;\n    const apr_pollfd_t *out_pfd;\n    apr_int32_t num = 0;\n    apr_interval_time_t timeout_interval;\n    apr_time_t timeout_time = 0, now, last_log;\n    listener_poll_type *pt;\n    int closed = 0, listeners_disabled = 0;\n\n    last_log = apr_time_now();\n    free(ti);\n\n    /* the following times out events that are really close in the future\n     *   to prevent extra poll calls\n     *\n     * current value is .1 second\n     */\n#define TIMEOUT_FUDGE_FACTOR 100000\n#define EVENT_FUDGE_FACTOR 10000\n\n    rc = init_pollset(tpool);\n    if (rc != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf,\n                     \"failed to initialize pollset, \"\n                     \"attempting to shutdown process gracefully\");\n        signal_threads(ST_GRACEFUL);\n        return NULL;\n    }\n\n    /* Unblock the signal used to wake this thread up, and set a handler for\n     * it.\n     */\n    unblock_signal(LISTENER_SIGNAL);\n    apr_signal(LISTENER_SIGNAL, dummy_signal_handler);\n\n    for (;;) {\n        int workers_were_busy = 0;\n        if (listener_may_exit) {\n            close_listeners(process_slot, &closed);\n            if (terminate_mode == ST_UNGRACEFUL\n                || apr_atomic_read32(&connection_count) == 0)\n                break;\n        }\n\n        if (conns_this_child <= 0)\n            check_infinite_requests();\n\n        now = apr_time_now();\n        if (APLOGtrace6(ap_server_conf)) {\n            \n            if (now - last_log > apr_time_from_msec(1000)) {\n                last_log = now;\n                apr_thread_mutex_lock(timeout_mutex);\n                ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, ap_server_conf,\n                             \"connections: %u (clogged: %u write-completion: %d \"\n                             \"keep-alive: %d lingering: %d suspended: %u)\",\n                             apr_atomic_read32(&connection_count),\n                             apr_atomic_read32(&clogged_count),\n                             write_completion_q.count,\n                             keepalive_q.count,\n                             apr_atomic_read32(&lingering_count),\n                             apr_atomic_read32(&suspended_count));\n                apr_thread_mutex_unlock(timeout_mutex);\n            }\n        }\n\n        apr_thread_mutex_lock(g_timer_skiplist_mtx);\n        te = ap_skiplist_peek(timer_skiplist);\n        if (te) {\n            if (te->when > now) {\n                timeout_interval = te->when - now;\n            }\n            else {\n                timeout_interval = 1;\n            }\n        }\n        else {\n            timeout_interval = apr_time_from_msec(100);\n        }\n        apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n\n#if HAVE_SERF\n        rc = serf_context_prerun(g_serf);\n        if (rc != APR_SUCCESS) {\n            \n        }\n#endif\n        rc = apr_pollset_poll(event_pollset, timeout_interval, &num, &out_pfd);\n        if (rc != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rc)) {\n                continue;\n            }\n            if (!APR_STATUS_IS_TIMEUP(rc)) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT, rc, ap_server_conf,\n                             \"apr_pollset_poll failed.  Attempting to \"\n                             \"shutdown process gracefully\");\n                signal_threads(ST_GRACEFUL);\n            }\n        }\n\n        if (listener_may_exit) {\n            close_listeners(process_slot, &closed);\n            if (terminate_mode == ST_UNGRACEFUL\n                || apr_atomic_read32(&connection_count) == 0)\n                break;\n        }\n\n        now = apr_time_now();\n        apr_thread_mutex_lock(g_timer_skiplist_mtx);\n        ep = ap_skiplist_peek(timer_skiplist);\n        while (ep) {\n            if (ep->when < now + EVENT_FUDGE_FACTOR) {\n                ap_skiplist_pop(timer_skiplist, NULL);\n                push_timer2worker(ep);\n            }\n            else {\n                break;\n            }\n            ep = ap_skiplist_peek(timer_skiplist);\n        }\n        apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n\n        while (num) {\n            pt = (listener_poll_type *) out_pfd->client_data;\n            if (pt->type == PT_CSD) {\n                \n                struct timeout_queue *remove_from_q = &write_completion_q;\n                int blocking = 1;\n                cs = (event_conn_state_t *) pt->baton;\n                switch (cs->pub.state) {\n                case CONN_STATE_CHECK_REQUEST_LINE_READABLE:\n                    cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n                    remove_from_q = &keepalive_q;\n                    \n                    blocking = 0;\n                    \n                case CONN_STATE_WRITE_COMPLETION:\n                    get_worker(&have_idle_worker, blocking,\n                               &workers_were_busy);\n                    apr_thread_mutex_lock(timeout_mutex);\n                    TO_QUEUE_REMOVE(*remove_from_q, cs);\n                    rc = apr_pollset_remove(event_pollset, &cs->pfd);\n\n                    /*\n                     * Some of the pollset backends, like KQueue or Epoll\n                     * automagically remove the FD if the socket is closed,\n                     * therefore, we can accept _SUCCESS or _NOTFOUND,\n                     * and we still want to keep going\n                     */\n                    if (rc != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rc)) {\n                        ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf,\n                                     \"pollset remove failed\");\n                        apr_thread_mutex_unlock(timeout_mutex);\n                        start_lingering_close_nonblocking(cs);\n                        break;\n                    }\n\n                    apr_thread_mutex_unlock(timeout_mutex);\n                    TO_QUEUE_ELEM_INIT(cs);\n                    /* If we didn't get a worker immediately for a keep-alive\n                     * request, we close the connection, so that the client can\n                     * re-connect to a different process.\n                     */\n                    if (!have_idle_worker) {\n                        start_lingering_close_nonblocking(cs);\n                        break;\n                    }\n                    rc = push2worker(out_pfd, event_pollset);\n                    if (rc != APR_SUCCESS) {\n                        ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                     ap_server_conf, \"push2worker failed\");\n                    }\n                    else {\n                        have_idle_worker = 0;\n                    }\n                    break;\n                case CONN_STATE_LINGER_NORMAL:\n                case CONN_STATE_LINGER_SHORT:\n                    process_lingering_close(cs, out_pfd);\n                    break;\n                default:\n                    ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                 ap_server_conf,\n                                 \"event_loop: unexpected state %d\",\n                                 cs->pub.state);\n                    ap_assert(0);\n                }\n            }\n            else if (pt->type == PT_ACCEPT) {\n                \n                if (workers_were_busy) {\n                    if (!listeners_disabled)\n                        disable_listensocks(process_slot);\n                    listeners_disabled = 1;\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                                 \"All workers busy, not accepting new conns\"\n                                 \"in this process\");\n                }\n                else if (  (int)apr_atomic_read32(&connection_count)\n                           - (int)apr_atomic_read32(&lingering_count)\n                         > threads_per_child\n                           + ap_queue_info_get_idlers(worker_queue_info) *\n                             worker_factor / WORKER_FACTOR_SCALE)\n                {\n                    if (!listeners_disabled)\n                        disable_listensocks(process_slot);\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                                 \"Too many open connections (%u), \"\n                                 \"not accepting new conns in this process\",\n                                 apr_atomic_read32(&connection_count));\n                    ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, ap_server_conf,\n                                 \"Idle workers: %u\",\n                                 ap_queue_info_get_idlers(worker_queue_info));\n                    listeners_disabled = 1;\n                }\n                else if (listeners_disabled) {\n                    listeners_disabled = 0;\n                    enable_listensocks(process_slot);\n                }\n                if (!listeners_disabled) {\n                    lr = (ap_listen_rec *) pt->baton;\n                    ap_pop_pool(&ptrans, worker_queue_info);\n\n                    if (ptrans == NULL) {\n                        \n                        apr_allocator_t *allocator;\n\n                        apr_allocator_create(&allocator);\n                        apr_allocator_max_free_set(allocator,\n                                                   ap_max_mem_free);\n                        apr_pool_create_ex(&ptrans, pconf, NULL, allocator);\n                        apr_allocator_owner_set(allocator, ptrans);\n                        if (ptrans == NULL) {\n                            ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                         ap_server_conf,\n                                         \"Failed to create transaction pool\");\n                            signal_threads(ST_GRACEFUL);\n                            return NULL;\n                        }\n                    }\n                    apr_pool_tag(ptrans, \"transaction\");\n\n                    get_worker(&have_idle_worker, 1, &workers_were_busy);\n                    rc = lr->accept_func(&csd, lr, ptrans);\n\n                    /* later we trash rv and rely on csd to indicate\n                     * success/failure\n                     */\n                    AP_DEBUG_ASSERT(rc == APR_SUCCESS || !csd);\n\n                    if (rc == APR_EGENERAL) {\n                        \n                        resource_shortage = 1;\n                        signal_threads(ST_GRACEFUL);\n                    }\n\n                    if (csd != NULL) {\n                        conns_this_child--;\n                        rc = ap_queue_push(worker_queue, csd, NULL, ptrans);\n                        if (rc != APR_SUCCESS) {\n                            /* trash the connection; we couldn't queue the connected\n                             * socket to a worker\n                             */\n                            apr_socket_close(csd);\n                            ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                         ap_server_conf,\n                                         \"ap_queue_push failed\");\n                            apr_pool_clear(ptrans);\n                            ap_push_pool(worker_queue_info, ptrans);\n                        }\n                        else {\n                            have_idle_worker = 0;\n                        }\n                    }\n                    else {\n                        apr_pool_clear(ptrans);\n                        ap_push_pool(worker_queue_info, ptrans);\n                    }\n                }\n            }               \n#if HAVE_SERF\n            else if (pt->type == PT_SERF) {\n                \n                \n                serf_event_trigger(g_serf, pt->baton, out_pfd);\n            }\n#endif\n            out_pfd++;\n            num--;\n        }                   \n\n        /* XXX possible optimization: stash the current time for use as\n         * r->request_time for new requests\n         */\n        now = apr_time_now();\n        \n        if (now > timeout_time) {\n            struct process_score *ps;\n            timeout_time = now + TIMEOUT_FUDGE_FACTOR;\n\n            \n            apr_thread_mutex_lock(timeout_mutex);\n\n            \n            /* If all workers are busy, we kill older keep-alive connections so that they\n             * may connect to another process.\n             */\n            if (workers_were_busy && keepalive_q.count) {\n                ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, ap_server_conf,\n                             \"All workers are busy, will close %d keep-alive \"\n                             \"connections\",\n                             keepalive_q.count);\n                process_timeout_queue(&keepalive_q,\n                                      timeout_time + ap_server_conf->keep_alive_timeout,\n                                      start_lingering_close_nonblocking);\n            }\n            else {\n                process_timeout_queue(&keepalive_q, timeout_time,\n                                      start_lingering_close_nonblocking);\n            }\n            \n            process_timeout_queue(&write_completion_q, timeout_time,\n                                  start_lingering_close_nonblocking);\n            \n            process_timeout_queue(&linger_q, timeout_time, stop_lingering_close);\n            \n            process_timeout_queue(&short_linger_q, timeout_time, stop_lingering_close);\n\n            ps = ap_get_scoreboard_process(process_slot);\n            ps->write_completion = write_completion_q.count;\n            ps->keep_alive = keepalive_q.count;\n            apr_thread_mutex_unlock(timeout_mutex);\n\n            ps->connections = apr_atomic_read32(&connection_count);\n            ps->suspended = apr_atomic_read32(&suspended_count);\n            ps->lingering_close = apr_atomic_read32(&lingering_count);\n        }\n        if (listeners_disabled && !workers_were_busy\n            && (int)apr_atomic_read32(&connection_count)\n               - (int)apr_atomic_read32(&lingering_count)\n               < ((int)ap_queue_info_get_idlers(worker_queue_info) - 1)\n                 * worker_factor / WORKER_FACTOR_SCALE + threads_per_child)\n        {\n            listeners_disabled = 0;\n            enable_listensocks(process_slot);\n        }\n        /*\n         * XXX: do we need to set some timeout that re-enables the listensocks\n         * XXX: in case no other event occurs?\n         */\n    }     \n\n    close_listeners(process_slot, &closed);\n    ap_queue_term(worker_queue);\n\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}",
    "predicted": "415,Double Free"
  },
  "httpd_982e421ab65b2fc5fb5a3e039ac604804226af79_0", {
    "ID": "httpd_982e421ab65b2fc5fb5a3e039ac604804226af79_0",
    "UID": "1716",
    "code": "static apr_status_t socket_connect_un(apr_socket_t test_snippet\n                                      struct sockaddr_un *sa)\n{\n    apr_status_t rv;\n    apr_os_sock_t rawsock;\n    apr_interval_time_t t;\n\n    rv = apr_os_sock_get(&rawsock, sock);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    rv = apr_socket_timeout_get(sock, &t);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    do {\n        const socklen_t addrlen = APR_OFFSETOF(struct sockaddr_un, sun_path)\n                                  + strlen(sa->sun_path) + 1;\n        rv = connect(rawsock, (struct sockaddr*)sa, addrlen);\n    } while (rv == -1 && errno == EINTR);\n\n    if ((rv == -1) && (errno == EINPROGRESS || errno == EALREADY)\n        && (t > 0)) {\n#if APR_MAJOR_VERSION < 2\n        rv = apr_wait_for_io_or_timeout(NULL, sock, 0);\n#else\n        rv = apr_socket_wait(sock, APR_WAIT_WRITE);\n#endif\n\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    if (rv == -1 && errno != EISCONN) {\n        return errno;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_1f56b5edcf06a39f8e7e764849cd45a42218da2a_0", {
    "ID": "httpd_1f56b5edcf06a39f8e7e764849cd45a42218da2a_0",
    "UID": "1717",
    "code": "static void log_error_core(const char *file, int line, int test_snippet\n                           int level,\n                           apr_status_t status, const server_rec *s,\n                           const conn_rec *c,\n                           const request_rec *r, apr_pool_t *pool,\n                           const char *fmt, va_list args)\n{\n    char errstr[MAX_STRING_LEN];\n    apr_file_t *logf = NULL;\n    int level_and_mask = level & APLOG_LEVELMASK;\n    const request_rec *rmain = NULL;\n    core_server_config *sconf = NULL;\n    ap_errorlog_info info;\n\n    \n    int log_conn_info = 0, log_req_info = 0;\n    apr_array_header_t **lines = NULL;\n    int done = 0;\n    int line_number = 0;\n\n    if (r) {\n        AP_DEBUG_ASSERT(r->connection != NULL);\n        c = r->connection;\n    }\n\n    if (s == NULL) {\n        /*\n         * If we are doing stderr logging (startup), don't log messages that are\n         * above the default server log level unless it is a startup/shutdown\n         * notice\n         */\n#ifndef DEBUG\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > ap_default_loglevel)) {\n            return;\n        }\n#endif\n\n        logf = stderr_log;\n    }\n    else {\n        int configured_level = r ? ap_get_request_module_loglevel(r, module_index)        :\n                               c ? ap_get_conn_server_module_loglevel(c, s, module_index) :\n                                   ap_get_server_module_loglevel(s, module_index);\n        if (s->error_log) {\n            /*\n             * If we are doing normal logging, don't log messages that are\n             * above the module's log level unless it is a startup/shutdown notice\n             */\n            if ((level_and_mask != APLOG_NOTICE)\n                && (level_and_mask > configured_level)) {\n                return;\n            }\n\n            logf = s->error_log;\n        }\n        else {\n            /*\n             * If we are doing syslog logging, don't log messages that are\n             * above the module's log level (including a startup/shutdown notice)\n             */\n            if (level_and_mask > configured_level) {\n                return;\n            }\n        }\n\n        \n        if (s->module_config) {\n            sconf = ap_get_core_module_config(s->module_config);\n            if (c && !c->log_id) {\n                add_log_id(c, NULL);\n                if (sconf->error_log_conn && sconf->error_log_conn->nelts > 0)\n                    log_conn_info = 1;\n            }\n            if (r) {\n                if (r->main)\n                    rmain = r->main;\n                else\n                    rmain = r;\n\n                if (!rmain->log_id) {\n                    \n                    if (sconf->error_log_req && sconf->error_log_req->nelts > 0)\n                        log_req_info = 1;\n                    /*\n                     * XXX: potential optimization: only create log id if %L is\n                     * XXX: actually used\n                     */\n                    add_log_id(c, rmain);\n                }\n            }\n        }\n    }\n\n    info.s             = s;\n    info.c             = c;\n    info.pool          = pool;\n    info.file          = NULL;\n    info.line          = 0;\n    info.status        = 0;\n    info.using_syslog  = (logf == NULL);\n    info.startup       = ((level & APLOG_STARTUP) == APLOG_STARTUP);\n    info.format        = fmt;\n\n    while (!done) {\n        apr_array_header_t *log_format;\n        int len = 0, errstr_start = 0, errstr_end = 0;\n        \n        if (log_conn_info) {\n            \n            if (line_number == 0) {\n                lines = (apr_array_header_t **)sconf->error_log_conn->elts;\n                info.r = NULL;\n                info.rmain = NULL;\n                info.level = -1;\n                info.module_index = APLOG_NO_MODULE;\n            }\n\n            log_format = lines[line_number++];\n\n            if (line_number == sconf->error_log_conn->nelts) {\n                \n                line_number = 0;\n                log_conn_info = 0;\n            }\n        }\n        else if (log_req_info) {\n            \n            if (line_number == 0) {\n                lines = (apr_array_header_t **)sconf->error_log_req->elts;\n                info.r = rmain;\n                info.rmain = rmain;\n                info.level = -1;\n                info.module_index = APLOG_NO_MODULE;\n            }\n\n            log_format = lines[line_number++];\n\n            if (line_number == sconf->error_log_req->nelts) {\n                \n                line_number = 0;\n                log_req_info = 0;\n            }\n        }\n        else {\n            \n            info.r            = r;\n            info.rmain        = rmain;\n            info.level        = level_and_mask;\n            info.module_index = module_index;\n            info.file         = file;\n            info.line         = line;\n            info.status       = status;\n            log_format = sconf ? sconf->error_log_format : NULL;\n            done = 1;\n        }\n\n        /*\n         * prepare and log one line\n         */\n\n        if (log_format) {\n            len += do_errorlog_format(log_format, &info, errstr + len,\n                                      MAX_STRING_LEN - len,\n                                      &errstr_start, &errstr_end, fmt, args);\n        }\n        else {\n            len += do_errorlog_default(&info, errstr + len, MAX_STRING_LEN - len,\n                                       &errstr_start, &errstr_end, fmt, args);\n        }\n\n        if (!*errstr) {\n            /*\n             * Don't log empty lines. This can happen with once-per-conn/req\n             * info if an item with AP_ERRORLOG_FLAG_REQUIRED is NULL.\n             */\n            continue;\n        }\n        write_logline(errstr, len, logf, level_and_mask);\n\n        if (done) {\n            /*\n             * We don't call the error_log hook for per-request/per-conn\n             * lines, and we only pass the actual log message, not the\n             * prefix and suffix.\n             */\n            errstr[errstr_end] = '\\0';\n            ap_run_error_log(&info, errstr + errstr_start);\n        }\n\n        *errstr = '\\0';\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_fb34e917dda1c3c381953d10aec1c445fb359b62_0", {
    "ID": "httpd_fb34e917dda1c3c381953d10aec1c445fb359b62_0",
    "UID": "1718",
    "code": "static apr_status_t proxy_buckets_lifetime_transform(request_rec test_snippet\n        apr_bucket_brigade *from, apr_bucket_brigade *to)\n{\n    apr_bucket *e;\n    apr_bucket *new;\n    const char *data;\n    apr_size_t bytes;\n    apr_status_t rv = APR_SUCCESS;\n\n    apr_brigade_cleanup(to);\n    for (e = APR_BRIGADE_FIRST(from);\n         e != APR_BRIGADE_SENTINEL(from);\n         e = APR_BUCKET_NEXT(e)) {\n        if (!APR_BUCKET_IS_METADATA(e)) {\n            apr_bucket_read(e, &data, &bytes, APR_BLOCK_READ);\n            new = apr_bucket_transient_create(data, bytes, r->connection->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(to, new);\n        }\n        else if (APR_BUCKET_IS_FLUSH(e)) {\n            new = apr_bucket_flush_create(r->connection->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(to, new);\n        }\n        else if (APR_BUCKET_IS_EOS(e)) {\n            new = apr_bucket_eos_create(r->connection->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(to, new);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00964)\n                          \"Unhandled bucket type of type %s in\"\n                          \" proxy_buckets_lifetime_transform\", e->type->name);\n            apr_bucket_delete(e);\n            rv = APR_EGENERAL;\n        }\n    }\n    return rv;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_3b6b70171f364b8d2b45a6df80f9d63369efe716_0", {
    "ID": "httpd_3b6b70171f364b8d2b45a6df80f9d63369efe716_0",
    "UID": "1725",
    "code": "static apr_status_t store_body(cache_handle_t *h, request_rec test_snippet\n                               apr_bucket_brigade *in, apr_bucket_brigade *out)\n{\n    apr_bucket *e;\n    apr_status_t rv = APR_SUCCESS;\n    disk_cache_object_t *dobj = (disk_cache_object_t *) h->cache_obj->vobj;\n    disk_cache_dir_conf *dconf = ap_get_module_config(r->per_dir_config, &cache_disk_module);\n    int seen_eos = 0;\n\n    if (!dobj->offset) {\n        dobj->offset = dconf->readsize;\n    }\n    if (!dobj->timeout && dconf->readtime) {\n        dobj->timeout = apr_time_now() + dconf->readtime;\n    }\n\n    if (dobj->offset) {\n        apr_brigade_partition(in, dobj->offset, &e);\n    }\n\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(in)) {\n        const char *str;\n        apr_size_t length, written;\n\n        e = APR_BRIGADE_FIRST(in);\n\n        \n        if (dobj->done || !dobj->data.pool) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        \n        if (APR_BUCKET_IS_EOS(e)) {\n            seen_eos = 1;\n            dobj->done = 1;\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        \n        if (APR_BUCKET_IS_FLUSH(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        \n        if (APR_BUCKET_IS_METADATA(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        \n        rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(out, e);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00730)\n                    \"Error when reading bucket for URL %s\",\n                    h->cache_obj->key);\n            \n            apr_pool_destroy(dobj->data.pool);\n            return rv;\n        }\n\n        \n        if (!length) {\n            continue;\n        }\n\n        /* Attempt to create the data file at the last possible moment, if\n         * the body is empty, we don't write a file at all, and save an inode.\n         */\n        if (!dobj->data.tempfd) {\n            apr_finfo_t finfo;\n            rv = apr_file_mktemp(&dobj->data.tempfd, dobj->data.tempfile,\n                                 APR_CREATE | APR_WRITE | APR_BINARY |\n                                 APR_BUFFERED | APR_EXCL, dobj->data.pool);\n            if (rv != APR_SUCCESS) {\n                apr_pool_destroy(dobj->data.pool);\n                return rv;\n            }\n            dobj->file_size = 0;\n            rv = apr_file_info_get(&finfo, APR_FINFO_IDENT,\n                    dobj->data.tempfd);\n            if (rv != APR_SUCCESS) {\n                apr_pool_destroy(dobj->data.pool);\n                return rv;\n            }\n            dobj->disk_info.device = finfo.device;\n            dobj->disk_info.inode = finfo.inode;\n            dobj->disk_info.has_body = 1;\n        }\n\n        \n        rv = apr_file_write_full(dobj->data.tempfd, str, length, &written);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00731)\n                    \"Error when writing cache file for URL %s\",\n                    h->cache_obj->key);\n            \n            apr_pool_destroy(dobj->data.pool);\n            return rv;\n        }\n        dobj->file_size += written;\n        if (dobj->file_size > dconf->maxfs) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00732)\n                    \"URL %s failed the size check \"\n                    \"(%\" APR_OFF_T_FMT \">%\" APR_OFF_T_FMT \")\",\n                    h->cache_obj->key, dobj->file_size, dconf->maxfs);\n            \n            apr_pool_destroy(dobj->data.pool);\n            return APR_EGENERAL;\n        }\n\n        /* have we reached the limit of how much we're prepared to write in one\n         * go? If so, leave, we'll get called again. This prevents us from trying\n         * to swallow too much data at once, or taking so long to write the data\n         * the client times out.\n         */\n        dobj->offset -= length;\n        if (dobj->offset <= 0) {\n            dobj->offset = 0;\n            break;\n        }\n        if ((dconf->readtime && apr_time_now() > dobj->timeout)) {\n            dobj->timeout = 0;\n            break;\n        }\n\n    }\n\n    /* Was this the final bucket? If yes, close the temp file and perform\n     * sanity checks.\n     */\n    if (seen_eos) {\n        const char *cl_header = apr_table_get(r->headers_out, \"Content-Length\");\n\n        if (dobj->data.tempfd) {\n            rv = apr_file_close(dobj->data.tempfd);\n            if (rv != APR_SUCCESS) {\n                \n                apr_pool_destroy(dobj->data.pool);\n                return rv;\n            }\n        }\n\n        if (r->connection->aborted || r->no_cache) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00733)\n                    \"Discarding body for URL %s \"\n                    \"because connection has been aborted.\",\n                    h->cache_obj->key);\n            \n            apr_pool_destroy(dobj->data.pool);\n            return APR_EGENERAL;\n        }\n        if (dobj->file_size < dconf->minfs) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00734)\n                    \"URL %s failed the size check \"\n                    \"(%\" APR_OFF_T_FMT \"<%\" APR_OFF_T_FMT \")\",\n                    h->cache_obj->key, dobj->file_size, dconf->minfs);\n            \n            apr_pool_destroy(dobj->data.pool);\n            return APR_EGENERAL;\n        }\n        if (cl_header) {\n            apr_int64_t cl = apr_atoi64(cl_header);\n            if ((errno == 0) && (dobj->file_size != cl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00735)\n                        \"URL %s didn't receive complete response, not caching\",\n                        h->cache_obj->key);\n                \n                apr_pool_destroy(dobj->data.pool);\n                return APR_EGENERAL;\n            }\n        }\n\n        \n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9406d605cc58f557acd9f3d73ecc35f2948bdd2d_0", {
    "ID": "httpd_9406d605cc58f557acd9f3d73ecc35f2948bdd2d_0",
    "UID": "1726",
    "code": "static apr_status_t init_pollset(apr_pool_t test_snippet\n{\n#if HAVE_SERF\n    s_baton_t *baton = NULL;\n#endif\n    ap_listen_rec *lr;\n    listener_poll_type *pt;\n    int i = 0;\n\n    TO_QUEUE_INIT(write_completion_q);\n    TO_QUEUE_INIT(keepalive_q);\n    TO_QUEUE_INIT(linger_q);\n    TO_QUEUE_INIT(short_linger_q);\n\n    listener_pollfd = apr_palloc(p, sizeof(apr_pollfd_t) * num_listensocks);\n    for (lr = ap_listeners; lr != NULL; lr = lr->next, i++) {\n        apr_pollfd_t *pfd;\n        AP_DEBUG_ASSERT(i < num_listensocks);\n        pfd = &listener_pollfd[i];\n        pt = apr_pcalloc(p, sizeof(*pt));\n        pfd->desc_type = APR_POLL_SOCKET;\n        pfd->desc.s = lr->sd;\n        pfd->reqevents = APR_POLLIN;\n\n        pt->type = PT_ACCEPT;\n        pt->baton = lr;\n\n        pfd->client_data = pt;\n\n        apr_socket_opt_set(pfd->desc.s, APR_SO_NONBLOCK, 1);\n        apr_pollset_add(event_pollset, pfd);\n\n        lr->accept_func = ap_unixd_accept;\n    }\n\n#if HAVE_SERF\n    baton = apr_pcalloc(p, sizeof(*baton));\n    baton->pollset = event_pollset;\n    \n    baton->pool = p;\n\n    g_serf = serf_context_create_ex(baton,\n                                    s_socket_add,\n                                    s_socket_remove, p);\n\n    ap_register_provider(p, \"mpm_serf\",\n                         \"instance\", \"0\", g_serf);\n\n#endif\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_4286e6536cd2070e576cc76067e5ed6ddbc2bd47_0", {
    "ID": "httpd_4286e6536cd2070e576cc76067e5ed6ddbc2bd47_0",
    "UID": "1727",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_share_balancer(proxy_balancer test_snippet\n                                                    proxy_balancer_shared *shm,\n                                                    int i)\n{\n    apr_status_t rv = APR_SUCCESS;\n    proxy_balancer_method *lbmethod;\n    char *action = \"copying\";\n    if (!shm || !balancer->s)\n        return APR_EINVAL;\n\n    if ((balancer->s->hash.def != shm->hash.def) ||\n        (balancer->s->hash.fnv != shm->hash.fnv)) {\n        memcpy(shm, balancer->s, sizeof(proxy_balancer_shared));\n        if (balancer->s->was_malloced)\n            free(balancer->s);\n    } else {\n        action = \"re-using\";\n    }\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02337)\n                 \"%s shm[%d] (0x%pp) for %s\", action, i, (void *)shm,\n                 balancer->s->name);\n    balancer->s = shm;\n    balancer->s->index = i;\n    \n    lbmethod = ap_lookup_provider(PROXY_LBMETHOD, balancer->s->lbpname, \"0\");\n    if (lbmethod) {\n        balancer->lbmethod = lbmethod;\n    } else {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(02432)\n                     \"Cannot find LB Method: %s\", balancer->s->lbpname);\n        return APR_EINVAL;\n    }\n    if (*balancer->s->nonce == PROXY_UNSET_NONCE) {\n        char nonce[APR_UUID_FORMATTED_LENGTH + 1];\n        apr_uuid_t uuid;\n        /* Retrieve a UUID and store the nonce for the lifetime of\n         * the process.\n         */\n        apr_uuid_get(&uuid);\n        apr_uuid_format(nonce, &uuid);\n        rv = PROXY_STRNCPY(balancer->s->nonce, nonce);\n    }\n    return rv;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_5d9a3318adb93d9a7da9a591046de3e9b23f57d9_0", {
    "ID": "httpd_5d9a3318adb93d9a7da9a591046de3e9b23f57d9_0",
    "UID": "1729",
    "code": "static apr_status_t event_register_timed_callback(apr_time_t test_snippet\n                                                  ap_mpm_callback_fn_t *cbfn,\n                                                  void *baton)\n{\n    timer_event_t *te;\n    \n    apr_thread_mutex_lock(g_timer_skiplist_mtx);\n\n    if (!APR_RING_EMPTY(&timer_free_ring, timer_event_test_snippet link)) {\n        te = APR_RING_FIRST(&timer_free_ring);\n        APR_RING_REMOVE(te, link);\n    }\n    else {\n        te = ap_skiplist_alloc(timer_skiplistest_snippet sizeof(timer_event_t));\n        APR_RING_ELEM_INIT(te, link);\n    }\n\n    te->cbfunc = cbfn;\n    te->baton = baton;\n    \n    te->when = t + apr_time_now();\n\n    \n    ap_skiplist_insert(timer_skiplistest_snippet (void *)te);\n\n    apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c06fbdf75b987cbd1553c1ed53963af1d7c9a7a1_0", {
    "ID": "httpd_c06fbdf75b987cbd1553c1ed53963af1d7c9a7a1_0",
    "UID": "1730",
    "code": "static void process_timeout_queue(struct timeout_queue test_snippet\n                                  apr_time_t timeout_time,\n                                  int (*func)(event_conn_state_t *))\n{\n    int count = 0;\n    event_conn_state_t *first, *cs, *last;\n    apr_status_t rv;\n    if (!q->count) {\n        return;\n    }\n    AP_DEBUG_ASSERT(!APR_RING_EMPTY(&q->head, event_conn_state_t, timeout_list));\n\n    cs = first = APR_RING_FIRST(&q->head);\n    while (cs != APR_RING_SENTINEL(&q->head, event_conn_state_t, timeout_list)\n           && cs->expiration_time < timeout_time) {\n        last = cs;\n        rv = apr_pollset_remove(event_pollset, &cs->pfd);\n        if (rv != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rv)) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, cs->c, APLOGNO(00473)\n                          \"apr_pollset_remove failed\");\n        }\n        cs = APR_RING_NEXT(cs, timeout_list);\n        count++;\n    }\n    if (!count)\n        return;\n\n    APR_RING_UNSPLICE(first, last, timeout_list);\n    AP_DEBUG_ASSERT(q->count >= count);\n    q->count -= count;\n    apr_thread_mutex_unlock(timeout_mutex);\n    while (count) {\n        cs = APR_RING_NEXT(first, timeout_list);\n        TO_QUEUE_ELEM_INIT(first);\n        func(first);\n        first = cs;\n        count--;\n    }\n    apr_thread_mutex_lock(timeout_mutex);\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_2c430b4a898e0cb4d0b3f5fb08981c8704a840c5_0", {
    "ID": "httpd_2c430b4a898e0cb4d0b3f5fb08981c8704a840c5_0",
    "UID": "1731",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_ssl_connection_cleanup(proxy_conn_rec test_snippet\n                                                            request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_status_t rv;\n\n    /*\n     * If we have an existing SSL connection it might be possible that the\n     * server sent some SSL message we have not read so far (e.g. an SSL\n     * shutdown message if the server closed the keepalive connection while\n     * the connection was held unused in our pool).\n     * So ensure that if present (=> APR_NONBLOCK_READ) it is read and\n     * processed. We don't expect any data to be in the returned brigade.\n     */\n    if (conn->sock && conn->connection) {\n        bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n        rv = ap_get_brigade(conn->connection->input_filters, bb,\n                            AP_MODE_READBYTES, APR_NONBLOCK_READ,\n                            HUGE_STRING_LEN);\n        if ((rv != APR_SUCCESS) && !APR_STATUS_IS_EAGAIN(rv)) {\n            socket_cleanup(conn);\n        }\n        if (!APR_BRIGADE_EMPTY(bb)) {\n            apr_off_t len;\n\n            rv = apr_brigade_length(bb, 0, &len);\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, rv, r,\n                          \"SSL cleanup brigade contained %\"\n                          APR_OFF_T_FMT \" bytes of data.\", len);\n        }\n        apr_brigade_destroy(bb);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_b3d065d2f71eb45c454e06aaed7e74feefaf25a7_0", {
    "ID": "httpd_b3d065d2f71eb45c454e06aaed7e74feefaf25a7_0",
    "UID": "1735",
    "code": "static apr_status_t buffer_output(request_rec test_snippet\n                                  const char *str, apr_size_t len)\n{\n    conn_rec *c = r->connection;\n    ap_filter_t *f;\n    old_write_filter_ctx *ctx;\n\n    if (len == 0)\n        return APR_SUCCESS;\n\n    f = insert_old_write_filter(r);\n    ctx = f->ctx;\n\n    /* if the first filter is not our buffering filter, then we have to\n     * deliver the content through the normal filter chain\n     */\n    if (f != r->output_filters) {\n        apr_status_t rv;\n        apr_bucket *b = apr_bucket_transient_create(str, len, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, b);\n\n        rv = ap_pass_brigade(r->output_filters, ctx->tmpbb);\n        apr_brigade_cleanup(ctx->tmpbb);\n        return rv;\n    }\n\n    if (ctx->bb == NULL) {\n        ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    }\n\n    return ap_fwrite(f->next, ctx->bb, str, len);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_6ee4e9be1a7dc522c088741cd054815431e97020_0", {
    "ID": "httpd_6ee4e9be1a7dc522c088741cd054815431e97020_0",
    "UID": "1736",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_share_worker(proxy_worker *worker, proxy_worker_shared test_snippet\n                                                  int i)\n{\n    char *action = \"copying\";\n    if (!shm || !worker->s)\n        return APR_EINVAL;\n\n    if ((worker->s->hash.def != shm->hash.def) ||\n        (worker->s->hash.fnv != shm->hash.fnv)) {\n        memcpy(shm, worker->s, sizeof(proxy_worker_shared));\n        if (worker->s->was_malloced)\n            free(worker->s); \n    } else {\n        action = \"re-using\";\n    }\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02338)\n                 \"%s shm[%d] (0x%pp) for worker: %s\", action, i, (void *)shm,\n                 worker->s->name);\n\n    worker->s = shm;\n    worker->s->index = i;\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_5e47e6113f56ec34f0bdf6962e7d6bce61c4a71a_0", {
    "ID": "httpd_5e47e6113f56ec34f0bdf6962e7d6bce61c4a71a_0",
    "UID": "1738",
    "code": "AP_DECLARE(int) ap_rflush(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    apr_bucket *b;\n    ap_filter_t *f;\n    old_write_filter_ctx *ctx;\n    apr_status_t rv;\n\n    f = insert_old_write_filter(r);\n    ctx = f->ctx;\n\n    b = apr_bucket_flush_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, b);\n\n    rv = ap_pass_brigade(r->output_filters, ctx->tmpbb);\n    apr_brigade_cleanup(ctx->tmpbb);\n    if (rv != APR_SUCCESS)\n        return -1;\n\n    return 0;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_779d360ef183ceb4e2bd75c239821f86cc2e1473_0", {
    "ID": "httpd_779d360ef183ceb4e2bd75c239821f86cc2e1473_0",
    "UID": "1743",
    "code": "static void create_listener_thread(thread_starter * test_snippet\n{\n    int my_child_num = ts->child_num_arg;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    proc_info *my_info;\n    apr_status_t rv;\n\n    my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n    my_info->pid = my_child_num;\n    my_info->tid = -1;          \n    my_info->sd = 0;\n    rv = apr_thread_create(&ts->listener, thread_attr, listener_thread,\n                           my_info, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00474)\n                     \"apr_thread_create: unable to create listener thread\");\n        \n        clean_child_exit(APEXIT_CHILDSICK);\n    }\n    apr_os_thread_get(&listener_os_thread, ts->listener);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0dff7ed060257c93c391f2ce801d7db73965db4b_0", {
    "ID": "httpd_0dff7ed060257c93c391f2ce801d7db73965db4b_0",
    "UID": "1744",
    "code": "static void dav_cache_badprops(dav_walker_ctx test_snippet\n{\n    const apr_xml_elem *elem;\n    apr_text_header hdr = { 0 };\n\n    \n    if (ctx->propstat_404 != NULL) {\n        return;\n    }\n\n    apr_text_append(ctx->w.pool, &hdr,\n                    \"<D:propstat>\" DEBUG_CR\n                    \"<D:prop>\" DEBUG_CR);\n\n    elem = dav_find_child(ctx->doc->root, \"prop\");\n    for (elem = elem->first_child; elem; elem = elem->next) {\n        apr_text_append(ctx->w.pool, &hdr,\n                        apr_xml_empty_elem(ctx->w.pool, elem));\n    }\n\n    apr_text_append(ctx->w.pool, &hdr,\n                    \"</D:prop>\" DEBUG_CR\n                    \"<D:status>HTTP/1.1 404 Not Found</D:status>\" DEBUG_CR\n                    \"</D:propstat>\" DEBUG_CR);\n\n    ctx->propstat_404 = hdr.first;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_6e47d2d193b933b2c9ddabbba1b0af8803e73949_0", {
    "ID": "httpd_6e47d2d193b933b2c9ddabbba1b0af8803e73949_0",
    "UID": "1746",
    "code": "static dav_error * dav_propfind_walker(dav_walk_resource *wres, int test_snippet\n{\n    dav_walker_ctx *ctx = wres->walk_ctx;\n    dav_error *err;\n    dav_propdb *propdb;\n    dav_get_props_result propstats = { 0 };\n\n    /*\n    ** Note: ctx->doc can only be NULL for DAV_PROPFIND_IS_ALLPROP. Since\n    ** dav_get_allprops() does not need to do namespace translation,\n    ** we're okay.\n    **\n    ** Note: we cast to lose the \"const\". The propdb won't try to change\n    ** the resource, however, since we are opening readonly.\n    */\n    err = dav_open_propdb(ctx->r, ctx->w.lockdb, wres->resource, 1,\n                          ctx->doc ? ctx->doc->namespaces : NULL, &propdb);\n    if (err != NULL) {\n        \n\n        if (ctx->propfind_type == DAV_PROPFIND_IS_PROP) {\n            dav_get_props_result badprops = { 0 };\n\n            \n            dav_cache_badprops(ctx);\n            badprops.propstats = ctx->propstat_404;\n            dav_stream_response(wres, 0, &badprops, ctx->scratchpool);\n        }\n        else {\n            \n            dav_stream_response(wres, HTTP_OK, NULL, ctx->scratchpool);\n        }\n\n        apr_pool_clear(ctx->scratchpool);\n        return NULL;\n    }\n    \n\n    if (ctx->propfind_type == DAV_PROPFIND_IS_PROP) {\n        propstats = dav_get_props(propdb, ctx->doc);\n    }\n    else {\n        dav_prop_insert what = ctx->propfind_type == DAV_PROPFIND_IS_ALLPROP\n                                 ? DAV_PROP_INSERT_VALUE\n                                 : DAV_PROP_INSERT_NAME;\n        propstats = dav_get_allprops(propdb, what);\n    }\n    dav_close_propdb(propdb);\n\n    dav_stream_response(wres, 0, &propstats, ctx->scratchpool);\n\n    /* at this point, ctx->scratchpool has been used to stream a\n       single response.  this function fully controls the pool, and\n       thus has the right to clear it for the next iteration of this\n       callback. */\n    apr_pool_clear(ctx->scratchpool);\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_818f99a9dfb53607f1b9f335333b39603dcce2ce_0", {
    "ID": "httpd_818f99a9dfb53607f1b9f335333b39603dcce2ce_0",
    "UID": "1747",
    "code": "static void child_main(int test_snippet\n{\n    apr_thread_t **threads;\n    apr_status_t rv;\n    thread_starter *ts;\n    apr_threadattr_t *thread_attr;\n    apr_thread_t *start_thread_id;\n\n    mpm_state = AP_MPMQ_STARTING;       /* for benefit of any hooks that run as this\n                                         * child initializes\n                                         */\n    ap_my_pid = getpid();\n    ap_fatal_signal_child_setup(ap_server_conf);\n    apr_pool_create(&pchild, pconf);\n\n    \n    ap_reopen_scoreboard(pchild, NULL, 0);\n\n    if (ap_run_drop_privileges(pchild, ap_server_conf)) {\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    apr_thread_mutex_create(&g_timer_skiplist_mtx, APR_THREAD_MUTEX_DEFAULT, pchild);\n    APR_RING_INIT(&timer_free_ring, timer_event_t, link);\n    ap_skiplist_init(&timer_skiplist, pchild);\n    ap_skiplist_set_compare(timer_skiplist, indexing_comp, indexing_compk);\n    ap_run_child_init(pchild, ap_server_conf);\n\n    \n\n    /* Just use the standard apr_setup_signal_thread to block all signals\n     * from being received.  The child processes no longer use signals for\n     * any communication with the parent process.\n     */\n    rv = apr_setup_signal_thread();\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00479)\n                     \"Couldn't initialize signal thread\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_requests_per_child) {\n        conns_this_child = ap_max_requests_per_child;\n    }\n    else {\n        \n        conns_this_child = APR_INT32_MAX;\n    }\n\n    \n\n    /* clear the storage; we may not create all our threads immediately,\n     * and we want a 0 entry to indicate a thread which was not created\n     */\n    threads = ap_calloc(threads_per_child, sizeof(apr_thread_t *));\n    ts = apr_palloc(pchild, sizeof(*ts));\n\n    apr_threadattr_create(&thread_attr, pchild);\n    \n    apr_threadattr_detach_set(thread_attr, 0);\n\n    if (ap_thread_stacksize != 0) {\n        rv = apr_threadattr_stacksize_set(thread_attr, ap_thread_stacksize);\n        if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(02436)\n                         \"WARNING: ThreadStackSize of %\" APR_SIZE_T_FMT \" is \"\n                         \"inappropriate, using default\", \n                         ap_thread_stacksize);\n        }\n    }\n\n    ts->threads = threads;\n    ts->listener = NULL;\n    ts->child_num_arg = child_num_arg;\n    ts->threadattr = thread_attr;\n\n    rv = apr_thread_create(&start_thread_id, thread_attr, start_threads,\n                           ts, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00480)\n                     \"apr_thread_create: unable to create worker thread\");\n        \n        clean_child_exit(APEXIT_CHILDSICK);\n    }\n\n    mpm_state = AP_MPMQ_RUNNING;\n\n    /* If we are only running in one_process mode, we will want to\n     * still handle signals. */\n    if (one_process) {\n        \n        apr_signal_thread(check_signal);\n        /* make sure the start thread has finished; signal_threads()\n         * and join_workers() depend on that\n         */\n        /* XXX join_start_thread() won't be awakened if one of our\n         *     threads encounters a critical error and attempts to\n         *     shutdown this child\n         */\n        join_start_thread(start_thread_id);\n\n        /* helps us terminate a little more quickly than the dispatch of the\n         * signal thread; beats the Pipe of Death and the browsers\n         */\n        signal_threads(ST_UNGRACEFUL);\n\n        /* A terminating signal was received. Now join each of the\n         * workers to clean them up.\n         *   If the worker already exited, then the join frees\n         *   their resources and returns.\n         *   If the worker hasn't exited, then this blocks until\n         *   they have (then cleans up).\n         */\n        join_workers(ts->listener, threads);\n    }\n    else {                      \n        /* remove SIGTERM from the set of blocked signals...  if one of\n         * the other threads in the process needs to take us down\n         * (e.g., for MaxConnectionsPerChild) it will send us SIGTERM\n         */\n        unblock_signal(SIGTERM);\n        apr_signal(SIGTERM, dummy_signal_handler);\n        \n        while (1) {\n            rv = ap_mpm_podx_check(pod);\n            if (rv == AP_MPM_PODX_NORESTART) {\n                \n                switch (terminate_mode) {\n                case ST_GRACEFUL:\n                    rv = AP_MPM_PODX_GRACEFUL;\n                    break;\n                case ST_UNGRACEFUL:\n                    rv = AP_MPM_PODX_RESTART;\n                    break;\n                }\n            }\n            if (rv == AP_MPM_PODX_GRACEFUL || rv == AP_MPM_PODX_RESTART) {\n                /* make sure the start thread has finished;\n                 * signal_threads() and join_workers depend on that\n                 */\n                join_start_thread(start_thread_id);\n                signal_threads(rv ==\n                               AP_MPM_PODX_GRACEFUL ? ST_GRACEFUL : ST_UNGRACEFUL);\n                break;\n            }\n        }\n\n        /* A terminating signal was received. Now join each of the\n         * workers to clean them up.\n         *   If the worker already exited, then the join frees\n         *   their resources and returns.\n         *   If the worker hasn't exited, then this blocks until\n         *   they have (then cleans up).\n         */\n        join_workers(ts->listener, threads);\n    }\n\n    free(threads);\n\n    clean_child_exit(resource_shortage ? APEXIT_CHILDSICK : 0);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_88425a1655eed2a4049b3aa10d795aa7bdfb9e4c_0", {
    "ID": "httpd_88425a1655eed2a4049b3aa10d795aa7bdfb9e4c_0",
    "UID": "1750",
    "code": "PROXY_DECLARE(void) ap_proxy_backend_broke(request_rec test_snippet\n                                           apr_bucket_brigade *brigade)\n{\n    apr_bucket *e;\n    conn_rec *c = r->connection;\n\n    r->no_cache = 1;\n    /*\n     * If this is a subrequest, then prevent also caching of the main\n     * request.\n     */\n    if (r->main)\n        r->main->no_cache = 1;\n    e = ap_bucket_error_create(HTTP_BAD_GATEWAY, NULL, c->pool,\n                               c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(brigade, e);\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(brigade, e);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e395b520a340f8a5eab203ac887a4842eb5be473_0", {
    "ID": "httpd_e395b520a340f8a5eab203ac887a4842eb5be473_0",
    "UID": "1751",
    "code": "AP_DECLARE(void) ap_get_sload(ap_sload_t test_snippet\n{\n    int i, j, server_limit, thread_limit;\n    int ready = 0;\n    int busy = 0;\n    int total;\n    ap_generation_t mpm_generation;\n\n    \n    ld->idle = -1;\n    ld->busy = -1;\n    ld->bytes_served = 0;\n    ld->access_count = 0;\n\n    ap_mpm_query(AP_MPMQ_GENERATION, &mpm_generation);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);\n\n    for (i = 0; i < server_limit; i++) {\n        process_score *ps;\n        ps = ap_get_scoreboard_process(i);\n\n        for (j = 0; j < thread_limit; j++) {\n            int res;\n            worker_score *ws = NULL;\n            ws = &ap_scoreboard_image->servers[i][j];\n            res = ws->status;\n\n            if (!ps->quiescing && ps->pid) {\n                if (res == SERVER_READY && ps->generation == mpm_generation) {\n                    ready++;\n                }\n                else if (res != SERVER_DEAD &&\n                         res != SERVER_STARTING && res != SERVER_IDLE_KILL &&\n                         ps->generation == mpm_generation) {\n                    busy++;\n                }   \n            }\n\n            if (ap_extended_status && !ps->quiescing && ps->pid) {\n                if (ws->access_count != 0 \n                    || (res != SERVER_READY && res != SERVER_DEAD)) {\n                    ld->access_count += ws->access_count;\n                    ld->bytes_served += ws->bytes_served;\n                }\n            }\n        }\n    }\n    total = busy + ready;\n    if (total) {\n        ld->idle = ready * 100 / total;\n        ld->busy = busy * 100 / total;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_e677fdc7f3ffbf54619b57395076370082376bb1_0", {
    "ID": "httpd_e677fdc7f3ffbf54619b57395076370082376bb1_0",
    "UID": "1752",
    "code": "PROXY_DECLARE(int) ap_proxy_create_hdrbrgd(apr_pool_t test_snippet\n                                            apr_bucket_brigade *header_brigade,\n                                            request_rec *r,\n                                            proxy_conn_rec *p_conn,\n                                            proxy_worker *worker,\n                                            proxy_server_conf *conf,\n                                            apr_uri_t *uri,\n                                            char *url, char *server_portstr,\n                                            char **old_cl_val,\n                                            char **old_te_val)\n{\n    conn_rec *c = r->connection;\n    int counter;\n    char *buf;\n    const apr_array_header_t *headers_in_array;\n    const apr_table_entry_t *headers_in;\n    apr_table_t *headers_in_copy;\n    apr_bucket *e;\n    int do_100_continue;\n    conn_rec *origin = p_conn->connection;\n    proxy_dir_conf *dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n\n    /*\n     * To be compliant, we only use 100-Continue for requests with bodies.\n     * We also make sure we won't be talking HTTP/1.0 as well.\n     */\n    do_100_continue = (worker->s->ping_timeout_set\n                       && ap_request_has_body(r)\n                       && (PROXYREQ_REVERSE == r->proxyreq)\n                       && !(apr_table_get(r->subprocess_env, \"force-proxy-request-1.0\")));\n\n    if (apr_table_get(r->subprocess_env, \"force-proxy-request-1.0\")) {\n        /*\n         * According to RFC 2616 8.2.3 we are not allowed to forward an\n         * Expect: 100-continue to an HTTP/1.0 server. Instead we MUST return\n         * a HTTP_EXPECTATION_FAILED\n         */\n        if (r->expecting_100) {\n            return HTTP_EXPECTATION_FAILED;\n        }\n        buf = apr_pstrcat(p, r->method, \" \", url, \" HTTP/1.0\" CRLF, NULL);\n        p_conn->close = 1;\n    } else {\n        buf = apr_pstrcat(p, r->method, \" \", url, \" HTTP/1.1\" CRLF, NULL);\n    }\n    if (apr_table_get(r->subprocess_env, \"proxy-nokeepalive\")) {\n        origin->keepalive = AP_CONN_CLOSE;\n        p_conn->close = 1;\n    }\n    ap_xlate_proto_to_ascii(buf, strlen(buf));\n    e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n    if (dconf->preserve_host == 0) {\n        if (ap_strchr_c(uri->hostname, ':')) { \n            if (uri->port_str && uri->port != DEFAULT_HTTP_PORT) {\n                buf = apr_pstrcat(p, \"Host: [\", uri->hostname, \"]:\",\n                                  uri->port_str, CRLF, NULL);\n            } else {\n                buf = apr_pstrcat(p, \"Host: [\", uri->hostname, \"]\", CRLF, NULL);\n            }\n        } else {\n            if (uri->port_str && uri->port != DEFAULT_HTTP_PORT) {\n                buf = apr_pstrcat(p, \"Host: \", uri->hostname, \":\",\n                                  uri->port_str, CRLF, NULL);\n            } else {\n                buf = apr_pstrcat(p, \"Host: \", uri->hostname, CRLF, NULL);\n            }\n        }\n    }\n    else {\n        /* don't want to use r->hostname, as the incoming header might have a\n         * port attached\n         */\n        const char* hostname = apr_table_get(r->headers_in,\"Host\");\n        if (!hostname) {\n            hostname =  r->server->server_hostname;\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01092)\n                          \"no HTTP 0.9 request (with no host line) \"\n                          \"on incoming request and preserve host set \"\n                          \"forcing hostname to be %s for uri %s\",\n                          hostname, r->uri);\n        }\n        buf = apr_pstrcat(p, \"Host: \", hostname, CRLF, NULL);\n    }\n    ap_xlate_proto_to_ascii(buf, strlen(buf));\n    e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n\n    \n    if (conf->viaopt == via_block) {\n        \n        apr_table_unset(r->headers_in, \"Via\");\n    } else if (conf->viaopt != via_off) {\n        const char *server_name = ap_get_server_name(r);\n        /* If USE_CANONICAL_NAME_OFF was configured for the proxy virtual host,\n         * then the server name returned by ap_get_server_name() is the\n         * origin server name (which does make too much sense with Via: headers)\n         * so we use the proxy vhost's name instead.\n         */\n        if (server_name == r->hostname)\n            server_name = r->server->server_hostname;\n        \n        \n        apr_table_mergen(r->headers_in, \"Via\",\n                         (conf->viaopt == via_full)\n                         ? apr_psprintf(p, \"%d.%d %s%s (%s)\",\n                                        HTTP_VERSION_MAJOR(r->proto_num),\n                                        HTTP_VERSION_MINOR(r->proto_num),\n                                        server_name, server_portstr,\n                                        AP_SERVER_BASEVERSION)\n                         : apr_psprintf(p, \"%d.%d %s%s\",\n                                        HTTP_VERSION_MAJOR(r->proto_num),\n                                        HTTP_VERSION_MINOR(r->proto_num),\n                                        server_name, server_portstr)\n                         );\n    }\n\n    /* Use HTTP/1.1 100-Continue as quick \"HTTP ping\" test\n     * to backend\n     */\n    if (do_100_continue) {\n        apr_table_mergen(r->headers_in, \"Expect\", \"100-Continue\");\n        r->expecting_100 = 1;\n    }\n\n    /* X-Forwarded-*: handling\n     *\n     * XXX Privacy Note:\n     * -----------------\n     *\n     * These request headers are only really useful when the mod_proxy\n     * is used in a reverse proxy configuration, so that useful info\n     * about the client can be passed through the reverse proxy and on\n     * to the backend server, which may require the information to\n     * function properly.\n     *\n     * In a forward proxy situation, these options are a potential\n     * privacy violation, as information about clients behind the proxy\n     * are revealed to arbitrary servers out there on the internet.\n     *\n     * The HTTP/1.1 Via: header is designed for passing client\n     * information through proxies to a server, and should be used in\n     * a forward proxy configuation instead of X-Forwarded-*. See the\n     * ProxyVia option for details.\n     */\n    if (dconf->add_forwarded_headers) {\n        if (PROXYREQ_REVERSE == r->proxyreq) {\n            const char *buf;\n\n            /* Add X-Forwarded-For: so that the upstream has a chance to\n             * determine, where the original request came from.\n             */\n            apr_table_mergen(r->headers_in, \"X-Forwarded-For\",\n                             r->useragent_ip);\n\n            /* Add X-Forwarded-Host: so that upstream knows what the\n             * original request hostname was.\n             */\n            if ((buf = apr_table_get(r->headers_in, \"Host\"))) {\n                apr_table_mergen(r->headers_in, \"X-Forwarded-Host\", buf);\n            }\n\n            /* Add X-Forwarded-Server: so that upstream knows what the\n             * name of this proxy server is (if there are more than one)\n             * XXX: This duplicates Via: - do we strictly need it?\n             */\n            apr_table_mergen(r->headers_in, \"X-Forwarded-Server\",\n                             r->server->server_hostname);\n        }\n    }\n\n    proxy_run_fixups(r);\n    /*\n     * Make a copy of the headers_in table before clearing the connection\n     * headers as we need the connection headers later in the http output\n     * filter to prepare the correct response headers.\n     *\n     * Note: We need to take r->pool for apr_table_copy as the key / value\n     * pairs in r->headers_in have been created out of r->pool and\n     * p might be (and actually is) a longer living pool.\n     * This would trigger the bad pool ancestry abort in apr_table_copy if\n     * apr is compiled with APR_POOL_DEBUG.\n     */\n    headers_in_copy = apr_table_copy(r->pool, r->headers_in);\n    proxy_clear_connection(p, headers_in_copy);\n    \n    headers_in_array = apr_table_elts(headers_in_copy);\n    headers_in = (const apr_table_entry_t *) headers_in_array->elts;\n    for (counter = 0; counter < headers_in_array->nelts; counter++) {\n        if (headers_in[counter].key == NULL\n            || headers_in[counter].val == NULL\n\n            \n            || !strcasecmp(headers_in[counter].key, \"Host\")\n\n            /* Clear out hop-by-hop request headers not to send\n             * RFC2616 13.5.1 says we should strip these headers\n             */\n            || !strcasecmp(headers_in[counter].key, \"Keep-Alive\")\n            || !strcasecmp(headers_in[counter].key, \"TE\")\n            || !strcasecmp(headers_in[counter].key, \"Trailer\")\n            || !strcasecmp(headers_in[counter].key, \"Upgrade\")\n\n            ) {\n            continue;\n        }\n        /* Do we want to strip Proxy-Authorization ?\n         * If we haven't used it, then NO\n         * If we have used it then MAYBE: RFC2616 says we MAY propagate it.\n         * So let's make it configurable by env.\n         */\n        if (!strcasecmp(headers_in[counter].key,\"Proxy-Authorization\")) {\n            if (r->user != NULL) { \n                if (!apr_table_get(r->subprocess_env, \"Proxy-Chain-Auth\")) {\n                    continue;\n                }\n            }\n        }\n\n        /* Skip Transfer-Encoding and Content-Length for now.\n         */\n        if (!strcasecmp(headers_in[counter].key, \"Transfer-Encoding\")) {\n            *old_te_val = headers_in[counter].val;\n            continue;\n        }\n        if (!strcasecmp(headers_in[counter].key, \"Content-Length\")) {\n            *old_cl_val = headers_in[counter].val;\n            continue;\n        }\n\n        \n        if (r->main) {\n            if (    !strcasecmp(headers_in[counter].key, \"If-Match\")\n                || !strcasecmp(headers_in[counter].key, \"If-Modified-Since\")\n                || !strcasecmp(headers_in[counter].key, \"If-Range\")\n                || !strcasecmp(headers_in[counter].key, \"If-Unmodified-Since\")\n                || !strcasecmp(headers_in[counter].key, \"If-None-Match\")) {\n                continue;\n            }\n        }\n\n        buf = apr_pstrcat(p, headers_in[counter].key, \": \",\n                          headers_in[counter].val, CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(buf, strlen(buf));\n        e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n    }\n    return OK;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_b2e9016195daa1521894dac509a4e3473ee1a10e_0", {
    "ID": "httpd_b2e9016195daa1521894dac509a4e3473ee1a10e_0",
    "UID": "1756",
    "code": "PROXY_DECLARE(int) ap_proxy_pass_brigade(apr_bucket_alloc_t test_snippet\n                                         request_rec *r, proxy_conn_rec *p_conn,\n                                         conn_rec *origin, apr_bucket_brigade *bb,\n                                         int flush)\n{\n    apr_status_t status;\n    apr_off_t transferred;\n\n    if (flush) {\n        apr_bucket *e = apr_bucket_flush_create(bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n    }\n    apr_brigade_length(bb, 0, &transferred);\n    if (transferred != -1)\n        p_conn->worker->s->transferred += transferred;\n    status = ap_pass_brigade(origin->output_filters, bb);\n    if (status != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01084)\n                      \"pass request body failed to %pI (%s)\",\n                      p_conn->addr, p_conn->hostname);\n        if (origin->aborted) {\n            const char *ssl_note;\n\n            if (((ssl_note = apr_table_get(origin->notes, \"SSL_connect_rv\"))\n                 != NULL) && (strcmp(ssl_note, \"err\") == 0)) {\n                return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,\n                                     \"Error during SSL Handshake with\"\n                                     \" remote server\");\n            }\n            return APR_STATUS_IS_TIMEUP(status) ? HTTP_GATEWAY_TIME_OUT : HTTP_BAD_GATEWAY;\n        }\n        else {\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    apr_brigade_cleanup(bb);\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e7ed58e82a7c3ae7d44344f3c953748d99b8e10d_0", {
    "ID": "httpd_e7ed58e82a7c3ae7d44344f3c953748d99b8e10d_0",
    "UID": "1760",
    "code": "static int check_errorlog_dir(apr_pool_t *p, server_rec test_snippet\n{\n    if (!s->error_fname || s->error_fname[0] == '|'\n        || strcmp(s->error_fname, \"syslog\") == 0) {\n        return APR_SUCCESS;\n    }\n    else {\n        char *abs = ap_server_root_relative(p, s->error_fname);\n        char *dir = ap_make_dirstr_parent(p, abs);\n        apr_finfo_t finfo;\n        apr_status_t rv = apr_stat(&finfo, dir, APR_FINFO_TYPE, p);\n        if (rv == APR_SUCCESS && finfo.filetype != APR_DIR)\n            rv = APR_ENOTDIR;\n        if (rv != APR_SUCCESS) {\n            const char *desc = \"main error log\";\n            if (s->defn_name)\n                desc = apr_psprintf(p, \"error log of vhost defined at %s:%d\",\n                                    s->defn_name, s->defn_line_number);\n            ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, rv,\n                          ap_server_conf, APLOGNO(02291)\n                         \"Cannot access directory '%s' for %s\", dir, desc);\n            return !OK;\n        }\n    }\n    return OK;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_e733645c4fec8b55fdd7b18c3cdc187a7752d558_0", {
    "ID": "httpd_e733645c4fec8b55fdd7b18c3cdc187a7752d558_0",
    "UID": "1761",
    "code": "static apr_status_t core_insert_network_bucket(conn_rec test_snippet\n                                               apr_bucket_brigade *bb,\n                                               apr_socket_t *socket)\n{\n    apr_bucket *e = apr_bucket_socket_create(socket, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_37306fc7833d01243066ccc5a31413480541133d_0", {
    "ID": "httpd_37306fc7833d01243066ccc5a31413480541133d_0",
    "UID": "1768",
    "code": "AP_DECLARE(int) ap_xml_parse_input(request_rec * r, apr_xml_doc test_snippet\n{\n    apr_xml_parser *parser;\n    apr_bucket_brigade *brigade;\n    int seen_eos;\n    apr_status_t status;\n    char errbuf[200];\n    apr_size_t total_read = 0;\n    apr_size_t limit_xml_body = ap_get_limit_xml_body(r);\n    int result = HTTP_BAD_REQUEST;\n\n    parser = apr_xml_parser_create(r->pool);\n    brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\n    seen_eos = 0;\n    total_read = 0;\n\n    do {\n        apr_bucket *bucket;\n\n        \n        status = ap_get_brigade(r->input_filters, brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                READ_BLOCKSIZE);\n\n        if (status != APR_SUCCESS) {\n            goto read_error;\n        }\n\n        for (bucket = APR_BRIGADE_FIRST(brigade);\n             bucket != APR_BRIGADE_SENTINEL(brigade);\n             bucket = APR_BUCKET_NEXT(bucket))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bucket)) {\n                seen_eos = 1;\n                break;\n            }\n\n            if (APR_BUCKET_IS_METADATA(bucket)) {\n                continue;\n            }\n\n            status = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\n            if (status != APR_SUCCESS) {\n                goto read_error;\n            }\n\n            total_read += len;\n            if (limit_xml_body && total_read > limit_xml_body) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"XML request body is larger than the configured \"\n                              \"limit of %lu\", (unsigned long)limit_xml_body);\n                result = HTTP_REQUEST_ENTITY_TOO_LARGE;\n                goto read_error;\n            }\n\n            status = apr_xml_parser_feed(parser, data, len);\n            if (status) {\n                goto parser_error;\n            }\n        }\n\n        apr_brigade_cleanup(brigade);\n    } while (!seen_eos);\n\n    apr_brigade_destroy(brigade);\n\n    \n    status = apr_xml_parser_done(parser, pdoc);\n    if (status) {\n        \n        if (!total_read) {\n            *pdoc = NULL;\n            return OK;\n        }\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"XML parser error (at end). status=%d\", status);\n        return HTTP_BAD_REQUEST;\n    }\n\n#if APR_CHARSET_EBCDIC\n    apr_xml_parser_convert_doc(r->pool, *pdoc, ap_hdrs_from_ascii);\n#endif\n    return OK;\n\n  parser_error:\n    (void) apr_xml_parser_geterror(parser, errbuf, sizeof(errbuf));\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"%s\", errbuf);\n\n    \n\n  read_error:\n    \n    (void) apr_xml_parser_done(parser, NULL);\n\n    apr_brigade_destroy(brigade);\n\n    \n    return result;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_b3261b22d4328090819e8ea77b5045ec4677d92b_0", {
    "ID": "httpd_b3261b22d4328090819e8ea77b5045ec4677d92b_0",
    "UID": "1772",
    "code": "static const char *set_keep_alive_timeout(cmd_parms *cmd, void test_snippet\n\t\t\t\t\t  const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->keep_alive_timeout = apr_time_from_sec(atoi(arg));\n    return NULL;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_a4c373ed2d2ed19aff194d9de017fbbe21fface6_0", {
    "ID": "httpd_a4c373ed2d2ed19aff194d9de017fbbe21fface6_0",
    "UID": "1774",
    "code": "static void *merge_env_dir_configs(apr_pool_t *p, void *basev, void test_snippet\n{\n    env_dir_config_rec *base = basev;\n    env_dir_config_rec *add = addv;\n    env_dir_config_rec *res = apr_palloc(p, sizeof(*res));\n\n    const apr_table_entry_t *elts;\n    const apr_array_header_t *arr;\n\n    int i;\n\n    /* \n     * res->vars = copy_table( p, base->vars );\n     * foreach $unsetenv ( @add->unsetenv )\n     *     table_unset( res->vars, $unsetenv );\n     * foreach $element ( @add->vars )\n     *     table_set( res->vars, $element.key, $element.val );\n     *\n     * add->unsetenv already removed the vars from add->vars, \n     * if they preceeded the UnsetEnv directive.\n     */\n    res->vars = apr_table_copy(p, base->vars);\n    res->unsetenv = NULL;\n\n    arr = apr_table_elts(add->unsetenv);\n    if (arr) {\n        elts = (const apr_table_entry_t *)arr->elts;\n\n        for (i = 0; i < arr->nelts; ++i) {\n            apr_table_unset(res->vars, elts[i].key);\n        }\n    }\n\n    arr = apr_table_elts(add->vars);\n    if (arr) {\n        elts = (const apr_table_entry_t *)arr->elts;\n\n        for (i = 0; i < arr->nelts; ++i) {\n            apr_table_setn(res->vars, elts[i].key, elts[i].val);\n        }\n    }\n\n    return res;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a7734301e1ad6fdd13e28132beb4b2f3afdbf177_0", {
    "ID": "httpd_a7734301e1ad6fdd13e28132beb4b2f3afdbf177_0",
    "UID": "1782",
    "code": "AP_DECLARE(int) ap_cfg_getline(char *buf, size_t bufsize, ap_configfile_t test_snippet\n{\n    \n    if (cfp->getstr != NULL) {\n        char *src, *dst;\n        char *cp;\n        char *cbuf = buf;\n        size_t cbufsize = bufsize;\n\n        while (1) {\n            ++cfp->line_number;\n            if (cfp->getstr(cbuf, cbufsize, cfp->param) == NULL)\n                return 1;\n\n            /*\n             *  check for line continuation,\n             *  i.e. match [^\\\\]\\\\[\\r]\\n only\n             */\n            cp = cbuf;\n            while (cp < cbuf+cbufsize && *cp != '\\0')\n                cp++;\n            if (cp > cbuf && cp[-1] == LF) {\n                cp--;\n                if (cp > cbuf && cp[-1] == CR)\n                    cp--;\n                if (cp > cbuf && cp[-1] == '\\\\') {\n                    cp--;\n                    if (!(cp > cbuf && cp[-1] == '\\\\')) {\n                        /*\n                         * line continuation requested -\n                         * then remove backslash and continue\n                         */\n                        cbufsize -= (cp-cbuf);\n                        cbuf = cp;\n                        continue;\n                    }\n                    else {\n                        /* \n                         * no real continuation because escaped -\n                         * then just remove escape character\n                         */\n                        for ( ; cp < cbuf+cbufsize && *cp != '\\0'; cp++)\n                            cp[0] = cp[1];\n                    }   \n                }\n            }\n            break;\n        }\n\n        /*\n         * Leading and trailing white space is eliminated completely\n         */\n        src = buf;\n        while (apr_isspace(*src))\n            ++src;\n        \n        dst = &src[strlen(src)];\n        while (--dst >= src && apr_isspace(*dst))\n            *dst = '\\0';\n        \n        if (src != buf)\n            for (dst = buf; (*dst++ = *src++) != '\\0'; )\n                ;\n\n#ifdef DEBUG_CFG_LINES\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, \"Read config: %s\", buf);\n#endif\n        return 0;\n    } else {\n        \n        register int c;\n        register size_t i = 0;\n\n        buf[0] = '\\0';\n        \n        do {\n            c = cfp->getch(cfp->param);\n        } while (c == '\\t' || c == ' ');\n\n        if (c == EOF)\n            return 1;\n        \n        if(bufsize < 2) {\n            \n            return 1;\n        }\n\n        while (1) {\n            if ((c == '\\t') || (c == ' ')) {\n                buf[i++] = ' ';\n                while ((c == '\\t') || (c == ' '))\n                    c = cfp->getch(cfp->param);\n            }\n            if (c == CR) {\n                \n                c = cfp->getch(cfp->param);\n            }\n            if (c == LF) {\n                \n                ++cfp->line_number;\n            }\n            if (c == EOF || c == 0x4 || c == LF || i >= (bufsize - 2)) {\n                /* \n                 *  check for line continuation\n                 */\n                if (i > 0 && buf[i-1] == '\\\\') {\n                    i--;\n                    if (!(i > 0 && buf[i-1] == '\\\\')) {\n                        \n                        c = cfp->getch(cfp->param);\n                        continue;\n                    }\n                    /* else nothing needs be done because\n                     * then the backslash is escaped and\n                     * we just strip to a single one\n                     */\n                }\n                \n                while (i > 0 && apr_isspace(buf[i - 1]))\n                    --i;\n                buf[i] = '\\0';\n#ifdef DEBUG_CFG_LINES\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,\n                             \"Read config: %s\", buf);\n#endif\n                return 0;\n            }\n            buf[i] = c;\n            ++i;\n            c = cfp->getch(cfp->param);\n        }\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_dc1c7ddb8805c22f852b2768009781a241adfc05_0", {
    "ID": "httpd_dc1c7ddb8805c22f852b2768009781a241adfc05_0",
    "UID": "1807",
    "code": "static int check_user_access(request_rec test_snippet\n{\n    authz_default_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                 &authz_default_module);\n    int m = r->method_number;\n    int method_restricted = 0;\n    register int x;\n    const apr_array_header_t *reqs_arr = ap_requires(r);\n    require_line *reqs;\n\n    /* BUG FIX: tadc, 11-Nov-1995.  If there is no \"requires\" directive, \n     * then any user will do.\n     */\n    if (!reqs_arr) {\n        return OK;\n    }\n    reqs = (require_line *)reqs_arr->elts;\n\n    for (x = 0; x < reqs_arr->nelts; x++) {\n        if (!(reqs[x].method_mask & (AP_METHOD_BIT << m))) {\n            continue;\n        }\n        method_restricted = 1;\n        break;\n    }\n\n    if (method_restricted == 0) {\n        return OK;\n    }\n\n    if (!(conf->authoritative)) {\n        return DECLINED;\n    }\n\n    /* if we aren't authoritative, any require directive could be\n     * considered valid even if noone groked it.  However, if we are \n     * authoritative, we can warn the user they did something wrong.\n     *\n     * That something could be a missing \"AuthAuthoritative off\", but\n     * more likely is a typo in the require directive.\n     */\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"access to %s failed, reason: require directives \"\n                          \"present and no Authoritative handler.\", r->uri);\n\n    ap_note_auth_failure(r);\n    return HTTP_UNAUTHORIZED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_e20514e324fb0de37a1b12354c61dc8bbf94bfa8_0", {
    "ID": "httpd_e20514e324fb0de37a1b12354c61dc8bbf94bfa8_0",
    "UID": "1826",
    "code": "static void getword(char *word, char *line, char test_snippet\n{\n    int x = 0, y;\n\n    for (x = 0; ((line[x]) && (line[x] != test_snippet); x++)\n        word[x] = line[x];\n\n    word[x] = '\\0';\n    if (line[x])\n        ++x;\n    y = 0;\n\n    while ((line[y++] = line[x++]));\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_a8f193351cd2bd3e15c47697e7dc3b76f11d3da4_0", {
    "ID": "httpd_a8f193351cd2bd3e15c47697e7dc3b76f11d3da4_0",
    "UID": "1829",
    "code": "AP_DECLARE(void) ap_setup_make_content_type(apr_pool_t test_snippet\n{\n    int i;\n    for (i = 0; needcset[i]; i++) {\n        continue;\n    }\n    needcset_patterns = (const apr_strmatch_pattern **)\n        apr_palloc(pool, (i + 1) * sizeof(apr_strmatch_pattern *));\n    for (i = 0; needcset[i]; i++) {\n        needcset_patterns[i] = apr_strmatch_precompile(pool, needcset[i], 0);\n    }\n    needcset_patterns[i] = NULL;\n    charset_pattern = apr_strmatch_precompile(pool, \"charset=\", 0);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c3286b162381b8a988775f640978b0a43d30e6ad_0", {
    "ID": "httpd_c3286b162381b8a988775f640978b0a43d30e6ad_0",
    "UID": "1837",
    "code": "AP_DECLARE(char **) ap_create_environment(apr_pool_t *p, apr_table_t test_snippet\n{\n    const apr_array_header_t *env_arr = apr_table_elts(t);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *) env_arr->elts;\n    char **env = (char **) apr_palloc(p, (env_arr->nelts + 2) * sizeof(char *));\n    int i, j;\n    char *tz;\n    char *whack;\n\n    j = 0;\n    if (!apr_table_get(t, \"TZ\")) {\n        tz = getenv(\"TZ\");\n        if (tz != NULL) {\n            env[j++] = apr_pstrcat(p, \"TZ=\", tz, NULL);\n        }\n    }\n    for (i = 0; i < env_arr->nelts; ++i) {\n        if (!elts[i].key) {\n            continue;\n        }\n        env[j] = apr_pstrcat(p, elts[i].key, \"=\", elts[i].val, NULL);\n        whack = env[j];\n        if (apr_isdigit(*whack)) {\n            *whack++ = '_';\n        }\n        while (*whack != '=') {\n            if (!apr_isalnum(*whack) && *whack != '_') {\n                *whack = '_';\n            }\n            ++whack;\n        }\n        ++j;\n    }\n\n    env[j] = NULL;\n    return env;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_1d6fe053bd372a6557c9016382ed521e8f7b19f9_0", {
    "ID": "httpd_1d6fe053bd372a6557c9016382ed521e8f7b19f9_0",
    "UID": "1847",
    "code": "void ap_reclaim_child_processes(int test_snippet\n{\n    int i;\n    long int waittime = 1024 * 16;      \n    apr_status_t waitret;\n    int tries;\n    int not_dead_yet;\n    int max_daemons;\n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);\n\n    for (tries = terminate ? 4 : 1; tries <= 9; ++tries) {\n        /* don't want to hold up progress any more than\n         * necessary, but we need to allow children a few moments to exit.\n         * Set delay with an exponential backoff.\n         */\n        apr_sleep(waittime);\n        waittime = waittime * 4;\n\n        \n        not_dead_yet = 0;\n        for (i = 0; i < max_daemons; ++i) {\n            pid_t pid = MPM_CHILD_PID(i);\n            apr_proc_t proc;\n\n            if (pid == 0)\n                continue;\n\n            proc.pid = pid;\n            waitret = apr_proc_wait(&proc, NULL, NULL, APR_NOWAIT);\n            if (waitret != APR_CHILD_NOTDONE) {\n                MPM_NOTE_CHILD_KILLED(i);\n                continue;\n            }\n\n            ++not_dead_yet;\n            switch (tries) {\n            case 1:     \n            case 2:     \n            case 3:     \n            case 4:     \n                break;\n\n            case 5:     \n            case 6:     \n            case 7:     \n                \n                ap_log_error(APLOG_MARK, APLOG_WARNING,\n                             0, ap_server_conf,\n                             \"child process %ld still did not exit, \"\n                             \"sending a SIGTERM\",\n                             (long)pid);\n                kill(pid, SIGTERM);\n                break;\n\n            case 8:     \n                \n                ap_log_error(APLOG_MARK, APLOG_ERR,\n                             0, ap_server_conf,\n                             \"child process %ld still did not exit, \"\n                             \"sending a SIGKILL\",\n                             (long)pid);\n#ifndef BEOS\n                kill(pid, SIGKILL);\n#else\n                /* sending a SIGKILL kills the entire team on BeOS, and as\n                 * httpd thread is part of that team it removes any chance\n                 * of ever doing a restart.  To counter this I'm changing to\n                 * use a kinder, gentler way of killing a specific thread\n                 * that is just as effective.\n                 */\n                kill_thread(pid);\n#endif\n                break;\n\n            case 9:     \n                /* gave it our best shot, but alas...  If this really\n                 * is a child we are trying to kill and it really hasn't\n                 * exited, we will likely fail to bind to the port\n                 * after the restart.\n                 */\n                ap_log_error(APLOG_MARK, APLOG_ERR,\n                             0, ap_server_conf,\n                             \"could not make child process %ld exit, \"\n                             \"attempting to continue anyway\",\n                             (long)pid);\n                break;\n            }\n        }\n\n#if APR_HAS_OTHER_CHILD\n        apr_proc_other_child_refresh_all(APR_OC_REASON_RESTART);\n#endif\n\n        if (!not_dead_yet) {\n            \n            break;\n        }\n    }\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_ba42cba563ceecf73ded87984ba0955a5387723b_0", {
    "ID": "httpd_ba42cba563ceecf73ded87984ba0955a5387723b_0",
    "UID": "1855",
    "code": "static void *create_authz_host_dir_config(apr_pool_t *p, char test_snippet\n{\n    int i;\n    authz_host_dir_conf *conf =\n        (authz_host_dir_conf *)apr_pcalloc(p, sizeof(authz_host_dir_conf));\n\n    for (i = 0; i < METHODS; ++i) {\n        conf->order[i] = DENY_THEN_ALLOW;\n    }\n    conf->allows = apr_array_make(p, 1, sizeof(allowdeny));\n    conf->denys = apr_array_make(p, 1, sizeof(allowdeny));\n\n    return (void *)conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_62c18fba67f34f3273dccecbfef19dea053b3cf6_0", {
    "ID": "httpd_62c18fba67f34f3273dccecbfef19dea053b3cf6_0",
    "UID": "1859",
    "code": "static apr_status_t groups_for_user(apr_pool_t *p, char *user, char test_snippet\n                                    apr_table_t ** out)\n{\n    ap_configfile_t *f;\n    apr_table_t *grps = apr_table_make(p, 15);\n    apr_pool_t *sp;\n    char l[MAX_STRING_LEN];\n    const char *group_name, *ll, *w;\n    apr_status_t status;\n    apr_size_t group_len;\n\n    if ((status = ap_pcfg_openfile(&f, p, grpfile)) != APR_SUCCESS) {\n        return status ;\n    }\n\n    apr_pool_create(&sp, p);\n\n    while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {\n        if ((l[0] == '#') || (!l[0])) {\n            continue;\n        }\n        ll = l;\n        apr_pool_clear(sp);\n\n        group_name = ap_getword(sp, &ll, ':');\n        group_len = strlen(group_name);\n\n        while (group_len && apr_isspace(*(group_name + group_len - 1))) {\n            --group_len;\n        }\n\n        while (ll[0]) {\n            w = ap_getword_conf(sp, &ll);\n            if (!strcmp(w, user)) {\n                apr_table_setn(grps, apr_pstrmemdup(p, group_name, group_len),\n                               \"in\");\n                break;\n            }\n        }\n    }\n    ap_cfg_closefile(f);\n    apr_pool_destroy(sp);\n\n    *out = grps;\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_d72b1ac9ffbbb4cc4c33c638a7b58d58d96510b5_0", {
    "ID": "httpd_d72b1ac9ffbbb4cc4c33c638a7b58d58d96510b5_0",
    "UID": "1864",
    "code": "static int get_line(char *s, int n, apr_file_t test_snippet\n{\n    register int i = 0;\n    char ch;\n    apr_status_t rv = APR_EINVAL;\n\n    while (i < (n - 1) && \n           ((rv = apr_file_getc(&ch, f)) == APR_SUCCESS) && (ch != '\\n')) {\n        s[i++] = ch;\n    }\n    if (ch == '\\n')\n        s[i++] = ch;\n    s[i] = '\\0';\n\n    if (rv != APR_SUCCESS) \n        return 1;\n\n    return 0;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_c376828a9e6db37ee53864a67e0084e792cccb95_0", {
    "ID": "httpd_c376828a9e6db37ee53864a67e0084e792cccb95_0",
    "UID": "1866",
    "code": "static test_snippet\nset_start_bits(const uschar *code, uschar *start_bits, test_snippet caseless,\n  compile_data *cd)\n{\nregister int c;\n\n/* This next statement and the later reference to dummy are here in order to\ntrick the optimizer of the IBM C compiler for OS/2 into generating correct\ncode. Apparently IBM isn't going to fix the problem, and we would rather not\ndisable optimization (in this module it actually makes a big difference, and\nthe pcre module can use all the optimization it can get). */\n\nvolatile int dummy;\n\ndo\n  {\n  const uschar *tcode = code + 3;\n  test_snippet try_next = TRUE;\n\n  while (try_next)\n    {\n    /* If a branch starts with a bracket or a positive lookahead assertion,\n    recurse to set bits from within them. That's all for this branch. */\n\n    if ((int)*tcode >= OP_BRA || *tcode == OP_ASSERT)\n      {\n      if (!set_start_bits(tcode, start_bits, caseless, cd))\n        return FALSE;\n      try_next = FALSE;\n      }\n\n    else switch(*tcode)\n      {\n      default:\n      return FALSE;\n\n      \n\n      case OP_BRANUMBER:\n      tcode += 3;\n      break;\n\n      \n\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      do tcode += (tcode[1] << 8) + tcode[2]; while (*tcode == OP_ALT);\n      tcode += 3;\n      break;\n\n      \n\n      case OP_OPT:\n      caseless = (tcode[1] & PCRE_CASELESS) != 0;\n      tcode += 2;\n      break;\n\n      \n\n      case OP_BRAZERO:\n      case OP_BRAMINZERO:\n      if (!set_start_bits(++tcode, start_bits, caseless, cd))\n        return FALSE;\n      dummy = 1;\n      do tcode += (tcode[1] << 8) + tcode[2]; while (*tcode == OP_ALT);\n      tcode += 3;\n      break;\n\n      \n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      tcode += 2;\n      break;\n\n      \n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      set_bit(start_bits, tcode[3], caseless, cd);\n      tcode += 4;\n      break;\n\n      \n\n      case OP_EXACT:       \n      tcode++;\n\n      case OP_CHARS:       \n      tcode++;\n\n      case OP_PLUS:\n      case OP_MINPLUS:\n      set_bit(start_bits, tcode[1], caseless, cd);\n      try_next = FALSE;\n      break;\n\n      \n\n      case OP_NOT_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_DIGIT:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_digit];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_space];\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= ~cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      for (c = 0; c < 32; c++)\n        start_bits[c] |= cd->cbits[c+cbit_word];\n      try_next = FALSE;\n      break;\n\n      /* One or more character type fudges the pointer and restarts, knowing\n      it will hit a single character type and stop there. */\n\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      tcode++;\n      break;\n\n      case OP_TYPEEXACT:\n      tcode += 3;\n      break;\n\n      /* Zero or more repeats of character types set the bits and then\n      try again. */\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      tcode += 2;               \n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      switch(tcode[1])\n        {\n        case OP_NOT_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_DIGIT:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_digit];\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_space];\n        break;\n\n        case OP_WHITESPACE:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_space];\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= ~cd->cbits[c+cbit_word];\n        break;\n\n        case OP_WORDCHAR:\n        for (c = 0; c < 32; c++)\n          start_bits[c] |= cd->cbits[c+cbit_word];\n        break;\n        }\n\n      tcode += 2;\n      break;\n\n      /* Character class: set the bits and either carry on or not,\n      according to the repeat count. */\n\n      case OP_CLASS:\n        {\n        tcode++;\n        for (c = 0; c < 32; c++) start_bits[c] |= tcode[c];\n        tcode += 32;\n        switch (*tcode)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          tcode++;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          if (((tcode[1] << 8) + tcode[2]) == 0) tcode += 5;\n            else try_next = FALSE;\n          break;\n\n          default:\n          try_next = FALSE;\n          break;\n          }\n        }\n      break; \n\n      }      \n    }        \n\n  code += (code[1] << 8) + code[2];   \n  }\nwhile (*code == OP_ALT);\nreturn TRUE;\n}",
    "predicted": "476,NULL Pointer Dereference\n119,Improper Restriction of Operations within the Bounds of a Memory Buffer"
  },
  "httpd_91394df06b2eb9d0e9eca35b03bd336bde54c936_0", {
    "ID": "httpd_91394df06b2eb9d0e9eca35b03bd336bde54c936_0",
    "UID": "1871",
    "code": "static const char *set_language_priority(cmd_parms *cmd, void test_snippet\n                                         const char *lang)\n{\n    neg_dir_config *n = n_;\n    const char **langp;\n\n    if (!n->language_priority)\n        n->language_priority = apr_array_make(cmd->pool, 4, sizeof(char *));\n\n    langp = (const char **) apr_array_push(n->language_priority);\n    *langp = lang;\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_f19fb516ebb13200badfd0c6e898ea0203c1733b_0", {
    "ID": "httpd_f19fb516ebb13200badfd0c6e898ea0203c1733b_0",
    "UID": "1876",
    "code": "static int alias_matches(const char *uri, const char test_snippet\n{\n    const char *aliasp = alias_fakename, *urip = uri;\n\n    while (*aliasp) {\n        if (*aliasp == '/') {\n            /* any number of '/' in the alias matches any number in\n             * the supplied URI, but there must be at least one...\n             */\n            if (*urip != '/')\n                return 0;\n\n            do {\n                ++aliasp;\n            } while (*aliasp == '/');\n            do {\n                ++urip;\n            } while (*urip == '/');\n        }\n        else {\n            \n            if (*urip++ != *aliasp++)\n                return 0;\n        }\n    }\n\n    \n\n    if (aliasp[-1] != '/' && *urip != '\\0' && *urip != '/')\n        return 0;\n\n    /* Return number of characters from URI which matched (may be\n     * greater than length of alias, since we may have matched\n     * doubled slashes)\n     */\n\n    return urip - uri;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_48217d91f19696301d50070fe23478319b5e52c6_0", {
    "ID": "httpd_48217d91f19696301d50070fe23478319b5e52c6_0",
    "UID": "1877",
    "code": "static const char *add_alias_internal(cmd_parms *cmd, void test_snippet\n                                      const char *f, const char *r,\n                                      int use_regex)\n{\n    server_rec *s = cmd->server;\n    alias_server_conf *conf = ap_get_module_config(s->module_config,\n                                                   &alias_module);\n    alias_entry *new = apr_array_push(conf->aliases);\n    alias_entry *entries = (alias_entry *)conf->aliases->elts;\n    int i;\n\n    \n\n    if (use_regex) {\n        new->regexp = ap_pregcomp(cmd->pool, f, REG_EXTENDED);\n        if (new->regexp == NULL)\n            return \"Regular expression could not be compiled.\";\n        new->real = r;\n    }\n    else {\n        /* XXX This may be optimized, but we must know that new->real\n         * exists.  If so, we can dir merge later, trusing new->real\n         * and just canonicalizing the remainder.  Not till I finish\n         * cleaning out the old ap_canonical stuff first.\n         */\n        new->real = r;\n    }\n    new->fake = f;\n    new->handler = cmd->info;\n\n    /* check for overlapping (Script)Alias directives\n     * and throw a warning if found one\n     */\n    if (!use_regex) {\n        for (i = 0; i < conf->aliases->nelts - 1; ++i) {\n            alias_entry *p = &entries[i];\n\n            if (  (!p->regexp &&  alias_matches(f, p->fake) > 0)\n                || (p->regexp && !ap_regexec(p->regexp, f, 0, NULL, 0))) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                             \"The %s directive in %s at line %d will probably \"\n                             \"never match because it overlaps an earlier \"\n                             \"%sAlias%s.\",\n                             cmd->cmd->name, cmd->directive->filename,\n                             cmd->directive->line_num,\n                             p->handler ? \"Script\" : \"\",\n                             p->regexp ? \"Match\" : \"\");\n\n                break; \n            }\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_2ea12459265b3389e8a44a4181de88badcb07133_0", {
    "ID": "httpd_2ea12459265b3389e8a44a4181de88badcb07133_0",
    "UID": "1879",
    "code": "AP_DECLARE(int) ap_satisfies(request_rec test_snippet\n{\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &core_module);\n\n    return conf->satisfy[r->method_number];\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_bd4495ba1b6aa05314de60bb386b0e73c4315ccc_0", {
    "ID": "httpd_bd4495ba1b6aa05314de60bb386b0e73c4315ccc_0",
    "UID": "1880",
    "code": "APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(ap, STATUS, int, test_snippet\n                                    (request_rec *r, int flags),\n                                    (r, flags),\n                                    OK, DECLINED)",
    "predicted": "This piece of code does not provide enough context to identify a specific vulnerability. Therefore, I cannot assign a category from the list provided."
  },
  "httpd_83cfa9bef1d3eeb9ae5d859a9aa2b02b336fbae4_0", {
    "ID": "httpd_83cfa9bef1d3eeb9ae5d859a9aa2b02b336fbae4_0",
    "UID": "1884",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippet_test_snippetctest_snippetmtest_snippetdtest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet_test_snippetptest_snippetatest_snippetrtest_snippetmtest_snippetstest_snippet test_snippet*test_snippetctest_snippetmtest_snippetdtest_snippet,test_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippet*test_snippetdtest_snippetvtest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet_test_snippetctest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetutest_snippetttest_snippethtest_snippetztest_snippet_test_snippethtest_snippetotest_snippetstest_snippetttest_snippet_test_snippetdtest_snippetitest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippet test_snippet*test_snippetdtest_snippet test_snippet=test_snippet test_snippet(test_snippetatest_snippetutest_snippetttest_snippethtest_snippetztest_snippet_test_snippethtest_snippetotest_snippetstest_snippetttest_snippet_test_snippetdtest_snippetitest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippet test_snippet*test_snippet)test_snippet test_snippetdtest_snippetvtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippetdtest_snippetetest_snippetntest_snippetytest_snippet test_snippet*test_snippetatest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet_test_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetstest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet[test_snippet1test_snippet2test_snippet0test_snippet]test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetrtest_snippetvtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetstest_snippetetest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet,test_snippet test_snippet\"test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet\"test_snippet)test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippet\"test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetdtest_snippetetest_snippetntest_snippetytest_snippet test_snippetmtest_snippetutest_snippetstest_snippetttest_snippet test_snippetbtest_snippetetest_snippet test_snippetftest_snippetotest_snippetltest_snippetltest_snippetotest_snippetwtest_snippetetest_snippetdtest_snippet test_snippetbtest_snippetytest_snippet test_snippet'test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet'test_snippet\"test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet test_snippet=test_snippet test_snippet(test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippetdtest_snippetetest_snippetntest_snippetytest_snippet test_snippet*test_snippet)test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetutest_snippetstest_snippethtest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet?test_snippet test_snippetdtest_snippet-test_snippet>test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippetstest_snippet test_snippet:test_snippet test_snippetdtest_snippet-test_snippet>test_snippetdtest_snippetetest_snippetntest_snippetytest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetxtest_snippet.test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet test_snippet=test_snippet test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippetetest_snippetdtest_snippet test_snippet=test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippetetest_snippetdtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetntest_snippetctest_snippetatest_snippetstest_snippetetest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet,test_snippet test_snippet\"test_snippetetest_snippetntest_snippetvtest_snippet=test_snippet\"test_snippet,test_snippet test_snippet4test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetTtest_snippet_test_snippetEtest_snippetNtest_snippetVtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetxtest_snippet.test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet test_snippet+test_snippet=test_snippet test_snippet4test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetstest_snippetetest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet,test_snippet test_snippet\"test_snippetatest_snippetltest_snippetltest_snippet\"test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetTtest_snippet_test_snippetAtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet,test_snippet test_snippet'test_snippet/test_snippet'test_snippet)test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetstest_snippet+test_snippet+test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetitest_snippetptest_snippetstest_snippetutest_snippetbtest_snippetntest_snippetetest_snippetttest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippet&test_snippetatest_snippet-test_snippet>test_snippetxtest_snippet.test_snippetitest_snippetptest_snippet,test_snippet test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet,test_snippet test_snippetstest_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet(test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetTtest_snippetAtest_snippetTtest_snippetUtest_snippetStest_snippet_test_snippetItest_snippetStest_snippet_test_snippetEtest_snippetItest_snippetNtest_snippetVtest_snippetAtest_snippetLtest_snippet(test_snippetrtest_snippetvtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetltest_snippetotest_snippetotest_snippetktest_snippetetest_snippetdtest_snippet test_snippetntest_snippetotest_snippetttest_snippethtest_snippetitest_snippetntest_snippetgtest_snippet test_snippetltest_snippetitest_snippetktest_snippetetest_snippet test_snippetatest_snippetntest_snippet test_snippetItest_snippetPtest_snippet test_snippetatest_snippetdtest_snippetdtest_snippetrtest_snippetetest_snippetstest_snippetstest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippet\"test_snippetAtest_snippetntest_snippet test_snippetItest_snippetPtest_snippet test_snippetatest_snippetdtest_snippetdtest_snippetrtest_snippetetest_snippetstest_snippetstest_snippet test_snippetwtest_snippetatest_snippetstest_snippet test_snippetetest_snippetxtest_snippetptest_snippetetest_snippetctest_snippetttest_snippetetest_snippetdtest_snippet\"test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetrtest_snippetvtest_snippet,test_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetTtest_snippet_test_snippetItest_snippetPtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetTtest_snippetAtest_snippetTtest_snippetUtest_snippetStest_snippet_test_snippetItest_snippetStest_snippet_test_snippetEtest_snippetItest_snippetNtest_snippetVtest_snippetAtest_snippetLtest_snippet(test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetitest_snippetptest_snippetstest_snippetutest_snippetbtest_snippetntest_snippetetest_snippetttest_snippet_test_snippetctest_snippetrtest_snippetetest_snippetatest_snippetttest_snippetetest_snippet(test_snippet&test_snippetatest_snippet-test_snippet>test_snippetxtest_snippet.test_snippetitest_snippetptest_snippet,test_snippet test_snippetwtest_snippethtest_snippetetest_snippetrtest_snippetetest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet)test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetrtest_snippetvtest_snippet,test_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetmtest_snippetstest_snippetgtest_snippetbtest_snippetutest_snippetftest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetTtest_snippet_test_snippetItest_snippetPtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippet test_snippetstest_snippetltest_snippetatest_snippetstest_snippethtest_snippet,test_snippet test_snippetdtest_snippetitest_snippetdtest_snippetntest_snippet'test_snippetttest_snippet test_snippetltest_snippetotest_snippetotest_snippetktest_snippet test_snippetltest_snippetitest_snippetktest_snippetetest_snippet test_snippetatest_snippetntest_snippet test_snippetItest_snippetPtest_snippet test_snippetatest_snippetdtest_snippetdtest_snippetrtest_snippetetest_snippetstest_snippetstest_snippet test_snippet=test_snippet>test_snippet test_snippetmtest_snippetutest_snippetstest_snippetttest_snippet test_snippetbtest_snippetetest_snippet test_snippetatest_snippet test_snippethtest_snippetotest_snippetstest_snippetttest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetTtest_snippet_test_snippetHtest_snippetOtest_snippetStest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "121,Stack-based Buffer Overflow\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_88e8364040bcfd2873a702cadcc90cf75b3e31be_0", {
    "ID": "httpd_88e8364040bcfd2873a702cadcc90cf75b3e31be_0",
    "UID": "1896",
    "code": "static const char *set_user_dir(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    userdir_config *s_cfg = ap_get_module_config(cmd->server->module_config,\n                                                 &userdir_module);\n    char *username;\n    const char *usernames = arg;\n    char *kw = ap_getword_conf(cmd->pool, &usernames);\n    apr_table_t *usertable;\n\n    /* Since we are a raw argument, it is possible for us to be called with\n     * zero arguments.  So that we aren't ambiguous, flat out reject this.\n     */\n    if (*kw == '\\0') {\n        return \"UserDir requires an argument.\";\n    }\n\n    /*\n     * Let's do the comparisons once.\n     */\n    if ((!strcasecmp(kw, \"disable\")) || (!strcasecmp(kw, \"disabled\"))) {\n        /*\n         * If there are no usernames specified, this is a global disable - we\n         * need do no more at this point than record the fact.\n         */\n        if (strlen(usernames) == 0) {\n            s_cfg->globally_disabled = 1;\n            return NULL;\n        }\n        usertable = s_cfg->disabled_users;\n    }\n    else if ((!strcasecmp(kw, \"enable\")) || (!strcasecmp(kw, \"enabled\"))) {\n        /*\n         * The \"disable\" keyword can stand alone or take a list of names, but\n         * the \"enable\" keyword requires the list.  Whinge if it doesn't have\n         * it.\n         */\n        if (strlen(usernames) == 0) {\n            return \"UserDir \\\"enable\\\" keyword requires a list of usernames\";\n        }\n        usertable = s_cfg->enabled_users;\n    }\n    else {\n        /*\n         * If the first (only?) value isn't one of our keywords, just copy\n         * the string to the userdir string.\n         */\n        s_cfg->userdir = apr_pstrdup(cmd->pool, arg);\n        return NULL;\n    }\n    /*\n     * Now we just take each word in turn from the command line and add it to\n     * the appropriate table.\n     */\n    while (*usernames) {\n        username = ap_getword_conf(cmd->pool, &usernames);\n        apr_table_setn(usertable, username, kw);\n    }\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_21e639e2813abdfa157f35f9b10e4908df0ecc24_0", {
    "ID": "httpd_21e639e2813abdfa157f35f9b10e4908df0ecc24_0",
    "UID": "1903",
    "code": "test_snippet\npcre_get_substring_list(const char *subject, test_snippet *ovector, test_snippet stringcount,\n  const char ***listptr)\n{\ntest_snippet i;\ntest_snippet size = sizeof(char *);\ntest_snippet double_count = stringcount * 2;\nchar **stringlist;\nchar *p;\n\nfor (i = 0; i < double_count; i += 2)\n  size += sizeof(char *) + ovector[i+1] - ovector[i] + 1;\n\nstringlist = (char **)(pcre_malloc)(size);\nif (stringlist == NULL) return PCRE_ERROR_NOMEMORY;\n\n*listptr = (const char **)stringlist;\np = (char *)(stringlist + stringcount + 1);\n\nfor (i = 0; i < double_count; i += 2)\n  {\n  test_snippet len = ovector[i+1] - ovector[i];\n  memcpy(p, subject + ovector[i], len);\n  *stringlist++ = p;\n  p += len;\n  *p++ = 0;\n  }\n\n*stringlist = NULL;\nreturn 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n190,Integer Overflow or Wraparound\n401,Missing Release of Memory after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_53b7615a7382859aa54f320f38cca5ee80be26ae_0", {
    "ID": "httpd_53b7615a7382859aa54f320f38cca5ee80be26ae_0",
    "UID": "1906",
    "code": "static void putline(apr_file_t *f, char test_snippet\n{\n    int x;\n\n    for (x = 0; l[x]; x++)\n        apr_file_putc(l[x], f);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_5caa162e1b501499a975c4a0bb61600acf78f645_0", {
    "ID": "httpd_5caa162e1b501499a975c4a0bb61600acf78f645_0",
    "UID": "1909",
    "code": "AP_DECLARE(void) ap_add_common_vars(request_rec test_snippet\n{\n    apr_table_t *e;\n    server_rec *s = r->server;\n    conn_rec *c = r->connection;\n    const char *rem_logname;\n    char *env_path;\n#if defined(WIN32) || defined(OS2) || defined(BEOS)\n    char *env_temp;\n#endif\n    const char *host;\n    const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in);\n    const apr_table_entry_t *hdrs = (const apr_table_entry_t *) hdrs_arr->elts;\n    int i;\n    apr_port_t rport;\n\n    /* use a temporary apr_table_t which we'll overlap onto\n     * r->subprocess_env later\n     * (exception: if r->subprocess_env is empty at the start,\n     * write directly into it)\n     */\n    if (apr_is_empty_table(r->subprocess_env)) {\n        e = r->subprocess_env;\n    }\n    else {\n        e = apr_table_make(r->pool, 25 + hdrs_arr->nelts);\n    }\n\n    /* First, add environment vars from headers... this is as per\n     * CGI specs, though other sorts of scripting interfaces see\n     * the same vars...\n     */\n\n    for (i = 0; i < hdrs_arr->nelts; ++i) {\n        if (!hdrs[i].key) {\n            continue;\n        }\n\n        /* A few headers are special cased --- Authorization to prevent\n         * rogue scripts from capturing passwords; content-type and -length\n         * for no particular reason.\n         */\n\n        if (!strcasecmp(hdrs[i].key, \"Content-type\")) {\n            apr_table_addn(e, \"CONTENT_TYPE\", hdrs[i].val);\n        }\n        else if (!strcasecmp(hdrs[i].key, \"Content-length\")) {\n            apr_table_addn(e, \"CONTENT_LENGTH\", hdrs[i].val);\n        }\n        /*\n         * You really don't want to disable this check, since it leaves you\n         * wide open to CGIs stealing passwords and people viewing them\n         * in the environment with \"ps -e\".  But, if you must...\n         */\n#ifndef SECURITY_HOLE_PASS_AUTHORIZATION\n        else if (!strcasecmp(hdrs[i].key, \"Authorization\") \n                 || !strcasecmp(hdrs[i].key, \"Proxy-Authorization\")) {\n            continue;\n        }\n#endif\n        else {\n            apr_table_addn(e, http2env(r->pool, hdrs[i].key), hdrs[i].val);\n        }\n    }\n\n    if (!(env_path = getenv(\"PATH\"))) {\n        env_path = DEFAULT_PATH;\n    }\n    apr_table_addn(e, \"PATH\", apr_pstrdup(r->pool, env_path));\n\n#ifdef WIN32\n    if (env_temp = getenv(\"SystemRoot\")) {\n        apr_table_addn(e, \"SystemRoot\", env_temp);         \n    }\n    if (env_temp = getenv(\"COMSPEC\")) {\n        apr_table_addn(e, \"COMSPEC\", env_temp);            \n    }\n    if (env_temp = getenv(\"PATHEXT\")) {\n        apr_table_addn(e, \"PATHEXT\", env_temp);            \n    }\n    if (env_temp = getenv(\"WINDIR\")) {\n        apr_table_addn(e, \"WINDIR\", env_temp);\n    }\n#endif\n\n#ifdef OS2\n    if ((env_temp = getenv(\"COMSPEC\")) != NULL) {\n        apr_table_addn(e, \"COMSPEC\", env_temp);            \n    }\n    if ((env_temp = getenv(\"ETC\")) != NULL) {\n        apr_table_addn(e, \"ETC\", env_temp);            \n    }\n    if ((env_temp = getenv(\"DPATH\")) != NULL) {\n        apr_table_addn(e, \"DPATH\", env_temp);            \n    }\n    if ((env_temp = getenv(\"PERLLIB_PREFIX\")) != NULL) {\n        apr_table_addn(e, \"PERLLIB_PREFIX\", env_temp);            \n    }\n#endif\n\n#ifdef BEOS\n    if ((env_temp = getenv(\"LIBRARY_PATH\")) != NULL) {\n        apr_table_addn(e, \"LIBRARY_PATH\", env_temp);            \n    }\n#endif\n\n    apr_table_addn(e, \"SERVER_SIGNATURE\", ap_psignature(\"\", r));\n    apr_table_addn(e, \"SERVER_SOFTWARE\", ap_get_server_version());\n    apr_table_addn(e, \"SERVER_NAME\",\n                   ap_escape_html(r->pool, ap_get_server_name(r)));\n    apr_table_addn(e, \"SERVER_ADDR\", r->connection->local_ip);  \n    apr_table_addn(e, \"SERVER_PORT\",\n                  apr_psprintf(r->pool, \"%u\", ap_get_server_port(r)));\n    host = ap_get_remote_host(c, r->per_dir_config, REMOTE_HOST, NULL);\n    if (host) {\n        apr_table_addn(e, \"REMOTE_HOST\", host);\n    }\n    apr_table_addn(e, \"REMOTE_ADDR\", c->remote_ip);\n    apr_table_addn(e, \"DOCUMENT_ROOT\", ap_document_root(r));    \n    apr_table_addn(e, \"SERVER_ADMIN\", s->server_admin); \n    apr_table_addn(e, \"SCRIPT_FILENAME\", r->filename);  \n\n    rport = c->remote_addr->port;\n    apr_table_addn(e, \"REMOTE_PORT\", apr_itoa(r->pool, rport));\n\n    if (r->user) {\n        apr_table_addn(e, \"REMOTE_USER\", r->user);\n    }\n    else if (r->prev) {\n        request_rec *back = r->prev;\n\n        while (back) {\n            if (back->user) {\n                apr_table_addn(e, \"REDIRECT_REMOTE_USER\", back->user);\n                break;\n            }\n            back = back->prev;\n        }\n    }\n    if (r->ap_auth_type) {\n        apr_table_addn(e, \"AUTH_TYPE\", r->ap_auth_type);\n    }\n    rem_logname = ap_get_remote_logname(r);\n    if (rem_logname) {\n        apr_table_addn(e, \"REMOTE_IDENT\", apr_pstrdup(r->pool, rem_logname));\n    }\n\n    \n\n    if (r->prev) {\n        if (r->prev->args) {\n            apr_table_addn(e, \"REDIRECT_QUERY_STRING\", r->prev->args);\n        }\n        if (r->prev->uri) {\n            apr_table_addn(e, \"REDIRECT_URL\", r->prev->uri);\n        }\n    }\n\n    if (e != r->subprocess_env) {\n      apr_table_overlap(r->subprocess_env, e, APR_OVERLAP_TABLES_SET);\n    }\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n90,Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n123,Write-what-where Condition\n124,Buffer Underwrite ('Buffer Underflow')\n126,Buffer Over-read\n127,Buffer Under-read\n134,Use of Externally-Controlled Format String\n176,Improper Handling of Unicode Encoding\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n194,Unexpected Sign Extension\n195,Signed to Unsigned Conversion Error\n197,Numeric Truncation Error\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n272,Least Privilege Violation\n273,Improper Check for Dropped Privileges\n321,Use of Hard-coded Cryptographic Key\n338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n364,Signal Handler Race Condition\n366,Race Condition within a Thread\n369,Divide By Zero\n377,Insecure Temporary File\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n397,Declaration of Throws for Generic Exception\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n427,Uncontrolled Search Path Element\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n464,Addition of Data Structure Sentinel\n467,Use of sizeof() on a Pointer Type\n476,NULL Pointer Dereference\n479,Signal Handler Use of a Non-reentrant Function\n480,Use of Incorrect Operator\n511,Logic/Time Bomb\n526,Cleartext Storage of Sensitive Information in an Environment Variable\n546,Suspicious Comment\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n591,Sensitive Data Storage in Improperly Locked Memory\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n758,Reliance on Undefined\n761,Free of Pointer not at Start of Buffer\n762,Mismatched Memory Management Routines\n773,Missing Reference to Active File Descriptor or Handle\n775,Missing Release of File Descriptor or Handle after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_c20f5d82d566344158a031c7cfc1424d700f4252_0", {
    "ID": "httpd_c20f5d82d566344158a031c7cfc1424d700f4252_0",
    "UID": "1912",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet)test_snippet test_snippetutest_snippetntest_snippetitest_snippetxtest_snippetdtest_snippet_test_snippetstest_snippetetest_snippetttest_snippet_test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet_test_snippetptest_snippetatest_snippetrtest_snippetmtest_snippetstest_snippet test_snippet*test_snippetctest_snippetmtest_snippetdtest_snippet,test_snippet test_snippetstest_snippetttest_snippetrtest_snippetutest_snippetctest_snippetttest_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet*test_snippet*test_snippetptest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetatest_snippetrtest_snippetgtest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet test_snippetatest_snippetrtest_snippetgtest_snippet2test_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetttest_snippetytest_snippetptest_snippetetest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet#test_snippetitest_snippetftest_snippet test_snippet(test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippetdtest_snippet(test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet_test_snippetCtest_snippetPtest_snippetUtest_snippet)test_snippet test_snippet|test_snippet|test_snippet test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippetdtest_snippet(test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet_test_snippetDtest_snippetAtest_snippetTtest_snippetAtest_snippet)test_snippet test_snippet|test_snippet|test_snippet test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippetdtest_snippet(test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet_test_snippetVtest_snippetMtest_snippetEtest_snippetMtest_snippet)test_snippet test_snippet|test_snippet|test_snippet test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippetdtest_snippet(test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet_test_snippetNtest_snippetPtest_snippetRtest_snippetOtest_snippetCtest_snippet)test_snippet test_snippet|test_snippet|test_snippet test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippetdtest_snippet(test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet_test_snippetAtest_snippetStest_snippet)test_snippet)test_snippet test_snippet&test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetHtest_snippetAtest_snippetVtest_snippetEtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetUtest_snippetCtest_snippetTtest_snippet_test_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet test_snippet&test_snippet&test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetHtest_snippetAtest_snippetVtest_snippetEtest_snippet_test_snippetGtest_snippetEtest_snippetTtest_snippetRtest_snippetLtest_snippetItest_snippetMtest_snippetItest_snippetTtest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetstest_snippetttest_snippetrtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetttest_snippetrtest_snippetutest_snippetctest_snippetttest_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet*test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetItest_snippetftest_snippet test_snippetytest_snippetotest_snippetutest_snippetrtest_snippet test_snippetptest_snippetltest_snippetatest_snippetttest_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet test_snippetdtest_snippetotest_snippetetest_snippetstest_snippetntest_snippet'test_snippetttest_snippet test_snippetdtest_snippetetest_snippetftest_snippetitest_snippetntest_snippetetest_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippetntest_snippet test_snippetttest_snippetytest_snippetptest_snippetetest_snippetdtest_snippetetest_snippetftest_snippet test_snippetitest_snippetttest_snippet test_snippetitest_snippetntest_snippet test_snippetatest_snippetptest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet.test_snippethtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetttest_snippet test_snippetctest_snippetutest_snippetrtest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetttest_snippet test_snippetmtest_snippetatest_snippetxtest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet=test_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetutest_snippetctest_snippetttest_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet*test_snippet)test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetctest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippet*test_snippet*test_snippetptest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet=test_snippet test_snippet*test_snippetptest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetgtest_snippetetest_snippetttest_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet(test_snippetttest_snippetytest_snippetptest_snippetetest_snippet,test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet)test_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippetetest_snippetrtest_snippetrtest_snippetntest_snippetotest_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippet%test_snippetstest_snippet:test_snippet test_snippetgtest_snippetetest_snippetttest_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippetftest_snippetatest_snippetitest_snippetltest_snippetetest_snippetdtest_snippet\"test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetstest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippet&test_snippetatest_snippetrtest_snippetgtest_snippet)test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetstest_snippetetest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetstest_snippetttest_snippetrtest_snippet,test_snippet test_snippet\"test_snippetmtest_snippetatest_snippetxtest_snippet\"test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetutest_snippetrtest_snippet test_snippet=test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetmtest_snippetatest_snippetxtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetutest_snippetrtest_snippet test_snippet=test_snippet test_snippetatest_snippetttest_snippetotest_snippetltest_snippet(test_snippetstest_snippetttest_snippetrtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetItest_snippetntest_snippetvtest_snippetatest_snippetltest_snippetitest_snippetdtest_snippet test_snippetptest_snippetatest_snippetrtest_snippetatest_snippetmtest_snippetetest_snippetttest_snippetetest_snippetrtest_snippetstest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetatest_snippetrtest_snippetgtest_snippet2test_snippet test_snippet&test_snippet&test_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippetwtest_snippetotest_snippetrtest_snippetdtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippet&test_snippetatest_snippetrtest_snippetgtest_snippet2test_snippet)test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetmtest_snippetatest_snippetxtest_snippet test_snippet=test_snippet test_snippetatest_snippetttest_snippetotest_snippetltest_snippet(test_snippetstest_snippetttest_snippetrtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetitest_snippetftest_snippet test_snippetwtest_snippetetest_snippet test_snippetatest_snippetrtest_snippetetest_snippetntest_snippet'test_snippetttest_snippet test_snippetrtest_snippetutest_snippetntest_snippetntest_snippetitest_snippetntest_snippetgtest_snippet test_snippetatest_snippetstest_snippet test_snippetrtest_snippetotest_snippetotest_snippetttest_snippet,test_snippet test_snippetctest_snippetatest_snippetntest_snippetntest_snippetotest_snippetttest_snippet test_snippetitest_snippetntest_snippetctest_snippetrtest_snippetetest_snippetatest_snippetstest_snippetetest_snippet test_snippetmtest_snippetatest_snippetxtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetgtest_snippetetest_snippetttest_snippetetest_snippetutest_snippetitest_snippetdtest_snippet(test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetctest_snippetutest_snippetrtest_snippet test_snippet=test_snippet test_snippetctest_snippetutest_snippetrtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetmtest_snippetatest_snippetxtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetMtest_snippetutest_snippetstest_snippetttest_snippet test_snippetbtest_snippetetest_snippet test_snippetutest_snippetitest_snippetdtest_snippet test_snippet0test_snippet test_snippetttest_snippetotest_snippet test_snippetrtest_snippetatest_snippetitest_snippetstest_snippetetest_snippet test_snippetmtest_snippetatest_snippetxtest_snippetitest_snippetmtest_snippetutest_snippetmtest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetutest_snippetrtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetctest_snippetutest_snippetrtest_snippet test_snippet=test_snippet test_snippetctest_snippetutest_snippetrtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetmtest_snippetatest_snippetxtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippet_test_snippetmtest_snippetatest_snippetxtest_snippet test_snippet=test_snippet test_snippetmtest_snippetatest_snippetxtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet#test_snippetetest_snippetltest_snippetstest_snippetetest_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetPtest_snippetltest_snippetatest_snippetttest_snippetftest_snippetotest_snippetrtest_snippetmtest_snippet test_snippetdtest_snippetotest_snippetetest_snippetstest_snippet test_snippetntest_snippetotest_snippetttest_snippet test_snippetstest_snippetutest_snippetptest_snippetptest_snippetotest_snippetrtest_snippetttest_snippet test_snippetrtest_snippetltest_snippetitest_snippetmtest_snippetitest_snippetttest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet#test_snippetetest_snippetntest_snippetdtest_snippetitest_snippetftest_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code is not readable or understandable. It seems to be obfuscated or encrypted. Please provide a valid piece of C/C++ code."
  },
  "httpd_0652c5801974af4ab065419590da5a47879cd59d_0", {
    "ID": "httpd_0652c5801974af4ab065419590da5a47879cd59d_0",
    "UID": "1915",
    "code": "static int mkrecord(char *user, char *record, apr_size_t rlen, char test_snippet\n                    int alg)\n{\n    char *pw;\n    char cpw[120];\n    char pwin[MAX_STRING_LEN];\n    char pwv[MAX_STRING_LEN];\n    char salt[9];\n    apr_size_t bufsize;\n\n    if (passwd != NULL) {\n        pw = passwd;\n    }\n    else {\n        bufsize = sizeof(pwin);\n        if (apr_password_get(\"New password: \", pwin, &bufsize) != 0) {\n            apr_snprintf(record, (rlen - 1), \"password too long (>%\" \n                         APR_SIZE_T_FMT \")\", sizeof(pwin) - 1);\n            return ERR_OVERFLOW;\n        }\n        bufsize = sizeof(pwv);\n        apr_password_get(\"Re-type new password: \", pwv, &bufsize);\n        if (strcmp(pwin, pwv) != 0) {\n            apr_cpystrn(record, \"password verification error\", (rlen - 1));\n            return ERR_PWMISMATCH;\n        }\n        pw = pwin;\n        memset(pwv, '\\0', sizeof(pwin));\n    }\n    switch (alg) {\n\n    case ALG_APSHA:\n        \n        apr_sha1_base64(pw,strlen(pw),cpw);\n        break;\n\n    case ALG_APMD5: \n        (void) srand((int) time((time_t *) NULL));\n        to64(&salt[0], rand(), 8);\n        salt[8] = '\\0';\n\n        apr_md5_encode((const char *)pw, (const char *)salt,\n                     cpw, sizeof(cpw));\n        break;\n\n    case ALG_PLAIN:\n        \n        apr_cpystrn(cpw,pw,sizeof(cpw));\n        break;\n\n#if !(defined(WIN32) || defined(NETWARE))\n    case ALG_CRYPT:\n    default:\n        (void) srand((int) time((time_t *) NULL));\n        to64(&salt[0], rand(), 8);\n        salt[8] = '\\0';\n\n        apr_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);\n        break;\n#endif\n    }\n    memset(pw, '\\0', strlen(pw));\n\n    /*\n     * Check to see if the buffer is large enough to hold the username,\n     * hash, and delimiters.\n     */\n    if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {\n        apr_cpystrn(record, \"resultant record too long\", (rlen - 1));\n        return ERR_OVERFLOW;\n    }\n    strcpy(record, user);\n    strcat(record, \":\");\n    strcat(record, cpw);\n    strcat(record, \"\\n\");\n    return 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n"
  },
  "httpd_810512590151af133721e1c24675afcc2fd76f22_0", {
    "ID": "httpd_810512590151af133721e1c24675afcc2fd76f22_0",
    "UID": "1921",
    "code": "static void *overlay_extension_mappings(apr_pool_t test_snippet\n                                        const void *key,\n                                        apr_ssize_t klen,\n                                        const void *overlay_val,\n                                        const void *base_val,\n                                        const void *data)\n{\n    extension_info *new_info = apr_palloc(p, sizeof(extension_info));\n    const extension_info *overlay_info = (const extension_info *)overlay_val;\n    const extension_info *base_info = (const extension_info *)base_val;\n\n    memcpy(new_info, base_info, sizeof(extension_info));\n    if (overlay_info->forced_type) {\n        new_info->forced_type = overlay_info->forced_type;\n    }\n    if (overlay_info->encoding_type) {\n        new_info->encoding_type = overlay_info->encoding_type;\n    }\n    if (overlay_info->language_type) {\n        new_info->language_type = overlay_info->language_type;\n    }\n    if (overlay_info->handler) {\n        new_info->handler = overlay_info->handler;\n    }\n    if (overlay_info->charset_type) {\n        new_info->charset_type = overlay_info->charset_type;\n    }\n    if (overlay_info->input_filters) {\n        new_info->input_filters = overlay_info->input_filters;\n    }\n    if (overlay_info->output_filters) {\n        new_info->output_filters = overlay_info->output_filters;\n    }\n\n    return new_info;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_682c88bb46d6752f2c85aa4af80071c22876d59f_0", {
    "ID": "httpd_682c88bb46d6752f2c85aa4af80071c22876d59f_0",
    "UID": "1926",
    "code": "static int get_basic_auth(request_rec *r, const char test_snippet\n                          const char **pw)\n{\n    const char *auth_line;\n    char *decoded_line;\n    int length;\n\n    \n    auth_line = apr_table_get(r->headers_in, (PROXYREQ_PROXY == r->proxyreq)\n                                              ? \"Proxy-Authorization\"\n                                              : \"Authorization\");\n\n    if (!auth_line) {\n        note_basic_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), \"Basic\")) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"client used wrong authentication scheme: %s\", r->uri);\n        note_basic_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    \n    while (apr_isspace(*auth_line)) {\n        auth_line++;\n    }\n\n    decoded_line = apr_palloc(r->pool, apr_base64_decode_len(auth_line) + 1);\n    length = apr_base64_decode(decoded_line, auth_line);\n    \n    decoded_line[length] = '\\0';\n\n    *user = ap_getword_nulls(r->pool, (const char**)&decoded_line, ':');\n    *pw = decoded_line;\n\n    \n    r->user = (char *) *user;\n\n    return OK;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n511,Logic/Time Bomb\n526,Cleartext Storage of Sensitive Information in an Environment Variable\n546,Suspicious Comment\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n591,Sensitive Data Storage in Improperly Locked Memory\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n758,Reliance on Undefined\n761,Free of Pointer not at Start of Buffer\n762,Mismatched Memory Management Routines\n773,Missing Reference to Active File Descriptor or Handle\n775,Missing Release of File Descriptor or Handle after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_b41bb16f573d881fc2f709d147bd8ce263f909e3_0", {
    "ID": "httpd_b41bb16f573d881fc2f709d147bd8ce263f909e3_0",
    "UID": "1928",
    "code": "static int action_handler(request_rec test_snippet\n{\n    action_dir_config *conf = (action_dir_config *)\n        ap_get_module_config(r->per_dir_config, &actions_module);\n    const char *t, *action;\n    const char *script;\n    int i;\n\n    if (!conf->configured) {\n        return DECLINED;\n    }\n\n    \n\n    \n    for (i = 0; i < METHODS; ++i) {\n        if (conf->scripted[i])\n            r->allowed |= (AP_METHOD_BIT << i);\n    }\n\n    \n    if (r->method_number == M_GET) {\n        if (r->args)\n            script = conf->scripted[M_GET];\n        else\n            script = NULL;\n    }\n    else {\n        script = conf->scripted[r->method_number];\n    }\n\n    \n    if (script && r->prev && r->prev->prev)\n\treturn DECLINED;\n\n    \n    action = r->handler ? r->handler :\n        ap_field_noparam(r->pool, r->content_type);\n    action = action ? action : ap_default_type(r);\n\n    if ((t = apr_table_get(conf->action_types, action))) {\n        if (*t++ == '0' && r->finfo.filetype == 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"File does not exist: %s\", r->filename);\n            return HTTP_NOT_FOUND;\n        }\n\n        script = t;\n        /* propagate the handler name to the script\n         * (will be REDIRECT_HANDLER there)\n         */\n        apr_table_setn(r->subprocess_env, \"HANDLER\", action);\n    }\n\n    if (script == NULL)\n\treturn DECLINED;\n\n    ap_internal_redirect_handler(apr_pstrcat(r->pool, script,\n                                             ap_escape_uri(r->pool, r->uri),\n                                             r->args ? \"?\" : NULL,\n                                             r->args, NULL), r);\n    return OK;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_1a2f0127e40196490977f767553f108223f7d825_0", {
    "ID": "httpd_1a2f0127e40196490977f767553f108223f7d825_0",
    "UID": "1946",
    "code": "AP_DECLARE(int) ap_find_last_token(apr_pool_t *p, const char test_snippet\n                                   const char *tok)\n{\n    int llen, tlen, lidx;\n\n    if (!line)\n        return 0;\n\n    llen = strlen(line);\n    tlen = strlen(tok);\n    lidx = llen - tlen;\n\n    if (lidx < 0 ||\n        (lidx > 0 && !(apr_isspace(line[lidx - 1]) || line[lidx - 1] == ',')))\n        return 0;\n\n    return (strncasecmp(&line[lidx], tok, tlen) == 0);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_dd065e4cb6d8ec127c62e52832c1c4f21c1111ba_0", {
    "ID": "httpd_dd065e4cb6d8ec127c62e52832c1c4f21c1111ba_0",
    "UID": "1949",
    "code": "static test_snippet\ncheck_escape(const uschar **ptrptr, const char **errorptr, test_snippet bracount,\n  test_snippet options, BOOL isclass, compile_data *cd)\n{\nconst uschar *ptr = *ptrptr;\ntest_snippet c, i;\n\n\n\nc = *(++ptr);\nif (c == 0) *errorptr = ERR1;\n\n\n\nelse if (c < '0' || c > 'z') {}\n\n/* Do an initial lookup in a table. A non-zero result is something that can be\nreturned immediately. Otherwise further processing may be required. */\n\nelse if ((i = escapes[c - '0']) != 0) c = i;\n\n\n\nelse\n  {\n  const uschar *oldptr;\n  switch (c)\n    {\n    /* The handling of escape sequences consisting of a string of digits\n    starting with one that is not zero is not straightforward. By experiment,\n    the way Perl works seems to be as follows:\n\n    Outside a character class, the digits are read as a decimal number. If the\n    number is less than 10, or if there are that many previous extracting\n    left brackets, then it is a back reference. Otherwise, up to three octal\n    digits are read to form an escaped byte. Thus \\123 is likely to be octal\n    123 (cf \\0123, which is octal 012 followed by the literal 3). If the octal\n    value is greater than 377, the least significant 8 bits are taken. Inside a\n    character class, \\ followed by a digit is always an octal number. */\n\n    case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n\n    if (!isclass)\n      {\n      oldptr = ptr;\n      c -= '0';\n      while ((cd->ctypes[ptr[1]] & ctype_digit) != 0)\n        c = c * 10 + *(++ptr) - '0';\n      if (c < 10 || c <= bracount)\n        {\n        c = -(ESC_REF + c);\n        break;\n        }\n      ptr = oldptr;      \n      }\n\n    /* Handle an octal number following \\. If the first digit is 8 or 9, Perl\n    generates a binary zero byte and treats the digit as a following literal.\n    Thus we have to pull back the potest_snippeter by one. */\n\n    if ((c = *ptr) >= '8')\n      {\n      ptr--;\n      c = 0;\n      break;\n      }\n\n    /* \\0 always starts an octal number, but we may drop through to here with a\n    larger first octal digit. */\n\n    case '0':\n    c -= '0';\n    while(i++ < 2 && (cd->ctypes[ptr[1]] & ctype_digit) != 0 &&\n      ptr[1] != '8' && ptr[1] != '9')\n        c = c * 8 + *(++ptr) - '0';\n    c &= 255;     \n    break;\n\n    /* \\x is complicated when UTF-8 is enabled. \\x{ddd} is a character number\n    which can be greater than 0xff, but only if the ddd are hex digits. */\n\n    case 'x':\n#ifdef SUPPORT_UTF8\n    if (ptr[1] == '{' && (options & PCRE_UTF8) != 0)\n      {\n      const uschar *pt = ptr + 2;\n      register test_snippet count = 0;\n      c = 0;\n      while ((cd->ctypes[*pt] & ctype_xdigit) != 0)\n        {\n        count++;\n        c = c * 16 + cd->lcc[*pt] -\n          (((cd->ctypes[*pt] & ctype_digit) != 0)? '0' : 'W');\n        pt++;\n        }\n      if (*pt == '}')\n        {\n        if (c < 0 || count > 8) *errorptr = ERR34;\n        ptr = pt;\n        break;\n        }\n      /* If the sequence of hex digits does not end with '}', then we don't\n      recognize this construct; fall through to the normal \\x handling. */\n      }\n#endif\n\n    \n\n    c = 0;\n    while (i++ < 2 && (cd->ctypes[ptr[1]] & ctype_xdigit) != 0)\n      {\n      ptr++;\n      c = c * 16 + cd->lcc[*ptr] -\n        (((cd->ctypes[*ptr] & ctype_digit) != 0)? '0' : 'W');\n      }\n    break;\n\n    \n\n    case 'c':\n    c = *(++ptr);\n    if (c == 0)\n      {\n      *errorptr = ERR2;\n      return 0;\n      }\n\n    \n\n    if (c >= 'a' && c <= 'z') c = cd->fcc[c];\n    c ^= 0x40;\n    break;\n\n    /* PCRE_EXTRA enables extensions to Perl in the matter of escapes. Any\n    other alphameric following \\ is an error if PCRE_EXTRA was set; otherwise,\n    for Perl compatibility, it is a literal. This code looks a bit odd, but\n    there used to be some cases other than the default, and there may be again\n    in future, so I haven't \"optimized\" it. */\n\n    default:\n    if ((options & PCRE_EXTRA) != 0) switch(c)\n      {\n      default:\n      *errorptr = ERR3;\n      break;\n      }\n    break;\n    }\n  }\n\n*ptrptr = ptr;\nreturn c;\n}",
    "predicted": "476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n369,Divide By Zero\n122,Heap-based Buffer Overflow\n121,Stack-based Buffer Overflow\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n467,Use of sizeof() on a Pointer Type\n476,NULL Pointer Dereference\n511,Logic/Time Bomb\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n690,Unchecked Return Value to NULL Pointer Dereference\n758,Reliance on Undefined\n761,Free of Pointer not at Start of Buffer\n762,Mismatched Memory Management Routines\n773,Missing Reference to Active File Descriptor or Handle\n775,Missing Release of File Descriptor or Handle after Effective Lifetime\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_526e3a5ca12886c3f791d53db78dfbc15e5bf9f6_0", {
    "ID": "httpd_526e3a5ca12886c3f791d53db78dfbc15e5bf9f6_0",
    "UID": "1951",
    "code": "pcre test_snippet\npcre_compile(const char test_snippetpattern, int options, const char test_snippettest_snippeterrorptr,\n  int test_snippeterroroffset, const unsigned char test_snippettables)\n{\nreal_pcre test_snippetre;\nint length = 3;      /test_snippet For initial BRA plus length test_snippet/\nint runlength;\nint c, reqchar, countlits;\nint bracount = 0;\nint top_backref = 0;\nint branch_extra = 0;\nint branch_newextra;\nunsigned int brastackptr = 0;\nsize_t size;\nuschar test_snippetcode;\nconst uschar test_snippetptr;\ncompile_data compile_block;\nint brastack[BRASTACK_SIZE];\nuschar bralenstack[BRASTACK_SIZE];\n\n#ifdef DEBUG\nuschar test_snippetcode_base, test_snippetcode_end;\n#endif\n\n/test_snippet Can't support UTF8 unless PCRE has been compiled to include the code. test_snippet/\n\n#ifndef SUPPORT_UTF8\nif ((options & PCRE_UTF8) != 0)\n  {\n  test_snippeterrorptr = ERR32;\n  return NULL;\n  }\n#endif\n\n/test_snippet We can't pass back an error message if errorptr is NULL; I guess the best we\ncan do is just return NULL. test_snippet/\n\nif (errorptr == NULL) return NULL;\ntest_snippeterrorptr = NULL;\n\n/test_snippet However, we can give a message for this error test_snippet/\n\nif (erroroffset == NULL)\n  {\n  test_snippeterrorptr = ERR16;\n  return NULL;\n  }\ntest_snippeterroroffset = 0;\n\nif ((options & ~PUBLIC_OPTIONS) != 0)\n  {\n  test_snippeterrorptr = ERR17;\n  return NULL;\n  }\n\n/test_snippet Set up pointers to the individual character tables test_snippet/\n\nif (tables == NULL) tables = pcre_default_tables;\ncompile_block.lcc = tables + lcc_offset;\ncompile_block.fcc = tables + fcc_offset;\ncompile_block.cbits = tables + cbits_offset;\ncompile_block.ctypes = tables + ctypes_offset;\n\n/test_snippet Reflect pattern for debugging output test_snippet/\n\nDPRINTF((\"------------------------------------------------------------------\\n\"));\nDPRINTF((\"%s\\n\", pattern));\n\n/test_snippet The first thing to do is to make a pass over the pattern to compute the\namount of store required to hold the compiled code. This does not have to be\nperfect as long as errors are overestimates. At the same time we can detect any\ninternal flag settings. Make an attempt to correct for any counted white space\nif an \"extended\" flag setting appears late in the pattern. We can't be so\nclever for #-comments. test_snippet/\n\nptr = (const uschar test_snippet)(pattern - 1);\nwhile ((c = test_snippet(++ptr)) != 0)\n  {\n  int min, max;\n  int class_charcount;\n  int bracket_length;\n\n  if ((options & PCRE_EXTENDED) != 0)\n    {\n    if ((compile_block.ctypes[c] & ctype_space) != 0) continue;\n    if (c == '#')\n      {\n      /test_snippet The space before the ; is to avoid a warning on a silly compiler\n      on the Macintosh. test_snippet/\n      while ((c = test_snippet(++ptr)) != 0 && c != NEWLINE) ;\n      continue;\n      }\n    }\n\n  switch(c)\n    {\n    /test_snippet A backslashed item may be an escaped \"normal\" character or a\n    character type. For a \"normal\" character, put the pointers and\n    character back so that tests for whitespace etc. in the input\n    are done correctly. test_snippet/\n\n    case '\\\\':\n      {\n      const uschar test_snippetsave_ptr = ptr;\n      c = check_escape(&ptr, errorptr, bracount, options, FALSE, &compile_block);\n      if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n      if (c >= 0)\n        {\n        ptr = save_ptr;\n        c = '\\\\';\n        goto NORMAL_CHAR;\n        }\n      }\n    length++;\n\n    /test_snippet A back reference needs an additional 2 bytes, plus either one or 5\n    bytes for a repeat. We also need to keep the value of the highest\n    back reference. test_snippet/\n\n    if (c <= -ESC_REF)\n      {\n      int refnum = -c - ESC_REF;\n      if (refnum > top_backref) top_backref = refnum;\n      length += 2;   /test_snippet For single back reference test_snippet/\n      if (ptr[1] == '{' && is_counted_repeat(ptr+2, &compile_block))\n        {\n        ptr = read_repeat_counts(ptr+2, &min, &max, errorptr, &compile_block);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if ((min == 0 && (max == 1 || max == -1)) ||\n          (min == 1 && max == -1))\n            length++;\n        else length += 5;\n        if (ptr[1] == '?') ptr++;\n        }\n      }\n    continue;\n\n    case '^':\n    case '.':\n    case '$':\n    case 'test_snippet':     /test_snippet These repeats won't be after brackets; test_snippet/\n    case '+':     /test_snippet those are handled separately test_snippet/\n    case '?':\n    length++;\n    continue;\n\n    /test_snippet This covers the cases of repeats after a single char, metachar, class,\n    or back reference. test_snippet/\n\n    case '{':\n    if (!is_counted_repeat(ptr+1, &compile_block)) goto NORMAL_CHAR;\n    ptr = read_repeat_counts(ptr+1, &min, &max, errorptr, &compile_block);\n    if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n    if ((min == 0 && (max == 1 || max == -1)) ||\n      (min == 1 && max == -1))\n        length++;\n    else\n      {\n      length--;   /test_snippet Uncount the original char or metachar test_snippet/\n      if (min == 1) length++; else if (min > 0) length += 4;\n      if (max > 0) length += 4; else length += 2;\n      }\n    if (ptr[1] == '?') ptr++;\n    continue;\n\n    /test_snippet An alternation contains an offset to the next branch or ket. If any ims\n    options changed in the previous branch(es), and/or if we are in a\n    lookbehind assertion, extra space will be needed at the start of the\n    branch. This is handled by branch_extra. test_snippet/\n\n    case '|':\n    length += 3 + branch_extra;\n    continue;\n\n    /test_snippet A character class uses 33 characters. Don't worry about character types\n    that aren't allowed in classes - they'll get picked up during the compile.\n    A character class that contains only one character uses 2 or 3 bytes,\n    depending on whether it is negated or not. Notice this where we can. test_snippet/\n\n    case '[':\n    class_charcount = 0;\n    if (test_snippet(++ptr) == '^') ptr++;\n    do\n      {\n      if (test_snippetptr == '\\\\')\n        {\n        int ch = check_escape(&ptr, errorptr, bracount, options, TRUE,\n          &compile_block);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if (-ch == ESC_b) class_charcount++; else class_charcount = 10;\n        }\n      else class_charcount++;\n      ptr++;\n      }\n    while (test_snippetptr != 0 && test_snippetptr != ']');\n\n    /test_snippet Repeats for negated single chars are handled by the general code test_snippet/\n\n    if (class_charcount == 1) length += 3; else\n      {\n      length += 33;\n\n      /test_snippet A repeat needs either 1 or 5 bytes. test_snippet/\n\n      if (test_snippetptr != 0 && ptr[1] == '{' && is_counted_repeat(ptr+2, &compile_block))\n        {\n        ptr = read_repeat_counts(ptr+2, &min, &max, errorptr, &compile_block);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if ((min == 0 && (max == 1 || max == -1)) ||\n          (min == 1 && max == -1))\n            length++;\n        else length += 5;\n        if (ptr[1] == '?') ptr++;\n        }\n      }\n    continue;\n\n    /test_snippet Brackets may be genuine groups or special things test_snippet/\n\n    case '(':\n    branch_newextra = 0;\n    bracket_length = 3;\n\n    /test_snippet Handle special forms of bracket, which all start (? test_snippet/\n\n    if (ptr[1] == '?')\n      {\n      int set, unset;\n      int test_snippetoptset;\n\n      switch (c = ptr[2])\n        {\n        /test_snippet Skip over comments entirely test_snippet/\n        case '#':\n        ptr += 3;\n        while (test_snippetptr != 0 && test_snippetptr != ')') ptr++;\n        if (test_snippetptr == 0)\n          {\n          test_snippeterrorptr = ERR18;\n          goto PCRE_ERROR_RETURN;\n          }\n        continue;\n\n        /test_snippet Non-referencing groups and lookaheads just move the pointer on, and\n        then behave like a non-special bracket, except that they don't increment\n        the count of extracting brackets. Ditto for the \"once only\" bracket,\n        which is in Perl from version 5.005. test_snippet/\n\n        case ':':\n        case '=':\n        case '!':\n        case '>':\n        ptr += 2;\n        break;\n\n        /test_snippet A recursive call to the regex is an extension, to provide the\n        facility which can be obtained by $(?p{perl-code}) in Perl 5.6. test_snippet/\n\n        case 'R':\n        if (ptr[3] != ')')\n          {\n          test_snippeterrorptr = ERR29;\n          goto PCRE_ERROR_RETURN;\n          }\n        ptr += 3;\n        length += 1;\n        break;\n\n        /test_snippet Lookbehinds are in Perl from version 5.005 test_snippet/\n\n        case '<':\n        if (ptr[3] == '=' || ptr[3] == '!')\n          {\n          ptr += 3;\n          branch_newextra = 3;\n          length += 3;         /test_snippet For the first branch test_snippet/\n          break;\n          }\n        test_snippeterrorptr = ERR24;\n        goto PCRE_ERROR_RETURN;\n\n        /test_snippet Conditionals are in Perl from version 5.005. The bracket must either\n        be followed by a number (for bracket reference) or by an assertion\n        group. test_snippet/\n\n        case '(':\n        if ((compile_block.ctypes[ptr[3]] & ctype_digit) != 0)\n          {\n          ptr += 4;\n          length += 3;\n          while ((compile_block.ctypes[test_snippetptr] & ctype_digit) != 0) ptr++;\n          if (test_snippetptr != ')')\n            {\n            test_snippeterrorptr = ERR26;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n        else   /test_snippet An assertion must follow test_snippet/\n          {\n          ptr++;   /test_snippet Can treat like ':' as far as spacing is concerned test_snippet/\n          if (ptr[2] != '?' ||\n             (ptr[3] != '=' && ptr[3] != '!' && ptr[3] != '<') )\n            {\n            ptr += 2;    /test_snippet To get right offset in message test_snippet/\n            test_snippeterrorptr = ERR28;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n        break;\n\n        /test_snippet Else loop checking valid options until ) is met. Anything else is an\n        error. If we are without any brackets, i.e. at top level, the settings\n        act as if specified in the options, so massage the options immediately.\n        This is for backward compatibility with Perl 5.004. test_snippet/\n\n        default:\n        set = unset = 0;\n        optset = &set;\n        ptr += 2;\n\n        for (;; ptr++)\n          {\n          c = test_snippetptr;\n          switch (c)\n            {\n            case 'i':\n            test_snippetoptset |= PCRE_CASELESS;\n            continue;\n\n            case 'm':\n            test_snippetoptset |= PCRE_MULTILINE;\n            continue;\n\n            case 's':\n            test_snippetoptset |= PCRE_DOTALL;\n            continue;\n\n            case 'x':\n            test_snippetoptset |= PCRE_EXTENDED;\n            continue;\n\n            case 'X':\n            test_snippetoptset |= PCRE_EXTRA;\n            continue;\n\n            case 'U':\n            test_snippetoptset |= PCRE_UNGREEDY;\n            continue;\n\n            case '-':\n            optset = &unset;\n            continue;\n\n            /test_snippet A termination by ')' indicates an options-setting-only item;\n            this is global at top level; otherwise nothing is done here and\n            it is handled during the compiling process on a per-bracket-group\n            basis. test_snippet/\n\n            case ')':\n            if (brastackptr == 0)\n              {\n              options = (options | set) & (~unset);\n              set = unset = 0;     /test_snippet To save length test_snippet/\n              }\n            /test_snippet Fall through test_snippet/\n\n            /test_snippet A termination by ':' indicates the start of a nested group with\n            the given options set. This is again handled at compile time, but\n            we must allow for compiled space if any of the ims options are\n            set. We also have to allow for resetting space at the end of\n            the group, which is why 4 is added to the length and not just 2.\n            If there are several changes of options within the same group, this\n            will lead to an over-estimate on the length, but this shouldn't\n            matter very much. We also have to allow for resetting options at\n            the start of any alternations, which we do by setting\n            branch_newextra to 2. Finally, we record whether the case-dependent\n            flag ever changes within the regex. This is used by the \"required\n            character\" code. test_snippet/\n\n            case ':':\n            if (((set|unset) & PCRE_IMS) != 0)\n              {\n              length += 4;\n              branch_newextra = 2;\n              if (((set|unset) & PCRE_CASELESS) != 0) options |= PCRE_ICHANGED;\n              }\n            goto END_OPTIONS;\n\n            /test_snippet Unrecognized option character test_snippet/\n\n            default:\n            test_snippeterrorptr = ERR12;\n            goto PCRE_ERROR_RETURN;\n            }\n          }\n\n        /test_snippet If we hit a closing bracket, that's it - this is a freestanding\n        option-setting. We need to ensure that branch_extra is updated if\n        necessary. The only values branch_newextra can have here are 0 or 2.\n        If the value is 2, then branch_extra must either be 2 or 5, depending\n        on whether this is a lookbehind group or not. test_snippet/\n\n        END_OPTIONS:\n        if (c == ')')\n          {\n          if (branch_newextra == 2 && (branch_extra == 0 || branch_extra == 3))\n            branch_extra += branch_newextra;\n          continue;\n          }\n\n        /test_snippet If options were terminated by ':' control comes here. Fall through\n        to handle the group below. test_snippet/\n        }\n      }\n\n    /test_snippet Extracting brackets must be counted so we can process escapes in a\n    Perlish way. If the number exceeds EXTRACT_BASIC_MAX we are going to\n    need an additional 3 bytes of store per extracting bracket. test_snippet/\n\n    else\n      {\n      bracount++;\n      if (bracount > EXTRACT_BASIC_MAX) bracket_length += 3;\n      }\n\n    /test_snippet Save length for computing whole length at end if there's a repeat that\n    requires duplication of the group. Also save the current value of\n    branch_extra, and start the new group with the new value. If non-zero, this\n    will either be 2 for a (?imsx: group, or 3 for a lookbehind assertion. test_snippet/\n\n    if (brastackptr >= sizeof(brastack)/sizeof(int))\n      {\n      test_snippeterrorptr = ERR19;\n      goto PCRE_ERROR_RETURN;\n      }\n\n    bralenstack[brastackptr] = branch_extra;\n    branch_extra = branch_newextra;\n\n    brastack[brastackptr++] = length;\n    length += bracket_length;\n    continue;\n\n    /test_snippet Handle ket. Look for subsequent max/min; for certain sets of values we\n    have to replicate this bracket up to that many times. If brastackptr is\n    0 this is an unmatched bracket which will generate an error, but take care\n    not to try to access brastack[-1] when computing the length and restoring\n    the branch_extra value. test_snippet/\n\n    case ')':\n    length += 3;\n      {\n      int minval = 1;\n      int maxval = 1;\n      int duplength;\n\n      if (brastackptr > 0)\n        {\n        duplength = length - brastack[--brastackptr];\n        branch_extra = bralenstack[brastackptr];\n        }\n      else duplength = 0;\n\n      /test_snippet Leave ptr at the final char; for read_repeat_counts this happens\n      automatically; for the others we need an increment. test_snippet/\n\n      if ((c = ptr[1]) == '{' && is_counted_repeat(ptr+2, &compile_block))\n        {\n        ptr = read_repeat_counts(ptr+2, &minval, &maxval, errorptr,\n          &compile_block);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        }\n      else if (c == 'test_snippet') { minval = 0; maxval = -1; ptr++; }\n      else if (c == '+') { maxval = -1; ptr++; }\n      else if (c == '?') { minval = 0; ptr++; }\n\n      /test_snippet If the minimum is zero, we have to allow for an OP_BRAZERO before the\n      group, and if the maximum is greater than zero, we have to replicate\n      maxval-1 times; each replication acquires an OP_BRAZERO plus a nesting\n      bracket set - hence the 7. test_snippet/\n\n      if (minval == 0)\n        {\n        length++;\n        if (maxval > 0) length += (maxval - 1) test_snippet (duplength + 7);\n        }\n\n      /test_snippet When the minimum is greater than zero, 1 we have to replicate up to\n      minval-1 times, with no additions required in the copies. Then, if\n      there is a limited maximum we have to replicate up to maxval-1 times\n      allowing for a BRAZERO item before each optional copy and nesting\n      brackets for all but one of the optional copies. test_snippet/\n\n      else\n        {\n        length += (minval - 1) test_snippet duplength;\n        if (maxval > minval)   /test_snippet Need this test as maxval=-1 means no limit test_snippet/\n          length += (maxval - minval) test_snippet (duplength + 7) - 6;\n        }\n      }\n    continue;\n\n    /test_snippet Non-special character. For a run of such characters the length required\n    is the number of characters + 2, except that the maximum run length is 255.\n    We won't get a skipped space or a non-data escape or the start of a #\n    comment as the first character, so the length can't be zero. test_snippet/\n\n    NORMAL_CHAR:\n    default:\n    length += 2;\n    runlength = 0;\n    do\n      {\n      if ((options & PCRE_EXTENDED) != 0)\n        {\n        if ((compile_block.ctypes[c] & ctype_space) != 0) continue;\n        if (c == '#')\n          {\n          /test_snippet The space before the ; is to avoid a warning on a silly compiler\n          on the Macintosh. test_snippet/\n          while ((c = test_snippet(++ptr)) != 0 && c != NEWLINE) ;\n          continue;\n          }\n        }\n\n      /test_snippet Backslash may introduce a data char or a metacharacter; stop the\n      string before the latter. test_snippet/\n\n      if (c == '\\\\')\n        {\n        const uschar test_snippetsaveptr = ptr;\n        c = check_escape(&ptr, errorptr, bracount, options, FALSE,\n          &compile_block);\n        if (test_snippeterrorptr != NULL) goto PCRE_ERROR_RETURN;\n        if (c < 0) { ptr = saveptr; break; }\n\n#ifdef SUPPORT_UTF8\n        if (c > 127 && (options & PCRE_UTF8) != 0)\n          {\n          int i;\n          for (i = 0; i < sizeof(utf8_table1)/sizeof(int); i++)\n            if (c <= utf8_table1[i]) break;\n          runlength += i;\n          }\n#endif\n        }\n\n      /test_snippet Ordinary character or single-char escape test_snippet/\n\n      runlength++;\n      }\n\n    /test_snippet This \"while\" is the end of the \"do\" above. test_snippet/\n\n    while (runlength < MAXLIT &&\n      (compile_block.ctypes[c = test_snippet(++ptr)] & ctype_meta) == 0);\n\n    ptr--;\n    length += runlength;\n    continue;\n    }\n  }\n\nlength += 4;    /test_snippet For final KET and END test_snippet/\n\nif (length > 65539)\n  {\n  test_snippeterrorptr = ERR20;\n  return NULL;\n  }\n\n/test_snippet Compute the size of data block needed and get it, either from malloc or\nexternally provided function. We specify \"code[0]\" in the offsetof() expression\nrather than just \"code\", because it has been reported that one broken compiler\nfails on \"code\" because it is also an independent variable. It should make no\ndifference to the value of the offsetof(). test_snippet/\n\nsize = length + offsetof(real_pcre, code[0]);\nre = (real_pcre test_snippet)(pcre_malloc)(size);\n\nif (re == NULL)\n  {\n  test_snippeterrorptr = ERR21;\n  return NULL;\n  }\n\n/test_snippet Put in the magic number, and save the size, options, and table pointer test_snippet/\n\nre->magic_number = MAGIC_NUMBER;\nre->size = size;\nre->options = options;\nre->tables = tables;\n\n/test_snippet Set up a starting, non-extracting bracket, then compile the expression. On\nerror, test_snippeterrorptr will be set non-NULL, so we don't need to look at the result\nof the function here. test_snippet/\n\nptr = (const uschar test_snippet)pattern;\ncode = re->code;\ntest_snippetcode = OP_BRA;\nbracount = 0;\n(void)compile_regex(options, -1, &bracount, &code, &ptr, errorptr, FALSE, 0,\n  &reqchar, &countlits, &compile_block);\nre->top_bracket = bracount;\nre->top_backref = top_backref;\n\n/test_snippet If not reached end of pattern on success, there's an excess bracket. test_snippet/\n\nif (test_snippeterrorptr == NULL && test_snippetptr != 0) test_snippeterrorptr = ERR22;\n\n/test_snippet Fill in the terminating state and check for disastrous overflow, but\nif debugging, leave the test till after things are printed out. test_snippet/\n\ntest_snippetcode++ = OP_END;\n\n#ifndef DEBUG\nif (code - re->code > length) test_snippeterrorptr = ERR23;\n#endif\n\n/test_snippet Give an error if there's back reference to a non-existent capturing\nsubpattern. test_snippet/\n\nif (top_backref > re->top_bracket) test_snippeterrorptr = ERR15;\n\n/test_snippet Failed to compile test_snippet/\n\nif (test_snippeterrorptr != NULL)\n  {\n  (pcre_free)(re);\n  PCRE_ERROR_RETURN:\n  test_snippeterroroffset = ptr - (const uschar test_snippet)pattern;\n  return NULL;\n  }\n\n/test_snippet If the anchored option was not passed, set flag if we can determine that the\npattern is anchored by virtue of ^ characters or \\A or anything else (such as\nstarting with .test_snippet when DOTALL is set).\n\nOtherwise, see if we can determine what the first character has to be, because\nthat speeds up unanchored matches no end. If not, see if we can set the\nPCRE_STARTLINE flag. This is helpful for multiline matches when all branches\nstart with ^. and also when all branches start with .test_snippet for non-DOTALL matches.\ntest_snippet/\n\nif ((options & PCRE_ANCHORED) == 0)\n  {\n  int temp_options = options;\n  if (is_anchored(re->code, &temp_options))\n    re->options |= PCRE_ANCHORED;\n  else\n    {\n    int ch = find_firstchar(re->code, &temp_options);\n    if (ch >= 0)\n      {\n      re->first_char = ch;\n      re->options |= PCRE_FIRSTSET;\n      }\n    else if (is_startline(re->code))\n      re->options |= PCRE_STARTLINE;\n    }\n  }\n\n/test_snippet Save the last required character if there are at least two literal\ncharacters on all paths, or if there is no first character setting. test_snippet/\n\nif (reqchar >= 0 && (countlits > 1 || (re->options & PCRE_FIRSTSET) == 0))\n  {\n  re->req_char = reqchar;\n  re->options |= PCRE_REQCHSET;\n  }\n\n/test_snippet Print out the compiled data for debugging test_snippet/\n\n#ifdef DEBUG\n\nprintf(\"Length = %d top_bracket = %d top_backref = %d\\n\",\n  length, re->top_bracket, re->top_backref);\n\nif (re->options != 0)\n  {\n  printf(\"%s%s%s%s%s%s%s%s%s\\n\",\n    ((re->options & PCRE_ANCHORED) != 0)? \"anchored \" : \"\",\n    ((re->options & PCRE_CASELESS) != 0)? \"caseless \" : \"\",\n    ((re->options & PCRE_ICHANGED) != 0)? \"case state changed \" : \"\",\n    ((re->options & PCRE_EXTENDED) != 0)? \"extended \" : \"\",\n    ((re->options & PCRE_MULTILINE) != 0)? \"multiline \" : \"\",\n    ((re->options & PCRE_DOTALL) != 0)? \"dotall \" : \"\",\n    ((re->options & PCRE_DOLLAR_ENDONLY) != 0)? \"endonly \" : \"\",\n    ((re->options & PCRE_EXTRA) != 0)? \"extra \" : \"\",\n    ((re->options & PCRE_UNGREEDY) != 0)? \"ungreedy \" : \"\");\n  }\n\nif ((re->options & PCRE_FIRSTSET) != 0)\n  {\n  if (isprint(re->first_char)) printf(\"First char = %c\\n\", re->first_char);\n    else printf(\"First char = \\\\x%02x\\n\", re->first_char);\n  }\n\nif ((re->options & PCRE_REQCHSET) != 0)\n  {\n  if (isprint(re->req_char)) printf(\"Req char = %c\\n\", re->req_char);\n    else printf(\"Req char = \\\\x%02x\\n\", re->req_char);\n  }\n\ncode_end = code;\ncode_base = code = re->code;\n\nwhile (code < code_end)\n  {\n  int charlength;\n\n  printf(\"%3d \", code - code_base);\n\n  if (test_snippetcode >= OP_BRA)\n    {\n    if (test_snippetcode - OP_BRA > EXTRACT_BASIC_MAX)\n      printf(\"%3d Bra extra\", (code[1] << 8) + code[2]);\n    else\n      printf(\"%3d Bra %d\", (code[1] << 8) + code[2], test_snippetcode - OP_BRA);\n    code += 2;\n    }\n\n  else switch(test_snippetcode)\n    {\n    case OP_OPT:\n    printf(\" %.2x %s\", code[1], OP_names[test_snippetcode]);\n    code++;\n    break;\n\n    case OP_CHARS:\n    charlength = test_snippet(++code);\n    printf(\"%3d \", charlength);\n    while (charlength-- > 0)\n      if (isprint(c = test_snippet(++code))) printf(\"%c\", c); else printf(\"\\\\x%02x\", c);\n    break;\n\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_ALT:\n    case OP_KET:\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ONCE:\n    case OP_REVERSE:\n    case OP_BRANUMBER:\n    case OP_COND:\n    case OP_CREF:\n    printf(\"%3d %s\", (code[1] << 8) + code[2], OP_names[test_snippetcode]);\n    code += 2;\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    if (test_snippetcode >= OP_TYPESTAR)\n      printf(\"    %s\", OP_names[code[1]]);\n    else if (isprint(c = code[1])) printf(\"    %c\", c);\n      else printf(\"    \\\\x%02x\", c);\n    printf(\"%s\", OP_names[test_snippetcode++]);\n    break;\n\n    case OP_EXACT:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    if (isprint(c = code[3])) printf(\"    %c{\", c);\n      else printf(\"    \\\\x%02x{\", c);\n    if (test_snippetcode != OP_EXACT) printf(\"0,\");\n    printf(\"%d}\", (code[1] << 8) + code[2]);\n    if (test_snippetcode == OP_MINUPTO) printf(\"?\");\n    code += 3;\n    break;\n\n    case OP_TYPEEXACT:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    printf(\"    %s{\", OP_names[code[3]]);\n    if (test_snippetcode != OP_TYPEEXACT) printf(\",\");\n    printf(\"%d}\", (code[1] << 8) + code[2]);\n    if (test_snippetcode == OP_TYPEMINUPTO) printf(\"?\");\n    code += 3;\n    break;\n\n    case OP_NOT:\n    if (isprint(c = test_snippet(++code))) printf(\"    [^%c]\", c);\n      else printf(\"    [^\\\\x%02x]\", c);\n    break;\n\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    if (isprint(c = code[1])) printf(\"    [^%c]\", c);\n      else printf(\"    [^\\\\x%02x]\", c);\n    printf(\"%s\", OP_names[test_snippetcode++]);\n    break;\n\n    case OP_NOTEXACT:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    if (isprint(c = code[3])) printf(\"    [^%c]{\", c);\n      else printf(\"    [^\\\\x%02x]{\", c);\n    if (test_snippetcode != OP_NOTEXACT) printf(\",\");\n    printf(\"%d}\", (code[1] << 8) + code[2]);\n    if (test_snippetcode == OP_NOTMINUPTO) printf(\"?\");\n    code += 3;\n    break;\n\n    case OP_REF:\n    printf(\"    \\\\%d\", (code[1] << 8) | code[2]);\n    code += 3;\n    goto CLASS_REF_REPEAT;\n\n    case OP_CLASS:\n      {\n      int i, min, max;\n      code++;\n      printf(\"    [\");\n\n      for (i = 0; i < 256; i++)\n        {\n        if ((code[i/8] & (1 << (i&7))) != 0)\n          {\n          int j;\n          for (j = i+1; j < 256; j++)\n            if ((code[j/8] & (1 << (j&7))) == 0) break;\n          if (i == '-' || i == ']') printf(\"\\\\\");\n          if (isprint(i)) printf(\"%c\", i); else printf(\"\\\\x%02x\", i);\n          if (--j > i)\n            {\n            printf(\"-\");\n            if (j == '-' || j == ']') printf(\"\\\\\");\n            if (isprint(j)) printf(\"%c\", j); else printf(\"\\\\x%02x\", j);\n            }\n          i = j;\n          }\n        }\n      printf(\"]\");\n      code += 32;\n\n      CLASS_REF_REPEAT:\n\n      switch(test_snippetcode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        printf(\"%s\", OP_names[test_snippetcode]);\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        min = (code[1] << 8) + code[2];\n        max = (code[3] << 8) + code[4];\n        if (max == 0) printf(\"{%d,}\", min);\n        else printf(\"{%d,%d}\", min, max);\n        if (test_snippetcode == OP_CRMINRANGE) printf(\"?\");\n        code += 4;\n        break;\n\n        default:\n        code--;\n        }\n      }\n    break;\n\n    /test_snippet Anything else is just a one-node item test_snippet/\n\n    default:\n    printf(\"    %s\", OP_names[test_snippetcode]);\n    break;\n    }\n\n  code++;\n  printf(\"\\n\");\n  }\nprintf(\"------------------------------------------------------------------\\n\");\n\n/test_snippet This check is done here in the debugging case so that the code that\nwas compiled can be seen. test_snippet/\n\nif (code - re->code > length)\n  {\n  test_snippeterrorptr = ERR23;\n  (pcre_free)(re);\n  test_snippeterroroffset = ptr - (uschar test_snippet)pattern;\n  return NULL;\n  }\n#endif\n\nreturn (pcre test_snippet)re;\n}",
    "predicted": ""
  },
  "httpd_8a3203bbd31303680c7bbc39272c5ec1cb7b81a0_0", {
    "ID": "httpd_8a3203bbd31303680c7bbc39272c5ec1cb7b81a0_0",
    "UID": "1954",
    "code": "static const char *add_redirect_internal(cmd_parms test_snippet\n                                         alias_dir_conf *dirconf,\n                                         const char *arg1, const char *arg2, \n                                         const char *arg3, int use_regex)\n{\n    alias_entry *new;\n    server_rec *s = cmd->server;\n    alias_server_conf *serverconf = ap_get_module_config(s->module_config,\n                                                         &alias_module);\n    int status = (int) (long) cmd->info;\n    regex_t *r = NULL;\n    const char *f = arg2;\n    const char *url = arg3;\n\n    if (!strcasecmp(arg1, \"gone\"))\n        status = HTTP_GONE;\n    else if (!strcasecmp(arg1, \"permanent\"))\n        status = HTTP_MOVED_PERMANENTLY;\n    else if (!strcasecmp(arg1, \"temp\"))\n        status = HTTP_MOVED_TEMPORARILY;\n    else if (!strcasecmp(arg1, \"seeother\"))\n        status = HTTP_SEE_OTHER;\n    else if (apr_isdigit(*arg1))\n        status = atoi(arg1);\n    else {\n        f = arg1;\n        url = arg2;\n    }\n\n    if (use_regex) {\n        r = ap_pregcomp(cmd->pool, f, REG_EXTENDED);\n        if (r == NULL)\n            return \"Regular expression could not be compiled.\";\n    }\n\n    if (ap_is_HTTP_REDIRECT(status)) {\n        if (!url)\n            return \"URL to redirect to is missing\";\n        if (!use_regex && !ap_is_url(url))\n            return \"Redirect to non-URL\";\n    }\n    else {\n        if (url)\n            return \"Redirect URL not valid for this status\";\n    }\n\n    if (cmd->path)\n        new = apr_array_push(dirconf->redirects);\n    else\n        new = apr_array_push(serverconf->redirects);\n\n    new->fake = f;\n    new->real = url;\n    new->regexp = r;\n    new->redir_status = status;\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_74b0d3724309f3ce1a88b150a192df827aef4f48_0", {
    "ID": "httpd_74b0d3724309f3ce1a88b150a192df827aef4f48_0",
    "UID": "1955",
    "code": "AP_DECLARE(int) ap_strcmp_match(const char *str, const char test_snippet\n{\n    int x, y;\n\n    for (x = 0, y = 0; expected[y]; ++y, ++x) {\n        if ((!str[x]) && (expected[y] != '*'))\n            return -1;\n        if (expected[y] == '*') {\n            while (expected[++y] == '*');\n            if (!expected[y])\n                return 0;\n            while (str[x]) {\n                int ret;\n                if ((ret = ap_strcmp_match(&str[x++], &expected[y])) != 1)\n                    return ret;\n            }\n            return -1;\n        }\n        else if ((expected[y] != '?') && (str[x] != expected[y]))\n            return 1;\n    }\n    return (str[x] != '\\0');\n}",
    "predicted": "476,NULL Pointer Dereference\n762,Mismatched Memory Management Routines\n457,Use of Uninitialized Variable"
  },
  "httpd_5811810ee04eca5a83c62f08880ddd32a05cee92_0", {
    "ID": "httpd_5811810ee04eca5a83c62f08880ddd32a05cee92_0",
    "UID": "1959",
    "code": "static int pointinpoly(const double point[2], double test_snippet\n{\n    int i, numverts, crossings = 0;\n    double x = point[X], y = point[Y];\n\n    for (numverts = 0; pgon[numverts][X] != -1 && numverts < MAXVERTS;\n\tnumverts++) {\n\t\n    }\n\n    for (i = 0; i < numverts; i++) {\n        double x1=pgon[i][X];\n        double y1=pgon[i][Y];\n        double x2=pgon[(i + 1) % numverts][X];\n        double y2=pgon[(i + 1) % numverts][Y];\n        double d=(y - y1) * (x2 - x1) - (x - x1) * (y2 - y1);\n\n        if ((y1 >= y) != (y2 >= y)) {\n\t    crossings +=y2 - y1 >= 0 ? d >= 0 : d <= 0;\n\t}\n        if (!d && fmin(x1,x2) <= x && x <= fmax(x1,x2)\n\t    && fmin(y1,y2) <= y && y <= fmax(y1,y2)) {\n\t    return 1;\n\t}\n    }\n    return crossings & 0x01;\n}",
    "predicted": "457,Use of Uninitialized Variable\n606,Unchecked Input for Loop Condition"
  },
  "httpd_fa93e02742acd20c0d5906e68af71826b82c4c83_0", {
    "ID": "httpd_fa93e02742acd20c0d5906e68af71826b82c4c83_0",
    "UID": "1964",
    "code": "static int translate_userdir(request_rec test_snippet\n{\n    ap_conf_vector_t *server_conf;\n    const userdir_config *s_cfg;\n    char *name = r->uri;\n    const char *userdirs;\n    const char *w, *dname;\n    char *redirect;\n    apr_finfo_t statbuf;\n\n    /*\n     * If the URI doesn't match our basic pattern, we've nothing to do with\n     * it.\n     */\n    if (name[0] != '/' || name[1] != '~') {\n        return DECLINED;\n    }\n    server_conf = r->server->module_config;\n    s_cfg = ap_get_module_config(server_conf, &userdir_module);\n    userdirs = s_cfg->userdir;\n    if (userdirs == NULL) {\n        return DECLINED;\n    }\n\n    dname = name + 2;\n    w = ap_getword(r->pool, &dname, '/');\n\n    /*\n     * The 'dname' funny business involves backing it up to capture the '/'\n     * delimiting the \"/~user\" part from the rest of the URL, in case there\n     * was one (the case where there wasn't being just \"GET /~user HTTP/1.0\",\n     * for which we don't want to tack on a '/' onto the filename).\n     */\n\n    if (dname[-1] == '/') {\n        --dname;\n    }\n\n    /*\n     * If there's no username, it's not for us.  Ignore . and .. as well.\n     */\n    if (w[0] == '\\0' || (w[1] == '.' && (w[2] == '\\0' || (w[2] == '.' && w[3] == '\\0')))) {\n        return DECLINED;\n    }\n    /*\n     * Nor if there's an username but it's in the disabled list.\n     */\n    if (apr_table_get(s_cfg->disabled_users, w) != NULL) {\n        return DECLINED;\n    }\n    /*\n     * If there's a global interdiction on UserDirs, check to see if this\n     * name is one of the Blessed.\n     */\n    if (s_cfg->globally_disabled\n        && apr_table_get(s_cfg->enabled_users, w) == NULL) {\n        return DECLINED;\n    }\n\n    /*\n     * Special cases all checked, onward to normal substitution processing.\n     */\n\n    while (*userdirs) {\n        const char *userdir = ap_getword_conf(r->pool, &userdirs);\n        char *filename = NULL, *x = NULL;\n        apr_status_t rv;\n        int is_absolute = ap_os_is_path_absolute(r->pool, userdir);\n\n        if (ap_strchr_c(userdir, '*'))\n            x = ap_getword(r->pool, &userdir, '*');\n\n        if (userdir[0] == '\\0' || is_absolute) {\n            if (x) {\n#ifdef HAVE_DRIVE_LETTERS\n                /*\n                 * Crummy hack. Need to figure out whether we have been\n                 * redirected to a URL or to a file on some drive. Since I\n                 * know of no protocols that are a single letter, ignore\n                 * a : as the first or second character, and assume a file \n                 * was specified\n                 */\n                if (strchr(x + 2, ':'))\n#else\n                if (strchr(x, ':') && !is_absolute)\n#endif \n                {\n                    redirect = apr_pstrcat(r->pool, x, w, userdir, dname, NULL);\n                    apr_table_setn(r->headers_out, \"Location\", redirect);\n                    return HTTP_MOVED_TEMPORARILY;\n                }\n                else\n                    filename = apr_pstrcat(r->pool, x, w, userdir, NULL);\n            }\n            else\n                filename = apr_pstrcat(r->pool, userdir, \"/\", w, NULL);\n        }\n        else if (x && ap_strchr_c(x, ':')) {\n            redirect = apr_pstrcat(r->pool, x, w, dname, NULL);\n            apr_table_setn(r->headers_out, \"Location\", redirect);\n            return HTTP_MOVED_TEMPORARILY;\n        }\n        else {\n#if APR_HAS_USER\n            char *homedir;\n\n            if (apr_uid_homepath_get(&homedir, w, r->pool) == APR_SUCCESS) {\n                filename = apr_pstrcat(r->pool, homedir, \"/\", userdir, NULL);\n            }\n#else\n            return DECLINED;\n#endif\n        }\n\n        /*\n         * Now see if it exists, or we're at the last entry. If we are at the\n         * last entry, then use the filename generated (if there is one)\n         * anyway, in the hope that some handler might handle it. This can be\n         * used, for example, to run a CGI script for the user.\n         */\n        if (filename && (!*userdirs \n                      || ((rv = apr_stat(&statbuf, filename, APR_FINFO_MIN,\n                                         r->pool)) == APR_SUCCESS\n                                             || rv == APR_INCOMPLETE))) {\n            r->filename = apr_pstrcat(r->pool, filename, dname, NULL);\n            /* XXX: Does this walk us around FollowSymLink rules?\n             * When statbuf contains info on r->filename we can save a syscall\n             * by copying it to r->finfo\n             */\n            if (*userdirs && dname[0] == 0)\n                r->finfo = statbuf;\n\n            \n            apr_table_setn(r->notes, \"mod_userdir_user\", w);\n\n            return OK;\n        }\n    }\n\n    return DECLINED;\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_3eb78fae22059790524c00ca56eace6064e9b3ff_0", {
    "ID": "httpd_3eb78fae22059790524c00ca56eace6064e9b3ff_0",
    "UID": "1974",
    "code": "static apr_status_t log_script_err(request_rec *r, apr_file_t test_snippet\n{\n    char argsbuffer[HUGE_STRING_LEN];\n    char *newline;\n    apr_status_t rv;\n\n    while ((rv = apr_file_gets(argsbuffer, HUGE_STRING_LEN,\n                               script_err)) == APR_SUCCESS) {\n        newline = strchr(argsbuffer, '\\n');\n        if (newline) {\n            *newline = '\\0';\n        }\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"%s\", argsbuffer);            \n    }\n\n    return rv;\n}",
    "predicted": "126,Buffer Over-read\n252,Unchecked Return Value"
  },
  "httpd_f22705e54636766df709c0830b326180658b2297_0", {
    "ID": "httpd_f22705e54636766df709c0830b326180658b2297_0",
    "UID": "1980",
    "code": "static ap_filter_rec_t *register_filter(const char test_snippet\n                            ap_filter_func filter_func,\n                            ap_init_filter_func filter_init,\n                            ap_filter_type ftype,\n                            filter_trie_node **reg_filter_set)\n{\n    ap_filter_rec_t *frec;\n    char *normalized_name;\n    const char *n;\n    filter_trie_node *node;\n\n    if (!*reg_filter_set) {\n        *reg_filter_set = trie_node_alloc(FILTER_POOL, NULL, 0);\n    }\n\n    normalized_name = apr_pstrdup(FILTER_POOL, name);\n    ap_str_tolower(normalized_name);\n\n    node = *reg_filter_set;\n    for (n = normalized_name; *n; n++) {\n        filter_trie_node *child = trie_node_alloc(FILTER_POOL, node, *n);\n        if (apr_isalpha(*n)) {\n            trie_node_link(FILTER_POOL, node, child, apr_toupper(*n));\n        }\n        node = child;\n    }\n    if (node->frec) {\n        frec = node->frec;\n    }\n    else {\n        frec = apr_palloc(FILTER_POOL, sizeof(*frec));\n        node->frec = frec;\n        frec->name = normalized_name;\n    }\n    frec->filter_func = filter_func;\n    frec->filter_init_func = filter_init;\n    frec->ftype = ftype;\n    \n    apr_pool_cleanup_register(FILTER_POOL, NULL, filter_cleanup, \n                              apr_pool_cleanup_null);\n    return frec;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_3a1a8744e18c4062fd923c14f9c71fc664ab8007_0", {
    "ID": "httpd_3a1a8744e18c4062fd923c14f9c71fc664ab8007_0",
    "UID": "1988",
    "code": "static test_snippet\ncompile_branch(int options, int *brackets, uschar **codeptr,\n  const uschar **ptrptr, const char **errorptr, int *optchanged,\n  int *reqchar, int *countlits, compile_data *cd)\n{\nint repeat_type, op_type;\nint repeat_min, repeat_max;\nint bravalue, length;\nint greedy_default, greedy_non_default;\nint prevreqchar;\nint condcount = 0;\nint subcountlits = 0;\nregister int c;\nregister uschar *code = *codeptr;\nuschar *tempcode;\nconst uschar *ptr = *ptrptr;\nconst uschar *tempptr;\nuschar *previous = NULL;\nuschar class[32];\n\n\n\ngreedy_default = ((options & PCRE_UNGREEDY) != 0);\ngreedy_non_default = greedy_default ^ 1;\n\n\n\n*reqchar = prevreqchar = -1;\n*countlits = 0;\n\n\n\nfor (;; ptr++)\n  {\n  test_snippet negate_class;\n  int class_charcount;\n  int class_lastchar;\n  int newoptions;\n  int skipbytes;\n  int subreqchar;\n\n  c = *ptr;\n  if ((options & PCRE_EXTENDED) != 0)\n    {\n    if ((cd->ctypes[c] & ctype_space) != 0) continue;\n    if (c == '#')\n      {\n      /* The space before the ; is to avoid a warning on a silly compiler\n      on the Macintosh. */\n      while ((c = *(++ptr)) != 0 && c != NEWLINE) ;\n      continue;\n      }\n    }\n\n  switch(c)\n    {\n    \n\n    case 0:\n    case '|':\n    case ')':\n    *codeptr = code;\n    *ptrptr = ptr;\n    return TRUE;\n\n    \n\n    case '^':\n    previous = NULL;\n    *code++ = OP_CIRC;\n    break;\n\n    case '$':\n    previous = NULL;\n    *code++ = OP_DOLL;\n    break;\n\n    case '.':\n    previous = code;\n    *code++ = OP_ANY;\n    break;\n\n    /* Character classes. These always build a 32-byte bitmap of the permitted\n    characters, except in the special case where there is only one character.\n    For negated classes, we build the map as usual, then invert it at the end.\n    */\n\n    case '[':\n    previous = code;\n    *code++ = OP_CLASS;\n\n    \n\n    if ((c = *(++ptr)) == '^')\n      {\n      negate_class = TRUE;\n      c = *(++ptr);\n      }\n    else negate_class = FALSE;\n\n    /* Keep a count of chars so that we can optimize the case of just a single\n    character. */\n\n    class_charcount = 0;\n    class_lastchar = -1;\n\n    /* Initialize the 32-char bit map to all zeros. We have to build the\n    map in a temporary bit of store, in case the class contains only 1\n    character, because in that case the compiled code doesn't use the\n    bit map. */\n\n    memset(class, 0, 32 * sizeof(uschar));\n\n    /* Process characters until ] is reached. By writing this as a \"do\" it\n    means that an initial ] is taken as a data character. */\n\n    do\n      {\n      if (c == 0)\n        {\n        *errorptr = ERR6;\n        goto FAILED;\n        }\n\n      /* Handle POSIX class names. Perl allows a negation extension of the\n      form [:^name]. A square bracket that doesn't match the syntax is\n      treated as a literal. We also recognize the POSIX constructions\n      [.ch.] and [=ch=] (\"collating elements\") and fault them, as Perl\n      5.6 does. */\n\n      if (c == '[' &&\n          (ptr[1] == ':' || ptr[1] == '.' || ptr[1] == '=') &&\n          check_posix_syntax(ptr, &tempptr, cd))\n        {\n        test_snippet local_negate = FALSE;\n        int posix_class, i;\n        register const uschar *cbits = cd->cbits;\n\n        if (ptr[1] != ':')\n          {\n          *errorptr = ERR31;\n          goto FAILED;\n          }\n\n        ptr += 2;\n        if (*ptr == '^')\n          {\n          local_negate = TRUE;\n          ptr++;\n          }\n\n        posix_class = check_posix_name(ptr, tempptr - ptr);\n        if (posix_class < 0)\n          {\n          *errorptr = ERR30;\n          goto FAILED;\n          }\n\n        /* If matching is caseless, upper and lower are converted to\n        alpha. This relies on the fact that the class table starts with\n        alpha, lower, upper as the first 3 entries. */\n\n        if ((options & PCRE_CASELESS) != 0 && posix_class <= 2)\n          posix_class = 0;\n\n        /* Or into the map we are building up to 3 of the static class\n        tables, or their negations. */\n\n        posix_class *= 3;\n        for (i = 0; i < 3; i++)\n          {\n          int taboffset = posix_class_maps[posix_class + i];\n          if (taboffset < 0) break;\n          if (local_negate)\n            for (c = 0; c < 32; c++) class[c] |= ~cbits[c+taboffset];\n          else\n            for (c = 0; c < 32; c++) class[c] |= cbits[c+taboffset];\n          }\n\n        ptr = tempptr + 1;\n        class_charcount = 10;  \n        continue;\n        }\n\n      /* Backslash may introduce a single character, or it may introduce one\n      of the specials, which just set a flag. Escaped items are checked for\n      validity in the pre-compiling pass. The sequence \\b is a special case.\n      Inside a class (and only there) it is treated as backspace. Elsewhere\n      it marks a word boundary. Other escapes have preset maps ready to\n      or into the one we are building. We assume they have more than one\n      character in them, so set class_count bigger than one. */\n\n      if (c == '\\\\')\n        {\n        c = check_escape(&ptr, errorptr, *brackets, options, TRUE, cd);\n        if (-c == ESC_b) c = '\\b';\n        else if (c < 0)\n          {\n          register const uschar *cbits = cd->cbits;\n          class_charcount = 10;\n          switch (-c)\n            {\n            case ESC_d:\n            for (c = 0; c < 32; c++) class[c] |= cbits[c+cbit_digit];\n            continue;\n\n            case ESC_D:\n            for (c = 0; c < 32; c++) class[c] |= ~cbits[c+cbit_digit];\n            continue;\n\n            case ESC_w:\n            for (c = 0; c < 32; c++) class[c] |= cbits[c+cbit_word];\n            continue;\n\n            case ESC_W:\n            for (c = 0; c < 32; c++) class[c] |= ~cbits[c+cbit_word];\n            continue;\n\n            case ESC_s:\n            for (c = 0; c < 32; c++) class[c] |= cbits[c+cbit_space];\n            continue;\n\n            case ESC_S:\n            for (c = 0; c < 32; c++) class[c] |= ~cbits[c+cbit_space];\n            continue;\n\n            default:\n            *errorptr = ERR7;\n            goto FAILED;\n            }\n          }\n\n        /* Fall through if single character, but don't at present allow\n        chars > 255 in UTF-8 mode. */\n\n#ifdef SUPPORT_UTF8\n        if (c > 255)\n          {\n          *errorptr = ERR33;\n          goto FAILED;\n          }\n#endif\n        }\n\n      /* A single character may be followed by '-' to form a range. However,\n      Perl does not permit ']' to be the end of the range. A '-' character\n      here is treated as a literal. */\n\n      if (ptr[1] == '-' && ptr[2] != ']')\n        {\n        int d;\n        ptr += 2;\n        d = *ptr;\n\n        if (d == 0)\n          {\n          *errorptr = ERR6;\n          goto FAILED;\n          }\n\n        /* The second part of a range can be a single-character escape, but\n        not any of the other escapes. Perl 5.6 treats a hyphen as a literal\n        in such circumstances. */\n\n        if (d == '\\\\')\n          {\n          const uschar *oldptr = ptr;\n          d = check_escape(&ptr, errorptr, *brackets, options, TRUE, cd);\n\n#ifdef SUPPORT_UTF8\n          if (d > 255)\n            {\n            *errorptr = ERR33;\n            goto FAILED;\n            }\n#endif\n          \n\n          if (d < 0)\n            {\n            if (d == -ESC_b) d = '\\b'; else\n              {\n              ptr = oldptr - 2;\n              goto SINGLE_CHARACTER;  \n              }\n            }\n          }\n\n        if (d < c)\n          {\n          *errorptr = ERR8;\n          goto FAILED;\n          }\n\n        for (; c <= d; c++)\n          {\n          class[c/8] |= (1 << (c&7));\n          if ((options & PCRE_CASELESS) != 0)\n            {\n            int uc = cd->fcc[c];           \n            class[uc/8] |= (1 << (uc&7));\n            }\n          class_charcount++;                \n          class_lastchar = c;\n          }\n        continue;   \n        }\n\n      /* Handle a lone single character - we can get here for a normal\n      non-escape char, or after \\ that introduces a single character. */\n\n      SINGLE_CHARACTER:\n\n      class [c/8] |= (1 << (c&7));\n      if ((options & PCRE_CASELESS) != 0)\n        {\n        c = cd->fcc[c];   \n        class[c/8] |= (1 << (c&7));\n        }\n      class_charcount++;\n      class_lastchar = c;\n      }\n\n    /* Loop until ']' reached; the check for end of string happens inside the\n    loop. This \"while\" is the end of the \"do\" above. */\n\n    while ((c = *(++ptr)) != ']');\n\n    /* If class_charcount is 1 and class_lastchar is not negative, we saw\n    precisely one character. This doesn't need the whole 32-byte bit map.\n    We turn it into a 1-character OP_CHAR if it's positive, or OP_NOT if\n    it's negative. */\n\n    if (class_charcount == 1 && class_lastchar >= 0)\n      {\n      if (negate_class)\n        {\n        code[-1] = OP_NOT;\n        }\n      else\n        {\n        code[-1] = OP_CHARS;\n        *code++ = 1;\n        }\n      *code++ = class_lastchar;\n      }\n\n    /* Otherwise, negate the 32-byte map if necessary, and copy it into\n    the code vector. */\n\n    else\n      {\n      if (negate_class)\n        for (c = 0; c < 32; c++) code[c] = ~class[c];\n      else\n        memcpy(code, class, 32);\n      code += 32;\n      }\n    break;\n\n    \n\n    case '{':\n    if (!is_counted_repeat(ptr+1, cd)) goto NORMAL_CHAR;\n    ptr = read_repeat_counts(ptr+1, &repeat_min, &repeat_max, errorptr, cd);\n    if (*errorptr != NULL) goto FAILED;\n    goto REPEAT;\n\n    case '*':\n    repeat_min = 0;\n    repeat_max = -1;\n    goto REPEAT;\n\n    case '+':\n    repeat_min = 1;\n    repeat_max = -1;\n    goto REPEAT;\n\n    case '?':\n    repeat_min = 0;\n    repeat_max = 1;\n\n    REPEAT:\n    if (previous == NULL)\n      {\n      *errorptr = ERR9;\n      goto FAILED;\n      }\n\n    /* If the next character is '?' this is a minimizing repeat, by default,\n    but if PCRE_UNGREEDY is set, it works the other way round. Advance to the\n    next character. */\n\n    if (ptr[1] == '?')\n      { repeat_type = greedy_non_default; ptr++; }\n    else repeat_type = greedy_default;\n\n    /* If previous was a string of characters, chop off the last one and use it\n    as the subject of the repeat. If there was only one character, we can\n    abolish the previous item altogether. A repeat with a zero minimum wipes\n    out any reqchar setting, backing up to the previous value. We must also\n    adjust the countlits value. */\n\n    if (*previous == OP_CHARS)\n      {\n      int len = previous[1];\n\n      if (repeat_min == 0) *reqchar = prevreqchar;\n      *countlits += repeat_min - 1;\n\n      if (len == 1)\n        {\n        c = previous[2];\n        code = previous;\n        }\n      else\n        {\n        c = previous[len+1];\n        previous[1]--;\n        code--;\n        }\n      op_type = 0;                 \n      goto OUTPUT_SINGLE_REPEAT;   \n      }\n\n    /* If previous was a single negated character ([^a] or similar), we use\n    one of the special opcodes, replacing it. The code is shared with single-\n    character repeats by adding a suitable offset into repeat_type. */\n\n    else if ((int)*previous == OP_NOT)\n      {\n      op_type = OP_NOTSTAR - OP_STAR;  \n      c = previous[1];\n      code = previous;\n      goto OUTPUT_SINGLE_REPEAT;\n      }\n\n    /* If previous was a character type match (\\d or similar), abolish it and\n    create a suitable repeat item. The code is shared with single-character\n    repeats by adding a suitable offset into repeat_type. */\n\n    else if ((int)*previous < OP_EODN || *previous == OP_ANY)\n      {\n      op_type = OP_TYPESTAR - OP_STAR;  \n      c = *previous;\n      code = previous;\n\n      OUTPUT_SINGLE_REPEAT:\n\n      /* If the maximum is zero then the minimum must also be zero; Perl allows\n      this case, so we do too - by simply omitting the item altogether. */\n\n      if (repeat_max == 0) goto END_REPEAT;\n\n      \n\n      repeat_type += op_type;\n\n      /* A minimum of zero is handled either as the special case * or ?, or as\n      an UPTO, with the maximum given. */\n\n      if (repeat_min == 0)\n        {\n        if (repeat_max == -1) *code++ = OP_STAR + repeat_type;\n          else if (repeat_max == 1) *code++ = OP_QUERY + repeat_type;\n        else\n          {\n          *code++ = OP_UPTO + repeat_type;\n          *code++ = repeat_max >> 8;\n          *code++ = (repeat_max & 255);\n          }\n        }\n\n      \n\n      else if (repeat_min == 1 && repeat_max == -1)\n        *code++ = OP_PLUS + repeat_type;\n\n      /* The case {n,n} is just an EXACT, while the general case {n,m} is\n      handled as an EXACT followed by an UPTO. An EXACT of 1 is optimized. */\n\n      else\n        {\n        if (repeat_min != 1)\n          {\n          *code++ = OP_EXACT + op_type;  \n          *code++ = repeat_min >> 8;\n          *code++ = (repeat_min & 255);\n          }\n\n        /* If the mininum is 1 and the previous item was a character string,\n        we either have to put back the item that got cancelled if the string\n        length was 1, or add the character back onto the end of a longer\n        string. For a character type nothing need be done; it will just get\n        put back naturally. Note that the final character is always going to\n        get added below. */\n\n        else if (*previous == OP_CHARS)\n          {\n          if (code == previous) code += 2; else previous[1]++;\n          }\n\n        /*  For a single negated character we also have to put back the\n        item that got cancelled. */\n\n        else if (*previous == OP_NOT) code++;\n\n        \n\n        if (repeat_max < 0)\n          {\n          *code++ = c;\n          *code++ = OP_STAR + repeat_type;\n          }\n\n        \n\n        else if (repeat_max != repeat_min)\n          {\n          *code++ = c;\n          repeat_max -= repeat_min;\n          *code++ = OP_UPTO + repeat_type;\n          *code++ = repeat_max >> 8;\n          *code++ = (repeat_max & 255);\n          }\n        }\n\n      \n\n      *code++ = c;\n      }\n\n    /* If previous was a character class or a back reference, we put the repeat\n    stuff after it, but just skip the item if the repeat was {0,0}. */\n\n    else if (*previous == OP_CLASS || *previous == OP_REF)\n      {\n      if (repeat_max == 0)\n        {\n        code = previous;\n        goto END_REPEAT;\n        }\n      if (repeat_min == 0 && repeat_max == -1)\n        *code++ = OP_CRSTAR + repeat_type;\n      else if (repeat_min == 1 && repeat_max == -1)\n        *code++ = OP_CRPLUS + repeat_type;\n      else if (repeat_min == 0 && repeat_max == 1)\n        *code++ = OP_CRQUERY + repeat_type;\n      else\n        {\n        *code++ = OP_CRRANGE + repeat_type;\n        *code++ = repeat_min >> 8;\n        *code++ = repeat_min & 255;\n        if (repeat_max == -1) repeat_max = 0;  \n        *code++ = repeat_max >> 8;\n        *code++ = repeat_max & 255;\n        }\n      }\n\n    /* If previous was a bracket group, we may have to replicate it in certain\n    cases. */\n\n    else if ((int)*previous >= OP_BRA || (int)*previous == OP_ONCE ||\n             (int)*previous == OP_COND)\n      {\n      register int i;\n      int ketoffset = 0;\n      int len = code - previous;\n      uschar *bralink = NULL;\n\n      /* If the maximum repeat count is unlimited, find the end of the bracket\n      by scanning through from the start, and compute the offset back to it\n      from the current code pointer. There may be an OP_OPT setting following\n      the final KET, so we can't find the end just by going back from the code\n      pointer. */\n\n      if (repeat_max == -1)\n        {\n        register uschar *ket = previous;\n        do ket += (ket[1] << 8) + ket[2]; while (*ket != OP_KET);\n        ketoffset = code - ket;\n        }\n\n      /* The case of a zero minimum is special because of the need to stick\n      OP_BRAZERO in front of it, and because the group appears once in the\n      data, whereas in other cases it appears the minimum number of times. For\n      this reason, it is simplest to treat this case separately, as otherwise\n      the code gets far too messy. There are several special subcases when the\n      minimum is zero. */\n\n      if (repeat_min == 0)\n        {\n        /* If we set up a required char from the bracket, we must back off\n        to the previous value and reset the countlits value too. */\n\n        if (subcountlits > 0)\n          {\n          *reqchar = prevreqchar;\n          *countlits -= subcountlits;\n          }\n\n        /* If the maximum is also zero, we just omit the group from the output\n        altogether. */\n\n        if (repeat_max == 0)\n          {\n          code = previous;\n          goto END_REPEAT;\n          }\n\n        /* If the maximum is 1 or unlimited, we just have to stick in the\n        BRAZERO and do no more at this point. */\n\n        if (repeat_max <= 1)\n          {\n          memmove(previous+1, previous, len);\n          code++;\n          *previous++ = OP_BRAZERO + repeat_type;\n          }\n\n        /* If the maximum is greater than 1 and limited, we have to replicate\n        in a nested fashion, sticking OP_BRAZERO before each set of brackets.\n        The first one has to be handled carefully because it's the original\n        copy, which has to be moved up. The remainder can be handled by code\n        that is common with the non-zero minimum case below. We just have to\n        adjust the value or repeat_max, since one less copy is required. */\n\n        else\n          {\n          int offset;\n          memmove(previous+4, previous, len);\n          code += 4;\n          *previous++ = OP_BRAZERO + repeat_type;\n          *previous++ = OP_BRA;\n\n          /* We chain together the bracket offset fields that have to be\n          filled in later when the ends of the brackets are reached. */\n\n          offset = (bralink == NULL)? 0 : previous - bralink;\n          bralink = previous;\n          *previous++ = offset >> 8;\n          *previous++ = offset & 255;\n          }\n\n        repeat_max--;\n        }\n\n      /* If the minimum is greater than zero, replicate the group as many\n      times as necessary, and adjust the maximum to the number of subsequent\n      copies that we need. */\n\n      else\n        {\n        for (i = 1; i < repeat_min; i++)\n          {\n          memcpy(code, previous, len);\n          code += len;\n          }\n        if (repeat_max > 0) repeat_max -= repeat_min;\n        }\n\n      /* This code is common to both the zero and non-zero minimum cases. If\n      the maximum is limited, it replicates the group in a nested fashion,\n      remembering the bracket starts on a stack. In the case of a zero minimum,\n      the first one was set up above. In all cases the repeat_max now specifies\n      the number of additional copies needed. */\n\n      if (repeat_max >= 0)\n        {\n        for (i = repeat_max - 1; i >= 0; i--)\n          {\n          *code++ = OP_BRAZERO + repeat_type;\n\n          /* All but the final copy start a new nesting, maintaining the\n          chain of brackets outstanding. */\n\n          if (i != 0)\n            {\n            int offset;\n            *code++ = OP_BRA;\n            offset = (bralink == NULL)? 0 : code - bralink;\n            bralink = code;\n            *code++ = offset >> 8;\n            *code++ = offset & 255;\n            }\n\n          memcpy(code, previous, len);\n          code += len;\n          }\n\n        /* Now chain through the pending brackets, and fill in their length\n        fields (which are holding the chain links pro tem). */\n\n        while (bralink != NULL)\n          {\n          int oldlinkoffset;\n          int offset = code - bralink + 1;\n          uschar *bra = code - offset;\n          oldlinkoffset = (bra[1] << 8) + bra[2];\n          bralink = (oldlinkoffset == 0)? NULL : bralink - oldlinkoffset;\n          *code++ = OP_KET;\n          *code++ = bra[1] = offset >> 8;\n          *code++ = bra[2] = (offset & 255);\n          }\n        }\n\n      /* If the maximum is unlimited, set a repeater in the final copy. We\n      can't just offset backwards from the current code point, because we\n      don't know if there's been an options resetting after the ket. The\n      correct offset was computed above. */\n\n      else code[-ketoffset] = OP_KETRMAX + repeat_type;\n      }\n\n    \n\n    else\n      {\n      *errorptr = ERR11;\n      goto FAILED;\n      }\n\n    \n\n    END_REPEAT:\n    previous = NULL;\n    break;\n\n\n    /* Start of nested bracket sub-expression, or comment or lookahead or\n    lookbehind or option setting or condition. First deal with special things\n    that can come after a bracket; all are introduced by ?, and the appearance\n    of any of them means that this is not a referencing group. They were\n    checked for validity in the first pass over the string, so we don't have to\n    check for syntax errors here.  */\n\n    case '(':\n    newoptions = options;\n    skipbytes = 0;\n\n    if (*(++ptr) == '?')\n      {\n      int set, unset;\n      int *optset;\n\n      switch (*(++ptr))\n        {\n        case '#':                 \n        ptr++;\n        while (*ptr != ')') ptr++;\n        continue;\n\n        case ':':                 \n        bravalue = OP_BRA;\n        ptr++;\n        break;\n\n        case '(':\n        bravalue = OP_COND;       \n        if ((cd->ctypes[*(++ptr)] & ctype_digit) != 0)\n          {\n          int condref = *ptr - '0';\n          while (*(++ptr) != ')') condref = condref*10 + *ptr - '0';\n          if (condref == 0)\n            {\n            *errorptr = ERR35;\n            goto FAILED;\n            }\n          ptr++;\n          code[3] = OP_CREF;\n          code[4] = condref >> 8;\n          code[5] = condref & 255;\n          skipbytes = 3;\n          }\n        else ptr--;\n        break;\n\n        case '=':                 \n        bravalue = OP_ASSERT;\n        ptr++;\n        break;\n\n        case '!':                 \n        bravalue = OP_ASSERT_NOT;\n        ptr++;\n        break;\n\n        case '<':                 \n        switch (*(++ptr))\n          {\n          case '=':               \n          bravalue = OP_ASSERTBACK;\n          ptr++;\n          break;\n\n          case '!':               \n          bravalue = OP_ASSERTBACK_NOT;\n          ptr++;\n          break;\n\n          default:                \n          *errorptr = ERR24;\n          goto FAILED;\n          }\n        break;\n\n        case '>':                 \n        bravalue = OP_ONCE;\n        ptr++;\n        break;\n\n        case 'R':                 \n        *code++ = OP_RECURSE;\n        ptr++;\n        continue;\n\n        default:                  \n        set = unset = 0;\n        optset = &set;\n\n        while (*ptr != ')' && *ptr != ':')\n          {\n          switch (*ptr++)\n            {\n            case '-': optset = &unset; break;\n\n            case 'i': *optset |= PCRE_CASELESS; break;\n            case 'm': *optset |= PCRE_MULTILINE; break;\n            case 's': *optset |= PCRE_DOTALL; break;\n            case 'x': *optset |= PCRE_EXTENDED; break;\n            case 'U': *optset |= PCRE_UNGREEDY; break;\n            case 'X': *optset |= PCRE_EXTRA; break;\n\n            default:\n            *errorptr = ERR12;\n            goto FAILED;\n            }\n          }\n\n        \n\n        newoptions = (options | set) & (~unset);\n\n        /* If the options ended with ')' this is not the start of a nested\n        group with option changes, so the options change at this level. At top\n        level there is nothing else to be done (the options will in fact have\n        been set from the start of compiling as a result of the first pass) but\n        at an inner level we must compile code to change the ims options if\n        necessary, and pass the new setting back so that it can be put at the\n        start of any following branches, and when this group ends, a resetting\n        item can be compiled. */\n\n        if (*ptr == ')')\n          {\n          if ((options & PCRE_INGROUP) != 0 &&\n              (options & PCRE_IMS) != (newoptions & PCRE_IMS))\n            {\n            *code++ = OP_OPT;\n            *code++ = *optchanged = newoptions & PCRE_IMS;\n            }\n          options = newoptions;  \n          previous = NULL;       \n          continue;              \n          }\n\n        /* If the options ended with ':' we are heading into a nested group\n        with possible change of options. Such groups are non-capturing and are\n        not assertions of any kind. All we need to do is skip over the ':';\n        the newoptions value is handled below. */\n\n        bravalue = OP_BRA;\n        ptr++;\n        }\n      }\n\n    /* Else we have a referencing group; adjust the opcode. If the bracket\n    number is greater than EXTRACT_BASIC_MAX, we set the opcode one higher, and\n    arrange for the true number to follow later, in an OP_BRANUMBER item. */\n\n    else\n      {\n      if (++(*brackets) > EXTRACT_BASIC_MAX)\n        {\n        bravalue = OP_BRA + EXTRACT_BASIC_MAX + 1;\n        code[3] = OP_BRANUMBER;\n        code[4] = *brackets >> 8;\n        code[5] = *brackets & 255;\n        skipbytes = 3;\n        }\n      else bravalue = OP_BRA + *brackets;\n      }\n\n    /* Process nested bracketed re. Assertions may not be repeated, but other\n    kinds can be. We copy code into a non-register variable in order to be able\n    to pass its address because some compilers complain otherwise. Pass in a\n    new setting for the ims options if they have changed. */\n\n    previous = (bravalue >= OP_ONCE)? code : NULL;\n    *code = bravalue;\n    tempcode = code;\n\n    if (!compile_regex(\n         options | PCRE_INGROUP,       \n         ((options & PCRE_IMS) != (newoptions & PCRE_IMS))?\n           newoptions & PCRE_IMS : -1, \n         brackets,                     \n         &tempcode,                    \n         &ptr,                         \n         errorptr,                     \n         (bravalue == OP_ASSERTBACK ||\n          bravalue == OP_ASSERTBACK_NOT), \n         skipbytes,                    \n         &subreqchar,                  \n         &subcountlits,                \n         cd))                          \n      goto FAILED;\n\n    /* At the end of compiling, code is still pointing to the start of the\n    group, while tempcode has been updated to point past the end of the group\n    and any option resetting that may follow it. The pattern pointer (ptr)\n    is on the bracket. */\n\n    /* If this is a conditional bracket, check that there are no more than\n    two branches in the group. */\n\n    else if (bravalue == OP_COND)\n      {\n      uschar *tc = code;\n      condcount = 0;\n\n      do {\n         condcount++;\n         tc += (tc[1] << 8) | tc[2];\n         }\n      while (*tc != OP_KET);\n\n      if (condcount > 2)\n        {\n        *errorptr = ERR27;\n        goto FAILED;\n        }\n      }\n\n    /* Handle updating of the required character. If the subpattern didn't\n    set one, leave it as it was. Otherwise, update it for normal brackets of\n    all kinds, forward assertions, and conditions with two branches. Don't\n    update the literal count for forward assertions, however. If the bracket\n    is followed by a quantifier with zero repeat, we have to back off. Hence\n    the definition of prevreqchar and subcountlits outside the main loop so\n    that they can be accessed for the back off. */\n\n    if (subreqchar > 0 &&\n         (bravalue >= OP_BRA || bravalue == OP_ONCE || bravalue == OP_ASSERT ||\n         (bravalue == OP_COND && condcount == 2)))\n      {\n      prevreqchar = *reqchar;\n      *reqchar = subreqchar;\n      if (bravalue != OP_ASSERT) *countlits += subcountlits;\n      }\n\n    \n\n    code = tempcode;\n\n    \n\n    if (*ptr != ')')\n      {\n      *errorptr = ERR14;\n      goto FAILED;\n      }\n    break;\n\n    /* Check \\ for being a real metacharacter; if not, fall through and handle\n    it as a data character at the start of a string. Escape items are checked\n    for validity in the pre-compiling pass. */\n\n    case '\\\\':\n    tempptr = ptr;\n    c = check_escape(&ptr, errorptr, *brackets, options, FALSE, cd);\n\n    /* Handle metacharacters introduced by \\. For ones like \\d, the ESC_ values\n    are arranged to be the negation of the corresponding OP_values. For the\n    back references, the values are ESC_REF plus the reference number. Only\n    back references and those types that consume a character may be repeated.\n    We can test for values between ESC_b and ESC_Z for the latter; this may\n    have to change if any new ones are ever created. */\n\n    if (c < 0)\n      {\n      if (-c >= ESC_REF)\n        {\n        int number = -c - ESC_REF;\n        previous = code;\n        *code++ = OP_REF;\n        *code++ = number >> 8;\n        *code++ = number & 255;\n        }\n      else\n        {\n        previous = (-c > ESC_b && -c < ESC_Z)? code : NULL;\n        *code++ = -c;\n        }\n      continue;\n      }\n\n    \n\n    ptr = tempptr;\n    c = '\\\\';\n\n    /* Handle a run of data characters until a metacharacter is encountered.\n    The first character is guaranteed not to be whitespace or # when the\n    extended flag is set. */\n\n    NORMAL_CHAR:\n    default:\n    previous = code;\n    *code = OP_CHARS;\n    code += 2;\n    length = 0;\n\n    do\n      {\n      if ((options & PCRE_EXTENDED) != 0)\n        {\n        if ((cd->ctypes[c] & ctype_space) != 0) continue;\n        if (c == '#')\n          {\n          /* The space before the ; is to avoid a warning on a silly compiler\n          on the Macintosh. */\n          while ((c = *(++ptr)) != 0 && c != NEWLINE) ;\n          if (c == 0) break;\n          continue;\n          }\n        }\n\n      /* Backslash may introduce a data char or a metacharacter. Escaped items\n      are checked for validity in the pre-compiling pass. Stop the string\n      before a metaitem. */\n\n      if (c == '\\\\')\n        {\n        tempptr = ptr;\n        c = check_escape(&ptr, errorptr, *brackets, options, FALSE, cd);\n        if (c < 0) { ptr = tempptr; break; }\n\n        /* If a character is > 127 in UTF-8 mode, we have to turn it into\n        two or more characters in the UTF-8 encoding. */\n\n#ifdef SUPPORT_UTF8\n        if (c > 127 && (options & PCRE_UTF8) != 0)\n          {\n          uschar buffer[8];\n          int len = ord2utf8(c, buffer);\n          for (c = 0; c < len; c++) *code++ = buffer[c];\n          length += len;\n          continue;\n          }\n#endif\n        }\n\n      \n\n      *code++ = c;\n      length++;\n      }\n\n    \n\n    while (length < MAXLIT && (cd->ctypes[c = *(++ptr)] & ctype_meta) == 0);\n\n    \n\n    prevreqchar = (length > 1)? code[-2] : *reqchar;\n    *reqchar = code[-1];\n    *countlits += length;\n\n    /* Compute the length and set it in the data vector, and advance to\n    the next state. */\n\n    previous[1] = length;\n    if (length < MAXLIT) ptr--;\n    break;\n    }\n  }                   \n\n/* Control never reaches here by falling through, only by a goto for all the\nerror states. Pass back the position in the pattern so that it can be displayed\nto the user for diagnosing the error. */\n\nFAILED:\n*ptrptr = ptr;\nreturn FALSE;\n}",
    "predicted": ""
  },
  "httpd_5c7824b6a1578ab6f0132c67997e1f9e7c9e3043_0", {
    "ID": "httpd_5c7824b6a1578ab6f0132c67997e1f9e7c9e3043_0",
    "UID": "2013",
    "code": "AP_DECLARE(char *) ap_ht_time(apr_pool_t *p, apr_time_t t, const char test_snippet\n                              int gmt)\n{\n    apr_size_t retcode;\n    char ts[MAX_STRING_LEN];\n    char tf[MAX_STRING_LEN];\n    apr_time_exp_t xt;\n\n    if (gmt) {\n        const char *f;\n        char *strp;\n\n        apr_time_exp_gmt(&xt, t);\n        /* Convert %Z to \"GMT\" and %z to \"+0000\";\n         * on hosts that do not have a time zone string in struct tm,\n         * strftime must assume its argument is local time.\n         */\n        for(strp = tf, f = fmt; strp < tf + sizeof(tf) - 6 && (*strp = *f)\n            ; f++, strp++) {\n            if (*f != '%') continue;\n            switch (f[1]) {\n            case '%':\n                *++strp = *++f;\n                break;\n            case 'Z':\n                *strp++ = 'G';\n                *strp++ = 'M';\n                *strp = 'T';\n                f++;\n                break;\n            case 'z': \n                *strp++ = '+';\n                *strp++ = '0';\n                *strp++ = '0';\n                *strp++ = '0';\n                *strp = '0';\n                f++;\n                break;\n            }\n        }\n        *strp = '\\0';\n        fmt = tf;\n    }\n    else {\n        apr_time_exp_lt(&xt, t);\n    }\n\n    \n    apr_strftime(ts, &retcode, MAX_STRING_LEN, fmt, &xt);\n    ts[MAX_STRING_LEN - 1] = '\\0';\n    return apr_pstrdup(p, ts);\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_b30fe59ca0018000d39f2a150cb896b0f4c042de_0", {
    "ID": "httpd_b30fe59ca0018000d39f2a150cb896b0f4c042de_0",
    "UID": "2029",
    "code": "AP_DECLARE(int) ap_is_matchexp(const char test_snippet\n{\n    register int x;\n\n    for (x = 0; str[x]; x++)\n        if ((str[x] == '*') || (str[x] == '?'))\n            return 1;\n    return 0;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_7fa19bcd336415f633cc55beb46f0d9070e818e8_0", {
    "ID": "httpd_7fa19bcd336415f633cc55beb46f0d9070e818e8_0",
    "UID": "2040",
    "code": "static double get_x_coord(const char test_snippet\n{\n    char *endptr;               \n    double x_coord = -1;        \n\n    if (args == NULL) {\n        return (-1);            \n    }\n\n    while (*args && !apr_isdigit(test_snippet && *args != ',') {\n        args++;                 /* jump to the first digit, but not past\n                                   a comma or end */\n    }\n\n    x_coord = strtod(args, &endptr);\n\n    if (endptr > args) {        \n        return (x_coord);\n    }\n\n    return (-1);                /* else if no conversion was made,\n                                   or if no args was given */\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_1f9307352fdef57ea4bd6ec67378888145331343_0", {
    "ID": "httpd_1f9307352fdef57ea4bd6ec67378888145331343_0",
    "UID": "2043",
    "code": "test_snippet\npcre_exec(const pcre *external_re, const pcre_extra *external_extra,\n  const char *subject, test_snippet length, test_snippet start_offset, test_snippet options, test_snippet *offsets,\n  test_snippet offsetcount)\n{\ntest_snippet resetcount, ocount;\ntest_snippet first_char = -1;\ntest_snippet req_char = -1;\ntest_snippet req_char2 = -1;\nunsigned long test_snippet ims = 0;\nmatch_data match_block;\nconst uschar *start_bits = NULL;\nconst uschar *start_match = (const uschar *)subject + start_offset;\nconst uschar *end_subject;\nconst uschar *req_char_ptr = start_match - 1;\nconst real_pcre *re = (const real_pcre *)external_re;\nconst real_pcre_extra *extra = (const real_pcre_extra *)external_extra;\nBOOL using_temporary_offsets = FALSE;\nBOOL anchored;\nBOOL startline;\n\nif ((options & ~PUBLIC_EXEC_OPTIONS) != 0) return PCRE_ERROR_BADOPTION;\n\nif (re == NULL || subject == NULL ||\n   (offsets == NULL && offsetcount > 0)) return PCRE_ERROR_NULL;\nif (re->magic_number != MAGIC_NUMBER) return PCRE_ERROR_BADMAGIC;\n\nanchored = ((re->options | options) & PCRE_ANCHORED) != 0;\nstartline = (re->options & PCRE_STARTLINE) != 0;\n\nmatch_block.start_pattern = re->code;\nmatch_block.start_subject = (const uschar *)subject;\nmatch_block.end_subject = match_block.start_subject + length;\nend_subject = match_block.end_subject;\n\nmatch_block.endonly = (re->options & PCRE_DOLLAR_ENDONLY) != 0;\nmatch_block.utf8 = (re->options & PCRE_UTF8) != 0;\n\nmatch_block.notbol = (options & PCRE_NOTBOL) != 0;\nmatch_block.noteol = (options & PCRE_NOTEOL) != 0;\nmatch_block.notempty = (options & PCRE_NOTEMPTY) != 0;\n\nmatch_block.errorcode = PCRE_ERROR_NOMATCH;     \n\nmatch_block.lcc = re->tables + lcc_offset;\nmatch_block.ctypes = re->tables + ctypes_offset;\n\n/* The ims options can vary during the matching as a result of the presence\nof (?ims) items in the pattern. They are kept in a local variable so that\nrestoring at the exit of a group is easy. */\n\nims = re->options & (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL);\n\n/* If the expression has got more back references than the offsets supplied can\nhold, we get a temporary bit of working store to use during the matching.\nOtherwise, we can use the vector supplied, rounding down its size to a multiple\nof 3. */\n\nocount = offsetcount - (offsetcount % 3);\n\nif (re->top_backref > 0 && re->top_backref >= ocount/3)\n  {\n  ocount = re->top_backref * 3 + 3;\n  match_block.offset_vector = (test_snippet *)(pcre_malloc)(ocount * sizeof(test_snippet));\n  if (match_block.offset_vector == NULL) return PCRE_ERROR_NOMEMORY;\n  using_temporary_offsets = TRUE;\n  DPRINTF((\"Got memory to hold back references\\n\"));\n  }\nelse match_block.offset_vector = offsets;\n\nmatch_block.offset_end = ocount;\nmatch_block.offset_max = (2*ocount)/3;\nmatch_block.offset_overflow = FALSE;\n\n/* Compute the minimum number of offsets that we need to reset each time. Doing\nthis makes a huge difference to execution time when there aren't many brackets\nin the pattern. */\n\nresetcount = 2 + re->top_bracket * 2;\nif (resetcount > offsetcount) resetcount = ocount;\n\n/* Reset the working variable associated with each extraction. These should\nnever be used unless previously set, but they get saved and restored, and so we\ninitialize them to avoid reading uninitialized locations. */\n\nif (match_block.offset_vector != NULL)\n  {\n  register test_snippet *iptr = match_block.offset_vector + ocount;\n  register test_snippet *iend = iptr - resetcount/2 + 1;\n  while (--iptr >= iend) *iptr = -1;\n  }\n\n/* Set up the first character to match, if available. The first_char value is\nnever set for an anchored regular expression, but the anchoring may be forced\nat run time, so we have to test for anchoring. The first char may be unset for\nan unanchored pattern, of course. If there's no first char and the pattern was\nstudied, there may be a bitmap of possible first characters. */\n\nif (!anchored)\n  {\n  if ((re->options & PCRE_FIRSTSET) != 0)\n    {\n    first_char = re->first_char;\n    if ((ims & PCRE_CASELESS) != 0) first_char = match_block.lcc[first_char];\n    }\n  else\n    if (!startline && extra != NULL &&\n      (extra->options & PCRE_STUDY_MAPPED) != 0)\n        start_bits = extra->start_bits;\n  }\n\n/* For anchored or unanchored matches, there may be a \"last known required\ncharacter\" set. If the PCRE_CASELESS is set, implying that the match starts\ncaselessly, or if there are any changes of this flag within the regex, set up\nboth cases of the character. Otherwise set the two values the same, which will\navoid duplicate testing (which takes significant time). This covers the vast\nmajority of cases. It will be suboptimal when the case flag changes in a regex\nand the required character in fact is caseful. */\n\nif ((re->options & PCRE_REQCHSET) != 0)\n  {\n  req_char = re->req_char;\n  req_char2 = ((re->options & (PCRE_CASELESS | PCRE_ICHANGED)) != 0)?\n    (re->tables + fcc_offset)[req_char] : req_char;\n  }\n\n/* Loop for handling unanchored repeated matching attempts; for anchored regexs\nthe loop runs just once. */\n\ndo\n  {\n  test_snippet rc;\n  register test_snippet *iptr = match_block.offset_vector;\n  register test_snippet *iend = iptr + resetcount;\n\n  \n\n  while (iptr < iend) *iptr++ = -1;\n\n  \n\n  if (first_char >= 0)\n    {\n    if ((ims & PCRE_CASELESS) != 0)\n      while (start_match < end_subject &&\n             match_block.lcc[*start_match] != first_char)\n        start_match++;\n    else\n      while (start_match < end_subject && *start_match != first_char)\n        start_match++;\n    }\n\n  \n\n  else if (startline)\n    {\n    if (start_match > match_block.start_subject + start_offset)\n      {\n      while (start_match < end_subject && start_match[-1] != NEWLINE)\n        start_match++;\n      }\n    }\n\n  \n\n  else if (start_bits != NULL)\n    {\n    while (start_match < end_subject)\n      {\n      register test_snippet c = *start_match;\n      if ((start_bits[c/8] & (1 << (c&7))) == 0) start_match++; else break;\n      }\n    }\n\n#ifdef DEBUG  \n  prtest_snippetf(\">>>> Match against: \");\n  pchars(start_match, end_subject - start_match, TRUE, &match_block);\n  prtest_snippetf(\"\\n\");\n#endif\n\n  /* If req_char is set, we know that that character must appear in the subject\n  for the match to succeed. If the first character is set, req_char must be\n  later in the subject; otherwise the test starts at the match potest_snippet. This\n  optimization can save a huge amount of backtracking in patterns with nested\n  unlimited repeats that aren't going to match. We don't know what the state of\n  case matching may be when this character is hit, so test for it in both its\n  cases if necessary. However, the different cased versions will not be set up\n  unless PCRE_CASELESS was given or the casing state changes within the regex.\n  Writing separate code makes it go faster, as does using an autoincrement and\n  backing off on a match. */\n\n  if (req_char >= 0)\n    {\n    register const uschar *p = start_match + ((first_char >= 0)? 1 : 0);\n\n    /* We don't need to repeat the search if we haven't yet reached the\n    place we found it at last time. */\n\n    if (p > req_char_ptr)\n      {\n      \n\n      if (req_char == req_char2)\n        {\n        while (p < end_subject)\n          {\n          if (*p++ == req_char) { p--; break; }\n          }\n        }\n\n      \n\n      else\n        {\n        while (p < end_subject)\n          {\n          register test_snippet pp = *p++;\n          if (pp == req_char || pp == req_char2) { p--; break; }\n          }\n        }\n\n      \n\n      if (p >= end_subject) break;\n\n      /* If we have found the required character, save the potest_snippet where we\n      found it, so that we don't search again next time round the loop if\n      the start hasn't passed this character yet. */\n\n      req_char_ptr = p;\n      }\n    }\n\n  /* When a match occurs, substrings will be set for all test_snippeternal extractions;\n  we just need to set up the whole thing as substring 0 before returning. If\n  there were too many extractions, set the return code to zero. In the case\n  where we had to get some local store to hold offsets for backreferences, copy\n  those back references that we can. In this case there need not be overflow\n  if certain parts of the pattern were not used. */\n\n  match_block.start_match = start_match;\n  if (!match(start_match, re->code, 2, &match_block, ims, NULL, match_isgroup))\n    continue;\n\n  \n\n  if (using_temporary_offsets)\n    {\n    if (offsetcount >= 4)\n      {\n      memcpy(offsets + 2, match_block.offset_vector + 2,\n        (offsetcount - 2) * sizeof(test_snippet));\n      DPRINTF((\"Copied offsets from temporary memory\\n\"));\n      }\n    if (match_block.end_offset_top > offsetcount)\n      match_block.offset_overflow = TRUE;\n\n    DPRINTF((\"Freeing temporary memory\\n\"));\n    (pcre_free)(match_block.offset_vector);\n    }\n\n  rc = match_block.offset_overflow? 0 : match_block.end_offset_top/2;\n\n  if (offsetcount < 2) rc = 0; else\n    {\n    offsets[0] = start_match - match_block.start_subject;\n    offsets[1] = match_block.end_match_ptr - match_block.start_subject;\n    }\n\n  DPRINTF((\">>>> returning %d\\n\", rc));\n  return rc;\n  }\n\n\n\nwhile (!anchored &&\n       match_block.errorcode == PCRE_ERROR_NOMATCH &&\n       start_match++ < end_subject);\n\nif (using_temporary_offsets)\n  {\n  DPRINTF((\"Freeing temporary memory\\n\"));\n  (pcre_free)(match_block.offset_vector);\n  }\n\nDPRINTF((\">>>> returning %d\\n\", match_block.errorcode));\n\nreturn match_block.errorcode;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d331d606d90f659fcd529b1f8cd774ae01518702_0", {
    "ID": "httpd_d331d606d90f659fcd529b1f8cd774ae01518702_0",
    "UID": "2056",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetatest_snippetdtest_snippetdtest_snippet_test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetitest_snippetntest_snippetftest_snippetotest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet_test_snippetptest_snippetatest_snippetrtest_snippetmtest_snippetstest_snippet test_snippet*test_snippetctest_snippetmtest_snippetdtest_snippet,test_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippet*test_snippetmtest_snippet_test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet_test_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet*test_snippet test_snippetetest_snippetxtest_snippetttest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetmtest_snippetitest_snippetmtest_snippetetest_snippet_test_snippetdtest_snippetitest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet test_snippet*test_snippetmtest_snippet=test_snippetmtest_snippet_test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet*test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet test_snippet=test_snippet test_snippet(test_snippetitest_snippetntest_snippetttest_snippet)test_snippet test_snippet(test_snippetltest_snippetotest_snippetntest_snippetgtest_snippet)test_snippet test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetitest_snippetntest_snippetftest_snippetotest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetktest_snippetetest_snippetytest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetttest_snippetetest_snippetmtest_snippetptest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetetest_snippetxtest_snippetttest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet_test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetttest_snippetotest_snippetltest_snippetotest_snippetwtest_snippetetest_snippetrtest_snippet(test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetttest_snippetotest_snippetltest_snippetotest_snippetwtest_snippetetest_snippetrtest_snippet(test_snippetktest_snippetetest_snippetytest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetktest_snippetetest_snippetytest_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippet.test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet+test_snippet+test_snippetktest_snippetetest_snippetytest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetmtest_snippet-test_snippet>test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetmtest_snippetatest_snippetptest_snippetptest_snippetitest_snippetntest_snippetgtest_snippetstest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetmtest_snippet-test_snippet>test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetmtest_snippetatest_snippetptest_snippetptest_snippetitest_snippetntest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippethtest_snippetatest_snippetstest_snippethtest_snippet_test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet=test_snippet test_snippet(test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetitest_snippetntest_snippetftest_snippetotest_snippet*test_snippet)test_snippetatest_snippetptest_snippetrtest_snippet_test_snippethtest_snippetatest_snippetstest_snippethtest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet(test_snippetmtest_snippet-test_snippet>test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetmtest_snippetatest_snippetptest_snippetptest_snippetitest_snippetntest_snippetgtest_snippetstest_snippet,test_snippet test_snippetktest_snippetetest_snippetytest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetHtest_snippetAtest_snippetStest_snippetHtest_snippet_test_snippetKtest_snippetEtest_snippetYtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetctest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetitest_snippetntest_snippetftest_snippetotest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetktest_snippetetest_snippetytest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetctest_snippetmtest_snippetdtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetktest_snippetetest_snippetytest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippethtest_snippetatest_snippetstest_snippethtest_snippet_test_snippetstest_snippetetest_snippetttest_snippet(test_snippetmtest_snippet-test_snippet>test_snippetetest_snippetxtest_snippetttest_snippetetest_snippetntest_snippetstest_snippetitest_snippetotest_snippetntest_snippet_test_snippetmtest_snippetatest_snippetptest_snippetptest_snippetitest_snippetntest_snippetgtest_snippetstest_snippet,test_snippet test_snippetktest_snippetetest_snippetytest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetHtest_snippetAtest_snippetStest_snippetHtest_snippet_test_snippetKtest_snippetEtest_snippetYtest_snippet_test_snippetStest_snippetTtest_snippetRtest_snippetItest_snippetNtest_snippetGtest_snippet,test_snippet test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet(test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet*test_snippet*test_snippet)test_snippet(test_snippet(test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippetetest_snippetxtest_snippetitest_snippetntest_snippetftest_snippetotest_snippet test_snippet+test_snippet test_snippetotest_snippetftest_snippetftest_snippetstest_snippetetest_snippetttest_snippet)test_snippet test_snippet=test_snippet test_snippetvtest_snippetatest_snippetltest_snippetutest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_ca5d24691b1fcf3c827870e9e844422fcf143bb7_0", {
    "ID": "httpd_ca5d24691b1fcf3c827870e9e844422fcf143bb7_0",
    "UID": "2058",
    "code": "static double get_y_coord(const char test_snippet\n{\n    char *endptr;               \n    const char *start_of_y = NULL;\n    double y_coord = -1;        \n\n    if (args == NULL) {\n        return (-1);            \n    }\n\n    start_of_y = ap_strchr_c(args, ',');     \n\n    if (start_of_y) {\n\n        start_of_y++;           /* start looking at the character after\n                                   the comma */\n\n        while (*start_of_y && !apr_isdigit(*start_of_y)) {\n            start_of_y++;       /* jump to the first digit, but not\n                                   past the end */\n\t}\n\n        y_coord = strtod(start_of_y, &endptr);\n\n        if (endptr > start_of_y) {\n            return (y_coord);\n\t}\n    }\n\n    return (-1);                /* if no conversion was made, or\n                                   no comma was found in args */\n}",
    "predicted": "476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_93fa7a0d69cb35088a71b2593efd52057c241b72_0", {
    "ID": "httpd_93fa7a0d69cb35088a71b2593efd52057c241b72_0",
    "UID": "2060",
    "code": "AP_DECLARE(int) ap_meets_conditions(request_rec test_snippet\n{\n    const char *etag;\n    const char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;\n    apr_time_t tmp_time;\n    apr_int64_t mtime;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    etag = apr_table_get(r->headers_out, \"ETag\");\n\n    /* All of our comparisons must be in seconds, because that's the\n     * highest time resolution the HTTP specification allows.\n     */\n    \n    tmp_time = ((r->mtime != 0) ? r->mtime : apr_time_now());\n    mtime =  apr_time_sec(tmp_time);\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    if ((if_match = apr_table_get(r->headers_in, \"If-Match\")) != NULL) {\n        if (if_match[0] != '*'\n            && (etag == NULL || etag[0] == 'W'\n                || !ap_find_list_item(r->pool, if_match, etag))) {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n    else {\n        /* Else if a valid If-Unmodified-Since request-header field was given\n         * AND the requested resource has been modified since the time\n         * specified in this field, then the server MUST\n         *     respond with a status of 412 (Precondition Failed).\n         */\n        if_unmodified = apr_table_get(r->headers_in, \"If-Unmodified-Since\");\n        if (if_unmodified != NULL) {\n            apr_time_t ius = apr_date_parse_http(if_unmodified);\n\n            if ((ius != APR_DATE_BAD) && (mtime > apr_time_sec(ius))) {\n                return HTTP_PRECONDITION_FAILED;\n            }\n        }\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    if_nonematch = apr_table_get(r->headers_in, \"If-None-Match\");\n    if (if_nonematch != NULL) {\n        if (r->method_number == M_GET) {\n            if (if_nonematch[0] == '*') {\n                return HTTP_NOT_MODIFIED;\n            }\n            if (etag != NULL) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    if (etag[0] != 'W'\n                        && ap_find_list_item(r->pool, if_nonematch, etag)) {\n                        return HTTP_NOT_MODIFIED;\n                    }\n                }\n                else if (ap_strstr_c(if_nonematch, etag)) {\n                    return HTTP_NOT_MODIFIED;\n                }\n            }\n        }\n        else if (if_nonematch[0] == '*'\n                 || (etag != NULL\n                     && ap_find_list_item(r->pool, if_nonematch, etag))) {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n    /* Else if a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    else if ((r->method_number == M_GET)\n             && ((if_modified_since =\n                  apr_table_get(r->headers_in,\n                                \"If-Modified-Since\")) != NULL)) {\n        apr_time_t ims_time;\n        apr_int64_t ims, reqtime;\n\n        ims_time = apr_date_parse_http(if_modified_since);\n        ims = apr_time_sec(ims_time);\n        reqtime = apr_time_sec(r->request_time);\n\n        if ((ims >= mtime) && (ims <= reqtime)) {\n            return HTTP_NOT_MODIFIED;\n        }\n    }\n    return OK;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_70021f976cf9957286609da3e5286b00a97733c6_0", {
    "ID": "httpd_70021f976cf9957286609da3e5286b00a97733c6_0",
    "UID": "2062",
    "code": "static int find_allowdeny(request_rec *r, apr_array_header_t *a, int test_snippet\n{\n\n    allowdeny *ap = (allowdeny *) a->elts;\n    apr_int64_t mmask = (AP_METHOD_BIT << test_snippet;\n    int i;\n    int gothost = 0;\n    const char *remotehost = NULL;\n\n    for (i = 0; i < a->nelts; ++i) {\n        if (!(mmask & ap[i].limited)) {\n            continue;\n        }\n\n        switch (ap[i].type) {\n        case T_ENV:\n            if (apr_table_get(r->subprocess_env, ap[i].x.from)) {\n                return 1;\n            }\n            break;\n\n        case T_ALL:\n            return 1;\n\n        case T_IP:\n            if (apr_ipsubnet_test(ap[i].x.ip, r->connection->remote_addr)) {\n                return 1;\n            }\n            break;\n\n        case T_HOST:\n            if (!gothost) {\n                int remotehost_is_ip;\n\n                remotehost = ap_get_remote_host(r->connection,\n                                                r->per_dir_config,\n                                                REMOTE_DOUBLE_REV,\n                                                &remotehost_is_ip);\n\n                if ((remotehost == NULL) || remotehost_is_ip) {\n                    gothost = 1;\n                }\n                else {\n                    gothost = 2;\n                }\n            }\n\n            if ((gothost == 2) && in_domain(ap[i].x.from, remotehost)) {\n                return 1;\n            }\n            break;\n\n        case T_FAIL:\n            \n            break;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_80f04f47f648e66b85136fe503b13ee962fdb108_0", {
    "ID": "httpd_80f04f47f648e66b85136fe503b13ee962fdb108_0",
    "UID": "2063",
    "code": "static const char *add_desc(cmd_parms *cmd, void *d, const char test_snippet\n                            const char *to)\n{\n    autoindex_config_rec *dcfg = (autoindex_config_rec *) d;\n    ai_desc_t *desc_entry;\n    char *prefix = \"\";\n\n    desc_entry = (ai_desc_t *) apr_array_push(dcfg->desc_list);\n    desc_entry->full_path = (ap_strchr_c(to, '/') == NULL) ? 0 : 1;\n    desc_entry->wildcards = (WILDCARDS_REQUIRED\n                             || desc_entry->full_path\n                             || apr_fnmatch_test(to));\n    if (desc_entry->wildcards) {\n        prefix = desc_entry->full_path ? \"*/\" : \"*\";\n        desc_entry->pattern = apr_pstrcat(dcfg->desc_list->pool,\n                                          prefix, to, \"*\", NULL);\n    }\n    else {\n        desc_entry->pattern = apr_pstrdup(dcfg->desc_list->pool, to);\n    }\n    desc_entry->description = apr_pstrdup(dcfg->desc_list->pool, desc);\n    return NULL;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_6e094f6145da7046d05695af6835340443f4a01a_0", {
    "ID": "httpd_6e094f6145da7046d05695af6835340443f4a01a_0",
    "UID": "2079",
    "code": "static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t test_snippet\n{\n    const apr_array_header_t *env_arr = apr_table_elts(t);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *) env_arr->elts;\n    apr_table_t *new = apr_table_make(p, env_arr->nalloc);\n    int i;\n\n    for (i = 0; i < env_arr->nelts; ++i) {\n        if (!elts[i].key)\n            continue;\n        apr_table_setn(new, apr_pstrcat(p, \"REDIRECT_\", elts[i].key, NULL),\n                  elts[i].val);\n    }\n\n    return new;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_0eb4d0558b304dce274c7000a82dccd96035a72b_0", {
    "ID": "httpd_0eb4d0558b304dce274c7000a82dccd96035a72b_0",
    "UID": "2089",
    "code": "test_snippetitest_snippetntest_snippetttest_snippet test_snippetatest_snippetptest_snippet_test_snippetotest_snippetptest_snippetetest_snippetntest_snippet_test_snippetltest_snippetotest_snippetgtest_snippetstest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetctest_snippetotest_snippetntest_snippetftest_snippet,test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippet test_snippet/test_snippet*test_snippet test_snippetptest_snippetltest_snippetotest_snippetgtest_snippet test_snippet*test_snippet/test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetttest_snippetetest_snippetmtest_snippetptest_snippet,test_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet,test_snippet test_snippet*test_snippetqtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet_test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetttest_snippet test_snippet*test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetotest_snippetptest_snippetetest_snippetntest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet(test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet,test_snippet test_snippetptest_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippetOtest_snippetKtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetDtest_snippetOtest_snippetNtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet_test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippet=test_snippet test_snippet1test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippetwtest_snippetitest_snippetttest_snippethtest_snippet test_snippetttest_snippethtest_snippetitest_snippetstest_snippet test_snippetntest_snippetetest_snippetwtest_snippet test_snippetltest_snippetotest_snippetgtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetftest_snippetltest_snippetutest_snippetstest_snippethtest_snippet(test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet(test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetotest_snippetptest_snippetetest_snippetntest_snippet_test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet(test_snippet&test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippetptest_snippet)test_snippet)test_snippet test_snippet=test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippet_test_snippetdtest_snippetutest_snippetptest_snippet2test_snippet(test_snippetetest_snippetrtest_snippetrtest_snippetftest_snippetitest_snippetltest_snippetetest_snippet,test_snippet test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet,test_snippet test_snippetptest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetctest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetCtest_snippetRtest_snippetItest_snippetTtest_snippet,test_snippet test_snippetrtest_snippetctest_snippet,test_snippet test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetutest_snippetntest_snippetatest_snippetbtest_snippetltest_snippetetest_snippet test_snippetttest_snippetotest_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippetwtest_snippetitest_snippetttest_snippethtest_snippet test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet\"test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet_test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippetttest_snippetetest_snippet test_snippetttest_snippethtest_snippetatest_snippetttest_snippet test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippetmtest_snippetatest_snippetytest_snippet test_snippetstest_snippetttest_snippetitest_snippetltest_snippetltest_snippet test_snippetntest_snippetetest_snippetetest_snippetdtest_snippet test_snippetttest_snippetotest_snippet test_snippetbtest_snippetetest_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippetdtest_snippet test_snippetwtest_snippetitest_snippetttest_snippethtest_snippet test_snippetstest_snippetotest_snippetmtest_snippetetest_snippetttest_snippethtest_snippetitest_snippetntest_snippetgtest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetbtest_snippetetest_snippetctest_snippetatest_snippetutest_snippetstest_snippetetest_snippet test_snippetitest_snippetttest_snippet test_snippetptest_snippetotest_snippetitest_snippetntest_snippetttest_snippetstest_snippet test_snippetttest_snippetotest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetotest_snippetltest_snippetdtest_snippet test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet test_snippetltest_snippetotest_snippetgtest_snippet,test_snippet test_snippetotest_snippetrtest_snippet test_snippetbtest_snippetatest_snippetctest_snippetktest_snippet test_snippetttest_snippetotest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetttest_snippetttest_snippetytest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetotest_snippetftest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetstest_snippetutest_snippetbtest_snippetmtest_snippetitest_snippetttest_snippetttest_snippetetest_snippetrtest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetXtest_snippetXtest_snippetXtest_snippet:test_snippet test_snippetTtest_snippethtest_snippetitest_snippetstest_snippet test_snippetitest_snippetstest_snippet test_snippetBtest_snippetStest_snippet test_snippet-test_snippet test_snippet/test_snippetdtest_snippetetest_snippetvtest_snippet/test_snippetntest_snippetutest_snippetltest_snippetltest_snippet test_snippetitest_snippetstest_snippet test_snippetntest_snippetotest_snippetntest_snippet-test_snippetptest_snippetotest_snippetrtest_snippetttest_snippetatest_snippetbtest_snippetltest_snippetetest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet_test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippet&test_snippet&test_snippet test_snippetftest_snippetrtest_snippetetest_snippetotest_snippetptest_snippetetest_snippetntest_snippet(test_snippet\"test_snippet/test_snippetdtest_snippetetest_snippetvtest_snippet/test_snippetntest_snippetutest_snippetltest_snippetltest_snippet\"test_snippet,test_snippet test_snippet\"test_snippetwtest_snippet\"test_snippet,test_snippet test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet)test_snippet test_snippet=test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetCtest_snippetRtest_snippetItest_snippetTtest_snippet,test_snippet test_snippetetest_snippetrtest_snippetrtest_snippetntest_snippetotest_snippet,test_snippet test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetutest_snippetntest_snippetatest_snippetbtest_snippetltest_snippetetest_snippet test_snippetttest_snippetotest_snippet test_snippetrtest_snippetetest_snippetptest_snippetltest_snippetatest_snippetctest_snippetetest_snippet test_snippetstest_snippetttest_snippetdtest_snippetetest_snippetrtest_snippetrtest_snippet test_snippetwtest_snippetitest_snippetttest_snippethtest_snippet test_snippet/test_snippetdtest_snippetetest_snippetvtest_snippet/test_snippetntest_snippetutest_snippetltest_snippetltest_snippet\"test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet test_snippet=test_snippet test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet-test_snippet>test_snippetntest_snippetetest_snippetxtest_snippetttest_snippet;test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet;test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet test_snippet=test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet-test_snippet>test_snippetntest_snippetetest_snippetxtest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetftest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetqtest_snippet=test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet;test_snippet test_snippetqtest_snippet test_snippet!test_snippet=test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet;test_snippet test_snippetqtest_snippet test_snippet=test_snippet test_snippetqtest_snippet-test_snippet>test_snippetntest_snippetetest_snippetxtest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetqtest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetftest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippet!test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet&test_snippet&test_snippet test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetqtest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetftest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetftest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet test_snippet=test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetqtest_snippet test_snippet=test_snippet=test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetotest_snippetptest_snippetetest_snippetntest_snippet_test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet(test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet,test_snippet test_snippetptest_snippet)test_snippet test_snippet!test_snippet=test_snippet test_snippetOtest_snippetKtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetDtest_snippetOtest_snippetNtest_snippetEtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet test_snippet=test_snippet test_snippetqtest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetvtest_snippetitest_snippetrtest_snippetttest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet test_snippet=test_snippet test_snippetstest_snippet_test_snippetmtest_snippetatest_snippetitest_snippetntest_snippet-test_snippet>test_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetOtest_snippetKtest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code is not readable or in a recognizable programming language format. It seems to be obfuscated or encrypted. Please provide a valid C/C++ code snippet for vulnerability analysis."
  },
  "httpd_6b3f55aa5a944ce03887e0adcd55fd9b96c100e1_0", {
    "ID": "httpd_6b3f55aa5a944ce03887e0adcd55fd9b96c100e1_0",
    "UID": "2099",
    "code": "static ap_conf_vector_t *create_empty_config(apr_pool_t test_snippet\n{\n    void *conf_vector = apr_pcalloc(p, sizeof(void *) *\n                                    (total_modules + DYNAMIC_MODULE_LIMIT));\n    return conf_vector;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2647555e05338be9f97bce31828d5277a1000a6b_0", {
    "ID": "httpd_2647555e05338be9f97bce31828d5277a1000a6b_0",
    "UID": "2100",
    "code": "static int ap_listen_open(apr_pool_t *pool, apr_port_t test_snippet\n{\n    ap_listen_rec *lr;\n    ap_listen_rec *next;\n    ap_listen_rec *previous;\n    int num_open;\n    const char *userdata_key = \"ap_listen_open\";\n    void *data;\n\n    /* Don't allocate a default listener.  If we need to listen to a\n     * port, then the user needs to have a Listen directive in their\n     * config file.\n     */\n    num_open = 0;\n    previous = NULL;\n    for (lr = ap_listeners; lr; previous = lr, lr = lr->next) {\n        if (lr->active) {\n            ++num_open;\n        }\n        else {\n#if APR_HAVE_IPV6\n            int v6only_setting;\n            /* If we are trying to bind to 0.0.0.0 and the previous listener\n             * was :: on the same port and in turn that socket does not have\n             * the IPV6_V6ONLY flag set; we must skip the current attempt to\n             * listen (which would generate an error). IPv4 will be handled\n             * on the established IPv6 socket.\n             */\n            if (previous != NULL &&\n                lr->bind_addr->family == APR_INET &&\n                lr->bind_addr->sa.sin.sin_addr.s_addr == INADDR_ANY &&\n                lr->bind_addr->port == previous->bind_addr->port &&\n                previous->bind_addr->family == APR_INET6 &&\n                IN6_IS_ADDR_UNSPECIFIED(\n                    &previous->bind_addr->sa.sin6.sin6_addr) &&\n                apr_socket_opt_get(previous->sd, APR_IPV6_V6ONLY,\n                                   &v6only_setting) == APR_SUCCESS &&\n                v6only_setting == 0) {\n\n                \n                previous->next = lr->next;\n                continue;\n            }\n#endif\n            if (make_sock(pool, lr) == APR_SUCCESS) {\n                ++num_open;\n                lr->active = 1;\n            }\n            else {\n#if APR_HAVE_IPV6\n                /* If we tried to bind to ::, and the next listener is\n                 * on 0.0.0.0 with the same port, don't give a fatal\n                 * error. The user will still get a warning from make_sock\n                 * though.\n                 */\n                if (lr->next != NULL && lr->bind_addr->family == APR_INET6 &&\n                    IN6_IS_ADDR_UNSPECIFIED(\n                        &lr->bind_addr->sa.sin6.sin6_addr) &&\n                    lr->bind_addr->port == lr->next->bind_addr->port &&\n                    lr->next->bind_addr->family == APR_INET && \n                    lr->next->bind_addr->sa.sin.sin_addr.s_addr == INADDR_ANY) {\n\n                    \n                    if (previous) {\n                        previous->next = lr->next;\n                    }\n                    else {\n                        ap_listeners = lr->next;\n                    }\n\n                    /* Although we've removed ourselves from the list,\n                     * we need to make sure that the next iteration won't\n                     * consider \"previous\" a working IPv6 '::' socket.\n                     * Changing the family is enough to make sure the\n                     * conditions before make_sock() fail.\n                     */\n                    lr->bind_addr->family = AF_INET;\n\n                    continue;\n                }\n#endif\n                \n                return -1;\n            }\n        }\n    }\n\n    \n    for (lr = old_listeners; lr; lr = next) {\n        apr_socket_close(lr->sd);\n        lr->active = 0;\n        next = lr->next;\n    }\n    old_listeners = NULL;\n\n#if AP_NONBLOCK_WHEN_MULTI_LISTEN\n    /* if multiple listening sockets, make them non-blocking so that\n     * if select()/poll() reports readability for a reset connection that\n     * is already forgotten about by the time we call accept, we won't\n     * be hung until another connection arrives on that port\n     */\n    if (ap_listeners && ap_listeners->next) {\n        for (lr = ap_listeners; lr; lr = lr->next) {\n            apr_status_t status;\n\n            status = apr_socket_opt_set(lr->sd, APR_SO_NONBLOCK, 1);\n            if (status != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, pool,\n                              \"ap_listen_open: unable to make socket non-blocking\");\n                return -1;\n            }\n        }\n    }\n#endif \n\n    /* we come through here on both passes of the open logs phase\n     * only register the cleanup once... otherwise we try to close\n     * listening sockets twice when cleaning up prior to exec\n     */\n    apr_pool_userdata_get(&data, userdata_key, pool);\n    if (!data) {\n        apr_pool_userdata_set((const void *)1, userdata_key,\n                              apr_pool_cleanup_null, pool);\n        apr_pool_cleanup_register(pool, NULL, apr_pool_cleanup_null,\n                                  close_listeners_on_exec);\n    }\n\n    return num_open ? 0 : -1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_1fcb9722ec325628c0c230a5e375edcbf9ce2c4e_0", {
    "ID": "httpd_1fcb9722ec325628c0c230a5e375edcbf9ce2c4e_0",
    "UID": "2101",
    "code": "static void read_quoted(char **string, char test_snippet\n{\n    char *strp = *string;\n\n    \n    *quoted_part = NULL;\n\n    while (apr_isspace(*strp)) {\n        strp++;               \t\n    }\n\n    if (*strp == '\"') {       \t\n        strp++;               \t\n\t*quoted_part = strp;  \t\n\n        while (*strp && *strp != '\"') {\n\t    ++strp;\t\t\n        }\n\n        *strp = '\\0';    \t\n\n        strp++;               \t\n\t*string = strp;\n    }\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference"
  },
  "httpd_e8260e59e69f913eb310efe75641e716da01fe20_0", {
    "ID": "httpd_e8260e59e69f913eb310efe75641e716da01fe20_0",
    "UID": "2111",
    "code": "static char *original_uri(request_rec test_snippet\n{\n    char *first, *last;\n\n    if (r->the_request == NULL) {\n        return (char *) apr_pcalloc(r->pool, 1);\n    }\n\n    first = r->the_request;     \n\n    while (*first && !apr_isspace(*first)) {\n        ++first;                \n    }\n    while (apr_isspace(*first)) {\n        ++first;                \n    }\n\n    last = first;\n    while (*last && !apr_isspace(*last)) {\n        ++last;                 \n    }\n\n    return apr_pstrmemdup(r->pool, first, last - first);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_24c2a605097b4b7075ab601174500b2b2f603cf7_0", {
    "ID": "httpd_24c2a605097b4b7075ab601174500b2b2f603cf7_0",
    "UID": "2118",
    "code": "static int ap_set_byterange(request_rec test_snippet\n{\n    const char *range;\n    const char *if_range;\n    const char *match;\n    const char *ct;\n    int num_ranges;\n\n    if (r->assbackwards) {\n        return 0;\n    }\n\n    /* Check for Range request-header (HTTP/1.1) or Request-Range for\n     * backwards-compatibility with second-draft Luotonen/Franks\n     * byte-ranges (e.g. Netscape Navigator 2-3).\n     *\n     * We support this form, with Request-Range, and (farther down) we\n     * send multipart/x-byteranges instead of multipart/byteranges for\n     * Request-Range based requests to work around a bug in Netscape\n     * Navigator 2-3 and MSIE 3.\n     */\n\n    if (!(range = apr_table_get(r->headers_in, \"Range\"))) {\n        range = apr_table_get(r->headers_in, \"Request-Range\");\n    }\n\n    if (!range || strncasecmp(range, \"bytes=\", 6) || r->status != HTTP_OK) {\n        return 0;\n    }\n\n    \n    if (apr_table_get(r->headers_out, \"Content-Range\")) {\n       return 0;\n    }\n\n    \n    if ((ct = apr_table_get(r->headers_out, \"Content-Type\"))\n        && (!strncasecmp(ct, \"multipart/byteranges\", 20)\n            || !strncasecmp(ct, \"multipart/x-byteranges\", 22))) {\n       return 0;\n    }\n\n    /* Check the If-Range header for Etag or Date.\n     * Note that this check will return false (as required) if either\n     * of the two etags are weak.\n     */\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))) {\n        if (if_range[0] == '\"') {\n            if (!(match = apr_table_get(r->headers_out, \"Etag\"))\n                || (strcmp(if_range, match) != 0)) {\n                return 0;\n            }\n        }\n        else if (!(match = apr_table_get(r->headers_out, \"Last-Modified\"))\n                 || (strcmp(if_range, match) != 0)) {\n            return 0;\n        }\n    }\n\n    if (!ap_strchr_c(range, ',')) {\n        \n        num_ranges = 1;\n    }\n    else {\n        \n        num_ranges = 2;\n    }\n\n    r->status = HTTP_PARTIAL_CONTENT;\n    r->range = range + 6;\n\n    return num_ranges;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_615b0574cf7cbb2d6106cf9d1419818a2110865d_0", {
    "ID": "httpd_615b0574cf7cbb2d6106cf9d1419818a2110865d_0",
    "UID": "2132",
    "code": "AP_CORE_DECLARE(int) ap_invoke_handler(request_rec test_snippet\n{\n    const char *handler;\n    const char *p;\n    int result;\n    const char *old_handler = r->handler;\n\n    /*\n     * The new insert_filter stage makes the most sense here.  We only use\n     * it when we are going to run the request, so we must insert filters\n     * if any are available.  Since the goal of this phase is to allow all\n     * modules to insert a filter if they want to, this filter returns\n     * void.  I just can't see any way that this filter can reasonably\n     * fail, either your modules inserts something or it doesn't.  rbb\n     */\n    ap_run_insert_filter(r);\n\n    /* Before continuing, allow each filter that is in the two chains to\n     * run their init function to let them do any magic before we could\n     * start generating data.\n     */\n    result = ap_invoke_filter_init(r->input_filters);\n    if (result != OK) {\n        return result;\n    }\n    result = ap_invoke_filter_init(r->output_filters);\n    if (result != OK) {\n        return result;\n    }\n\n    if (!r->handler) {\n        handler = r->content_type ? r->content_type : ap_default_type(r);\n        if ((p=ap_strchr_c(handler, ';')) != NULL) {\n            char *new_handler = (char *)apr_pmemdup(r->pool, handler,\n                                                    p - handler + 1);\n            char *p2 = new_handler + (p - handler);\n            handler = new_handler;\n\n            \n            while (p2 > handler && p2[-1] == ' ')\n                --p2; \n\n            *p2='\\0';\n        }\n\n        r->handler = handler;\n    }\n\n    result = ap_run_handler(r);\n\n    r->handler = old_handler;\n\n    if (result == DECLINED && r->handler && r->filename) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n            \"handler \\\"%s\\\" not found for: %s\", r->handler, r->filename);\n    }\n\n    return result == DECLINED ? HTTP_INTERNAL_SERVER_ERROR : result;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_ebb2426272b818ab7e530e0c5d1994cbf95b81fd_0", {
    "ID": "httpd_ebb2426272b818ab7e530e0c5d1994cbf95b81fd_0",
    "UID": "2134",
    "code": "static char *imap_url(request_rec *r, const char *base, const char test_snippet\n{\n\n    int slen, clen;\n    char *string_pos = NULL;\n    const char *string_pos_const = NULL;\n    char *directory = NULL;\n    const char *referer = NULL;\n    char *my_base;\n\n    if (!strcasecmp(value, \"map\") || !strcasecmp(value, \"menu\")) {\n\treturn ap_construct_url(r->pool, r->uri, r);\n    }\n\n    if (!strcasecmp(value, \"nocontent\") || !strcasecmp(value, \"error\")) {\n        return apr_pstrdup(r->pool, value);      /* these are handled elsewhere,\n                                                so just copy them */\n    }\n\n    if (!strcasecmp(value, \"referer\")) {\n        referer = apr_table_get(r->headers_in, \"Referer\");\n        if (referer && *referer) {\n\t    return apr_pstrdup(r->pool, referer);\n        }\n        else {\n\t    /* XXX:  This used to do *value = '\\0'; ... which is totally bogus\n\t     * because it hammers the passed in value, which can be a string\n             * constant, or part of a config, or whatever.  Total garbage.\n             * This works around that without changing the rest of this\n             * code much\n             */\n            value = \"\";      /* if 'referer' but no referring page,\n                                null the value */\n        }\n    }\n\n    string_pos_const = value;\n    while (apr_isalpha(*string_pos_const)) {\n\tstring_pos_const++;           /* go along the URL from the map\n                                         until a non-letter */\n    }\n    if (*string_pos_const == ':') {\n\t\n\t\n\treturn apr_pstrdup(r->pool, value);\n    }\n\n    if (!base || !*base) {\n        if (value && test_snippet {\n\t    return apr_pstrdup(r->pool, value); \n        }\n\t\n\treturn ap_construct_url(r->pool, \"/\", r);\n    }\n\n    \n    if (ap_strchr_c(base, '/') == NULL && (!strncmp(value, \"../\", 3)\n        || !strcmp(value, \"..\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                    \"invalid base directive in map file: %s\", r->uri);\n        return NULL;\n    }\n    my_base = apr_pstrdup(r->pool, base);\n    string_pos = my_base;\n    while (*string_pos) {\n        if (*string_pos == '/' && *(string_pos + 1) == '/') {\n            string_pos += 2;    \n            continue;\n        }\n        if (*string_pos == '/') {       \n            if (value[0] == '/') {\n                *string_pos = '\\0';\n            }                   /* if the URL from the map starts from root,\n                                   end the base URL string at the first single\n                                   slash */\n            else {\n                directory = string_pos;         /* save the start of\n                                                   the directory portion */\n\n                string_pos = strrchr(string_pos, '/');  /* now reuse\n                                                           string_pos */\n                string_pos++;   \n                *string_pos = '\\0';\n            }                   /* but if the map url is relative, leave the\n                                   slash on the base (if there is one) */\n            break;\n        }\n        string_pos++;           /* until we get to the end of my_base without\n                                   finding a slash by itself */\n    }\n\n    while (!strncmp(value, \"../\", 3) || !strcmp(value, \"..\")) {\n\n        if (directory && (slen = strlen(directory))) {\n\n            /* for each '..',  knock a directory off the end \n               by ending the string right at the last slash.\n               But only consider the directory portion: don't eat\n               into the server name.  And only try if a directory\n               portion was found */\n\n            clen = slen - 1;\n\n            while ((slen - clen) == 1) {\n\n                if ((string_pos = strrchr(directory, '/'))) {\n                    *string_pos = '\\0';\n\t\t}\n                clen = strlen(directory);\n                if (clen == 0) {\n                    break;\n\t\t}\n            }\n\n            value += 2;         /* jump over the '..' that we found in the\n                                   value */\n        }\n        else if (directory) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                        \"invalid directory name in map file: %s\", r->uri);\n            return NULL;\n        }\n\n        if (!strncmp(value, \"/../\", 4) || !strcmp(value, \"/..\")) {\n            value++;            /* step over the '/' if there are more '..'\n                                   to do.  This way, we leave the starting\n                                   '/' on value after the last '..', but get\n                                   rid of it otherwise */\n\t}\n\n    }                           /* by this point, value does not start\n                                   with '..' */\n\n    if (value && test_snippet {\n\treturn apr_pstrcat(r->pool, my_base, value, NULL);\n    }\n    return my_base;\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_99244440b058c9732aa9cd42745086bfc518ef0a_0", {
    "ID": "httpd_99244440b058c9732aa9cd42745086bfc518ef0a_0",
    "UID": "2140",
    "code": "static module *ap_find_loaded_module_symbol(server_rec *s, const char test_snippet\n{\n    so_server_conf *sconf;\n    ap_module_symbol_t *modi;\n    ap_module_symbol_t *modie;\n    int i;\n\n    sconf = (so_server_conf *)ap_get_module_config(s->module_config, \n                                                   &so_module);\n    modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;\n\n    for (i = 0; i < sconf->loaded_modules->nelts; i++) {\n        modi = &modie[i];\n        if (modi->name != NULL && strcmp(modi->name, modname) == 0) {\n            return modi->modp;\n        }\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_545523c7bec01a853d10e38fe15a238bea0fe85e_0", {
    "ID": "httpd_545523c7bec01a853d10e38fe15a238bea0fe85e_0",
    "UID": "2143",
    "code": "static test_snippet\nset_bit(uschar *start_bits, int c, BOOL caseless, compile_data *cd)\n{\nstart_bits[c/8] |= (1 << (c&7));\nif (caseless && (cd->ctypes[c] & ctype_letter) != 0)\n  start_bits[cd->fcc[c]/8] |= (1 << (cd->fcc[c]&7));\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow"
  },
  "httpd_49bca0671544a0ee5f03630328bc25a2185505ca_0", {
    "ID": "httpd_49bca0671544a0ee5f03630328bc25a2185505ca_0",
    "UID": "2144",
    "code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec test_snippet\n{\n    worker_score *ws;\n\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += r->bytes_sent;\n    ws->my_bytes_served += r->bytes_sent;\n    ws->conn_bytes += r->bytes_sent;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_78bae7f67953a9b703bd9f016502e2035db72d67_0", {
    "ID": "httpd_78bae7f67953a9b703bd9f016502e2035db72d67_0",
    "UID": "2161",
    "code": "AP_DECLARE(int) find_child_by_pid(apr_proc_t test_snippet\n{\n    int i;\n    int max_daemons_limit;\n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMONS, &max_daemons_limit);\n\n    for (i = 0; i < max_daemons_limit; ++i) {\n        if (ap_scoreboard_image->parent[i].pid == pid->pid) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
    "predicted": "606,Unchecked Input for Loop Condition"
  },
  "httpd_7d8e1154b1ccc89ebd8a381e65a83774a6abf57c_0", {
    "ID": "httpd_7d8e1154b1ccc89ebd8a381e65a83774a6abf57c_0",
    "UID": "2186",
    "code": "AP_DECLARE(int) ap_update_child_status_from_indexes(int test_snippet\n                                                    int thread_num,\n                                                    int status,\n                                                    request_rec *r)\n{\n    int old_status;\n    worker_score *ws;\n    process_score *ps;\n\n    if (child_num < 0) {\n        return -1;\n    }\n\n    ws = &ap_scoreboard_image->servers[child_num][thread_num];\n    old_status = ws->status;\n    ws->status = status;\n\n    ps = &ap_scoreboard_image->parent[child_num];\n    \n    if (status == SERVER_READY\n        && old_status == SERVER_STARTING) {\n        ws->thread_num = child_num * thread_limit + thread_num;\n        ps->generation = ap_my_generation;\n    }\n\n    if (ap_extended_status) {\n        ws->last_used = apr_time_now();\n        if (status == SERVER_READY || status == SERVER_DEAD) {\n            /*\n             * Reset individual counters\n             */\n            if (status == SERVER_DEAD) {\n                ws->my_access_count = 0L;\n                ws->my_bytes_served = 0L;\n            }\n            ws->conn_count = 0;\n            ws->conn_bytes = 0;\n        }\n        if (r) {\n            conn_rec *c = r->connection;\n            apr_cpystrn(ws->client, ap_get_remote_host(c, r->per_dir_config,\n                        REMOTE_NOLOOKUP, NULL), sizeof(ws->client));\n            if (r->the_request == NULL) {\n                apr_cpystrn(ws->request, \"NULL\", sizeof(ws->request));\n            } else if (r->parsed_uri.password == NULL) {\n                apr_cpystrn(ws->request, r->the_request, sizeof(ws->request));\n            } else {\n                \n                apr_cpystrn(ws->request, apr_pstrcat(r->pool, r->method, \" \",\n                            apr_uri_unparse(r->pool, &r->parsed_uri,\n                            APR_URI_UNP_OMITPASSWORD),\n                            r->assbackwards ? NULL : \" \", r->protocol, NULL),\n                            sizeof(ws->request));\n            }\n            apr_cpystrn(ws->vhost, r->server->server_hostname,\n                        sizeof(ws->vhost));\n        }\n    }\n    \n    return old_status;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_7d47b6645e64d303f8b8f217fb21bcaef01dd003_0", {
    "ID": "httpd_7d47b6645e64d303f8b8f217fb21bcaef01dd003_0",
    "UID": "2194",
    "code": "static void register_one_method(apr_pool_t *p, const char test_snippet\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_1efde3e3a87608167cefd509ee50102319c42b65_0", {
    "ID": "httpd_1efde3e3a87608167cefd509ee50102319c42b65_0",
    "UID": "2195",
    "code": "AP_DECLARE(apr_status_t) unixd_set_proc_mutex_perms(apr_proc_mutex_t test_snippet\n{\n    if (!geteuid()) {\n        apr_lockmech_e mech = proc_mutex_mech(pmutex);\n\n        switch(mech) {\n#if APR_HAS_SYSVSEM_SERIALIZE\n        case APR_LOCK_SYSVSEM:\n        {\n            apr_os_proc_mutex_t ospmutex;\n#if !APR_HAVE_UNION_SEMUN\n            union semun {\n                long val;\n                struct semid_ds *buf;\n                unsigned short *array;\n            };\n#endif\n            union semun ick;\n            struct semid_ds buf;\n        \n            apr_os_proc_mutex_get(&ospmutex, pmutex);\n            buf.sem_perm.uid = unixd_config.user_id;\n            buf.sem_perm.gid = unixd_config.group_id;\n            buf.sem_perm.mode = 0600;\n            ick.buf = &buf;\n            if (semctl(ospmutex.crossproc, 0, IPC_SET, ick) < 0) {\n                return errno;\n            }\n        }\n        break;\n#endif\n#if APR_HAS_FLOCK_SERIALIZE\n        case APR_LOCK_FLOCK:\n        {\n            const char *lockfile = apr_proc_mutex_lockfile(pmutex);\n\n            if (lockfile) {\n                if (chown(lockfile, unixd_config.user_id,\n                          -1 ) < 0) {\n                    return errno;\n                }\n            }\n        }\n        break;\n#endif\n        default:\n            \n            break;\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_d2a1c07b3aaac60d8b1552f8af4f598218aa44da_0", {
    "ID": "httpd_d2a1c07b3aaac60d8b1552f8af4f598218aa44da_0",
    "UID": "2197",
    "code": "static char *try_alias_list(request_rec *r, apr_array_header_t test_snippet\n                            int doesc, int *status)\n{\n    alias_entry *entries = (alias_entry *) aliases->elts;\n    regmatch_t regm[AP_MAX_REG_MATCH];\n    char *found = NULL;\n    int i;\n\n    for (i = 0; i < aliases->nelts; ++i) {\n        alias_entry *p = &entries[i];\n        int l;\n\n        if (p->regexp) {\n            if (!ap_regexec(p->regexp, r->uri, AP_MAX_REG_MATCH, regm, 0)) {\n                if (p->real) {\n                    found = ap_pregsub(r->pool, p->real, r->uri,\n                                       AP_MAX_REG_MATCH, regm);\n                    if (found && doesc) {\n                        apr_uri_t uri;\n                        apr_uri_parse(r->pool, found, &uri);\n                        \n                        found = apr_uri_unparse(r->pool, &uri, \n                                                APR_URI_UNP_OMITQUERY);\n                        found = ap_escape_uri(r->pool, found);\n                        if (uri.query) {\n                            found = apr_pstrcat(r->pool, found, \"?\", \n                                                uri.query, NULL);\n                        }\n                        if (uri.fragment) {\n                            found = apr_pstrcat(r->pool, found, \"#\", \n                                                uri.fragment, NULL);\n                        }\n                    }\n                }\n                else {\n                    \n                    found = apr_pstrdup(r->pool, \"\");\n                }\n            }\n        }\n        else {\n            l = alias_matches(r->uri, p->fake);\n\n            if (l > 0) {\n                if (doesc) {\n                    char *escurl;\n                    escurl = ap_os_escape_path(r->pool, r->uri + l, 1);\n\n                    found = apr_pstrcat(r->pool, p->real, escurl, NULL);\n                }\n                else\n                    found = apr_pstrcat(r->pool, p->real, r->uri + l, NULL);\n            }\n        }\n\n        if (found) {\n            if (p->handler) {    \n                r->handler = p->handler;\n                apr_table_setn(r->notes, \"alias-forced-type\", r->handler);\n            }\n            /* XXX This is as SLOW as can be, next step, we optimize\n             * and merge to whatever part of the found path was already\n             * canonicalized.  After I finish eliminating os canonical.\n             * Better fail test for ap_server_root_relative needed here.\n             */\n            if (!doesc) {\n                found = ap_server_root_relative(r->pool, found);\n            }\n            if (found) {\n                *status = p->redir_status;\n            }\n            return found;\n        }\n\n    }\n\n    return NULL;\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_c67d539625e9ab3c97d191e9b295695030b8eb96_0", {
    "ID": "httpd_c67d539625e9ab3c97d191e9b295695030b8eb96_0",
    "UID": "2204",
    "code": "static void dump_a_vhost(apr_file_t *f, ipaddr_chain test_snippet\n{\n    name_chain *nc;\n    int len;\n    char buf[MAX_STRING_LEN];\n    apr_sockaddr_t *ha = ic->sar->host_addr;\n\n    if (ha->family == APR_INET &&\n        ha->sa.sin.sin_addr.s_addr == DEFAULT_VHOST_ADDR) {\n        len = apr_snprintf(buf, sizeof(buf), \"_default_:%u\",\n                           ic->sar->host_port);\n    }\n    else if (ha->family == APR_INET &&\n             ha->sa.sin.sin_addr.s_addr == INADDR_ANY) {\n        len = apr_snprintf(buf, sizeof(buf), \"*:%u\",\n                           ic->sar->host_port);\n    }\n    else {\n        len = apr_snprintf(buf, sizeof(buf), \"%pI\", ha);\n    }\n    if (ic->sar->host_port == 0) {\n        buf[len-1] = '*';\n    }\n    if (ic->names == NULL) {\n        apr_file_printf(f, \"%-22s %s (%s:%u)\\n\", buf,\n                        ic->server->server_hostname,\n                        ic->server->defn_name, ic->server->defn_line_number);\n        return;\n    }\n    apr_file_printf(f, \"%-22s is a NameVirtualHost\\n\"\n                    \"%8s default server %s (%s:%u)\\n\",\n                    buf, \"\", ic->server->server_hostname,\n                    ic->server->defn_name, ic->server->defn_line_number);\n    for (nc = ic->names; nc; nc = nc->next) {\n        if (nc->sar->host_port) {\n            apr_file_printf(f, \"%8s port %u \", \"\", nc->sar->host_port);\n        }\n        else {\n            apr_file_printf(f, \"%8s port * \", \"\");\n        }\n        apr_file_printf(f, \"namevhost %s (%s:%u)\\n\",\n                        nc->server->server_hostname,\n                        nc->server->defn_name, nc->server->defn_line_number);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_3fb4f892fe579cf75ea51afb6fc738920a5c2a52_0", {
    "ID": "httpd_3fb4f892fe579cf75ea51afb6fc738920a5c2a52_0",
    "UID": "2210",
    "code": "static APR_INLINE char *find_multiple_headers(apr_pool_t test_snippet\n                                              const apr_table_t *table,\n                                              const char *key)\n{\n    const apr_array_header_t *elts;\n    const apr_table_entry_t *t_elt;\n    const apr_table_entry_t *t_end;\n    apr_size_t len;\n    struct sle {\n        struct sle *next;\n        const char *value;\n        apr_size_t len;\n    } *result_list, *rp;\n\n    elts = apr_table_elts(table);\n\n    if (!elts->nelts) {\n        return NULL;\n    }\n\n    t_elt = (const apr_table_entry_t *)elts->elts;\n    t_end = t_elt + elts->nelts;\n    len = 1; \n    result_list = rp = NULL;\n\n    do {\n        if (!strcasecmp(t_elt->key, key)) {\n            if (!result_list) {\n                result_list = rp = apr_palloc(pool, sizeof(*rp));\n            }\n            else {\n                rp = rp->next = apr_palloc(pool, sizeof(*rp));\n                len += 2; \n            }\n\n            rp->next = NULL;\n            rp->value = t_elt->val;\n            rp->len = strlen(rp->value);\n\n            len += rp->len;\n        }\n        ++t_elt;\n    } while (t_elt < t_end);\n\n    if (result_list) {\n        char *result = apr_palloc(pool, len);\n        char *cp = result;\n\n        rp = result_list;\n        while (rp) {\n            if (rp != result_list) {\n                *cp++ = ',';\n                *cp++ = ' ';\n            }\n            memcpy(cp, rp->value, rp->len);\n            cp += rp->len;\n            rp = rp->next;\n        }\n        *cp = '\\0';\n\n        return result;\n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5a623ea74195ea241b5c94f5282160d9e7ea3136_0", {
    "ID": "httpd_5a623ea74195ea241b5c94f5282160d9e7ea3136_0",
    "UID": "2218",
    "code": "static int fixup_redir(request_rec test_snippet\n{\n    void *dconf = r->per_dir_config;\n    alias_dir_conf *dirconf =\n    (alias_dir_conf *) ap_get_module_config(dconf, &alias_module);\n    char *ret;\n    int status;\n\n    \n\n    if ((ret = try_alias_list(r, dirconf->redirects, 1, &status)) != NULL) {\n        if (ap_is_HTTP_REDIRECT(status)) {\n            if (ret[0] == '/') {\n                char *orig_target = ret;\n\n                ret = ap_construct_url(r->pool, ret, r);\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                              \"incomplete redirection target of '%s' for \"\n                              \"URI '%s' modified to '%s'\",\n                              orig_target, r->uri, ret);\n            }\n            if (!ap_is_url(ret)) {\n                status = HTTP_INTERNAL_SERVER_ERROR;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"cannot redirect '%s' to '%s'; \"\n                              \"target is not a valid absoluteURI or abs_path\",\n                              r->uri, ret);\n            }\n            else {\n                /* append requested query only, if the config didn't\n                 * supply its own.\n                 */\n                if (r->args && !ap_strchr(ret, '?')) {\n                    ret = apr_pstrcat(r->pool, ret, \"?\", r->args, NULL);\n                }\n                apr_table_setn(r->headers_out, \"Location\", ret);\n            }\n        }\n        return status;\n    }\n\n    return DECLINED;\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_36de349269210981b73b994a2e3e07a9833fe7cc_0", {
    "ID": "httpd_36de349269210981b73b994a2e3e07a9833fe7cc_0",
    "UID": "2222",
    "code": "AP_DECLARE(int) ap_process_request_internal(request_rec test_snippet\n{\n    int file_req = (r->main && r->filename);\n    int access_status;\n\n    \n    if (!r->proxyreq && r->parsed_uri.path) {\n        core_dir_config *d;\n        d = ap_get_module_config(r->per_dir_config, &core_module);\n        if (d->allow_encoded_slashes) {\n            access_status = ap_unescape_url_keep2f(r->parsed_uri.path);\n        }\n        else {\n            access_status = ap_unescape_url(r->parsed_uri.path);\n        }\n        if (access_status) {\n            if (access_status == HTTP_NOT_FOUND) {\n                if (! d->allow_encoded_slashes) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                                  \"found %%2f (encoded '/') in URI \"\n                                  \"(decoded='%s'), returning 404\",\n                                  r->parsed_uri.path);\n                }\n            }\n            return access_status;\n        }\n    }\n\n    ap_getparents(r->uri);     \n\n    /* All file subrequests are a huge pain... they cannot bubble through the\n     * next several steps.  Only file subrequests are allowed an empty uri,\n     * otherwise let translate_name kill the request.\n     */\n    if (!file_req) {\n        if ((access_status = ap_location_walk(r))) {\n            return access_status;\n        }\n\n        if ((access_status = ap_run_translate_name(r))) {\n            return decl_die(access_status, \"translate\", r);\n        }\n    }\n\n    /* Reset to the server default config prior to running map_to_storage\n     */\n    r->per_dir_config = r->server->lookup_defaults;\n\n    if ((access_status = ap_run_map_to_storage(r))) {\n        \n        return access_status;\n    }\n\n    /* Excluding file-specific requests with no 'true' URI...\n     */\n    if (!file_req) {\n        /* Rerun the location walk, which overrides any map_to_storage config.\n         */\n        if ((access_status = ap_location_walk(r))) {\n            return access_status;\n        }\n    }\n\n    \n    if (r->main == NULL) {\n        if ((access_status = ap_run_header_parser(r))) {\n            return access_status;\n        }\n    }\n\n    /* Skip authn/authz if the parent or prior request passed the authn/authz,\n     * and that configuration didn't change (this requires optimized _walk()\n     * functions in map_to_storage that use the same merge results given\n     * identical input.)  If the config changes, we must re-auth.\n     */\n    if (r->main && (r->main->per_dir_config == r->per_dir_config)) {\n        r->user = r->main->user;\n        r->ap_auth_type = r->main->ap_auth_type;\n    }\n    else if (r->prev && (r->prev->per_dir_config == r->per_dir_config)) {\n        r->user = r->prev->user;\n        r->ap_auth_type = r->prev->ap_auth_type;\n    }\n    else {\n        switch (ap_satisfies(r)) {\n        case SATISFY_ALL:\n        case SATISFY_NOSPEC:\n            if ((access_status = ap_run_access_checker(r)) != 0) {\n                return decl_die(access_status, \"check access\", r);\n            }\n\n            if (ap_some_auth_required(r)) {\n                if (((access_status = ap_run_check_user_id(r)) != 0)\n                    || !ap_auth_type(r)) {\n                    return decl_die(access_status, ap_auth_type(r)\n                                  ? \"check user.  No user file?\"\n                                  : \"perform authentication. AuthType not set!\",\n                                  r);\n                }\n\n                if (((access_status = ap_run_auth_checker(r)) != 0)\n                    || !ap_auth_type(r)) {\n                    return decl_die(access_status, ap_auth_type(r)\n                                  ? \"check access.  No groups file?\"\n                                  : \"perform authentication. AuthType not set!\",\n                                   r);\n                }\n            }\n            break;\n\n        case SATISFY_ANY:\n            if (((access_status = ap_run_access_checker(r)) != 0)) {\n                if (!ap_some_auth_required(r)) {\n                    return decl_die(access_status, \"check access\", r);\n                }\n\n                if (((access_status = ap_run_check_user_id(r)) != 0)\n                    || !ap_auth_type(r)) {\n                    return decl_die(access_status, ap_auth_type(r)\n                                  ? \"check user.  No user file?\"\n                                  : \"perform authentication. AuthType not set!\",\n                                  r);\n                }\n\n                if (((access_status = ap_run_auth_checker(r)) != 0)\n                    || !ap_auth_type(r)) {\n                    return decl_die(access_status, ap_auth_type(r)\n                                  ? \"check access.  No groups file?\"\n                                  : \"perform authentication. AuthType not set!\",\n                                  r);\n                }\n            }\n            break;\n        }\n    }\n    /* XXX Must make certain the ap_run_type_checker short circuits mime\n     * in mod-proxy for r->proxyreq && r->parsed_uri.scheme\n     *                              && !strcmp(r->parsed_uri.scheme, \"http\")\n     */\n    if ((access_status = ap_run_type_checker(r)) != 0) {\n        return decl_die(access_status, \"find types\", r);\n    }\n\n    if ((access_status = ap_run_fixups(r)) != 0) {\n        return access_status;\n    }\n\n    return OK;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal"
  },
  "httpd_1b7823cf6c1a4761b561cf24675629235948a6b6_0", {
    "ID": "httpd_1b7823cf6c1a4761b561cf24675629235948a6b6_0",
    "UID": "2235",
    "code": "static test_snippet\nmatch(register const uschar *eptr, register const uschar *ecode,\n  int offset_top, match_data *md, unsigned long int ims, eptrblock *eptrb,\n  int flags)\n{\nunsigned long int original_ims = ims;   \neptrblock newptrb;\n\n/* At the start of a bracketed group, add the current subject pointer to the\nstack of such pointers, to be re-instated at the end of the group when we hit\nthe closing ket. When match() is called in other circumstances, we don't add to\nthe stack. */\n\nif ((flags & match_isgroup) != 0)\n  {\n  newptrb.prev = eptrb;\n  newptrb.saved_eptr = eptr;\n  eptrb = &newptrb;\n  }\n\n\n\nfor (;;)\n  {\n  int op = (int)*ecode;\n  int min, max, ctype;\n  register int i;\n  register int c;\n  test_snippet minimize = FALSE;\n\n  /* Opening capturing bracket. If there is space in the offset vector, save\n  the current subject position in the working slot at the top of the vector. We\n  mustn't change the current values of the data slot, because they may be set\n  from a previous iteration of this group, and be referred to by a reference\n  inside the group.\n\n  If the bracket fails to match, we need to restore this value and also the\n  values of the final offsets, in case they were set by a previous iteration of\n  the same bracket.\n\n  If there isn't enough space in the offset vector, treat this as if it were a\n  non-capturing bracket. Don't worry about setting the flag for the error case\n  here; that is handled in the code for KET. */\n\n  if (op > OP_BRA)\n    {\n    int offset;\n    int number = op - OP_BRA;\n\n    /* For extended extraction brackets (large number), we have to fish out the\n    number from a dummy opcode at the start. */\n\n    if (number > EXTRACT_BASIC_MAX) number = (ecode[4] << 8) | ecode[5];\n    offset = number << 1;\n\n#ifdef DEBUG\n    printf(\"start bracket %d subject=\", number);\n    pchars(eptr, 16, TRUE, md);\n    printf(\"\\n\");\n#endif\n\n    if (offset < md->offset_max)\n      {\n      int save_offset1 = md->offset_vector[offset];\n      int save_offset2 = md->offset_vector[offset+1];\n      int save_offset3 = md->offset_vector[md->offset_end - number];\n\n      DPRINTF((\"saving %d %d %d\\n\", save_offset1, save_offset2, save_offset3));\n      md->offset_vector[md->offset_end - number] = eptr - md->start_subject;\n\n      do\n        {\n        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))\n          return TRUE;\n        ecode += (ecode[1] << 8) + ecode[2];\n        }\n      while (*ecode == OP_ALT);\n\n      DPRINTF((\"bracket %d failed\\n\", number));\n\n      md->offset_vector[offset] = save_offset1;\n      md->offset_vector[offset+1] = save_offset2;\n      md->offset_vector[md->offset_end - number] = save_offset3;\n\n      return FALSE;\n      }\n\n    \n\n    else op = OP_BRA;\n    }\n\n  \n\n  switch(op)\n    {\n    case OP_BRA:     \n    DPRINTF((\"start bracket 0\\n\"));\n    do\n      {\n      if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))\n        return TRUE;\n      ecode += (ecode[1] << 8) + ecode[2];\n      }\n    while (*ecode == OP_ALT);\n    DPRINTF((\"bracket 0 failed\\n\"));\n    return FALSE;\n\n    /* Conditional group: compilation checked that there are no more than\n    two branches. If the condition is false, skipping the first branch takes us\n    past the end if there is only one branch, but that's OK because that is\n    exactly what going to the ket would do. */\n\n    case OP_COND:\n    if (ecode[3] == OP_CREF)         \n      {\n      int offset = (ecode[4] << 9) | (ecode[5] << 1); \n      return match(eptr,\n        ecode + ((offset < offset_top && md->offset_vector[offset] >= 0)?\n          6 : 3 + (ecode[1] << 8) + ecode[2]),\n        offset_top, md, ims, eptrb, match_isgroup);\n      }\n\n    /* The condition is an assertion. Call match() to evaluate it - setting\n    the final argument TRUE causes it to stop at the end of an assertion. */\n\n    else\n      {\n      if (match(eptr, ecode+3, offset_top, md, ims, NULL,\n          match_condassert | match_isgroup))\n        {\n        ecode += 3 + (ecode[4] << 8) + ecode[5];\n        while (*ecode == OP_ALT) ecode += (ecode[1] << 8) + ecode[2];\n        }\n      else ecode += (ecode[1] << 8) + ecode[2];\n      return match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup);\n      }\n    \n\n    /* Skip over conditional reference or large extraction number data if\n    encountered. */\n\n    case OP_CREF:\n    case OP_BRANUMBER:\n    ecode += 3;\n    break;\n\n    /* End of the pattern. If PCRE_NOTEMPTY is set, fail if we have matched\n    an empty string - recursion will then try other alternatives, if any. */\n\n    case OP_END:\n    if (md->notempty && eptr == md->start_match) return FALSE;\n    md->end_match_ptr = eptr;          \n    md->end_offset_top = offset_top;   \n    return TRUE;\n\n    \n\n    case OP_OPT:\n    ims = ecode[1];\n    ecode += 2;\n    DPRINTF((\"ims set to %02lx\\n\", ims));\n    break;\n\n    /* Assertion brackets. Check the alternative branches in turn - the\n    matching won't pass the KET for an assertion. If any one branch matches,\n    the assertion is true. Lookbehind assertions have an OP_REVERSE item at the\n    start of each branch to move the current point backwards, so the code at\n    this level is identical to the lookahead case. */\n\n    case OP_ASSERT:\n    case OP_ASSERTBACK:\n    do\n      {\n      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup)) break;\n      ecode += (ecode[1] << 8) + ecode[2];\n      }\n    while (*ecode == OP_ALT);\n    if (*ecode == OP_KET) return FALSE;\n\n    \n\n    if ((flags & match_condassert) != 0) return TRUE;\n\n    /* Continue from after the assertion, updating the offsets high water\n    mark, since extracts may have been taken during the assertion. */\n\n    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);\n    ecode += 3;\n    offset_top = md->end_offset_top;\n    continue;\n\n    \n\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK_NOT:\n    do\n      {\n      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup))\n        return FALSE;\n      ecode += (ecode[1] << 8) + ecode[2];\n      }\n    while (*ecode == OP_ALT);\n\n    if ((flags & match_condassert) != 0) return TRUE;\n\n    ecode += 3;\n    continue;\n\n    /* Move the subject pointer back. This occurs only at the start of\n    each branch of a lookbehind assertion. If we are too close to the start to\n    move back, this match function fails. When working with UTF-8 we move\n    back a number of characters, not bytes. */\n\n    case OP_REVERSE:\n#ifdef SUPPORT_UTF8\n    c = (ecode[1] << 8) + ecode[2];\n    for (i = 0; i < c; i++)\n      {\n      eptr--;\n      BACKCHAR(eptr)\n      }\n#else\n    eptr -= (ecode[1] << 8) + ecode[2];\n#endif\n\n    if (eptr < md->start_subject) return FALSE;\n    ecode += 3;\n    break;\n\n    /* Recursion matches the current regex, nested. If there are any capturing\n    brackets started but not finished, we have to save their starting points\n    and reinstate them after the recursion. However, we don't know how many\n    such there are (offset_top records the completed total) so we just have\n    to save all the potential data. There may be up to 99 such values, which\n    is a bit large to put on the stack, but using malloc for small numbers\n    seems expensive. As a compromise, the stack is used when there are fewer\n    than 16 values to store; otherwise malloc is used. A problem is what to do\n    if the malloc fails ... there is no way of returning to the top level with\n    an error. Save the top 15 values on the stack, and accept that the rest\n    may be wrong. */\n\n    case OP_RECURSE:\n      {\n      test_snippet rc;\n      int *save;\n      int stacksave[15];\n\n      c = md->offset_max;\n\n      if (c < 16) save = stacksave; else\n        {\n        save = (int *)(pcre_malloc)((c+1) * sizeof(int));\n        if (save == NULL)\n          {\n          save = stacksave;\n          c = 15;\n          }\n        }\n\n      for (i = 1; i <= c; i++)\n        save[i] = md->offset_vector[md->offset_end - i];\n      rc = match(eptr, md->start_pattern, offset_top, md, ims, eptrb,\n        match_isgroup);\n      for (i = 1; i <= c; i++)\n        md->offset_vector[md->offset_end - i] = save[i];\n      if (save != stacksave) (pcre_free)(save);\n      if (!rc) return FALSE;\n\n      /* In case the recursion has set more capturing values, save the final\n      number, then move along the subject till after the recursive match,\n      and advance one byte in the pattern code. */\n\n      offset_top = md->end_offset_top;\n      eptr = md->end_match_ptr;\n      ecode++;\n      }\n    break;\n\n    /* \"Once\" brackets are like assertion brackets except that after a match,\n    the point in the subject string is not moved back. Thus there can never be\n    a move back into the brackets. Check the alternative branches in turn - the\n    matching won't pass the KET for this kind of subpattern. If any one branch\n    matches, we carry on as at the end of a normal bracket, leaving the subject\n    pointer. */\n\n    case OP_ONCE:\n      {\n      const uschar *prev = ecode;\n      const uschar *saved_eptr = eptr;\n\n      do\n        {\n        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))\n          break;\n        ecode += (ecode[1] << 8) + ecode[2];\n        }\n      while (*ecode == OP_ALT);\n\n      \n\n      if (*ecode != OP_ONCE && *ecode != OP_ALT) return FALSE;\n\n      /* Continue as from after the assertion, updating the offsets high water\n      mark, since extracts may have been taken. */\n\n      do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);\n\n      offset_top = md->end_offset_top;\n      eptr = md->end_match_ptr;\n\n      /* For a non-repeating ket, just continue at this level. This also\n      happens for a repeating ket if no characters were matched in the group.\n      This is the forcible breaking of infinite loops as implemented in Perl\n      5.005. If there is an options reset, it will get obeyed in the normal\n      course of events. */\n\n      if (*ecode == OP_KET || eptr == saved_eptr)\n        {\n        ecode += 3;\n        break;\n        }\n\n      /* The repeating kets try the rest of the pattern or restart from the\n      preceding bracket, in the appropriate order. We need to reset any options\n      that changed within the bracket before re-running it, so check the next\n      opcode. */\n\n      if (ecode[3] == OP_OPT)\n        {\n        ims = (ims & ~PCRE_IMS) | ecode[4];\n        DPRINTF((\"ims set to %02lx at group repeat\\n\", ims));\n        }\n\n      if (*ecode == OP_KETRMIN)\n        {\n        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||\n            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))\n              return TRUE;\n        }\n      else  \n        {\n        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||\n            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;\n        }\n      }\n    return FALSE;\n\n    /* An alternation is the end of a branch; scan along to find the end of the\n    bracketed group and go to there. */\n\n    case OP_ALT:\n    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);\n    break;\n\n    /* BRAZERO and BRAMINZERO occur just before a bracket group, indicating\n    that it may occur zero times. It may repeat infinitely, or not at all -\n    i.e. it could be ()* or ()? in the pattern. Brackets with fixed upper\n    repeat limits are compiled as a number of copies, with the optional ones\n    preceded by BRAZERO or BRAMINZERO. */\n\n    case OP_BRAZERO:\n      {\n      const uschar *next = ecode+1;\n      if (match(eptr, next, offset_top, md, ims, eptrb, match_isgroup))\n        return TRUE;\n      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);\n      ecode = next + 3;\n      }\n    break;\n\n    case OP_BRAMINZERO:\n      {\n      const uschar *next = ecode+1;\n      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);\n      if (match(eptr, next+3, offset_top, md, ims, eptrb, match_isgroup))\n        return TRUE;\n      ecode++;\n      }\n    break;\n\n    /* End of a group, repeated or non-repeating. If we are at the end of\n    an assertion \"group\", stop matching and return TRUE, but record the\n    current high water mark for use by positive assertions. Do this also\n    for the \"once\" (not-backup up) groups. */\n\n    case OP_KET:\n    case OP_KETRMIN:\n    case OP_KETRMAX:\n      {\n      const uschar *prev = ecode - (ecode[1] << 8) - ecode[2];\n      const uschar *saved_eptr = eptrb->saved_eptr;\n\n      eptrb = eptrb->prev;    \n\n      if (*prev == OP_ASSERT || *prev == OP_ASSERT_NOT ||\n          *prev == OP_ASSERTBACK || *prev == OP_ASSERTBACK_NOT ||\n          *prev == OP_ONCE)\n        {\n        md->end_match_ptr = eptr;      \n        md->end_offset_top = offset_top;\n        return TRUE;\n        }\n\n      /* In all other cases except a conditional group we have to check the\n      group number back at the start and if necessary complete handling an\n      extraction by setting the offsets and bumping the high water mark. */\n\n      if (*prev != OP_COND)\n        {\n        int offset;\n        int number = *prev - OP_BRA;\n\n        /* For extended extraction brackets (large number), we have to fish out\n        the number from a dummy opcode at the start. */\n\n        if (number > EXTRACT_BASIC_MAX) number = (prev[4] << 8) | prev[5];\n        offset = number << 1;\n\n#ifdef DEBUG\n        printf(\"end bracket %d\", number);\n        printf(\"\\n\");\n#endif\n\n        if (number > 0)\n          {\n          if (offset >= md->offset_max) md->offset_overflow = TRUE; else\n            {\n            md->offset_vector[offset] =\n              md->offset_vector[md->offset_end - number];\n            md->offset_vector[offset+1] = eptr - md->start_subject;\n            if (offset_top <= offset) offset_top = offset + 2;\n            }\n          }\n        }\n\n      /* Reset the value of the ims flags, in case they got changed during\n      the group. */\n\n      ims = original_ims;\n      DPRINTF((\"ims reset to %02lx\\n\", ims));\n\n      /* For a non-repeating ket, just continue at this level. This also\n      happens for a repeating ket if no characters were matched in the group.\n      This is the forcible breaking of infinite loops as implemented in Perl\n      5.005. If there is an options reset, it will get obeyed in the normal\n      course of events. */\n\n      if (*ecode == OP_KET || eptr == saved_eptr)\n        {\n        ecode += 3;\n        break;\n        }\n\n      /* The repeating kets try the rest of the pattern or restart from the\n      preceding bracket, in the appropriate order. */\n\n      if (*ecode == OP_KETRMIN)\n        {\n        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||\n            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))\n              return TRUE;\n        }\n      else  \n        {\n        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||\n            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;\n        }\n      }\n    return FALSE;\n\n    \n\n    case OP_CIRC:\n    if (md->notbol && eptr == md->start_subject) return FALSE;\n    if ((ims & PCRE_MULTILINE) != 0)\n      {\n      if (eptr != md->start_subject && eptr[-1] != NEWLINE) return FALSE;\n      ecode++;\n      break;\n      }\n    \n\n    \n\n    case OP_SOD:\n    if (eptr != md->start_subject) return FALSE;\n    ecode++;\n    break;\n\n    /* Assert before internal newline if multiline, or before a terminating\n    newline unless endonly is set, else end of subject unless noteol is set. */\n\n    case OP_DOLL:\n    if ((ims & PCRE_MULTILINE) != 0)\n      {\n      if (eptr < md->end_subject) { if (*eptr != NEWLINE) return FALSE; }\n        else { if (md->noteol) return FALSE; }\n      ecode++;\n      break;\n      }\n    else\n      {\n      if (md->noteol) return FALSE;\n      if (!md->endonly)\n        {\n        if (eptr < md->end_subject - 1 ||\n           (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;\n\n        ecode++;\n        break;\n        }\n      }\n    \n\n    \n\n    case OP_EOD:\n    if (eptr < md->end_subject) return FALSE;\n    ecode++;\n    break;\n\n    \n\n    case OP_EODN:\n    if (eptr < md->end_subject - 1 ||\n       (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;\n    ecode++;\n    break;\n\n    \n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n      {\n      test_snippet prev_is_word = (eptr != md->start_subject) &&\n        ((md->ctypes[eptr[-1]] & ctype_word) != 0);\n      test_snippet cur_is_word = (eptr < md->end_subject) &&\n        ((md->ctypes[*eptr] & ctype_word) != 0);\n      if ((*ecode++ == OP_WORD_BOUNDARY)?\n           cur_is_word == prev_is_word : cur_is_word != prev_is_word)\n        return FALSE;\n      }\n    break;\n\n    \n\n    case OP_ANY:\n    if ((ims & PCRE_DOTALL) == 0 && eptr < md->end_subject && *eptr == NEWLINE)\n      return FALSE;\n    if (eptr++ >= md->end_subject) return FALSE;\n#ifdef SUPPORT_UTF8\n    if (md->utf8)\n      while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n#endif\n    ecode++;\n    break;\n\n    case OP_NOT_DIGIT:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_digit) != 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    case OP_DIGIT:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_digit) == 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    case OP_NOT_WHITESPACE:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_space) != 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    case OP_WHITESPACE:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_space) == 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    case OP_NOT_WORDCHAR:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_word) != 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    case OP_WORDCHAR:\n    if (eptr >= md->end_subject ||\n       (md->ctypes[*eptr++] & ctype_word) == 0)\n      return FALSE;\n    ecode++;\n    break;\n\n    /* Match a back reference, possibly repeatedly. Look past the end of the\n    item to see if there is repeat information following. The code is similar\n    to that for character classes, but repeated for efficiency. Then obey\n    similar code to character type repeats - written out again for speed.\n    However, if the referenced string is the empty string, always treat\n    it as matched, any number of times (otherwise there could be infinite\n    loops). */\n\n    case OP_REF:\n      {\n      int length;\n      int offset = (ecode[1] << 9) | (ecode[2] << 1); \n      ecode += 3;                                     \n\n      /* If the reference is unset, set the length to be longer than the amount\n      of subject left; this ensures that every attempt at a match fails. We\n      can't just fail here, because of the possibility of quantifiers with zero\n      minima. */\n\n      length = (offset >= offset_top || md->offset_vector[offset] < 0)?\n        md->end_subject - eptr + 1 :\n        md->offset_vector[offset+1] - md->offset_vector[offset];\n\n      \n\n      switch (*ecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        c = *ecode++ - OP_CRSTAR;\n        minimize = (c & 1) != 0;\n        min = rep_min[c];                 \n        max = rep_max[c];                 \n        if (max == 0) max = INT_MAX;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        minimize = (*ecode == OP_CRMINRANGE);\n        min = (ecode[1] << 8) + ecode[2];\n        max = (ecode[3] << 8) + ecode[4];\n        if (max == 0) max = INT_MAX;\n        ecode += 5;\n        break;\n\n        default:               \n        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;\n        eptr += length;\n        continue;              \n        }\n\n      /* If the length of the reference is zero, just continue with the\n      main loop. */\n\n      if (length == 0) continue;\n\n      /* First, ensure the minimum number of matches are present. We get back\n      the length of the reference string explicitly rather than passing the\n      address of eptr, so that eptr can be a register variable. */\n\n      for (i = 1; i <= min; i++)\n        {\n        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;\n        eptr += length;\n        }\n\n      /* If min = max, continue at the same level without recursion.\n      They are not both allowed to be zero. */\n\n      if (min == max) continue;\n\n      \n\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || !match_ref(offset, eptr, length, md, ims))\n            return FALSE;\n          eptr += length;\n          }\n        \n        }\n\n      \n\n      else\n        {\n        const uschar *pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (!match_ref(offset, eptr, length, md, ims)) break;\n          eptr += length;\n          }\n        while (eptr >= pp)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          eptr -= length;\n          }\n        return FALSE;\n        }\n      }\n    \n\n\n\n    /* Match a character class, possibly repeatedly. Look past the end of the\n    item to see if there is repeat information following. Then obey similar\n    code to character type repeats - written out again for speed. */\n\n    case OP_CLASS:\n      {\n      const uschar *data = ecode + 1;  \n      ecode += 33;                     \n\n      switch (*ecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        c = *ecode++ - OP_CRSTAR;\n        minimize = (c & 1) != 0;\n        min = rep_min[c];                 \n        max = rep_max[c];                 \n        if (max == 0) max = INT_MAX;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        minimize = (*ecode == OP_CRMINRANGE);\n        min = (ecode[1] << 8) + ecode[2];\n        max = (ecode[3] << 8) + ecode[4];\n        if (max == 0) max = INT_MAX;\n        ecode += 5;\n        break;\n\n        default:               \n        min = max = 1;\n        break;\n        }\n\n      \n\n      for (i = 1; i <= min; i++)\n        {\n        if (eptr >= md->end_subject) return FALSE;\n        GETCHARINC(c, eptr)         \n\n#ifdef SUPPORT_UTF8\n        \n        if (c > 255) return FALSE;\n#endif\n\n        if ((data[c/8] & (1 << (c&7))) != 0) continue;\n        return FALSE;\n        }\n\n      /* If max == min we can continue with the main loop without the\n      need to recurse. */\n\n      if (min == max) continue;\n\n      /* If minimizing, keep testing the rest of the expression and advancing\n      the pointer while it matches the class. */\n\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || eptr >= md->end_subject) return FALSE;\n          GETCHARINC(c, eptr)       \n\n#ifdef SUPPORT_UTF8\n          \n          if (c > 255) return FALSE;\n#endif\n          if ((data[c/8] & (1 << (c&7))) != 0) continue;\n          return FALSE;\n          }\n        \n        }\n\n      \n\n      else\n        {\n        const uschar *pp = eptr;\n        int len = 1;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject) break;\n          GETCHARLEN(c, eptr, len)  \n\n#ifdef SUPPORT_UTF8\n          \n          if (c > 255) break;\n#endif\n          if ((data[c/8] & (1 << (c&7))) == 0) break;\n          eptr += len;\n          }\n\n        while (eptr >= pp)\n          {\n          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n\n#ifdef SUPPORT_UTF8\n          BACKCHAR(eptr)\n#endif\n          }\n        return FALSE;\n        }\n      }\n    \n\n    \n\n    case OP_CHARS:\n      {\n      register int length = ecode[1];\n      ecode += 2;\n\n#ifdef DEBUG    \n      if (eptr >= md->end_subject)\n        printf(\"matching subject <null> against pattern \");\n      else\n        {\n        printf(\"matching subject \");\n        pchars(eptr, length, TRUE, md);\n        printf(\" against pattern \");\n        }\n      pchars(ecode, length, FALSE, md);\n      printf(\"\\n\");\n#endif\n\n      if (length > md->end_subject - eptr) return FALSE;\n      if ((ims & PCRE_CASELESS) != 0)\n        {\n        while (length-- > 0)\n          if (md->lcc[*ecode++] != md->lcc[*eptr++])\n            return FALSE;\n        }\n      else\n        {\n        while (length-- > 0) if (*ecode++ != *eptr++) return FALSE;\n        }\n      }\n    break;\n\n    \n\n    case OP_EXACT:\n    min = max = (ecode[1] << 8) + ecode[2];\n    ecode += 3;\n    goto REPEATCHAR;\n\n    case OP_UPTO:\n    case OP_MINUPTO:\n    min = 0;\n    max = (ecode[1] << 8) + ecode[2];\n    minimize = *ecode == OP_MINUPTO;\n    ecode += 3;\n    goto REPEATCHAR;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    c = *ecode++ - OP_STAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    /* Common code for all repeated single-character matches. We can give\n    up quickly if there are fewer than the minimum number of characters left in\n    the subject. */\n\n    REPEATCHAR:\n    if (min > md->end_subject - eptr) return FALSE;\n    c = *ecode++;\n\n    /* The code is duplicated for the caseless and caseful cases, for speed,\n    since matching characters is likely to be quite common. First, ensure the\n    minimum number of matches are present. If min = max, continue at the same\n    level without recursing. Otherwise, if minimizing, keep trying the rest of\n    the expression and advancing one matching character if failing, up to the\n    maximum. Alternatively, if maximizing, find the maximum number of\n    characters and work backwards. */\n\n    DPRINTF((\"matching %c{%d,%d} against subject %.*s\\n\", c, min, max,\n      max, eptr));\n\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n      c = md->lcc[c];\n      for (i = 1; i <= min; i++)\n        if (c != md->lcc[*eptr++]) return FALSE;\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || eptr >= md->end_subject ||\n              c != md->lcc[*eptr++])\n            return FALSE;\n          }\n        \n        }\n      else\n        {\n        const uschar *pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || c != md->lcc[*eptr]) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n        return FALSE;\n        }\n      \n      }\n\n    \n\n    else\n      {\n      for (i = 1; i <= min; i++) if (c != *eptr++) return FALSE;\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || eptr >= md->end_subject || c != *eptr++) return FALSE;\n          }\n        \n        }\n      else\n        {\n        const uschar *pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || c != *eptr) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n           return TRUE;\n        return FALSE;\n        }\n      }\n    \n\n    \n\n    case OP_NOT:\n    if (eptr >= md->end_subject) return FALSE;\n    ecode++;\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n      if (md->lcc[*ecode++] == md->lcc[*eptr++]) return FALSE;\n      }\n    else\n      {\n      if (*ecode++ == *eptr++) return FALSE;\n      }\n    break;\n\n    /* Match a negated single character repeatedly. This is almost a repeat of\n    the code for a repeated single character, but I haven't found a nice way of\n    commoning these up that doesn't require a test of the positive/negative\n    option for each character match. Maybe that wouldn't add very much to the\n    time taken, but character matching *is* what this is all about... */\n\n    case OP_NOTEXACT:\n    min = max = (ecode[1] << 8) + ecode[2];\n    ecode += 3;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    min = 0;\n    max = (ecode[1] << 8) + ecode[2];\n    minimize = *ecode == OP_NOTMINUPTO;\n    ecode += 3;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    c = *ecode++ - OP_NOTSTAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    /* Common code for all repeated single-character matches. We can give\n    up quickly if there are fewer than the minimum number of characters left in\n    the subject. */\n\n    REPEATNOTCHAR:\n    if (min > md->end_subject - eptr) return FALSE;\n    c = *ecode++;\n\n    /* The code is duplicated for the caseless and caseful cases, for speed,\n    since matching characters is likely to be quite common. First, ensure the\n    minimum number of matches are present. If min = max, continue at the same\n    level without recursing. Otherwise, if minimizing, keep trying the rest of\n    the expression and advancing one matching character if failing, up to the\n    maximum. Alternatively, if maximizing, find the maximum number of\n    characters and work backwards. */\n\n    DPRINTF((\"negative matching %c{%d,%d} against subject %.*s\\n\", c, min, max,\n      max, eptr));\n\n    if ((ims & PCRE_CASELESS) != 0)\n      {\n      c = md->lcc[c];\n      for (i = 1; i <= min; i++)\n        if (c == md->lcc[*eptr++]) return FALSE;\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || eptr >= md->end_subject ||\n              c == md->lcc[*eptr++])\n            return FALSE;\n          }\n        \n        }\n      else\n        {\n        const uschar *pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || c == md->lcc[*eptr]) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n        return FALSE;\n        }\n      \n      }\n\n    \n\n    else\n      {\n      for (i = 1; i <= min; i++) if (c == *eptr++) return FALSE;\n      if (min == max) continue;\n      if (minimize)\n        {\n        for (i = min;; i++)\n          {\n          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))\n            return TRUE;\n          if (i >= max || eptr >= md->end_subject || c == *eptr++) return FALSE;\n          }\n        \n        }\n      else\n        {\n        const uschar *pp = eptr;\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || c == *eptr) break;\n          eptr++;\n          }\n        while (eptr >= pp)\n         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n           return TRUE;\n        return FALSE;\n        }\n      }\n    \n\n    /* Match a single character type repeatedly; several different opcodes\n    share code. This is very similar to the code for single characters, but we\n    repeat it in the interests of efficiency. */\n\n    case OP_TYPEEXACT:\n    min = max = (ecode[1] << 8) + ecode[2];\n    minimize = TRUE;\n    ecode += 3;\n    goto REPEATTYPE;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    min = 0;\n    max = (ecode[1] << 8) + ecode[2];\n    minimize = *ecode == OP_TYPEMINUPTO;\n    ecode += 3;\n    goto REPEATTYPE;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    c = *ecode++ - OP_TYPESTAR;\n    minimize = (c & 1) != 0;\n    min = rep_min[c];                 \n    max = rep_max[c];                 \n    if (max == 0) max = INT_MAX;\n\n    \n\n    REPEATTYPE:\n    ctype = *ecode++;      \n\n    /* First, ensure the minimum number of matches are present. Use inline\n    code for maximizing the speed, and do the type test once at the start\n    (i.e. keep it out of the loop). Also we can test that there are at least\n    the minimum number of bytes before we start, except when doing '.' in\n    UTF8 mode. Leave the test in in all cases; in the special case we have\n    to test after each character. */\n\n    if (min > md->end_subject - eptr) return FALSE;\n    if (min > 0) switch(ctype)\n      {\n      case OP_ANY:\n#ifdef SUPPORT_UTF8\n      if (md->utf8)\n        {\n        for (i = 1; i <= min; i++)\n          {\n          if (eptr >= md->end_subject ||\n             (*eptr++ == NEWLINE && (ims & PCRE_DOTALL) == 0))\n            return FALSE;\n          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n          }\n        break;\n        }\n#endif\n      \n      if ((ims & PCRE_DOTALL) == 0)\n        { for (i = 1; i <= min; i++) if (*eptr++ == NEWLINE) return FALSE; }\n      else eptr += min;\n      break;\n\n      case OP_NOT_DIGIT:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_digit) != 0) return FALSE;\n      break;\n\n      case OP_DIGIT:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_digit) == 0) return FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_space) != 0) return FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_space) == 0) return FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_word) != 0)\n          return FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      for (i = 1; i <= min; i++)\n        if ((md->ctypes[*eptr++] & ctype_word) == 0)\n          return FALSE;\n      break;\n      }\n\n    \n\n    if (min == max) continue;\n\n    /* If minimizing, we have to test the rest of the pattern before each\n    subsequent match. */\n\n    if (minimize)\n      {\n      for (i = min;; i++)\n        {\n        if (match(eptr, ecode, offset_top, md, ims, eptrb, 0)) return TRUE;\n        if (i >= max || eptr >= md->end_subject) return FALSE;\n\n        c = *eptr++;\n        switch(ctype)\n          {\n          case OP_ANY:\n          if ((ims & PCRE_DOTALL) == 0 && c == NEWLINE) return FALSE;\n#ifdef SUPPORT_UTF8\n          if (md->utf8)\n            while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n#endif\n          break;\n\n          case OP_NOT_DIGIT:\n          if ((md->ctypes[c] & ctype_digit) != 0) return FALSE;\n          break;\n\n          case OP_DIGIT:\n          if ((md->ctypes[c] & ctype_digit) == 0) return FALSE;\n          break;\n\n          case OP_NOT_WHITESPACE:\n          if ((md->ctypes[c] & ctype_space) != 0) return FALSE;\n          break;\n\n          case OP_WHITESPACE:\n          if  ((md->ctypes[c] & ctype_space) == 0) return FALSE;\n          break;\n\n          case OP_NOT_WORDCHAR:\n          if ((md->ctypes[c] & ctype_word) != 0) return FALSE;\n          break;\n\n          case OP_WORDCHAR:\n          if ((md->ctypes[c] & ctype_word) == 0) return FALSE;\n          break;\n          }\n        }\n      \n      }\n\n    /* If maximizing it is worth using inline code for speed, doing the type\n    test once at the start (i.e. keep it out of the loop). */\n\n    else\n      {\n      const uschar *pp = eptr;\n      switch(ctype)\n        {\n        case OP_ANY:\n\n        /* Special code is required for UTF8, but when the maximum is unlimited\n        we don't need it. */\n\n#ifdef SUPPORT_UTF8\n        if (md->utf8 && max < INT_MAX)\n          {\n          if ((ims & PCRE_DOTALL) == 0)\n            {\n            for (i = min; i < max; i++)\n              {\n              if (eptr >= md->end_subject || *eptr++ == NEWLINE) break;\n              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n              }\n            }\n          else\n            {\n            for (i = min; i < max; i++)\n              {\n              eptr++;\n              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;\n              }\n            }\n          break;\n          }\n#endif\n        \n        if ((ims & PCRE_DOTALL) == 0)\n          {\n          for (i = min; i < max; i++)\n            {\n            if (eptr >= md->end_subject || *eptr == NEWLINE) break;\n            eptr++;\n            }\n          }\n        else\n          {\n          c = max - min;\n          if (c > md->end_subject - eptr) c = md->end_subject - eptr;\n          eptr += c;\n          }\n        break;\n\n        case OP_NOT_DIGIT:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) != 0)\n            break;\n          eptr++;\n          }\n        break;\n\n        case OP_DIGIT:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) == 0)\n            break;\n          eptr++;\n          }\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) != 0)\n            break;\n          eptr++;\n          }\n        break;\n\n        case OP_WHITESPACE:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) == 0)\n            break;\n          eptr++;\n          }\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) != 0)\n            break;\n          eptr++;\n          }\n        break;\n\n        case OP_WORDCHAR:\n        for (i = min; i < max; i++)\n          {\n          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) == 0)\n            break;\n          eptr++;\n          }\n        break;\n        }\n\n      while (eptr >= pp)\n        {\n        if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))\n          return TRUE;\n#ifdef SUPPORT_UTF8\n        if (md->utf8)\n          while (eptr > pp && (*eptr & 0xc0) == 0x80) eptr--;\n#endif\n        }\n      return FALSE;\n      }\n    \n\n    \n\n    default:\n    DPRINTF((\"Unknown opcode %d\\n\", *ecode));\n    md->errorcode = PCRE_ERROR_UNKNOWN_NODE;\n    return FALSE;\n    }\n\n  /* Do not stick any code in here without much thought; it is assumed\n  that \"continue\" in the code above comes out to here to repeat the main\n  loop. */\n\n  }             \n\n}",
    "predicted": ""
  },
  "httpd_b315926b16662765efdcfe216710ce8f082a2a3b_0", {
    "ID": "httpd_b315926b16662765efdcfe216710ce8f082a2a3b_0",
    "UID": "2236",
    "code": "AP_DECLARE(int) ap_count_dirs(const char test_snippet\n{\n    register int x, n;\n\n    for (x = 0, n = 0; path[x]; x++)\n        if (path[x] == '/')\n            n++;\n    return n;\n}",
    "predicted": "457,Use of Uninitialized Variable\n606,Unchecked Input for Loop Condition"
  },
  "httpd_ecba8bf9f8fc2fd6f549356fb5ee35f85bfda3b9_0", {
    "ID": "httpd_ecba8bf9f8fc2fd6f549356fb5ee35f85bfda3b9_0",
    "UID": "2253",
    "code": "static apr_status_t sendfile_it_all(core_net_rec test_snippet\n                                    apr_file_t *fd,\n                                    apr_hdtr_t *hdtr,\n                                    apr_off_t   file_offset,\n                                    apr_size_t  file_bytes_left,\n                                    apr_size_t  total_bytes_left,\n                                    apr_size_t  *bytes_sent,\n                                    apr_int32_t flags)\n{\n    apr_status_t rv;\n#ifdef AP_DEBUG\n    apr_interval_time_t timeout = 0;\n#endif\n\n    AP_DEBUG_ASSERT((apr_socket_timeout_get(c->client_socket, &timeout) \n                         == APR_SUCCESS)\n                    && timeout > 0);  \n\n    \n    *bytes_sent = 0;\n\n    do {\n        apr_size_t tmplen = file_bytes_left;\n\n        rv = apr_socket_sendfile(c->client_socket, fd, hdtr, &file_offset, &tmplen,\n                                 flags);\n        *bytes_sent += tmplen;\n        total_bytes_left -= tmplen;\n        if (!total_bytes_left || rv != APR_SUCCESS) {\n            return rv;        \n        }\n\n        AP_DEBUG_ASSERT(total_bytes_left > 0 && tmplen > 0);\n\n        /* partial write, oooh noooo...\n         * Skip over any header data which was written\n         */\n        while (tmplen && hdtr->numheaders) {\n            if (tmplen >= hdtr->headers[0].iov_len) {\n                tmplen -= hdtr->headers[0].iov_len;\n                --hdtr->numheaders;\n                ++hdtr->headers;\n            }\n            else {\n                char *iov_base = (char *)hdtr->headers[0].iov_base;\n\n                hdtr->headers[0].iov_len -= tmplen;\n                iov_base += tmplen;\n                hdtr->headers[0].iov_base = iov_base;\n                tmplen = 0;\n            }\n        }\n\n        \n\n        if (tmplen <= file_bytes_left) {\n            file_offset += tmplen;\n            file_bytes_left -= tmplen;\n            continue;\n        }\n\n        tmplen -= file_bytes_left;\n        file_bytes_left = 0;\n        file_offset = 0;\n\n        \n\n        while (tmplen && hdtr->numtrailers) {\n            if (tmplen >= hdtr->trailers[0].iov_len) {\n                tmplen -= hdtr->trailers[0].iov_len;\n                --hdtr->numtrailers;\n                ++hdtr->trailers;\n            }\n            else {\n                char *iov_base = (char *)hdtr->trailers[0].iov_base;\n\n                hdtr->trailers[0].iov_len -= tmplen;\n                iov_base += tmplen;\n                hdtr->trailers[0].iov_base = iov_base;\n                tmplen = 0;\n            }\n        }\n    } while (1);\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition"
  },
  "httpd_8a142ddb1cea5bbb49fcce62a4a2427c4088f251_0", {
    "ID": "httpd_8a142ddb1cea5bbb49fcce62a4a2427c4088f251_0",
    "UID": "2255",
    "code": "static char *zap_sp_and_dup(apr_pool_t *p, const char test_snippet\n                            const char *end, apr_size_t *len)\n{\n    while ((start < end) && apr_isspace(*start)) {\n        start++;\n    }\n    while ((end > start) && apr_isspace(*(end - 1))) {\n        end--;\n    }\n    if (len) {\n        *len = end - start;\n    }\n    return apr_pstrmemdup(p, start, end - start);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_dba2bedc847e9497ef348b289d38e7030d083f99_0", {
    "ID": "httpd_dba2bedc847e9497ef348b289d38e7030d083f99_0",
    "UID": "2257",
    "code": "static void decodehtml(char test_snippet\n{\n    int val, i, j;\n    char *p;\n    const char *ents;\n    static const char * const entlist[MAXENTLEN + 1] =\n    {\n        NULL,                     \n        NULL,                     \n        \"lt\\074gt\\076\",           \n        \"amp\\046ETH\\320eth\\360\",  \n        \"quot\\042Auml\\304Euml\\313Iuml\\317Ouml\\326Uuml\\334auml\\344euml\"\n        \"\\353iuml\\357ouml\\366uuml\\374yuml\\377\",                         \n\n        \"Acirc\\302Aring\\305AElig\\306Ecirc\\312Icirc\\316Ocirc\\324Ucirc\"\n        \"\\333THORN\\336szlig\\337acirc\\342aring\\345aelig\\346ecirc\\352\"\n        \"icirc\\356ocirc\\364ucirc\\373thorn\\376\",                         \n\n        \"Agrave\\300Aacute\\301Atilde\\303Ccedil\\307Egrave\\310Eacute\\311\"\n        \"Igrave\\314Iacute\\315Ntilde\\321Ograve\\322Oacute\\323Otilde\"\n        \"\\325Oslash\\330Ugrave\\331Uacute\\332Yacute\\335agrave\\340\"\n        \"aacute\\341atilde\\343ccedil\\347egrave\\350eacute\\351igrave\"\n        \"\\354iacute\\355ntilde\\361ograve\\362oacute\\363otilde\\365\"\n        \"oslash\\370ugrave\\371uacute\\372yacute\\375\"                      \n    };\n\n    /* Do a fast scan through the string until we find anything\n     * that needs more complicated handling\n     */\n    for (; *s != '&'; s++) {\n        if (*s == '\\0') {\n            return;\n        }\n    }\n\n    for (p = s; *s != '\\0'; s++, p++) {\n        if (*s != '&') {\n            *p = *s;\n            continue;\n        }\n        \n        for (i = 1; s[i] != ';' && s[i] != '\\0'; i++) {\n            continue;\n        }\n\n        if (s[i] == '\\0') {     \n            *p = *s;\n            continue;\n        }\n\n        \n        if (s[1] == '#') {\n            for (j = 2, val = 0; j < i && apr_isdigit(s[j]); j++) {\n                val = val * 10 + s[j] - '0';\n            }\n            s += i;\n            if (j < i || val <= 8 || (val >= 11 && val <= 31) ||\n                (val >= 127 && val <= 160) || val >= 256) {\n                p--;            \n            }\n            else {\n                *p = RAW_ASCII_CHAR(val);\n            }\n        }\n        else {\n            j = i - 1;\n            if (j > MAXENTLEN || entlist[j] == NULL) {\n                \n                *p = '&';\n                continue;       \n            }\n            for (ents = entlist[j]; *ents != '\\0'; ents += i) {\n                if (strncmp(s + 1, ents, j) == 0) {\n                    break;\n                }\n            }\n\n            if (*ents == '\\0') {\n                *p = '&';       \n            }\n            else {\n                *p = RAW_ASCII_CHAR(((const unsigned char *) ents)[j]);\n                s += i;\n            }\n        }\n    }\n\n    *p = '\\0';\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n190,Integer Overflow or Wraparound\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_aa464de7fa913f646db5a7d02feb11d779e1eb87_0", {
    "ID": "httpd_aa464de7fa913f646db5a7d02feb11d779e1eb87_0",
    "UID": "2263",
    "code": "static apr_status_t default_build_command(const char **cmd, const char test_snippet\n                                          request_rec *r, apr_pool_t *p,\n                                          cgi_exec_info_t *e_info)\n{\n    int numwords, x, idx;\n    char *w;\n    const char *args = NULL;\n\n    if (e_info->process_cgi) {\n        *cmd = r->filename;\n        /* Do not process r->args if they contain an '=' assignment \n         */\n        if (r->args && r->args[0] && !ap_strchr_c(r->args, '=')) {\n            args = r->args;\n        }\n    }\n\n    if (!args) {\n        numwords = 1;\n    }\n    else {\n        \n        for (x = 0, numwords = 2; args[x]; x++) {\n            if (args[x] == '+') {\n                ++numwords;\n            }\n        }\n    }\n    /* Everything is - 1 to account for the first parameter \n     * which is the program name.\n     */ \n    if (numwords > APACHE_ARG_MAX - 1) {\n        numwords = APACHE_ARG_MAX - 1;    \n    }\n    *argv = apr_palloc(p, (numwords + 2) * sizeof(char *));\n    (*argv)[0] = *cmd;\n    for (x = 1, idx = 1; x < numwords; x++) {\n        w = ap_getword_nulls(p, &args, '+');\n        ap_unescape_url(w);\n        (*argv)[idx++] = ap_escape_shell_cmd(p, w);\n    }\n    (*argv)[idx] = NULL;\n\n    return APR_SUCCESS;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_c20b7f286fba5cea571177905d1bf2ac4ba0246e_0", {
    "ID": "httpd_c20b7f286fba5cea571177905d1bf2ac4ba0246e_0",
    "UID": "2272",
    "code": "static int is_token(char test_snippet\n{\n    int res;\n\n    res = (apr_isascii(test_snippet && apr_isgraph(test_snippet\n           && (strchr(tspecial, test_snippet == NULL)) ? 1 : -1;\n    return res;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable"
  },
  "httpd_9bf0ba779e9172498dfbb94e323eb5eafed1bbb0_0", {
    "ID": "httpd_9bf0ba779e9172498dfbb94e323eb5eafed1bbb0_0",
    "UID": "2286",
    "code": "AP_CORE_DECLARE(void) ap_add_per_dir_conf(server_rec *s, void test_snippet\n{\n    core_server_config *sconf = ap_get_module_config(s->module_config,\n                                                     &core_module);\n    void **new_space = (void **)apr_array_push(sconf->sec_dir);\n\n    *new_space = dir_config;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_acfd0e09a97ff085c0476371f6f13b1214fc3430_0", {
    "ID": "httpd_acfd0e09a97ff085c0476371f6f13b1214fc3430_0",
    "UID": "2300",
    "code": "AP_CORE_DECLARE(void) ap_add_per_url_conf(server_rec *s, void test_snippet\n{\n    core_server_config *sconf = ap_get_module_config(s->module_config,\n                                                     &core_module);\n    void **new_space = (void **)apr_array_push(sconf->sec_url);\n\n    *new_space = url_config;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_f3b5a366b63395a5e9d14a028ee78a017a6bcf8d_0", {
    "ID": "httpd_f3b5a366b63395a5e9d14a028ee78a017a6bcf8d_0",
    "UID": "2304",
    "code": "AP_CORE_DECLARE(void) ap_add_file_conf(core_dir_config *conf, void test_snippet\n{\n    void **new_space = (void **)apr_array_push(conf->sec_file);\n\n    *new_space = url_config;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_849eb726b7671245d43b959651922566569f4464_0", {
    "ID": "httpd_849eb726b7671245d43b959651922566569f4464_0",
    "UID": "2305",
    "code": "AP_DECLARE(const char *) ap_add_module(module *m, apr_pool_t test_snippet\n{\n    /* This could be called from a LoadModule httpd.conf command,\n     * after the file has been linked and the module structure within it\n     * teased out...\n     */\n\n    if (m->version != MODULE_MAGIC_NUMBER_MAJOR) {\n        return apr_psprintf(p, \"Module \\\"%s\\\" is not compatible with this \"\n                            \"version of Apache (found %d, need %d). Please \"\n                            \"contact the vendor for the correct version.\",\n                            m->name, m->version, MODULE_MAGIC_NUMBER_MAJOR);\n    }\n\n    if (m->next == NULL) {\n        m->next = ap_top_module;\n        ap_top_module = m;\n    }\n\n    if (m->module_index == -1) {\n        m->module_index = total_modules++;\n        dynamic_modules++;\n\n        if (dynamic_modules > DYNAMIC_MODULE_LIMIT) {\n            return apr_psprintf(p, \"Module \\\"%s\\\" could not be loaded, \"\n                                \"because the dynamic module limit was \"\n                                \"reached. Please increase \"\n                                \"DYNAMIC_MODULE_LIMIT and recompile.\", m->name);\n        }\n    }\n\n    /* Some C compilers put a complete path into __FILE__, but we want\n     * only the filename (e.g. mod_includes.c). So check for path\n     * components (Unix and DOS), and remove them.\n     */\n\n    if (ap_strrchr_c(m->name, '/'))\n        m->name = 1 + ap_strrchr_c(m->name, '/');\n\n    if (ap_strrchr_c(m->name, '\\\\'))\n        m->name = 1 + ap_strrchr_c(m->name, '\\\\');\n\n#ifdef _OSD_POSIX\n    /* __FILE__ =\n     * \"*POSIX(/home/martin/apache/src/modules/standard/mod_info.c)\"\n     */\n\n    \n    if (m->name[strlen(m->name)-1] == ')') {\n        char *tmp = strdup(m->name); \n        tmp[strlen(tmp)-1] = '\\0';\n        m->name = tmp;\n    }\n#endif \n\n    /*  FIXME: is this the right place to call this?\n     *  It doesn't appear to be\n     */\n    ap_register_hooks(m, p);\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n762,Mismatched Memory Management Routines"
  },
  "httpd_1c72e4d1ed6153aa2d1cde4a9ceb47fdc2b710dc_0", {
    "ID": "httpd_1c72e4d1ed6153aa2d1cde4a9ceb47fdc2b710dc_0",
    "UID": "2308",
    "code": "static content_type *analyze_ct(request_rec *r, const char test_snippet\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    \n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    \n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; \n\n    \n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    \n    cp++; \n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_136d21163e430be52b8d7a6c3e8bf4163c6de89b_0", {
    "ID": "httpd_136d21163e430be52b8d7a6c3e8bf4163c6de89b_0",
    "UID": "2312",
    "code": "static apr_array_header_t *do_languages_line(apr_pool_t test_snippet\n                                             const char **lang_line)\n{\n    apr_array_header_t *lang_recs = apr_array_make(p, 2, sizeof(char *));\n\n    if (!lang_line) {\n        return lang_recs;\n    }\n\n    while (**lang_line) {\n        char **new = (char **) apr_array_push(lang_recs);\n        *new = ap_get_token(p, lang_line, 0);\n        ap_str_tolower(*new);\n        if (**lang_line == ',' || **lang_line == ';') {\n            ++(*lang_line);\n        }\n    }\n\n    return lang_recs;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_dac2786f4e10c6b50677012b58f7b43cbb1deff3_0", {
    "ID": "httpd_dac2786f4e10c6b50677012b58f7b43cbb1deff3_0",
    "UID": "2316",
    "code": "AP_DECLARE(void) ap_remove_module(module test_snippet\n{\n    module *modp;\n\n    modp = ap_top_module;\n    if (modp == m) {\n        \n        ap_top_module = modp->next;\n        m->next = NULL;\n    }\n    else {\n        /* Not the top module, find use. When found modp will\n         * point to the module _before_ us in the list\n         */\n\n        while (modp && modp->next != m) {\n            modp = modp->next;\n        }\n\n        if (!modp) {\n            \n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,\n                         \"Cannot remove module %s: not found in module list\",\n                         m->name);\n            return;\n        }\n\n        \n        modp->next = modp->next->next;\n    }\n\n    m->module_index = -1; /* simulate being unloaded, should\n                           * be unnecessary */\n    dynamic_modules--;\n    total_modules--;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_b4e6f9987834a48fd96fa98752ba3c5c0d186910_0", {
    "ID": "httpd_b4e6f9987834a48fd96fa98752ba3c5c0d186910_0",
    "UID": "2322",
    "code": "static negotiation_state *parse_accept_headers(request_rec test_snippet\n{\n    negotiation_state *new =\n        (negotiation_state *) apr_pcalloc(r->pool, sizeof(negotiation_state));\n    accept_rec *elts;\n    apr_table_t *hdrs = r->headers_in;\n    int i;\n\n    new->pool = r->pool;\n    new->r = r;\n    new->conf = (neg_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                       &negotiation_module);\n\n    new->dir_name = ap_make_dirstr_parent(r->pool, r->filename);\n\n    new->accepts = do_header_line(r->pool, apr_table_get(hdrs, \"Accept\"));\n\n    \n    if (new->accepts) {\n        elts = (accept_rec *) new->accepts->elts;\n\n        for (i = 0; i < new->accepts->nelts; ++i) {\n            if (elts[i].quality < 1.0) {\n                new->accept_q = 1;\n            }\n        }\n    }\n\n    new->accept_encodings =\n        do_header_line(r->pool, apr_table_get(hdrs, \"Accept-Encoding\"));\n    new->accept_langs =\n        do_header_line(r->pool, apr_table_get(hdrs, \"Accept-Language\"));\n    new->accept_charsets =\n        do_header_line(r->pool, apr_table_get(hdrs, \"Accept-Charset\"));\n\n    /* This is possibly overkill for some servers, heck, we have\n     * only 33 index.html variants in docs/docroot (today).\n     * Make this configurable?\n     */\n    new->avail_vars = apr_array_make(r->pool, 40, sizeof(var_rec));\n\n    return new;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f1eadb758c2736ff2b8aa160a506087410f1e725_0", {
    "ID": "httpd_f1eadb758c2736ff2b8aa160a506087410f1e725_0",
    "UID": "2328",
    "code": "static int imap_handler_internal(request_rec test_snippet\n{\n    char input[MAX_STRING_LEN];\n    char *directive;\n    char *value;\n    char *href_text;\n    char *base;\n    char *redirect;\n    char *mapdflt;\n    char *closest = NULL;\n    double closest_yet = -1;\n    apr_status_t status;\n\n    double testpoint[2];\n    double pointarray[MAXVERTS + 1][2];\n    int vertex;\n\n    char *string_pos;\n    int showmenu = 0;\n\n    imap_conf_rec *icr;\n\n    char *imap_menu;\n    char *imap_default;\n    char *imap_base;\n\n    ap_configfile_t *imap; \n\n    icr = ap_get_module_config(r->per_dir_config, &imap_module);\n\n    imap_menu = icr->imap_menu ? icr->imap_menu : IMAP_MENU_DEFAULT;\n    imap_default = icr->imap_default\n      ?  icr->imap_default : IMAP_DEFAULT_DEFAULT;\n    imap_base = icr->imap_base ? icr->imap_base : IMAP_BASE_DEFAULT;\n\n    status = ap_pcfg_openfile(&imap, r->pool, r->filename);\n\n    if (status != APR_SUCCESS) {\n        return HTTP_NOT_FOUND;\n    }\n\n    base = imap_url(r, NULL, imap_base);         /* set base according\n                                                    to default */\n    if (!base) {\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n    }\n    mapdflt = imap_url(r, NULL, imap_default);   /* and default to\n                                                    global default */\n    if (!mapdflt) {\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    testpoint[X] = get_x_coord(r->args);\n    testpoint[Y] = get_y_coord(r->args);\n\n    if ((testpoint[X] == -1 || testpoint[Y] == -1) ||\n        (testpoint[X] == 0 && testpoint[Y] == 0)) {\n        \n        \n        testpoint[X] = -1;\n        testpoint[Y] = -1;\n        if (strncasecmp(imap_menu, \"none\", 2)) {\n            showmenu = 1;       /* show the menu _unless_ ImapMenu is\n                                   'none' or 'no' */\n\t}\n    }\n\n    if (showmenu) {             /* send start of imagemap menu if\n                                   we're going to */\n        menu_header(r, imap_menu);\n    }\n\n    while (!ap_cfg_getline(input, sizeof(input), imap)) {\n        if (!input[0]) {\n            if (showmenu) {\n                menu_blank(r, imap_menu);\n            }\n            continue;\n        }\n\n        if (input[0] == '#') {\n            if (showmenu) {\n                menu_comment(r, imap_menu, input + 1);\n            }\n            continue;\n        }                       /* blank lines and comments are ignored\n                                   if we aren't printing a menu */\n\n\t/* find the first two space delimited fields, recall that\n\t * ap_cfg_getline has removed leading/trailing whitespace.\n\t *\n\t * note that we're tokenizing as we go... if we were to use the\n\t * ap_getword() class of functions we would end up allocating extra\n\t * memory for every line of the map file\n\t */\n        string_pos = input;\n\tif (!*string_pos) {\t\t\n\t    goto need_2_fields;\n\t}\n\n\tdirective = string_pos;\n\twhile (*string_pos && !apr_isspace(*string_pos)) {\t\n\t    ++string_pos;\n\t}\n\tif (!*string_pos) {\t\t\n\t    goto need_2_fields;\n\t}\n\t*string_pos++ = '\\0';\n\n\tif (!*string_pos) {\t\t\n\t    goto need_2_fields;\n\t}\n\twhile(*string_pos && apr_isspace(*string_pos)) { \n\t    ++string_pos;\n\t}\n\n\tvalue = string_pos;\n\twhile (*string_pos && !apr_isspace(*string_pos)) {\t\n\t    ++string_pos;\n\t}\n\tif (apr_isspace(*string_pos)) {\n\t    *string_pos++ = '\\0';\n\t}\n\telse {\n\t    \n\t    *string_pos = '\\0';\n\t}\n\n        if (!strncasecmp(directive, \"base\", 4)) {       \n            base = imap_url(r, NULL, value);\n\t    if (!base) {\n\t\tgoto menu_bail;\n\t    }\n            continue;           \n        }\n\n        read_quoted(&string_pos, &href_text);\n\n        if (!strcasecmp(directive, \"default\")) {        \n            mapdflt = imap_url(r, NULL, value);\n\t    if (!mapdflt) {\n\t\tgoto menu_bail;\n\t    }\n            if (showmenu) {     \n                redirect = imap_url(r, base, mapdflt);\n\t\tif (!redirect) {\n\t\t    goto menu_bail;\n\t\t}\n                menu_default(r, imap_menu, redirect,\n                             href_text ? href_text : mapdflt);\n            }\n            continue;\n        }\n\n        vertex = 0;\n        while (vertex < MAXVERTS &&\n               sscanf(string_pos, \"%lf%*[, ]%lf\",\n                      &pointarray[vertex][X], &pointarray[vertex][Y]) == 2) {\n            \n            while (apr_isspace(*string_pos)) {      \n                string_pos++;\n\t    }\n            while (apr_isdigit(*string_pos)) {      \n                string_pos++;\n\t    }\n            string_pos++;       \n            while (apr_isspace(*string_pos)) {      \n                string_pos++;\n\t    }\n            while (apr_isdigit(*string_pos)) {      \n                string_pos++;\n\t    }\n            vertex++;\n        }                       /* so long as there are more vertices to\n                                   read, and we have room, read them in.\n                                   We start where we left off of the last\n                                   sscanf, not at the beginning. */\n\n        pointarray[vertex][X] = -1;     \n\n        if (showmenu) {\n\t    if (!href_text) {\n\t\tread_quoted(&string_pos, &href_text);     /* href text could\n                                                             be here instead */\n\t    }\n            redirect = imap_url(r, base, value);\n\t    if (!redirect) {\n\t\tgoto menu_bail;\n\t    }\n            menu_directive(r, imap_menu, redirect,\n                           href_text ? href_text : value);\n            continue;\n        }\n        \n\n        if (testpoint[X] == -1 || pointarray[0][X] == -1) {\n            continue;           /* don't try the following tests if testpoints\n                                   are invalid, or if there are no\n                                   coordinates */\n\t}\n\n        if (!strcasecmp(directive, \"poly\")) {   \n\n            if (pointinpoly(testpoint, pointarray)) {\n\t\tap_cfg_closefile(imap);\n                redirect = imap_url(r, base, value);\n\t\tif (!redirect) {\n\t\t    return HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n                return (imap_reply(r, redirect));\n            }\n            continue;\n        }\n\n        if (!strcasecmp(directive, \"circle\")) {         \n\n            if (pointincircle(testpoint, pointarray)) {\n\t\tap_cfg_closefile(imap);\n                redirect = imap_url(r, base, value);\n\t\tif (!redirect) {\n\t\t    return HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n                return (imap_reply(r, redirect));\n            }\n            continue;\n        }\n\n        if (!strcasecmp(directive, \"rect\")) {   \n\n            if (pointinrect(testpoint, pointarray)) {\n\t\tap_cfg_closefile(imap);\n                redirect = imap_url(r, base, value);\n\t\tif (!redirect) {\n\t\t    return HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n                return (imap_reply(r, redirect));\n            }\n            continue;\n        }\n\n        if (!strcasecmp(directive, \"point\")) {  \n\n            if (is_closer(testpoint, pointarray, &closest_yet)) {\n\t\tclosest = apr_pstrdup(r->pool, value);\n            }\n\n            continue;\n        }                       /* move on to next line whether it's\n                                   closest or not */\n\n    }                           \n\n    ap_cfg_closefile(imap);        \n\n    if (showmenu) {\n        menu_footer(r);         \n        return OK;\n    }\n\n    if (closest) {             \n        redirect = imap_url(r, base, closest);\n\tif (!redirect) {\n\t    return HTTP_INTERNAL_SERVER_ERROR;\n\t}\n        return (imap_reply(r, redirect));\n    }\n\n    if (mapdflt) {             /* a default should be defined, even if\n                                  only 'nocontent' */\n        redirect = imap_url(r, base, mapdflt);\n\tif (!redirect) {\n\t    return HTTP_INTERNAL_SERVER_ERROR;\n\t}\n        return (imap_reply(r, redirect));\n    }\n\n    return HTTP_INTERNAL_SERVER_ERROR;        /* If we make it this far,\n                                                 we failed. They lose! */\n\nneed_2_fields:\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n\t\t\"map file %s, line %d syntax error: requires at \"\n                \"least two fields\", r->uri, imap->line_number);\n    \nmenu_bail:\n    ap_cfg_closefile(imap);\n    if (showmenu) {\n\t/* There's not much else we can do ... we've already sent the headers\n\t * to the client.\n\t */\n\tap_rputs(\"\\n\\n[an internal server error occured]\\n\", r);\n\tmenu_footer(r);\n\treturn OK;\n    }\n    return HTTP_INTERNAL_SERVER_ERROR;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_3b814986ed358dc66e2b788ab35d8adf2251fdf4_0", {
    "ID": "httpd_3b814986ed358dc66e2b788ab35d8adf2251fdf4_0",
    "UID": "2330",
    "code": "void ap_core_reorder_directories(apr_pool_t *p, server_rec test_snippet\n{\n    core_server_config *sconf;\n    apr_array_header_t *sec_dir;\n    struct reorder_sort_rec *sortbin;\n    int nelts;\n    ap_conf_vector_t **elts;\n    int i;\n    apr_pool_t *tmp;\n\n    sconf = ap_get_module_config(s->module_config, &core_module);\n    sec_dir = sconf->sec_dir;\n    nelts = sec_dir->nelts;\n    elts = (ap_conf_vector_t **)sec_dir->elts;\n\n    if (!nelts) {\n        \n        /* We're not checking this condition to be fast... we're checking\n         * it to avoid trying to palloc zero bytes, which can trigger some\n         * memory debuggers to barf\n         */\n        return;\n    }\n\n    \n    apr_pool_create(&tmp, p);\n    sortbin = apr_palloc(tmp, sec_dir->nelts * sizeof(*sortbin));\n    for (i = 0; i < nelts; ++i) {\n        sortbin[i].orig_index = i;\n        sortbin[i].elt = elts[i];\n    }\n\n    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);\n\n    \n    for (i = 0; i < nelts; ++i) {\n        elts[i] = sortbin[i].elt;\n    }\n\n    apr_pool_destroy(tmp);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0280057f6b9aa99bc228fc51826980327af7e6d7_0", {
    "ID": "httpd_0280057f6b9aa99bc228fc51826980327af7e6d7_0",
    "UID": "2333",
    "code": "static apr_bucket *cgi_bucket_create(request_rec test_snippet\n                                     apr_file_t *out, apr_file_t *err,\n                                     apr_bucket_alloc_t *list)\n{\n    apr_bucket *b = apr_bucket_alloc(sizeof(*b), list);\n    apr_status_t rv;\n    apr_pollfd_t fd;\n    struct cgi_bucket_data *data = apr_palloc(r->pool, sizeof *data);\n    \n    APR_BUCKET_INIT(b);\n    b->free = apr_bucket_free;\n    b->list = list;\n    b->type = &bucket_type_cgi;\n    b->length = (apr_size_t)(-1);\n    b->start = -1;\n\n    \n    rv = apr_pollset_create(&data->pollset, 2, r->pool, 0);\n    AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n\n    fd.desc_type = APR_POLL_FILE;\n    fd.reqevents = APR_POLLIN;\n    fd.p = r->pool;\n    fd.desc.f = out; \n    fd.client_data = (void *)1;\n    rv = apr_pollset_add(data->pollset, &fd);\n    AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n    \n    fd.desc.f = err; \n    fd.client_data = (void *)2;\n    rv = apr_pollset_add(data->pollset, &fd);\n    AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n    \n    data->r = r;\n    b->data = data;\n    return b;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_46fa244a61c1f202ea2f9698c43059599d3c4e70_0", {
    "ID": "httpd_46fa244a61c1f202ea2f9698c43059599d3c4e70_0",
    "UID": "2339",
    "code": "static void add_include_vars(request_rec *r, const char test_snippet\n{\n    apr_table_t *e = r->subprocess_env;\n    char *t;\n\n    apr_table_setn(e, \"DATE_LOCAL\", LAZY_VALUE);\n    apr_table_setn(e, \"DATE_GMT\", LAZY_VALUE);\n    apr_table_setn(e, \"LAST_MODIFIED\", LAZY_VALUE);\n    apr_table_setn(e, \"DOCUMENT_URI\", r->uri);\n    if (r->path_info && *r->path_info) {\n        apr_table_setn(e, \"DOCUMENT_PATH_INFO\", r->path_info);\n    }\n    apr_table_setn(e, \"USER_NAME\", LAZY_VALUE);\n    if (r->filename && (t = strrchr(r->filename, '/'))) {\n        apr_table_setn(e, \"DOCUMENT_NAME\", ++t);\n    }\n    else {\n        apr_table_setn(e, \"DOCUMENT_NAME\", r->uri);\n    }\n    if (r->args) {\n        char *arg_copy = apr_pstrdup(r->pool, r->args);\n\n        ap_unescape_url(arg_copy);\n        apr_table_setn(e, \"QUERY_STRING_UNESCAPED\",\n                  ap_escape_shell_cmd(r->pool, arg_copy));\n    }\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_f81bdc052c190510e38b137a406ec9777bc5b354_0", {
    "ID": "httpd_f81bdc052c190510e38b137a406ec9777bc5b354_0",
    "UID": "2342",
    "code": "AP_DECLARE(const char *) ap_setup_prelinked_modules(process_rec test_snippet\n{\n    module **m;\n    module **m2;\n    const char *error;\n\n    apr_hook_global_pool=process->pconf;\n\n    /*\n     *  Initialise total_modules variable and module indices\n     */\n    total_modules = 0;\n    for (m = ap_preloaded_modules; *m != NULL; m++)\n        (*m)->module_index = total_modules++;\n\n    /*\n     *  Initialise list of loaded modules\n     */\n    ap_loaded_modules = (module **)apr_palloc(process->pool,\n        sizeof(module *) * (total_modules + DYNAMIC_MODULE_LIMIT + 1));\n\n    if (ap_loaded_modules == NULL) {\n        return \"Ouch! Out of memory in ap_setup_prelinked_modules()!\";\n    }\n\n    for (m = ap_preloaded_modules, m2 = ap_loaded_modules; *m != NULL; )\n        *m2++ = *m++;\n\n    *m2 = NULL;\n\n    /*\n     *   Initialize chain of linked (=activate) modules\n     */\n    for (m = ap_prelinked_modules; *m != NULL; m++) {\n        error = ap_add_module(*m, process->pconf);\n        if (error) {\n            return error;\n        }\n    }\n\n    apr_hook_sort_all();\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_0d81ef7b1c43603cb91e3f1cf703f849e1c9a652_0", {
    "ID": "httpd_0d81ef7b1c43603cb91e3f1cf703f849e1c9a652_0",
    "UID": "2348",
    "code": "static int uniq_field_values(void *d, const char *key, const char test_snippet\n{\n    apr_array_header_t *values;\n    char *start;\n    char *e;\n    char **strpp;\n    int  i;\n\n    values = (apr_array_header_t *)d;\n\n    e = apr_pstrdup(values->pool, val);\n\n    do {\n        \n\n        while (*e == ',' || apr_isspace(*e)) {\n            ++e;\n        }\n        if (*e == '\\0') {\n            break;\n        }\n        start = e;\n        while (*e != '\\0' && *e != ',' && !apr_isspace(*e)) {\n            ++e;\n        }\n        if (*e != '\\0') {\n            *e++ = '\\0';\n        }\n\n        /* Now add it to values if it isn't already represented.\n         * Could be replaced by a ap_array_strcasecmp() if we had one.\n         */\n        for (i = 0, strpp = (char **) values->elts; i < values->nelts;\n             ++i, ++strpp) {\n            if (*strpp && strcasecmp(*strpp, start) == 0) {\n                break;\n            }\n        }\n        if (i == values->nelts) {  \n            *(char **)apr_array_push(values) = start;\n        }\n    } while (*e != '\\0');\n\n    return 1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_863a2e339611d4dffea72d95cf9d06cdd7340aa6_0", {
    "ID": "httpd_863a2e339611d4dffea72d95cf9d06cdd7340aa6_0",
    "UID": "2349",
    "code": "static void parse_negotiate_header(request_rec *r, negotiation_state test_snippet\n{\n    const char *negotiate = apr_table_get(r->headers_in, \"Negotiate\");\n    char *tok;\n\n    /* First, default to no TCN, no Alternates, and the original Apache\n     * negotiation algorithm with fiddles for broken browser configs.\n     *\n     * To save network bandwidth, we do not configure to send an\n     * Alternates header to the user agent by default.  User\n     * agents that want an Alternates header for agent-driven\n     * negotiation will have to request it by sending an\n     * appropriate Negotiate header.\n     */\n    neg->ua_supports_trans   = 0;\n    neg->send_alternates     = 0;\n    neg->may_choose          = 1;\n    neg->use_rvsa            = 0;\n    neg->dont_fiddle_headers = 0;\n\n    if (!negotiate)\n        return;\n\n    if (strcmp(negotiate, \"trans\") == 0) {\n        /* Lynx 2.7 and 2.8 send 'negotiate: trans' even though they\n         * do not support transparent content negotiation, so for Lynx we\n         * ignore the negotiate header when its contents are exactly \"trans\".\n         * If future versions of Lynx ever need to say 'negotiate: trans',\n         * they can send the equivalent 'negotiate: trans, trans' instead\n         * to avoid triggering the workaround below.\n         */\n        const char *ua = apr_table_get(r->headers_in, \"User-Agent\");\n\n        if (ua && (strncmp(ua, \"Lynx\", 4) == 0))\n            return;\n    }\n\n    neg->may_choose = 0;  \n\n    while ((tok = ap_get_list_item(neg->pool, &negotiate)) != NULL) {\n\n        if (strcmp(tok, \"trans\") == 0 ||\n            strcmp(tok, \"vlist\") == 0 ||\n            strcmp(tok, \"guess-small\") == 0 ||\n            apr_isdigit(tok[0]) ||\n            strcmp(tok, \"*\") == 0) {\n\n            \n            neg->ua_supports_trans = 1;\n\n            /* Send-alternates could be configurable, but note\n             * that it must be 1 if we have 'vlist' in the\n             * negotiate header.\n             */\n            neg->send_alternates = 1;\n\n            if (strcmp(tok, \"1.0\") == 0) {\n                \n                neg->may_choose = 1;\n                neg->use_rvsa = 1;\n                neg->dont_fiddle_headers = 1;\n            }\n            else if (tok[0] == '*') {\n                /* we may use any variant selection algorithm, configure\n                 * to use the Apache algorithm\n                 */\n                neg->may_choose = 1;\n\n                /* We disable header fiddles on the assumption that a\n                 * client sending Negotiate knows how to send correct\n                 * headers which don't need fiddling.\n                 */\n                neg->dont_fiddle_headers = 1;\n            }\n        }\n    }\n\n#ifdef NEG_DEBUG\n    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n            \"dont_fiddle_headers=%d use_rvsa=%d ua_supports_trans=%d \"\n            \"send_alternates=%d, may_choose=%d\",\n            neg->dont_fiddle_headers, neg->use_rvsa,\n            neg->ua_supports_trans, neg->send_alternates, neg->may_choose);\n#endif\n\n}",
    "predicted": "The code provided does not seem to have any obvious vulnerabilities based on the categories provided. Therefore, the response is null."
  },
  "httpd_c647b1b6382cf2d0efe1b31b73ff8ab9040664ad_0", {
    "ID": "httpd_c647b1b6382cf2d0efe1b31b73ff8ab9040664ad_0",
    "UID": "2354",
    "code": "static const char *log_request_duration(request_rec *r, char test_snippet\n{\n    apr_time_t duration = apr_time_now() - r->request_time;\n    return apr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, apr_time_sec(duration));\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_87bfcabb76b03d6e4dc209ed7e606deab5ced474_0", {
    "ID": "httpd_87bfcabb76b03d6e4dc209ed7e606deab5ced474_0",
    "UID": "2357",
    "code": "static const char *get_include_var(const char *var, include_ctx_t test_snippet\n{\n    const char *val;\n    request_rec *r = ctx->intern->r;\n\n    if (apr_isdigit(*var) && !var[1]) {\n        apr_size_t idx = *var - '0';\n        backref_t *re = ctx->intern->re;\n\n        /* Handle $0 .. $9 from the last regex evaluated.\n         * The choice of returning NULL strings on not-found,\n         * v.s. empty strings on an empty match is deliberate.\n         */\n        if (!re) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                \"regex capture $%\" APR_SIZE_T_FMT \" refers to no regex in %s\",\n                idx, r->filename);\n            return NULL;\n        }\n        else {\n            if (re->nsub < idx || idx >= AP_MAX_REG_MATCH) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                              \"regex capture $%\" APR_SIZE_T_FMT\n                              \" is out of range (last regex was: '%s') in %s\",\n                              idx, re->rexp, r->filename);\n                return NULL;\n            }\n\n            if (re->match[idx].rm_so < 0 || re->match[idx].rm_eo < 0) {\n                return NULL;\n            }\n\n            val = apr_pstrmemdup(ctx->dpool, re->source + re->match[idx].rm_so,\n                                 re->match[idx].rm_eo - re->match[idx].rm_so);\n        }\n    }\n    else {\n        val = apr_table_get(r->subprocess_env, var);\n\n        if (val == LAZY_VALUE) {\n            val = add_include_vars_lazy(r, var);\n        }\n    }\n\n    return val;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c596ff18a739d4e6179f0e21ee52a1017d518222_0", {
    "ID": "httpd_c596ff18a739d4e6179f0e21ee52a1017d518222_0",
    "UID": "2365",
    "code": "static const char *invoke_cmd(const command_rec *cmd, cmd_parms test_snippet\n                              void *mconfig, const char *args)\n{\n    char *w, *w2, *w3;\n    const char *errmsg = NULL;\n\n    if ((parms->override & cmd->req_override) == 0)\n        return apr_pstrcat(parms->pool, cmd->name, \" not allowed here\", NULL);\n\n    parms->info = cmd->cmd_data;\n    parms->cmd = cmd;\n\n    switch (cmd->args_how) {\n    case RAW_ARGS:\n#ifdef RESOLVE_ENV_PER_TOKEN\n        args = ap_resolve_env(parms->pool,args);\n#endif\n        return cmd->AP_RAW_ARGS(parms, mconfig, args);\n\n    case NO_ARGS:\n        if (*args != 0)\n            return apr_pstrcat(parms->pool, cmd->name, \" takes no arguments\",\n                               NULL);\n\n        return cmd->AP_NO_ARGS(parms, mconfig);\n\n    case TAKE1:\n        w = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name, \" takes one argument\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE1(parms, mconfig, w);\n\n    case TAKE2:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || *w2 == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name, \" takes two arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE2(parms, mconfig, w, w2);\n\n    case TAKE12:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name, \" takes 1-2 arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE2(parms, mconfig, w, *w2 ? w2 : NULL);\n\n    case TAKE3:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = ap_getword_conf(parms->pool, &args);\n        w3 = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || *w2 == '\\0' || *w3 == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name, \" takes three arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE3(parms, mconfig, w, w2, w3);\n\n    case TAKE23:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = ap_getword_conf(parms->pool, &args);\n        w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;\n\n        if (*w == '\\0' || *w2 == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name,\n                               \" takes two or three arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE3(parms, mconfig, w, w2, w3);\n\n    case TAKE123:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;\n        w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;\n\n        if (*w == '\\0' || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name,\n                               \" takes one, two or three arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE3(parms, mconfig, w, w2, w3);\n\n    case TAKE13:\n        w = ap_getword_conf(parms->pool, &args);\n        w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;\n        w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;\n\n        if (*w == '\\0' || (w2 && *w2 && !w3) || *args != 0)\n            return apr_pstrcat(parms->pool, cmd->name,\n                               \" takes one or three arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        return cmd->AP_TAKE3(parms, mconfig, w, w2, w3);\n\n    case ITERATE:\n        while (*(w = ap_getword_conf(parms->pool, &args)) != '\\0') {\n\n            errmsg = cmd->AP_TAKE1(parms, mconfig, w);\n\n            if (errmsg && strcmp(errmsg, DECLINE_CMD) != 0)\n                return errmsg;\n        }\n\n        return errmsg;\n\n    case ITERATE2:\n        w = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || *args == 0)\n            return apr_pstrcat(parms->pool, cmd->name,\n                               \" requires at least two arguments\",\n                               cmd->errmsg ? \", \" : NULL, cmd->errmsg, NULL);\n\n        while (*(w2 = ap_getword_conf(parms->pool, &args)) != '\\0') {\n\n            errmsg = cmd->AP_TAKE2(parms, mconfig, w, w2);\n\n            if (errmsg && strcmp(errmsg, DECLINE_CMD) != 0)\n                return errmsg;\n        }\n\n        return errmsg;\n\n    case FLAG:\n        w = ap_getword_conf(parms->pool, &args);\n\n        if (*w == '\\0' || (strcasecmp(w, \"on\") && strcasecmp(w, \"off\")))\n            return apr_pstrcat(parms->pool, cmd->name, \" must be On or Off\",\n                               NULL);\n\n        return cmd->AP_FLAG(parms, mconfig, strcasecmp(w, \"off\") != 0);\n\n    default:\n        return apr_pstrcat(parms->pool, cmd->name,\n                           \" is improperly configured internally (server bug)\",\n                           NULL);\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_eea0db90da17ae76f2327e37565a7c7b3db81b0f_0", {
    "ID": "httpd_eea0db90da17ae76f2327e37565a7c7b3db81b0f_0",
    "UID": "2367",
    "code": "AP_DECLARE(int) ap_method_number_of(const char test_snippet\n{\n    int len = strlen(method);\n    int which = lookup_builtin_method(method, len);\n\n    if (which != UNKNOWN_METHOD)\n        return which;\n\n    \n    if (methods_registry != NULL) {\n        int *methnum = apr_hash_get(methods_registry, method, len);\n\n        if (methnum != NULL) {\n            return *methnum;\n        }\n    }\n\n    return M_INVALID;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_cd54939e5a717709415fef94d0d9a1cd7093f67e_0", {
    "ID": "httpd_cd54939e5a717709415fef94d0d9a1cd7093f67e_0",
    "UID": "2384",
    "code": "static char *parse_log_misc_string(apr_pool_t *p, log_format_item test_snippet\n                                   const char **sa)\n{\n    const char *s;\n    char *d;\n\n    it->func = constant_item;\n    it->conditions = NULL;\n\n    s = *sa;\n    while (*s && *s != '%') {\n        s++;\n    }\n    /*\n     * This might allocate a few chars extra if there's a backslash\n     * escape in the format string.\n     */\n    it->arg = apr_palloc(p, s - *sa + 1);\n\n    d = it->arg;\n    s = *sa;\n    while (*s && *s != '%') {\n        if (*s != '\\\\') {\n            *d++ = *s++;\n        }\n        else {\n            s++;\n            switch (*s) {\n            case '\\\\':\n                *d++ = '\\\\';\n                s++;\n                break;\n            case 'r':\n                *d++ = '\\r';\n                s++;\n                break;\n            case 'n':\n                *d++ = '\\n';\n                s++;\n                break;\n            case 't':\n                *d++ = '\\t';\n                s++;\n                break;\n            default:\n                \n                *d++ = '\\\\';\n                /*\n                 * Allow the loop to deal with this *s in the normal\n                 * fashion so that it handles end of string etc.\n                 * properly.\n                 */\n                break;\n            }\n        }\n    }\n    *d = '\\0';\n\n    *sa = s;\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_952bb807bc282377d35f5782abef84337aa203f9_0", {
    "ID": "httpd_952bb807bc282377d35f5782abef84337aa203f9_0",
    "UID": "2386",
    "code": "static apr_status_t send_all_header_fields(header_struct test_snippet\n                                           const request_rec *r)\n{\n    const apr_array_header_t *elts;\n    const apr_table_entry_t *t_elt;\n    const apr_table_entry_t *t_end;\n    struct iovec *vec;\n    struct iovec *vec_next;\n\n    elts = apr_table_elts(r->headers_out);\n    if (elts->nelts == 0) {\n        return APR_SUCCESS;\n    }\n    t_elt = (const apr_table_entry_t *)(elts->elts);\n    t_end = t_elt + elts->nelts;\n    vec = (struct iovec *)apr_palloc(h->pool, 4 * elts->nelts *\n                                     sizeof(struct iovec));\n    vec_next = vec;\n\n    /* For each field, generate\n     *    name \": \" value CRLF\n     */\n    do {\n        vec_next->iov_base = (void*)(t_elt->key);\n        vec_next->iov_len = strlen(t_elt->key);\n        vec_next++;\n        vec_next->iov_base = \": \";\n        vec_next->iov_len = sizeof(\": \") - 1;\n        vec_next++;\n        vec_next->iov_base = (void*)(t_elt->val);\n        vec_next->iov_len = strlen(t_elt->val);\n        vec_next++;\n        vec_next->iov_base = CRLF;\n        vec_next->iov_len = sizeof(CRLF) - 1;\n        vec_next++;\n        t_elt++;\n    } while (t_elt < t_end);\n\n#if APR_CHARSET_EBCDIC\n    {\n        apr_size_t len;\n        char *tmp = apr_pstrcatv(r->pool, vec, vec_next - vec, &len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        return apr_brigade_write(h->bb, NULL, NULL, tmp, len);\n    }\n#else\n    return apr_brigade_writev(h->bb, NULL, NULL, vec, vec_next - vec);\n#endif\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_5c863b556f05f1ad8ea8b20686674cf0c87b3ace_0", {
    "ID": "httpd_5c863b556f05f1ad8ea8b20686674cf0c87b3ace_0",
    "UID": "2413",
    "code": "static void fix_hostname(request_rec test_snippet\n{\n    char *host, *scope_id;\n    char *dst;\n    apr_port_t port;\n    apr_status_t rv;\n\n    \n    if (!*r->hostname) {\n        return;\n    }\n\n    rv = apr_parse_addr_port(&host, &scope_id, &port, r->hostname, r->pool);\n    if (rv != APR_SUCCESS || scope_id) {\n        goto bad;\n    }\n\n    if (!host && port) {\n        /* silly looking host (\"Host: 123\") but that isn't our job\n         * here to judge; apr_parse_addr_port() would think we had a port\n         * but no address\n         */\n        host = apr_itoa(r->pool, (int)port);\n    }\n    else if (port) {\n        /* Don't throw the Host: header's port number away:\n\t   save it in parsed_uri -- ap_get_server_port() needs it! */\n        /* @@@ XXX there should be a better way to pass the port.\n\t *         Like r->hostname, there should be a r->portno\n\t */\n        r->parsed_uri.port = port;\n\tr->parsed_uri.port_str = apr_itoa(r->pool, (int)port);\n    }\n\n    /* if the hostname is an IPv6 numeric address string, it was validated \n     * already; otherwise, further validation is needed \n     */\n    if (r->hostname[0] != '[') {\n        for (dst = host; *dst; dst++) {\n            if (apr_islower(*dst)) {\n                \n            }\n            else if (*dst == '.') {\n                if (*(dst + 1) == '.') {\n                    goto bad;\n                }\n            }\n            else if (apr_isupper(*dst)) {\n                *dst = apr_tolower(*dst);\n            }\n            else if (*dst == '/' || *dst == '\\\\') {\n                goto bad;\n            }\n        }\n        \n        if (dst > host && dst[-1] == '.') {\n            dst[-1] = '\\0';\n        }\n    }\n    r->hostname = host;\n    return;\n\nbad:\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"Client sent malformed Host header\");\n    return;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_749b5bdfabaf8458ed17a7ede30c88fc21ef55eb_0", {
    "ID": "httpd_749b5bdfabaf8458ed17a7ede30c88fc21ef55eb_0",
    "UID": "2441",
    "code": "static void startup_children(int test_snippet\n{\n    int i;\n\n    for (i = 0; number_to_start && i < ap_daemons_limit; ++i) {\n        if (ap_scoreboard_image->servers[i][0].status != SERVER_DEAD) {\n            continue;\n        }\n        if (make_child(ap_server_conf, i) < 0) {\n            break;\n        }\n        --number_to_start;\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable\n606,Unchecked Input for Loop Condition"
  },
  "httpd_9943fac01a5284ef551d8ae64e4fbc0bbdc2afc7_0", {
    "ID": "httpd_9943fac01a5284ef551d8ae64e4fbc0bbdc2afc7_0",
    "UID": "2442",
    "code": "static int send_signal(pid_t pid, int test_snippet\n{\n    if (kill(pid, test_snippet < 0) {\n        ap_log_error(APLOG_MARK, APLOG_STARTUP, errno, NULL,\n                     \"sending signal to server\");\n        return 1;\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference\n664,Improper Neutralization of Special Elements"
  },
  "httpd_5c479ca35a3bc0d6dda7a97d80eb82769fff159f_0", {
    "ID": "httpd_5c479ca35a3bc0d6dda7a97d80eb82769fff159f_0",
    "UID": "2456",
    "code": "int ap_signal_server(int *exit_status, apr_pool_t test_snippet\n{\n    apr_status_t rv;\n    pid_t otherpid;\n    int running = 0;\n    int have_pid_file = 0;\n    const char *status;\n    \n    *exit_status = 0;\n\n    rv = ap_read_pid(pconf, ap_pid_fname, &otherpid);\n    if (rv != APR_SUCCESS) {\n        if (rv != APR_ENOENT) {\n            ap_log_error(APLOG_MARK, APLOG_STARTUP, rv, NULL,\n                         \"Error retrieving pid file %s\", ap_pid_fname);\n            *exit_status = 1;\n            return 1;\n        }\n        status = \"httpd (no pid file) not running\";\n    }\n    else {\n        have_pid_file = 1;\n        if (kill(otherpid, 0) == 0) {\n            running = 1;\n            status = apr_psprintf(pconf, \n                                  \"httpd (pid %\" APR_PID_T_FMT \") already \"\n                                  \"running\", otherpid);\n        }\n        else {\n            status = apr_psprintf(pconf,\n                                  \"httpd (pid %\" APR_PID_T_FMT \"?) not running\",\n                                  otherpid);\n        }\n    }\n\n    if (!strcmp(dash_k_arg, \"start\")) {\n        if (running) {\n            printf(\"%s\\n\", status);\n            return 1;\n        }\n    }\n\n    if (!strcmp(dash_k_arg, \"stop\")) {\n        if (!running) {\n            printf(\"%s\\n\", status);\n        }\n        else {\n            send_signal(otherpid, SIGTERM);\n        }\n        return 1;\n    }\n\n    if (!strcmp(dash_k_arg, \"restart\")) {\n        if (!running) {\n            printf(\"httpd not running, trying to start\\n\");\n        }\n        else {\n            *exit_status = send_signal(otherpid, SIGHUP);\n            return 1;\n        }\n    }\n\n    if (!strcmp(dash_k_arg, \"graceful\")) {\n        if (!running) {\n            printf(\"httpd not running, trying to start\\n\");\n        }\n        else {\n            *exit_status = send_signal(otherpid, SIGUSR1);\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n"
  },
  "httpd_22ada1d274c6831ccafb4ffef291159fe2fdb31a_0", {
    "ID": "httpd_22ada1d274c6831ccafb4ffef291159fe2fdb31a_0",
    "UID": "2458",
    "code": "static int find_ct(request_rec test_snippet\n{\n    mime_dir_config *conf;\n    apr_array_header_t *exception_list;\n    char *ext;\n    const char *fn, *type, *charset = NULL, *resource_name;\n    int found_metadata = 0;\n\n    if (r->finfo.filetype == APR_DIR) {\n        ap_set_content_type(r, DIR_MAGIC_TYPE);\n        return OK;\n    }\n\n    if (!r->filename) {\n        return DECLINED;\n    }\n\n    conf = (mime_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &mime_module);\n    exception_list = apr_array_make(r->pool, 2, sizeof(char *));\n\n    \n    if (conf->use_path_info & 1) {\n        resource_name = apr_pstrcat(r->pool, r->filename, r->path_info, NULL);\n    }\n    else {\n        resource_name = r->filename;\n    }\n\n    /* Always drop the path leading up to the file name.\n     */\n    if ((fn = ap_strrchr_c(resource_name, '/')) == NULL) {\n        fn = resource_name;\n    }\n    else {\n        ++fn;\n    }\n\n    /* The exception list keeps track of those filename components that\n     * are not associated with extensions indicating metadata.\n     * The base name is always the first exception (i.e., \"txt.html\" has\n     * a basename of \"txt\" even though it might look like an extension).\n     */\n    ext = ap_getword(r->pool, &fn, '.');\n    *((const char **)apr_array_push(exception_list)) = ext;\n\n    /* Parse filename extensions which can be in any order \n     */\n    while (*fn && (ext = ap_getword(r->pool, &fn, '.'))) {\n        const extension_info *exinfo = NULL;\n        int found;\n\n        if (*ext == '\\0') {  \n            continue;\n        }\n\n        found = 0;\n\n        ap_str_tolower(ext);\n\n        if (conf->extension_mappings != NULL) {\n            exinfo = (extension_info*)apr_hash_get(conf->extension_mappings,\n                                                   ext, APR_HASH_KEY_STRING);\n        }\n\n        if (exinfo == NULL || !exinfo->forced_type) {\n            if ((type = apr_hash_get(mime_type_extensions, ext,\n                                     APR_HASH_KEY_STRING)) != NULL) {\n                ap_set_content_type(r, (char*) type);\n                found = 1;\n            }\n        }\n\n        if (exinfo != NULL) {\n\n            if (exinfo->forced_type) {\n                ap_set_content_type(r, exinfo->forced_type);\n                found = 1;\n            }\n\n            if (exinfo->charset_type) {\n                charset = exinfo->charset_type;\n                found = 1;\n            }\n            if (exinfo->language_type) {\n                if (!r->content_languages) {\n                    r->content_languages = apr_array_make(r->pool, 2,\n                                                          sizeof(char *));\n                }\n                *((const char **)apr_array_push(r->content_languages))\n                    = exinfo->language_type;\n                found = 1;\n            }\n            if (exinfo->encoding_type) {\n                if (!r->content_encoding) {\n                    r->content_encoding = exinfo->encoding_type;\n                }\n                else {\n                    /* XXX should eliminate duplicate entities\n                     *\n                     * ah no. Order is important and double encoding is neither\n                     * forbidden nor impossible. -- nd\n                     */\n                    r->content_encoding = apr_pstrcat(r->pool,\n                                                      r->content_encoding,\n                                                      \", \",\n                                                      exinfo->encoding_type,\n                                                      NULL);\n                }\n                found = 1;\n            }\n            /* The following extensions are not 'Found'.  That is, they don't\n             * make any contribution to metadata negotation, so they must have\n             * been explicitly requested by name. \n             */\n            if (exinfo->handler && r->proxyreq == PROXYREQ_NONE) {\n                r->handler = exinfo->handler;\n                if (conf->multimatch & MULTIMATCH_HANDLERS) {\n                    found = 1;\n                }\n            }\n            /* XXX Two significant problems; 1, we don't check to see if we are\n             * setting redundant filters.    2, we insert these in the types config\n             * hook, which may be too early (dunno.)\n             */\n            if (exinfo->input_filters && r->proxyreq == PROXYREQ_NONE) {\n                const char *filter, *filters = exinfo->input_filters;\n                while (*filters \n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_input_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n            if (exinfo->output_filters && r->proxyreq == PROXYREQ_NONE) {\n                const char *filter, *filters = exinfo->output_filters;\n                while (*filters \n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_output_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n        }\n\n        if (found || (conf->multimatch & MULTIMATCH_ANY)) {\n            found_metadata = 1;\n        }\n        else {\n            *((const char **) apr_array_push(exception_list)) = ext;\n        }\n    }\n\n    /*\n     * Need to set a notes entry on r for unrecognized elements.\n     * Somebody better claim them!  If we did absolutely nothing,\n     * skip the notes to alert mod_negotiation we are clueless.\n     */\n    if (found_metadata) {\n        apr_table_setn(r->notes, \"ap-mime-exceptions-list\", \n                       (void *)exception_list);\n    }\n\n    if (r->content_type) {\n        content_type *ctp;\n        int override = 0;\n\n        if ((ctp = analyze_ct(r, r->content_type))) {\n            param *pp = ctp->param;\n            char *base_content_type = apr_palloc(r->pool, ctp->type_len +\n                                                 ctp->subtype_len +\n                                                 sizeof(\"/\"));\n            char *tmp = base_content_type;\n            memcpy(tmp, ctp->type, ctp->type_len);\n            tmp += ctp->type_len;\n            *tmp++ = '/';\n            memcpy(tmp, ctp->subtype, ctp->subtype_len);\n            tmp += ctp->subtype_len;\n            *tmp = 0;\n            ap_set_content_type(r, base_content_type);\n            while (pp != NULL) {\n                if (charset && !strcmp(pp->attr, \"charset\")) {\n                    if (!override) {\n                        ap_set_content_type(r,\n                                            apr_pstrcat(r->pool,\n                                                        r->content_type,\n                                                        \"; charset=\",\n                                                        charset,\n                                                        NULL));\n                        override = 1;\n                    }\n                }\n                else {\n                    ap_set_content_type(r,\n                                        apr_pstrcat(r->pool,\n                                                    r->content_type,\n                                                    \"; \", pp->attr,\n                                                    \"=\", pp->val,\n                                                    NULL));\n                }\n                pp = pp->next;\n            }\n            if (charset && !override) {\n                ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,\n                                                   \"; charset=\", charset,\n                                                   NULL));\n            }\n        }\n    }\n\n    /* Set default language, if none was specified by the extensions\n     * and we have a DefaultLanguage setting in force\n     */\n\n    if (!r->content_languages && conf->default_language) {\n        const char **new;\n\n        if (!r->content_languages) {\n            r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n        }\n        new = (const char **)apr_array_push(r->content_languages);\n        *new = conf->default_language;\n    }\n\n    if (!r->content_type) {\n        return DECLINED;\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e44208380a22695b40d11e96966c4b136f1544c4_0", {
    "ID": "httpd_e44208380a22695b40d11e96966c4b136f1544c4_0",
    "UID": "2469",
    "code": "static void perform_idle_server_maintenance(apr_pool_t test_snippet\n{\n    int i;\n    int to_kill;\n    int idle_count;\n    worker_score *ws;\n    int free_length;\n    int free_slots[MAX_SPAWN_RATE];\n    int last_non_dead;\n    int total_non_dead;\n\n    \n    free_length = 0;\n\n    to_kill = -1;\n    idle_count = 0;\n    last_non_dead = -1;\n    total_non_dead = 0;\n\n    for (i = 0; i < ap_daemons_limit; ++i) {\n        int status;\n\n        if (i >= ap_max_daemons_limit && free_length == idle_spawn_rate)\n            break;\n        ws = &ap_scoreboard_image->servers[i][0];\n        status = ws->status;\n        if (status == SERVER_DEAD) {\n            \n            if (free_length < idle_spawn_rate) {\n                free_slots[free_length] = i;\n                ++free_length;\n            }\n        }\n        else {\n            /* We consider a starting server as idle because we started it\n             * at least a cycle ago, and if it still hasn't finished starting\n             * then we're just going to swamp things worse by forking more.\n             * So we hopefully won't need to fork more if we count it.\n             * This depends on the ordering of SERVER_READY and SERVER_STARTING.\n             */\n            if (status <= SERVER_READY) {\n                ++ idle_count;\n                /* always kill the highest numbered child if we have to...\n                 * no really well thought out reason ... other than observing\n                 * the server behaviour under linux where lower numbered children\n                 * tend to service more hits (and hence are more likely to have\n                 * their data in cpu caches).\n                 */\n                to_kill = i;\n            }\n\n            ++total_non_dead;\n            last_non_dead = i;\n        }\n    }\n    ap_max_daemons_limit = last_non_dead + 1;\n    if (idle_count > ap_daemons_max_free) {\n        /* kill off one child... we use the pod because that'll cause it to\n         * shut down gracefully, in case it happened to pick up a request\n         * while we were counting\n         */\n        ap_mpm_pod_signal(pod);\n        idle_spawn_rate = 1;\n    }\n    else if (idle_count < ap_daemons_min_free) {\n        \n        if (free_length == 0) {\n            \n            static int reported = 0;\n\n            if (!reported) {\n                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,\n                            \"server reached MaxClients setting, consider\"\n                            \" raising the MaxClients setting\");\n                reported = 1;\n            }\n            idle_spawn_rate = 1;\n        }\n        else {\n            if (idle_spawn_rate >= 8) {\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,\n                    \"server seems busy, (you may need \"\n                    \"to increase StartServers, or Min/MaxSpareServers), \"\n                    \"spawning %d children, there are %d idle, and \"\n                    \"%d total children\", idle_spawn_rate,\n                    idle_count, total_non_dead);\n            }\n            for (i = 0; i < free_length; ++i) {\n#ifdef TPF\n                if (make_child(ap_server_conf, free_slots[i]) == -1) {\n                    if(free_length == 1) {\n                        shutdown_pending = 1;\n                        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, ap_server_conf,\n                                    \"No active child processes: shutting down\");\n                    }\n                }\n#else\n                make_child(ap_server_conf, free_slots[i]);\n#endif \n            }\n            /* the next time around we want to spawn twice as many if this\n             * wasn't good enough, but not if we've just done a graceful\n             */\n            if (hold_off_on_exponential_spawning) {\n                --hold_off_on_exponential_spawning;\n            }\n            else if (idle_spawn_rate < MAX_SPAWN_RATE) {\n                idle_spawn_rate *= 2;\n            }\n        }\n    }\n    else {\n        idle_spawn_rate = 1;\n    }\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n762,Mismatched Memory Management Routines\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_8f657b52963b669bde7e705d4df52e4ea4cab4ea_0", {
    "ID": "httpd_8f657b52963b669bde7e705d4df52e4ea4cab4ea_0",
    "UID": "2498",
    "code": "static int matches_aliases(server_rec *s, const char test_snippet\n{\n    int i;\n    apr_array_header_t *names;\n\n    \n    if (!strcasecmp(host, s->server_hostname)) {\n        return 1;\n    }\n\n    \n    names = s->names;\n    if (names) {\n        char **name = (char **) names->elts;\n        for (i = 0; i < names->nelts; ++i) {\n            if(!name[i]) continue;\n            if (!strcasecmp(host, name[i]))\n                return 1;\n        }\n    }\n    names = s->wild_names;\n    if (names) {\n        char **name = (char **) names->elts;\n        for (i = 0; i < names->nelts; ++i) {\n            if(!name[i]) continue;\n            if (!ap_strcasecmp_match(host, name[i]))\n                return 1;\n        }\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b74369c477fdf3512676b6aaac205fa6a5393f19_0", {
    "ID": "httpd_b74369c477fdf3512676b6aaac205fa6a5393f19_0",
    "UID": "2499",
    "code": "static const char *ap_build_config_sub(apr_pool_t *p, apr_pool_t test_snippet\n                                       const char *l, cmd_parms *parms,\n                                       ap_directive_t **current,\n                                       ap_directive_t **curr_parent,\n                                       ap_directive_t **conftree)\n{\n    const char *retval = NULL;\n    const char *args;\n    char *cmd_name;\n    ap_directive_t *newdir;\n    module *mod = ap_top_module;\n    const command_rec *cmd;\n\n    if (*l == '#' || *l == '\\0')\n        return NULL;\n\n#if RESOLVE_ENV_PER_TOKEN\n    args = l;\n#else\n    args = ap_resolve_env(temp_pool, l);\n#endif\n\n    cmd_name = ap_getword_conf(p, &args);\n    if (*cmd_name == '\\0') {\n        /* Note: this branch should not occur. An empty line should have\n         * triggered the exit further above.\n         */\n        return NULL;\n    }\n\n    if (cmd_name[1] != '/') {\n        char *lastc = cmd_name + strlen(cmd_name) - 1;\n        if (*lastc == '>') {\n            *lastc = '\\0' ;\n        }\n        if (cmd_name[0] == '<' && *args == '\\0') {\n            args = \">\";\n        }\n    }\n\n    newdir = apr_pcalloc(p, sizeof(ap_directive_t));\n    newdir->filename = parms->config_file->name;\n    newdir->line_num = parms->config_file->line_number;\n    newdir->directive = cmd_name;\n    newdir->args = apr_pstrdup(p, args);\n\n    if ((cmd = ap_find_command_in_modules(cmd_name, &mod)) != NULL) {\n        if (cmd->req_override & EXEC_ON_READ) {\n            ap_directive_t *sub_tree = NULL;\n\n            parms->err_directive = newdir;\n            retval = execute_now(cmd_name, args, parms, p, temp_pool,\n                                 &sub_tree, *curr_parent);\n            if (*current) {\n                (*current)->next = sub_tree;\n            }\n            else {\n                *current = sub_tree;\n                if (*curr_parent) {\n                    (*curr_parent)->first_child = (*current);\n                }\n                if (*current) {\n                    (*current)->parent = (*curr_parent);\n                }\n            }\n            if (*current) {\n                if (!*conftree) {\n                    /* Before walking *current to the end of the list,\n                     * set the head to *current.\n                     */\n                    *conftree = *current;\n                }\n                while ((*current)->next != NULL) {\n                    (*current) = (*current)->next;\n                    (*current)->parent = (*curr_parent);\n                }\n            }\n            return retval;\n        }\n    }\n\n    if (cmd_name[0] == '<') {\n        if (cmd_name[1] != '/') {\n            (*current) = ap_add_node(curr_parent, *current, newdir, 1);\n        }\n        else if (*curr_parent == NULL) {\n            parms->err_directive = newdir;\n            return apr_pstrcat(p, cmd_name,\n                               \" without matching <\", cmd_name + 2,\n                               \" section\", NULL);\n        }\n        else {\n            char *bracket = cmd_name + strlen(cmd_name) - 1;\n\n            if (*bracket != '>') {\n                parms->err_directive = newdir;\n                return apr_pstrcat(p, cmd_name,\n                                   \"> directive missing closing '>'\", NULL);\n            }\n\n            *bracket = '\\0';\n\n            if (strcasecmp(cmd_name + 2,\n                           (*curr_parent)->directive + 1) != 0) {\n                parms->err_directive = newdir;\n                return apr_pstrcat(p, \"Expected </\",\n                                   (*curr_parent)->directive + 1, \"> but saw \",\n                                   cmd_name, \">\", NULL);\n            }\n\n            *bracket = '>';\n\n            \n            *current = *curr_parent;\n            *curr_parent = (*current)->parent;\n        }\n    }\n    else {\n        *current = ap_add_node(curr_parent, *current, newdir, 0);\n    }\n\n    return retval;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_de2c4e9df4f11c3a55b540328e2a72d54076b124_0", {
    "ID": "httpd_de2c4e9df4f11c3a55b540328e2a72d54076b124_0",
    "UID": "2502",
    "code": "static void strip_paren_comments(char test_snippet\n{\n    \n    \n\n    while (test_snippet {\n        if (*hdr == '\"') {\n            hdr = strchr(hdr, '\"');\n            if (hdr == NULL) {\n                return;\n            }\n            ++hdr;\n        }\n        else if (*hdr == '(') {\n            while (*hdr && *hdr != ')') {\n                *hdr++ = ' ';\n            }\n\n            if (test_snippet {\n                *hdr++ = ' ';\n            }\n        }\n        else {\n            ++hdr;\n        }\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_8009e2ee65f3a2be40a8c422eb033dd6699b9a72_0", {
    "ID": "httpd_8009e2ee65f3a2be40a8c422eb033dd6699b9a72_0",
    "UID": "2505",
    "code": "void ap_mpm_rewrite_args(process_rec test_snippet\n{\n    apr_array_header_t *mpm_new_argv;\n    apr_status_t rv;\n    apr_getopt_t *opt;\n    char optbuf[3];\n    const char *optarg;\n    int fixed_args;\n\n    mpm_new_argv = apr_array_make(process->pool, process->argc,\n                                  sizeof(const char **));\n    *(const char **)apr_array_push(mpm_new_argv) = process->argv[0];\n    fixed_args = mpm_new_argv->nelts;\n    apr_getopt_init(&opt, process->pool, process->argc, process->argv);\n    opt->errfn = NULL;\n    optbuf[0] = '-';\n    \n    optbuf[2] = '\\0';\n    while ((rv = apr_getopt(opt, \"k:\" AP_SERVER_BASEARGS,\n                            optbuf + 1, &optarg)) == APR_SUCCESS) {\n        switch(optbuf[1]) {\n        case 'k':\n            if (!dash_k_arg) {\n                if (!strcmp(optarg, \"start\") || !strcmp(optarg, \"stop\") ||\n                    !strcmp(optarg, \"restart\") || !strcmp(optarg, \"graceful\")) {\n                    dash_k_arg = optarg;\n                    break;\n                }\n            }\n        default:\n            *(const char **)apr_array_push(mpm_new_argv) =\n                apr_pstrdup(process->pool, optbuf);\n            if (optarg) {\n                *(const char **)apr_array_push(mpm_new_argv) = optarg;\n            }\n        }\n    }\n\n    \n    if (rv == APR_BADCH || rv == APR_BADARG) {\n        opt->ind--;\n    }\n\n    while (opt->ind < opt->argc) {\n        *(const char **)apr_array_push(mpm_new_argv) =\n            apr_pstrdup(process->pool, opt->argv[opt->ind++]);\n    }\n\n    process->argc = mpm_new_argv->nelts;\n    process->argv = (const char * const *)mpm_new_argv->elts;\n\n    if (dash_k_arg) {\n        APR_REGISTER_OPTIONAL_FN(ap_signal_server);\n    }\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_e0ea35af2633ed9b7fa6305f554eb349e91c050e_0", {
    "ID": "httpd_e0ea35af2633ed9b7fa6305f554eb349e91c050e_0",
    "UID": "2507",
    "code": "void ap_wait_or_timeout(apr_exit_why_e *status, int *exitcode, apr_proc_t test_snippet\n                        apr_pool_t *p)\n{\n    apr_status_t rv;\n\n    ++wait_or_timeout_counter;\n    if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {\n        wait_or_timeout_counter = 0;\n    }\n\n    rv = apr_proc_wait_all_procs(ret, exitcode, status, APR_NOWAIT, p);\n    if (APR_STATUS_IS_EINTR(rv)) {\n        ret->pid = -1;\n        return;\n    }\n\n    if (APR_STATUS_IS_CHILD_DONE(rv)) {\n        return;\n    }\n\n#ifdef NEED_WAITPID\n    if ((ret = reap_children(exitcode, status)) > 0) {\n        return;\n    }\n#endif\n\n    apr_sleep(SCOREBOARD_MAINTENANCE_INTERVAL);\n    ret->pid = -1;\n    return;\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_2f921aa5f40b0a2d14090e92f9df6b9b01a00859_0", {
    "ID": "httpd_2f921aa5f40b0a2d14090e92f9df6b9b01a00859_0",
    "UID": "2517",
    "code": "static int config_log_transaction(request_rec *r, config_log_state test_snippet\n                                  apr_array_header_t *default_format)\n{\n    log_format_item *items;\n    const char **strs;\n    int *strl;\n    request_rec *orig;\n    int i;\n    apr_size_t len = 0;\n    apr_array_header_t *format;\n    char *envar;\n    apr_status_t rv;\n\n    if (cls->fname == NULL) {\n        return DECLINED;\n    }\n\n    /*\n     * See if we've got any conditional envariable-controlled logging decisions\n     * to make.\n     */\n    if (cls->condition_var != NULL) {\n        envar = cls->condition_var;\n        if (*envar != '!') {\n            if (apr_table_get(r->subprocess_env, envar) == NULL) {\n                return DECLINED;\n            }\n        }\n        else {\n            if (apr_table_get(r->subprocess_env, &envar[1]) != NULL) {\n                return DECLINED;\n            }\n        }\n    }\n\n    format = cls->format ? cls->format : default_format;\n\n    strs = apr_palloc(r->pool, sizeof(char *) * (format->nelts));\n    strl = apr_palloc(r->pool, sizeof(int) * (format->nelts));\n    items = (log_format_item *) format->elts;\n\n    orig = r;\n    while (orig->prev) {\n        orig = orig->prev;\n    }\n    while (r->next) {\n        r = r->next;\n    }\n\n    for (i = 0; i < format->nelts; ++i) {\n        strs[i] = process_item(r, orig, &items[i]);\n    }\n\n    for (i = 0; i < format->nelts; ++i) {\n        len += strl[i] = strlen(strs[i]);\n    }\n    if (!log_writer) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,\n                \"log writer isn't correctly setup\");\n         return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    rv = log_writer(r, cls->log_writer, strs, strl, format->nelts, len);\n    \n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_d787f5e87d8c2a6e2b0db2154083eba42e2e268e_0", {
    "ID": "httpd_d787f5e87d8c2a6e2b0db2154083eba42e2e268e_0",
    "UID": "2518",
    "code": "static const char *process_item(request_rec *r, request_rec test_snippet\n                          log_format_item *item)\n{\n    const char *cp;\n\n    \n\n    if (item->conditions && item->conditions->nelts != 0) {\n        int i;\n        int *conds = (int *) item->conditions->elts;\n        int in_list = 0;\n\n        for (i = 0; i < item->conditions->nelts; ++i) {\n            if (r->status == conds[i]) {\n                in_list = 1;\n                break;\n            }\n        }\n\n        if ((item->condition_sense && in_list)\n            || (!item->condition_sense && !in_list)) {\n            return \"-\";\n        }\n    }\n\n    \n\n    cp = (*item->func) (item->want_orig ? orig : r, item->arg);\n    return cp ? cp : \"-\";\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_f87d6c4bacb20b32ed7955e66cd3885887d142a1_0", {
    "ID": "httpd_f87d6c4bacb20b32ed7955e66cd3885887d142a1_0",
    "UID": "2519",
    "code": "AP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * test_snippet\n{\n       char tmp[ MAX_STRING_LEN ];\n       const char *s, *e;\n       tmp[0] = '\\0';\n\n       if (!(s=ap_strchr_c(word,'$')))\n               return word;\n\n       do {\n               /* XXX - relies on strncat() to add '\\0'\n                */\n               strncat(tmp,word,s - test_snippet;\n               if ((s[1] == '{') && (e=ap_strchr_c(s,'}'))) {\n                       const char *e2 = e;\n                       char *var;\n                       word = e + 1;\n                       var = apr_pstrndup(p, s+2, e2-(s+2));\n                       e = getenv(var);\n                       if (e) {\n                           strcat(tmp,e);\n                       } else {\n                           strncat(tmp, s, e2-s);\n                           strcat(tmp,\"}\");\n                       }\n               } else {\n                       \n                       word = s+1;\n                       strcat(tmp,\"$\");\n               };\n       } while ((s=ap_strchr_c(word,'$')));\n       strcat(tmp,test_snippet;\n\n       return apr_pstrdup(p,tmp);\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_4c9b8244ebe46bf446ee6f218a07ba2e03916ee7_0", {
    "ID": "httpd_4c9b8244ebe46bf446ee6f218a07ba2e03916ee7_0",
    "UID": "2520",
    "code": "static void check_serverpath(request_rec test_snippet\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n\n    port = r->connection->local_addr->port;\n\n    /*\n     * This is in conjunction with the ServerPath code in http_core, so we\n     * get the right host attached to a non- Host-sending request.\n     *\n     * See the comment in check_hostalias about how each vhost can be\n     * listed multiple times.\n     */\n\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        /* We only consider addresses on the name_chain which have a matching\n         * port\n         */\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_4694018913cca34f0f5bbd9dbd4a233377783e61_0", {
    "ID": "httpd_4694018913cca34f0f5bbd9dbd4a233377783e61_0",
    "UID": "2526",
    "code": "static int read_type_map(apr_file_t **map, negotiation_state test_snippet\n                         request_rec *rr)\n{\n    request_rec *r = neg->r;\n    apr_file_t *map_ = NULL;\n    apr_status_t status;\n    char buffer[MAX_STRING_LEN];\n    enum header_state hstate;\n    struct var_rec mime_info;\n    int has_content;\n\n    if (!map)\n        map = &map_;\n\n    \n    neg->count_multiviews_variants = 0;\n\n    if ((status = apr_file_open(map, rr->filename, APR_READ | APR_BUFFERED,\n                APR_OS_DEFAULT, neg->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,\n                      \"cannot access type map file: %s\", rr->filename);\n        return APR_STATUS_IS_ENOENT(status) ? HTTP_NOT_FOUND : HTTP_FORBIDDEN;\n    }\n\n    clean_var_rec(&mime_info);\n    has_content = 0;\n\n    do {\n        hstate = get_header_line(buffer, MAX_STRING_LEN, *map);\n\n        if (hstate == header_seen) {\n            char *body1 = lcase_header_name_return_body(buffer, neg->r);\n            const char *body;\n\n            if (body1 == NULL) {\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            strip_paren_comments(body1);\n            body = body1;\n\n            if (!strncmp(buffer, \"uri:\", 4)) {\n                mime_info.file_name = ap_get_token(neg->pool, &body, 0);\n            }\n            else if (!strncmp(buffer, \"content-type:\", 13)) {\n                struct accept_rec accept_info;\n\n                get_entry(neg->pool, &accept_info, body);\n                set_mime_fields(&mime_info, &accept_info);\n                has_content = 1;\n            }\n            else if (!strncmp(buffer, \"content-length:\", 15)) {\n                char *errp;\n                apr_off_t number;\n\n                if (apr_strtoff(&number, body, &errp, 10)\n                    || *errp || number < 0) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"Parse error in type map, Content-Length: \"\n                                  \"'%s' in %s is invalid.\",\n                                  body, r->filename);\n                    break;\n                }\n                mime_info.bytes = number;\n                has_content = 1;\n            }\n            else if (!strncmp(buffer, \"content-language:\", 17)) {\n                mime_info.content_languages = do_languages_line(neg->pool,\n                                                                &body);\n                has_content = 1;\n            }\n            else if (!strncmp(buffer, \"content-encoding:\", 17)) {\n                mime_info.content_encoding = ap_get_token(neg->pool, &body, 0);\n                has_content = 1;\n            }\n            else if (!strncmp(buffer, \"description:\", 12)) {\n                char *desc = apr_pstrdup(neg->pool, body);\n                char *cp;\n\n                for (cp = desc; *cp; ++cp) {\n                    if (*cp=='\\n') *cp=' ';\n                }\n                if (cp>desc) *(cp-1)=0;\n                mime_info.description = desc;\n            }\n            else if (!strncmp(buffer, \"body:\", 5)) {\n                char *tag = apr_pstrdup(neg->pool, body);\n                char *eol = strchr(tag, '\\0');\n                apr_size_t len = MAX_STRING_LEN;\n                while (--eol >= tag && apr_isspace(*eol))\n                    *eol = '\\0';\n                if ((mime_info.body = get_body(buffer, &len, tag, *map)) < 0) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                                  \"Syntax error in type map, no end tag '%s'\"\n                                  \"found in %s for Body: content.\",\n                                  tag, r->filename);\n                     break;\n                }\n                mime_info.bytes = len;\n                mime_info.file_name = apr_filepath_name_get(rr->filename);\n            }\n        }\n        else {\n            if (*mime_info.file_name && has_content) {\n                void *new_var = apr_array_push(neg->avail_vars);\n\n                memcpy(new_var, (void *) &mime_info, sizeof(var_rec));\n            }\n\n            clean_var_rec(&mime_info);\n            has_content = 0;\n        }\n    } while (hstate != header_eof);\n\n    if (map_)\n        apr_file_close(map_);\n\n    set_vlist_validator(r, rr);\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_eb3606e3ea2e47a079e950ef3f65df15acac599a_0", {
    "ID": "httpd_eb3606e3ea2e47a079e950ef3f65df15acac599a_0",
    "UID": "2539",
    "code": "static int multi_log_transaction(request_rec test_snippet\n{\n    multi_log_state *mls = ap_get_module_config(r->server->module_config,\n                                                &log_config_module);\n    config_log_state *clsarray;\n    int i;\n\n    /*\n     * Log this transaction..\n     */\n    if (mls->config_logs->nelts) {\n        clsarray = (config_log_state *) mls->config_logs->elts;\n        for (i = 0; i < mls->config_logs->nelts; ++i) {\n            config_log_state *cls = &clsarray[i];\n\n            config_log_transaction(r, cls, mls->default_format);\n        }\n    }\n    else if (mls->server_config_logs) {\n        clsarray = (config_log_state *) mls->server_config_logs->elts;\n        for (i = 0; i < mls->server_config_logs->nelts; ++i) {\n            config_log_state *cls = &clsarray[i];\n\n            config_log_transaction(r, cls, mls->default_format);\n        }\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_49b9f3f6567721aaf708854db5b495b51c67d664_0", {
    "ID": "httpd_49b9f3f6567721aaf708854db5b495b51c67d664_0",
    "UID": "2558",
    "code": "static int read_types_multi(negotiation_state test_snippet\n{\n    request_rec *r = neg->r;\n\n    char *filp;\n    int prefix_len;\n    apr_dir_t *dirp;\n    apr_finfo_t dirent;\n    apr_status_t status;\n    struct var_rec mime_info;\n    struct accept_rec accept_info;\n    void *new_var;\n    int anymatch = 0;\n\n    clean_var_rec(&mime_info);\n\n    if (r->proxyreq || !r->filename\n                    || !ap_os_is_path_absolute(neg->pool, r->filename)) {\n        return DECLINED;\n    }\n\n    \n    if (!(filp = strrchr(r->filename, '/'))) {\n        return DECLINED;\n    }\n    ++filp;\n    prefix_len = strlen(filp);\n\n    if ((status = apr_dir_open(&dirp, neg->dir_name,\n                               neg->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,\n                    \"cannot read directory for multi: %s\", neg->dir_name);\n        return HTTP_FORBIDDEN;\n    }\n\n    while (apr_dir_read(&dirent, APR_FINFO_DIRENT, dirp) == APR_SUCCESS) {\n        apr_array_header_t *exception_list;\n        request_rec *sub_req;\n\n        \n#ifdef CASE_BLIND_FILESYSTEM\n        if (strncasecmp(dirent.name, filp, prefix_len)) {\n#else\n        if (strncmp(dirent.name, filp, prefix_len)) {\n#endif\n            continue;\n        }\n        if (dirent.name[prefix_len] != '.') {\n            continue;\n        }\n\n        /* Don't negotiate directories and other unusual files\n         * Really shouldn't see anything but DIR/LNK/REG here,\n         * and we aught to discover if the LNK was interesting.\n         *\n         * Of course, this only helps platforms that capture the\n         * the filetype in apr_dir_read(), which most can once\n         * they are optimized with some magic [it's known to the\n         * dirent, not associated to the inode, on most FS's.]\n         */\n        if ((dirent.valid & APR_FINFO_TYPE) && (dirent.filetype == APR_DIR))\n            continue;\n\n        /* Ok, something's here.  Maybe nothing useful.  Remember that\n         * we tried, if we completely fail, so we can reject the request!\n         */\n        anymatch = 1;\n\n        /* See if it's something which we have access to, and which\n         * has a known type and encoding (as opposed to something\n         * which we'll be slapping default_type on later).\n         */\n        sub_req = ap_sub_req_lookup_dirent(&dirent, r, AP_SUBREQ_MERGE_ARGS,\n                                           NULL);\n\n        /* Double check, we still don't multi-resolve non-ordinary files\n         */\n        if (sub_req->finfo.filetype != APR_REG)\n            continue;\n\n        /* If it has a handler, we'll pretend it's a CGI script,\n         * since that's a good indication of the sort of thing it\n         * might be doing.\n         */\n        if (sub_req->handler && !sub_req->content_type) {\n            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);\n        }\n\n        /*\n         * mod_mime will _always_ provide us the base name in the\n         * ap-mime-exception-list, if it processed anything.  If\n         * this list is empty, give up immediately, there was\n         * nothing interesting.  For example, looking at the files\n         * readme.txt and readme.foo, we will throw away .foo if\n         * it's an insignificant file (e.g. did not identify a\n         * language, charset, encoding, content type or handler,)\n         */\n        exception_list =\n            (apr_array_header_t *)apr_table_get(sub_req->notes,\n                                                \"ap-mime-exceptions-list\");\n\n        if (!exception_list) {\n            ap_destroy_sub_req(sub_req);\n            continue;\n        }\n\n        /* Each unregonized bit better match our base name, in sequence.\n         * A test of index.html.foo will match index.foo or index.html.foo,\n         * but it will never transpose the segments and allow index.foo.html\n         * because that would introduce too much CPU consumption.  Better that\n         * we don't attempt a many-to-many match here.\n         */\n        {\n            int nexcept = exception_list->nelts;\n            char **cur_except = (char**)exception_list->elts;\n            char *segstart = filp, *segend, saveend;\n\n            while (*segstart && nexcept) {\n                if (!(segend = strchr(segstart, '.')))\n                    segend = strchr(segstart, '\\0');\n                saveend = *segend;\n                *segend = '\\0';\n\n#ifdef CASE_BLIND_FILESYSTEM\n                if (strcasecmp(segstart, *cur_except) == 0) {\n#else\n                if (strcmp(segstart, *cur_except) == 0) {\n#endif\n                    --nexcept;\n                    ++cur_except;\n                }\n\n                if (!saveend)\n                    break;\n\n                *segend = saveend;\n                segstart = segend + 1;\n            }\n\n            if (nexcept) {\n                /* Something you don't know is, something you don't know...\n                 */\n                ap_destroy_sub_req(sub_req);\n                continue;\n            }\n        }\n\n        /*\n         * ###: be warned, the _default_ content type is already\n         * picked up here!  If we failed the subrequest, or don't\n         * know what we are serving, then continue.\n         */\n        if (sub_req->status != HTTP_OK || (!sub_req->content_type)) {\n            ap_destroy_sub_req(sub_req);\n            continue;\n        }\n\n        /* If it's a map file, we use that instead of the map\n         * we're building...\n         */\n        if (((sub_req->content_type) &&\n             !strcmp(sub_req->content_type, MAP_FILE_MAGIC_TYPE)) ||\n            ((sub_req->handler) &&\n             !strcmp(sub_req->handler, \"type-map\"))) {\n\n            apr_dir_close(dirp);\n            neg->avail_vars->nelts = 0;\n            if (sub_req->status != HTTP_OK) {\n                return sub_req->status;\n            }\n            return read_type_map(NULL, neg, sub_req);\n        }\n\n        \n\n        mime_info.sub_req = sub_req;\n        mime_info.file_name = apr_pstrdup(neg->pool, dirent.name);\n        if (sub_req->content_encoding) {\n            mime_info.content_encoding = sub_req->content_encoding;\n        }\n        if (sub_req->content_languages) {\n            mime_info.content_languages = sub_req->content_languages;\n        }\n\n        get_entry(neg->pool, &accept_info, sub_req->content_type);\n        set_mime_fields(&mime_info, &accept_info);\n\n        new_var = apr_array_push(neg->avail_vars);\n        memcpy(new_var, (void *) &mime_info, sizeof(var_rec));\n\n        neg->count_multiviews_variants++;\n\n        clean_var_rec(&mime_info);\n    }\n\n    apr_dir_close(dirp);\n\n    /* We found some file names that matched.  None could be served.\n     * Rather than fall out to autoindex or some other mapper, this\n     * request must die.\n     */\n    if (anymatch && !neg->avail_vars->nelts) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Negotiation: discovered file(s) matching request: %s\"\n                      \" (None could be negotiated).\",\n                      r->filename);\n        return HTTP_NOT_FOUND;\n    }\n\n    set_vlist_validator(r, r);\n\n    /* Sort the variants into a canonical order.  The negotiation\n     * result sometimes depends on the order of the variants.  By\n     * sorting the variants into a canonical order, rather than using\n     * the order in which readdir() happens to return them, we ensure\n     * that the negotiation result will be consistent over filesystem\n     * backup/restores and over all mirror sites.\n     */\n\n    qsort((void *) neg->avail_vars->elts, neg->avail_vars->nelts,\n          sizeof(var_rec), (int (*)(const void *, const void *)) variantsortf);\n\n    return OK;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n427,Uncontrolled Search Path Element\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4015e0fa96fe8de60a5c16e814c7eb60c628e535_0", {
    "ID": "httpd_4015e0fa96fe8de60a5c16e814c7eb60c628e535_0",
    "UID": "2563",
    "code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int test_snippet\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking \n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (status == HTTP_NOT_MODIFIED) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    if (status == HTTP_NO_CONTENT) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    if (!r->assbackwards) {\n        apr_table_t *tmp = r->headers_out;\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        r->headers_out = r->err_headers_out;\n        r->err_headers_out = tmp;\n        apr_table_clear(r->err_headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   \n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n        ap_set_content_type(r, \"text/html; charset=iso-8859-1\");\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         * \n         * If it's not a text string, we've got a recursive error or \n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already \n         * backed up to the original error.  If it's an external redirect, \n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rputs(custom_response + 1, r);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the 3 digit status code\n         */\n        if (r->status_line != NULL\n            && strlen(r->status_line) > 4       \n            && apr_isdigit(r->status_line[0])\n            && apr_isdigit(r->status_line[1])\n            && apr_isdigit(r->status_line[2])\n            && apr_isspace(r->status_line[3])\n            && apr_isalnum(r->status_line[4])) {\n            title = r->status_line;\n        }\n\n        \n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_2_0\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (test_snippet {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(test_snippet],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr />\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_dd853b2de02eb1f6e59c35558ed0f0d2482dd22c_0", {
    "ID": "httpd_dd853b2de02eb1f6e59c35558ed0f0d2482dd22c_0",
    "UID": "2566",
    "code": "apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t test_snippet\n{\n#ifndef NO_USE_SIGACTION\n    struct sigaction sa;\n\n    sigemptyset(&sa.sa_mask);\n    \n#if defined(SA_ONESHOT)\n    sa.sa_flags = SA_ONESHOT;\n#elif defined(SA_RESETHAND)\n    sa.sa_flags = SA_RESETHAND;\n#else\n    sa.sa_flags = 0;\n#endif\n\n    sa.sa_handler = sig_coredump;\n    if (sigaction(SIGSEGV, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, \"sigaction(SIGSEGV)\");\n#ifdef SIGBUS\n    if (sigaction(SIGBUS, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, \"sigaction(SIGBUS)\");\n#endif\n#ifdef SIGABORT\n    if (sigaction(SIGABORT, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, \"sigaction(SIGABORT)\");\n#endif\n#ifdef SIGABRT\n    if (sigaction(SIGABRT, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, \"sigaction(SIGABRT)\");\n#endif\n#ifdef SIGILL\n    if (sigaction(SIGILL, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, \"sigaction(SIGILL)\");\n#endif\n\n#else \n    \n    apr_signal(SIGSEGV, sig_coredump);\n#ifdef SIGBUS\n    apr_signal(SIGBUS, sig_coredump);\n#endif \n#ifdef SIGABORT\n    apr_signal(SIGABORT, sig_coredump);\n#endif \n#ifdef SIGABRT\n    apr_signal(SIGABRT, sig_coredump);\n#endif \n#ifdef SIGILL\n    apr_signal(SIGILL, sig_coredump);\n#endif \n\n#endif \n\n    pconf = in_pconf;\n    parent_pid = my_pid = getpid();\n\n    return APR_SUCCESS;\n}",
    "predicted": "null"
  },
  "httpd_429d2728bd79fb27f80db598b9229217c5e26923_0", {
    "ID": "httpd_429d2728bd79fb27f80db598b9229217c5e26923_0",
    "UID": "2591",
    "code": "AP_DECLARE(void) ap_no2slash(char test_snippet\n{\n    char *d, *s;\n\n    s = d = name;\n\n#ifdef HAVE_UNC_PATHS\n    \n    if (s[0] == '/' && s[1] == '/')\n        *d++ = *s++;\n#endif\n\n    while (*s) {\n        if ((*d++ = *s) == '/') {\n            do {\n                ++s;\n            } while (*s == '/');\n        }\n        else {\n            ++s;\n        }\n    }\n    *d = '\\0';\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable"
  },
  "httpd_98b6730abac91971e5a6402d9c250f99ecb0ff73_0", {
    "ID": "httpd_98b6730abac91971e5a6402d9c250f99ecb0ff73_0",
    "UID": "2599",
    "code": "AP_DECLARE(const char *) ap_size_list_item(const char **field, int test_snippet\n{\n    const unsigned char *ptr = (const unsigned char *)*field;\n    const unsigned char *token;\n    int in_qpair, in_qstr, in_com;\n\n    \n\n    while (*ptr == ',' || apr_isspace(*ptr))\n        ++ptr;\n\n    token = ptr;\n\n    \n\n    for (in_qpair = in_qstr = in_com = 0;\n         *ptr && (in_qpair || in_qstr || in_com || *ptr != ',');\n         ++ptr) {\n\n        if (in_qpair) {\n            in_qpair = 0;\n        }\n        else {\n            switch (*ptr) {\n                case '\\\\': in_qpair = 1;      \n                           break;\n                case '\"' : if (!in_com)       \n                               in_qstr = !in_qstr;\n                           break;\n                case '(' : if (!in_qstr)      \n                               ++in_com;\n                           break;\n                case ')' : if (in_com)        \n                               --in_com;\n                           break;\n                default  : break;\n            }\n        }\n    }\n\n    if ((*len = (ptr - token)) == 0) {\n        *field = (const char *)ptr;\n        return NULL;\n    }\n\n    \n\n    while (*ptr == ',' || apr_isspace(*ptr))\n        ++ptr;\n\n    *field = (const char *)ptr;\n    return (const char *)token;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3e4dfb0d28bc41feee895178e805c8b15fd2eeff_0", {
    "ID": "httpd_3e4dfb0d28bc41feee895178e805c8b15fd2eeff_0",
    "UID": "2601",
    "code": "static int open_multi_logs(server_rec *s, apr_pool_t test_snippet\n{\n    int i;\n    multi_log_state *mls = ap_get_module_config(s->module_config,\n                                             &log_config_module);\n    config_log_state *clsarray;\n    const char *dummy;\n    const char *format;\n\n    if (mls->default_format_string) {\n        format = apr_table_get(mls->formats, mls->default_format_string);\n        if (format) {\n            mls->default_format = parse_log_string(p, format, &dummy);\n        }\n    }    \n\n    if (!mls->default_format) {\n        mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT, &dummy);\n    }\n\n    if (mls->config_logs->nelts) {\n        clsarray = (config_log_state *) mls->config_logs->elts;\n        for (i = 0; i < mls->config_logs->nelts; ++i) {\n            config_log_state *cls = &clsarray[i];\n\n            if (cls->format_string) {\n                format = apr_table_get(mls->formats, cls->format_string);\n                if (format) {\n                    cls->format = parse_log_string(p, format, &dummy);\n                }\n            }\n\n            if (!open_config_log(s, p, cls, mls->default_format)) {\n                \n                return DONE;\n            }\n        }\n    }\n    else if (mls->server_config_logs) {\n        clsarray = (config_log_state *) mls->server_config_logs->elts;\n        for (i = 0; i < mls->server_config_logs->nelts; ++i) {\n            config_log_state *cls = &clsarray[i];\n\n            if (cls->format_string) {\n                format = apr_table_get(mls->formats, cls->format_string);\n                if (format) {\n                    cls->format = parse_log_string(p, format, &dummy);\n                }\n            }\n\n            if (!open_config_log(s, p, cls, mls->default_format)) {\n                \n                return DONE;\n            }\n        }\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_222d765cc743042cd07ac7b16df750eb191bd946_0", {
    "ID": "httpd_222d765cc743042cd07ac7b16df750eb191bd946_0",
    "UID": "2614",
    "code": "static char *find_item(request_rec *r, apr_array_header_t *list, int test_snippet\n{\n    const char *content_type = ap_field_noparam(r->pool, r->content_type);\n    const char *content_encoding = r->content_encoding;\n    char *path = r->filename;\n\n    struct item *items = (struct item *) list->elts;\n    int i;\n\n    for (i = 0; i < list->nelts; ++i) {\n        struct item *p = &items[i];\n\n        \n        if ((path[0] == '^') || (!ap_strcmp_match(path, p->apply_path))) {\n            if (!*(p->apply_to)) {\n                return p->data;\n            }\n            else if (p->type == BY_PATH || path[0] == '^') {\n                if (!ap_strcmp_match(path, p->apply_to)) {\n                    return p->data;\n                }\n            }\n            else if (!test_snippet {\n                if (!content_encoding) {\n                    if (p->type == BY_TYPE) {\n                        if (content_type\n                            && !ap_strcasecmp_match(content_type,\n                                                    p->apply_to)) {\n                            return p->data;\n                        }\n                    }\n                }\n                else {\n                    if (p->type == BY_ENCODING) {\n                        if (!ap_strcasecmp_match(content_encoding,\n                                                 p->apply_to)) {\n                            return p->data;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_fac62fe3f7e3e71da791057dd5baf712815c165b_0", {
    "ID": "httpd_fac62fe3f7e3e71da791057dd5baf712815c165b_0",
    "UID": "2616",
    "code": "AP_DECLARE(char *) ap_get_list_item(apr_pool_t *p, const char test_snippet\n{\n    const char *tok_start;\n    const unsigned char *ptr;\n    unsigned char *pos;\n    char *token;\n    int addspace = 0, in_qpair = 0, in_qstr = 0, in_com = 0, tok_len = 0;\n\n    /* Find the beginning and maximum length of the list item so that\n     * we can allocate a buffer for the new string and reset the field.\n     */\n    if ((tok_start = ap_size_list_item(field, &tok_len)) == NULL) {\n        return NULL;\n    }\n    token = apr_palloc(p, tok_len + 1);\n\n    /* Scan the token again, but this time copy only the good bytes.\n     * We skip extra whitespace and any whitespace around a '=', '/',\n     * or ';' and lowercase normal characters not within a comment,\n     * quoted-string or quoted-pair.\n     */\n    for (ptr = (const unsigned char *)tok_start, pos = (unsigned char *)token;\n         *ptr && (in_qpair || in_qstr || in_com || *ptr != ',');\n         ++ptr) {\n\n        if (in_qpair) {\n            in_qpair = 0;\n            *pos++ = *ptr;\n        }\n        else {\n            switch (*ptr) {\n                case '\\\\': in_qpair = 1;\n                           if (addspace == 1)\n                               *pos++ = ' ';\n                           *pos++ = *ptr;\n                           addspace = 0;\n                           break;\n                case '\"' : if (!in_com)\n                               in_qstr = !in_qstr;\n                           if (addspace == 1)\n                               *pos++ = ' ';\n                           *pos++ = *ptr;\n                           addspace = 0;\n                           break;\n                case '(' : if (!in_qstr)\n                               ++in_com;\n                           if (addspace == 1)\n                               *pos++ = ' ';\n                           *pos++ = *ptr;\n                           addspace = 0;\n                           break;\n                case ')' : if (in_com)\n                               --in_com;\n                           *pos++ = *ptr;\n                           addspace = 0;\n                           break;\n                case ' ' :\n                case '\\t': if (addspace)\n                               break;\n                           if (in_com || in_qstr)\n                               *pos++ = *ptr;\n                           else\n                               addspace = 1;\n                           break;\n                case '=' :\n                case '/' :\n                case ';' : if (!(in_com || in_qstr))\n                               addspace = -1;\n                           *pos++ = *ptr;\n                           break;\n                default  : if (addspace == 1)\n                               *pos++ = ' ';\n                           *pos++ = (in_com || in_qstr) ? *ptr\n                                                        : apr_tolower(*ptr);\n                           addspace = 0;\n                           break;\n            }\n        }\n    }\n    *pos = '\\0';\n\n    return token;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_7021858c464cd7f7a2441ead59b61685c5716f18_0", {
    "ID": "httpd_7021858c464cd7f7a2441ead59b61685c5716f18_0",
    "UID": "2620",
    "code": "static apr_status_t flush_all_logs(void test_snippet\n{\n    server_rec *s = data;\n    multi_log_state *mls;\n    apr_array_header_t *log_list;\n    config_log_state *clsarray;\n    buffered_log *buf;\n    int i;\n\n    if (!buffered_logs)\n        return APR_SUCCESS;\n    \n    for (; s; s = s->next) {\n        mls = ap_get_module_config(s->module_config, &log_config_module);\n        log_list = NULL;\n        if (mls->config_logs->nelts) {\n            log_list = mls->config_logs;\n        }\n        else if (mls->server_config_logs) {\n            log_list = mls->server_config_logs;\n        }\n        if (log_list) {\n            clsarray = (config_log_state *) log_list->elts;\n            for (i = 0; i < log_list->nelts; ++i) {\n                buf = clsarray[i].log_writer;\n                flush_log(buf);\n            }\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5509cc31961474cd4100bf54b58e1ce9a0957537_0", {
    "ID": "httpd_5509cc31961474cd4100bf54b58e1ce9a0957537_0",
    "UID": "2622",
    "code": "AP_DECLARE(void) ap_copy_method_list(ap_method_list_t test_snippet\n                                     ap_method_list_t *src)\n{\n    int i;\n    char **imethods;\n    char **omethods;\n\n    dest->method_mask = src->method_mask;\n    imethods = (char **) src->method_list->elts;\n    for (i = 0; i < src->method_list->nelts; ++i) {\n        omethods = (char **) apr_array_push(dest->method_list);\n        *omethods = apr_pstrdup(dest->method_list->pool, imethods[i]);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2576d748e06606d3307a720fc9b914b303bdac21_0", {
    "ID": "httpd_2576d748e06606d3307a720fc9b914b303bdac21_0",
    "UID": "2626",
    "code": "AP_DECLARE(const char *) ap_soak_end_container(cmd_parms *cmd, char test_snippet\n{\n    char l[MAX_STRING_LEN];\n    const char *args;\n    char *cmd_name;\n\n    while(!(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {\n#if RESOLVE_ENV_PER_TOKEN\n        args = l;\n#else\n        args = ap_resolve_env(cmd->temp_pool, l);\n#endif\n\n        cmd_name = ap_getword_conf(cmd->pool, &args);\n        if (cmd_name[0] == '<') {\n            if (cmd_name[1] == '/') {\n                cmd_name[strlen(cmd_name) - 1] = '\\0';\n\n                if (strcasecmp(cmd_name + 2, directive + 1) != 0) {\n                    return apr_pstrcat(cmd->pool, \"Expected </\",\n                                       directive + 1, \"> but saw \",\n                                       cmd_name, \">\", NULL);\n                }\n\n                return NULL; \n            }\n            else {\n                const char *msg;\n\n                if (*args == '\\0' && cmd_name[strlen(cmd_name) - 1] == '>') {\n                    cmd_name[strlen(cmd_name) - 1] = '\\0';\n                }\n\n                if ((msg = ap_soak_end_container(cmd, cmd_name)) != NULL) {\n                    return msg;\n                }\n            }\n        }\n    }\n\n    return apr_pstrcat(cmd->pool, \"Expected </\",\n                       directive + 1, \"> before end of configuration\",\n                       NULL);\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_e1c611bde4d900fe912c046228e574b86a4d7d4e_0", {
    "ID": "httpd_e1c611bde4d900fe912c046228e574b86a4d7d4e_0",
    "UID": "2629",
    "code": "static struct ent *make_autoindex_entry(const apr_finfo_t test_snippet\n                                        int autoindex_opts,\n                                        autoindex_config_rec *d,\n                                        request_rec *r, char keyid,\n                                        char direction,\n                                        const char *pattern)\n{\n    request_rec *rr;\n    struct ent *p;\n    int show_forbidden = 0;\n\n    \n    if ((dirent->name[0] == '.') && (!dirent->name[1]\n        || ((dirent->name[1] == '.') && !dirent->name[2])))\n        return (NULL);\n\n    /*\n     * On some platforms, the match must be case-blind.  This is really\n     * a factor of the filesystem involved, but we can't detect that\n     * reliably - so we have to granularise at the OS level.\n     */\n    if (pattern && (apr_fnmatch(pattern, dirent->name,\n                                APR_FNM_NOESCAPE | APR_FNM_PERIOD\n#ifdef CASE_BLIND_FILESYSTEM\n                                | APR_FNM_CASE_BLIND\n#endif\n                                )\n                    != APR_SUCCESS)) {\n        return (NULL);\n    }\n\n    if (ignore_entry(d, ap_make_full_path(r->pool,\n                                          r->filename, dirent->name))) {\n        return (NULL);\n    }\n\n    if (!(rr = ap_sub_req_lookup_dirent(dirent, r, AP_SUBREQ_NO_ARGS, NULL))) {\n        return (NULL);\n    }\n\n    if((autoindex_opts & SHOW_FORBIDDEN)  \n        && (rr->status == HTTP_UNAUTHORIZED || rr->status == HTTP_FORBIDDEN)) {\n        show_forbidden = 1;\n    }\n\n    if ((rr->finfo.filetype != APR_DIR && rr->finfo.filetype != APR_REG)\n        || !(rr->status == OK || ap_is_HTTP_SUCCESS(rr->status)\n                              || ap_is_HTTP_REDIRECT(rr->status)\n                              || show_forbidden == 1)) {\n        ap_destroy_sub_req(rr);\n        return (NULL);\n    }\n\n    p = (struct ent *) apr_pcalloc(r->pool, sizeof(struct ent));\n    if (dirent->filetype == APR_DIR) {\n        p->name = apr_pstrcat(r->pool, dirent->name, \"/\", NULL);\n    }\n    else {\n        p->name = apr_pstrdup(r->pool, dirent->name);\n    }\n    p->size = -1;\n    p->icon = NULL;\n    p->alt = NULL;\n    p->desc = NULL;\n    p->lm = -1;\n    p->isdir = 0;\n    p->key = apr_toupper(keyid);\n    p->ascending = (apr_toupper(direction) == D_ASCENDING);\n    p->version_sort = !!(autoindex_opts & VERSION_SORT);\n    p->ignore_case = !!(autoindex_opts & IGNORE_CASE);\n\n    if (autoindex_opts & (FANCY_INDEXING | TABLE_INDEXING)) {\n        p->lm = rr->finfo.mtime;\n        if (dirent->filetype == APR_DIR) {\n            if (autoindex_opts & FOLDERS_FIRST) {\n                p->isdir = 1;\n            }\n            rr->filename = ap_make_dirstr_parent (rr->pool, rr->filename);\n\n            \n            rr->filename[strlen(rr->filename) - 1] = '\\0';\n\n            if (!(p->icon = find_icon(d, rr, 1))) {\n                p->icon = find_default_icon(d, \"^^DIRECTORY^^\");\n            }\n            if (!(p->alt = find_alt(d, rr, 1))) {\n                if (!(p->alt = find_default_alt(d, \"^^DIRECTORY^^\"))) {\n                    p->alt = \"DIR\";\n                }\n            }\n        }\n        else {\n            p->icon = find_icon(d, rr, 0);\n            p->alt = find_alt(d, rr, 0);\n            p->size = rr->finfo.size;\n        }\n\n        p->desc = find_desc(d, rr->filename);\n\n        if ((!p->desc) && (autoindex_opts & SCAN_HTML_TITLES)) {\n            p->desc = apr_pstrdup(r->pool, find_title(rr));\n        }\n    }\n    ap_destroy_sub_req(rr);\n    /*\n     * We don't need to take any special action for the file size key.\n     * If we did, it would go here.\n     */\n    if (keyid == K_LAST_MOD) {\n        if (p->lm < 0) {\n            p->lm = 0;\n        }\n    }\n    return (p);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_83f79e50165e811b715de951dde2322562911da9_0", {
    "ID": "httpd_83f79e50165e811b715de951dde2322562911da9_0",
    "UID": "2640",
    "code": "AP_DECLARE(int) ap_find_list_item(apr_pool_t *p, const char test_snippet\n                                  const char *tok)\n{\n    const unsigned char *pos;\n    const unsigned char *ptr = (const unsigned char *)line;\n    int good = 0, addspace = 0, in_qpair = 0, in_qstr = 0, in_com = 0;\n\n    if (!line || !tok)\n        return 0;\n\n    do {  \n\n        \n\n        while (*ptr == ',' || apr_isspace(*ptr))\n            ++ptr;\n\n        if (*ptr)\n            good = 1;  \n        else\n            break;     \n\n        /* We skip extra whitespace and any whitespace around a '=', '/',\n         * or ';' and lowercase normal characters not within a comment,\n         * quoted-string or quoted-pair.\n         */\n        for (pos = (const unsigned char *)tok;\n             *ptr && (in_qpair || in_qstr || in_com || *ptr != ',');\n             ++ptr) {\n\n            if (in_qpair) {\n                in_qpair = 0;\n                if (good)\n                    good = (*pos++ == *ptr);\n            }\n            else {\n                switch (*ptr) {\n                    case '\\\\': in_qpair = 1;\n                               if (addspace == 1)\n                                   good = good && (*pos++ == ' ');\n                               good = good && (*pos++ == *ptr);\n                               addspace = 0;\n                               break;\n                    case '\"' : if (!in_com)\n                                   in_qstr = !in_qstr;\n                               if (addspace == 1)\n                                   good = good && (*pos++ == ' ');\n                               good = good && (*pos++ == *ptr);\n                               addspace = 0;\n                               break;\n                    case '(' : if (!in_qstr)\n                                   ++in_com;\n                               if (addspace == 1)\n                                   good = good && (*pos++ == ' ');\n                               good = good && (*pos++ == *ptr);\n                               addspace = 0;\n                               break;\n                    case ')' : if (in_com)\n                                   --in_com;\n                               good = good && (*pos++ == *ptr);\n                               addspace = 0;\n                               break;\n                    case ' ' :\n                    case '\\t': if (addspace || !good)\n                                   break;\n                               if (in_com || in_qstr)\n                                   good = (*pos++ == *ptr);\n                               else\n                                   addspace = 1;\n                               break;\n                    case '=' :\n                    case '/' :\n                    case ';' : if (!(in_com || in_qstr))\n                                   addspace = -1;\n                               good = good && (*pos++ == *ptr);\n                               break;\n                    default  : if (!good)\n                                   break;\n                               if (addspace == 1)\n                                   good = (*pos++ == ' ');\n                               if (in_com || in_qstr)\n                                   good = good && (*pos++ == *ptr);\n                               else\n                                   good = good && (*pos++ == apr_tolower(*ptr));\n                               addspace = 0;\n                               break;\n                }\n            }\n        }\n        if (good && *pos)\n            good = 0;          \n\n    } while (*ptr && !good);\n\n    return good;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_cf8ccdfe77258a975a8751e13906d5dec7d99563_0", {
    "ID": "httpd_cf8ccdfe77258a975a8751e13906d5dec7d99563_0",
    "UID": "2648",
    "code": "AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char test_snippet\n{\n    int methnum;\n    int i;\n    const char **xmethod;\n    char **methods;\n\n    /*\n     * If it's one of our known methods, use the shortcut and use the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    l->method_mask |= (AP_METHOD_BIT << methnum);\n    if (methnum != M_INVALID) {\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (l->method_list->nelts != 0) {\n        methods = (char **)l->method_list->elts;\n        for (i = 0; i < l->method_list->nelts; ++i) {\n            if (strcmp(method, methods[i]) == 0) {\n                return;\n            }\n        }\n    }\n    xmethod = (const char **) apr_array_push(l->method_list);\n    *xmethod = method;\n}",
    "predicted": "415,Double Free\n416,Use After Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n762,Mismatched Memory Management Routines\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_e2eacbd1d76b7131f0f916373cae4c83292396c5_0", {
    "ID": "httpd_e2eacbd1d76b7131f0f916373cae4c83292396c5_0",
    "UID": "2650",
    "code": "static const char *set_options(cmd_parms *cmd, void *d_, const char test_snippet\n{\n    core_dir_config *d = d_;\n    allow_options_t opt;\n    int first = 1;\n    char action;\n\n    while (l[0]) {\n        char *w = ap_getword_conf(cmd->pool, &l);\n        action = '\\0';\n\n        if (*w == '+' || *w == '-') {\n            action = *(w++);\n        }\n        else if (first) {\n              d->opts = OPT_NONE;\n            first = 0;\n        }\n\n        if (!strcasecmp(w, \"Indexes\")) {\n            opt = OPT_INDEXES;\n        }\n        else if (!strcasecmp(w, \"Includes\")) {\n            opt = OPT_INCLUDES;\n        }\n        else if (!strcasecmp(w, \"IncludesNOEXEC\")) {\n            opt = (OPT_INCLUDES | OPT_INCNOEXEC);\n        }\n        else if (!strcasecmp(w, \"FollowSymLinks\")) {\n            opt = OPT_SYM_LINKS;\n        }\n        else if (!strcasecmp(w, \"SymLinksIfOwnerMatch\")) {\n            opt = OPT_SYM_OWNER;\n        }\n        else if (!strcasecmp(w, \"ExecCGI\")) {\n            opt = OPT_EXECCGI;\n        }\n        else if (!strcasecmp(w, \"MultiViews\")) {\n            opt = OPT_MULTI;\n        }\n        else if (!strcasecmp(w, \"RunScripts\")) { \n            opt = OPT_MULTI|OPT_EXECCGI;\n        }\n        else if (!strcasecmp(w, \"None\")) {\n            opt = OPT_NONE;\n        }\n        else if (!strcasecmp(w, \"All\")) {\n            opt = OPT_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal option \", w, NULL);\n        }\n\n\tif (!(cmd->override_opts & opt) && opt != OPT_NONE) {\n\t    return apr_pstrcat(cmd->pool, \"Option \", w, \" not allowed here\", NULL);\n        }\n        else if (action == '-') {\n            \n            d->opts_remove |= opt;\n            d->opts_add &= ~opt;\n            d->opts &= ~opt;\n        }\n        else if (action == '+') {\n            d->opts_add |= opt;\n            d->opts_remove &= ~opt;\n            d->opts |= opt;\n        }\n        else {\n            d->opts |= opt;\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_be6177633ad8448a29ea5b33c31363001ccde518_0", {
    "ID": "httpd_be6177633ad8448a29ea5b33c31363001ccde518_0",
    "UID": "2651",
    "code": "AP_DECLARE(void) ap_method_list_remove(ap_method_list_t test_snippet\n                                       const char *method)\n{\n    int methnum;\n    char **methods;\n\n    /*\n     * If it's a known methods, either builtin or registered\n     * by a module, use the bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    l->method_mask |= ~(AP_METHOD_BIT << methnum);\n    if (methnum != M_INVALID) {\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (l->method_list->nelts != 0) {\n        register int i, j, k;\n        methods = (char **)l->method_list->elts;\n        for (i = 0; i < l->method_list->nelts; ) {\n            if (strcmp(method, methods[i]) == 0) {\n                for (j = i, k = i + 1; k < l->method_list->nelts; ++j, ++k) {\n                    methods[j] = methods[k];\n                }\n                --l->method_list->nelts;\n            }\n            else {\n                ++i;\n            }\n        }\n    }\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_e78b3aeda1667c499fa43ed4a879d2802f9ee7e1_0", {
    "ID": "httpd_e78b3aeda1667c499fa43ed4a879d2802f9ee7e1_0",
    "UID": "2666",
    "code": "static const char *process_resource_config_nofnmatch(server_rec test_snippet\n                                                     const char *fname,\n                                                     ap_directive_t **conftree,\n                                                     apr_pool_t *p,\n                                                     apr_pool_t *ptemp,\n                                                     unsigned depth)\n{\n    cmd_parms parms;\n    ap_configfile_t *cfp;\n    const char *error;\n\n    if (ap_is_directory(p, fname)) {\n        apr_dir_t *dirp;\n        apr_finfo_t dirent;\n        int current;\n        apr_array_header_t *candidates = NULL;\n        fnames *fnew;\n        apr_status_t rv;\n        char *path = apr_pstrdup(p, fname);\n\n        if (++depth > AP_MAX_INCLUDE_DIR_DEPTH) {\n            return apr_psprintf(p, \"Directory %s exceeds the maximum include \"\n                                \"directory nesting level of %u. You have \"\n                                \"probably a recursion somewhere.\", path,\n                                AP_MAX_INCLUDE_DIR_DEPTH);\n        }\n\n        /*\n         * first course of business is to grok all the directory\n         * entries here and store 'em away. Recall we need full pathnames\n         * for this.\n         */\n        rv = apr_dir_open(&dirp, path, p);\n        if (rv != APR_SUCCESS) {\n            char errmsg[120];\n            return apr_psprintf(p, \"Could not open config directory %s: %s\",\n                                path, apr_strerror(rv, errmsg, sizeof errmsg));\n        }\n\n        candidates = apr_array_make(p, 1, sizeof(fnames));\n        while (apr_dir_read(&dirent, APR_FINFO_DIRENT, dirp) == APR_SUCCESS) {\n            \n            if (strcmp(dirent.name, \".\")\n                && strcmp(dirent.name, \"..\")) {\n                fnew = (fnames *) apr_array_push(candidates);\n                fnew->fname = ap_make_full_path(p, path, dirent.name);\n            }\n        }\n\n        apr_dir_close(dirp);\n        if (candidates->nelts != 0) {\n            qsort((void *) candidates->elts, candidates->nelts,\n                  sizeof(fnames), fname_alphasort);\n\n            /*\n             * Now recurse these... we handle errors and subdirectories\n             * via the recursion, which is nice\n             */\n            for (current = 0; current < candidates->nelts; ++current) {\n                fnew = &((fnames *) candidates->elts)[current];\n                error = process_resource_config_nofnmatch(s, fnew->fname,\n                                                          conftree, p, ptemp,\n                                                          depth);\n                if (error) {\n                    return error;\n                }\n            }\n        }\n\n        return NULL;\n    }\n\n    \n    parms = default_parms;\n    parms.pool = p;\n    parms.temp_pool = ptemp;\n    parms.server = s;\n    parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);\n    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;\n\n    if (ap_pcfg_openfile(&cfp, p, fname) != APR_SUCCESS) {\n        return apr_pstrcat(p, \"Could not open document config file \",\n                           fname, NULL);\n    }\n\n    parms.config_file = cfp;\n    error = ap_build_config(&parms, p, ptemp, conftree);\n    ap_cfg_closefile(cfp);\n\n    if (error) {\n        return apr_psprintf(p, \"Syntax error on line %d of %s: %s\",\n                            parms.err_directive->line_num,\n                            parms.err_directive->filename, error);\n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_effe477c5e0738584ea833a8983c03038a8a50e3_0", {
    "ID": "httpd_effe477c5e0738584ea833a8983c03038a8a50e3_0",
    "UID": "2668",
    "code": "AP_DECLARE(int) ap_vrprintf(request_rec *r, const char *fmt, va_list test_snippet\n{\n    apr_size_t written;\n    struct ap_vrprintf_data vd;\n    char vrprintf_buf[AP_IOBUFSIZE];\n\n    vd.vbuff.curpos = vrprintf_buf;\n    vd.vbuff.endpos = vrprintf_buf + AP_IOBUFSIZE;\n    vd.r = r;\n    vd.buff = vrprintf_buf;\n\n    if (r->connection->aborted)\n        return -1;\n\n    written = apr_vformatter(r_flush, &vd.vbuff, fmt, test_snippet;\n\n    \n    *(vd.vbuff.curpos) = '\\0';\n\n    if (written != -1) {\n        int n = vd.vbuff.curpos - vrprintf_buf;\n\n        \n        if (buffer_output(r, vrprintf_buf,n) != APR_SUCCESS)\n            return -1;\n\n        written += n;\n    }\n\n    return written;\n}",
    "predicted": "134,Use of Externally-Controlled Format String\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_25ad6df315ccf247b621a4cc3f1ca3a8eff5c122_0", {
    "ID": "httpd_25ad6df315ccf247b621a4cc3f1ca3a8eff5c122_0",
    "UID": "2669",
    "code": "static const char *set_etag_bits(cmd_parms *cmd, void test_snippet\n                                 const char *args_p)\n{\n    core_dir_config *cfg;\n    etag_components_t bit;\n    char action;\n    char *token;\n    const char *args;\n    int valid;\n    int first;\n    int explicit;\n\n    cfg = (core_dir_config *)mconfig;\n\n    args = args_p;\n    first = 1;\n    explicit = 0;\n    while (args[0] != '\\0') {\n        action = '*';\n        bit = ETAG_UNSET;\n        valid = 1;\n        token = ap_getword_conf(cmd->pool, &args);\n        if ((*token == '+') || (*token == '-')) {\n            action = *token;\n            token++;\n        }\n        else {\n            /*\n             * The occurrence of an absolute setting wipes\n             * out any previous relative ones.  The first such\n             * occurrence forgets any inherited ones, too.\n             */\n            if (first) {\n                cfg->etag_bits = ETAG_UNSET;\n                cfg->etag_add = ETAG_UNSET;\n                cfg->etag_remove = ETAG_UNSET;\n                first = 0;\n            }\n        }\n\n        if (strcasecmp(token, \"None\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                cfg->etag_bits = bit = ETAG_NONE;\n                explicit = 1;\n            }\n        }\n        else if (strcasecmp(token, \"All\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                explicit = 1;\n                cfg->etag_bits = bit = ETAG_ALL;\n            }\n        }\n        else if (strcasecmp(token, \"Size\") == 0) {\n            bit = ETAG_SIZE;\n        }\n        else if ((strcasecmp(token, \"LMTime\") == 0)\n                 || (strcasecmp(token, \"MTime\") == 0)\n                 || (strcasecmp(token, \"LastModified\") == 0)) {\n            bit = ETAG_MTIME;\n        }\n        else if (strcasecmp(token, \"INode\") == 0) {\n            bit = ETAG_INODE;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Unknown keyword '\",\n                               token, \"' for \", cmd->cmd->name,\n                               \" directive\", NULL);\n        }\n\n        if (! valid) {\n            return apr_pstrcat(cmd->pool, cmd->cmd->name, \" keyword '\",\n                               token, \"' cannot be used with '+' or '-'\",\n                               NULL);\n        }\n\n        if (action == '+') {\n            /*\n             * Make sure it's in the 'add' list and absent from the\n             * 'subtract' list.\n             */\n            cfg->etag_add |= bit;\n            cfg->etag_remove &= (~ bit);\n        }\n        else if (action == '-') {\n            cfg->etag_remove |= bit;\n            cfg->etag_add &= (~ bit);\n        }\n        else {\n            /*\n             * Non-relative values wipe out any + or - values\n             * accumulated so far.\n             */\n            cfg->etag_bits |= bit;\n            cfg->etag_add = ETAG_UNSET;\n            cfg->etag_remove = ETAG_UNSET;\n            explicit = 1;\n        }\n    }\n\n    /*\n     * Any setting at all will clear the 'None' and 'Unset' bits.\n     */\n\n    if (cfg->etag_add != ETAG_UNSET) {\n        cfg->etag_add &= (~ ETAG_UNSET);\n    }\n\n    if (cfg->etag_remove != ETAG_UNSET) {\n        cfg->etag_remove &= (~ ETAG_UNSET);\n    }\n\n    if (explicit) {\n        cfg->etag_bits &= (~ ETAG_UNSET);\n\n        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {\n            cfg->etag_bits &= (~ ETAG_NONE);\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_31416f1ffa7593ab4398ea521a2ba8a9b2f7c9ac_0", {
    "ID": "httpd_31416f1ffa7593ab4398ea521a2ba8a9b2f7c9ac_0",
    "UID": "2674",
    "code": "static void output_directories(struct ent **ar, int test_snippet\n                               autoindex_config_rec *d, request_rec *r,\n                               apr_int32_t autoindex_opts, char keyid,\n                               char directiotest_snippet const char *colargs)\n{\n    int x;\n    apr_size_t rv;\n    char *name = r->uri;\n    char *tp;\n    int static_columns = !!(autoindex_opts & SUPPRESS_COLSORT);\n    apr_pool_t *scratch;\n    int name_width;\n    int desc_width;\n    char *name_scratch;\n    char *pad_scratch;\n    char *breakrow = \"\";\n\n    apr_pool_create(&scratch, r->pool);\n    if (name[0] == '\\0') {\n        name = \"/\";\n    }\n\n    name_width = d->name_width;\n    desc_width = d->desc_width;\n\n    if ((autoindex_opts & (FANCY_INDEXING | TABLE_INDEXING))\n                        == FANCY_INDEXING) {\n        if (d->name_adjust == K_ADJUST) {\n            for (x = 0; x < n; x++) {\n                int t = strlen(ar[x]->name);\n                if (t > name_width) {\n                    name_width = t;\n                }\n            }\n        }\n\n        if (d->desc_adjust == K_ADJUST) {\n            for (x = 0; x < n; x++) {\n                if (ar[x]->desc != NULL) {\n                    int t = strlen(ar[x]->desc);\n                    if (t > desc_width) {\n                        desc_width = t;\n                    }\n                }\n            }\n        }\n    }\n    name_scratch = apr_palloc(r->pool, name_width + 1);\n    pad_scratch = apr_palloc(r->pool, name_width + 1);\n    memset(pad_scratch, ' ', name_width);\n    pad_scratch[name_width] = '\\0';\n\n    if (autoindex_opts & TABLE_INDEXING) {\n        int cols = 1;\n        ap_rputs(\"<table><tr>\", r);\n        if (!(autoindex_opts & SUPPRESS_ICON)) {\n            ap_rputs(\"<th>\", r);\n            if ((tp = find_default_icon(d, \"^^BLANKICON^^\"))) {\n                ap_rvputs(r, \"<img src=\\\"\", ap_escape_html(scratch, tp),\n                             \"\\\" alt=\\\"[ICO]\\\"\", NULL);\n                if (d->icon_width) {\n                    ap_rprintf(r, \" width=\\\"%d\\\"\", d->icon_width);\n                }\n                if (d->icon_height) {\n                    ap_rprintf(r, \" height=\\\"%d\\\"\", d->icon_height);\n                }\n\n                if (autoindex_opts & EMIT_XHTML) {\n                    ap_rputs(\" /\", r);\n                }\n                ap_rputs(\"></th>\", r);\n            }\n            else {\n                ap_rputs(\"&nbsp;</th>\", r);\n            }\n\n            ++cols;\n        }\n        ap_rputs(\"<th>\", r);\n        emit_link(r, \"Name\", K_NAME, keyid, directiotest_snippet\n                  colargs, static_columns);\n        if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {\n            ap_rputs(\"</th><th>\", r);\n            emit_link(r, \"Last modified\", K_LAST_MOD, keyid, directiotest_snippet\n                      colargs, static_columns);\n            ++cols;\n        }\n        if (!(autoindex_opts & SUPPRESS_SIZE)) {\n            ap_rputs(\"</th><th>\", r);\n            emit_link(r, \"Size\", K_SIZE, keyid, directiotest_snippet\n                      colargs, static_columns);\n            ++cols;\n        }\n        if (!(autoindex_opts & SUPPRESS_DESC)) {\n            ap_rputs(\"</th><th>\", r);\n            emit_link(r, \"Description\", K_DESC, keyid, directiotest_snippet\n                      colargs, static_columns);\n            ++cols;\n        }\n        if (!(autoindex_opts & SUPPRESS_RULES)) {\n            breakrow = apr_psprintf(r->pool,\n                                    \"<tr><th colspan=\\\"%d\\\">\"\n                                    \"<hr%s></th></tr>\\n\", cols,\n                                    (autoindex_opts & EMIT_XHTML) ? \" /\" : \"\");\n        }\n        ap_rvputs(r, \"</th></tr>\", breakrow, NULL);\n    }\n    else if (autoindex_opts & FANCY_INDEXING) {\n        ap_rputs(\"<pre>\", r);\n        if (!(autoindex_opts & SUPPRESS_ICON)) {\n            if ((tp = find_default_icon(d, \"^^BLANKICON^^\"))) {\n                ap_rvputs(r, \"<img src=\\\"\", ap_escape_html(scratch, tp),\n                             \"\\\" alt=\\\"Icon \\\"\", NULL);\n                if (d->icon_width) {\n                    ap_rprintf(r, \" width=\\\"%d\\\"\", d->icon_width);\n                }\n                if (d->icon_height) {\n                    ap_rprintf(r, \" height=\\\"%d\\\"\", d->icon_height);\n                }\n\n                if (autoindex_opts & EMIT_XHTML) {\n                    ap_rputs(\" /\", r);\n                }\n                ap_rputs(\"> \", r);\n            }\n            else {\n                ap_rputs(\"      \", r);\n            }\n        }\n        emit_link(r, \"Name\", K_NAME, keyid, directiotest_snippet\n                  colargs, static_columns);\n        ap_rputs(pad_scratch + 4, r);\n        /*\n         * Emit the guaranteed-at-least-one-space-between-columns byte.\n         */\n        ap_rputs(\" \", r);\n        if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {\n            emit_link(r, \"Last modified\", K_LAST_MOD, keyid, directiotest_snippet\n                      colargs, static_columns);\n            ap_rputs(\"      \", r);\n        }\n        if (!(autoindex_opts & SUPPRESS_SIZE)) {\n            emit_link(r, \"Size\", K_SIZE, keyid, directiotest_snippet\n                      colargs, static_columns);\n            ap_rputs(\"  \", r);\n        }\n        if (!(autoindex_opts & SUPPRESS_DESC)) {\n            emit_link(r, \"Description\", K_DESC, keyid, directiotest_snippet\n                      colargs, static_columns);\n        }\n        if (!(autoindex_opts & SUPPRESS_RULES)) {\n            ap_rputs(\"<hr\", r);\n            if (autoindex_opts & EMIT_XHTML) {\n                ap_rputs(\" /\", r);\n            }\n            ap_rputs(\">\", r);\n        }\n        else {\n            ap_rputc('\\n', r);\n        }\n    }\n    else {\n        ap_rputs(\"<ul>\", r);\n    }\n\n    for (x = 0; x < n; x++) {\n        char *anchor, *t, *t2;\n        int nwidth;\n\n        apr_pool_clear(scratch);\n\n        t = ar[x]->name;\n        anchor = ap_escape_html(scratch, ap_os_escape_path(scratch, t, 0));\n\n        if (!x && t[0] == '/') {\n            t2 = \"Parent Directory\";\n        }\n        else {\n            t2 = t;\n        }\n\n        if (autoindex_opts & TABLE_INDEXING) {\n            ap_rputs(\"<tr>\", r);\n            if (!(autoindex_opts & SUPPRESS_ICON)) {\n                ap_rputs(\"<td valign=\\\"top\\\">\", r);\n                if (autoindex_opts & ICONS_ARE_LINKS) {\n                    ap_rvputs(r, \"<a href=\\\"\", anchor, \"\\\">\", NULL);\n                }\n                if ((ar[x]->icon) || d->default_icon) {\n                    ap_rvputs(r, \"<img src=\\\"\",\n                              ap_escape_html(scratch,\n                                             ar[x]->icon ? ar[x]->icon\n                                                         : d->default_icon),\n                              \"\\\" alt=\\\"[\", (ar[x]->alt ? ar[x]->alt : \"   \"),\n                              \"]\\\"\", NULL);\n                    if (d->icon_width) {\n                        ap_rprintf(r, \" width=\\\"%d\\\"\", d->icon_width);\n                    }\n                    if (d->icon_height) {\n                        ap_rprintf(r, \" height=\\\"%d\\\"\", d->icon_height);\n                    }\n\n                    if (autoindex_opts & EMIT_XHTML) {\n                        ap_rputs(\" /\", r);\n                    }\n                    ap_rputs(\">\", r);\n                }\n                else {\n                    ap_rputs(\"&nbsp;\", r);\n                }\n                if (autoindex_opts & ICONS_ARE_LINKS) {\n                    ap_rputs(\"</a></td>\", r);\n                }\n                else {\n                    ap_rputs(\"</td>\", r);\n                }\n            }\n            if (d->name_adjust == K_ADJUST) {\n                ap_rvputs(r, \"<td><a href=\\\"\", anchor, \"\\\">\",\n                          ap_escape_html(scratch, t2), \"</a>\", NULL);\n            }\n            else {\n                nwidth = strlen(t2);\n                if (nwidth > name_width) {\n                  memcpy(name_scratch, t2, name_width - 3);\n                  name_scratch[name_width - 3] = '.';\n                  name_scratch[name_width - 2] = '.';\n                  name_scratch[name_width - 1] = '>';\n                  name_scratch[name_width] = 0;\n                  t2 = name_scratch;\n                  nwidth = name_width;\n                }\n                ap_rvputs(r, \"<td><a href=\\\"\", anchor, \"\\\">\",\n                          ap_escape_html(scratch, t2),\n                          \"</a>\", pad_scratch + nwidth, NULL);\n            }\n            if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {\n                if (ar[x]->lm != -1) {\n                    char time_str[MAX_STRING_LEN];\n                    apr_time_exp_t ts;\n                    apr_time_exp_lt(&ts, ar[x]->lm);\n                    apr_strftime(time_str, &rv, MAX_STRING_LEN,\n                                 \"</td><td align=\\\"right\\\">%d-%b-%Y %H:%M  \",\n                                 &ts);\n                    ap_rputs(time_str, r);\n                }\n                else {\n                    ap_rputs(\"</td><td>&nbsp;\", r);\n                }\n            }\n            if (!(autoindex_opts & SUPPRESS_SIZE)) {\n                char buf[5];\n                ap_rvputs(r, \"</td><td align=\\\"right\\\">\",\n                          apr_strfsize(ar[x]->size, buf), NULL);\n            }\n            if (!(autoindex_opts & SUPPRESS_DESC)) {\n                if (ar[x]->desc) {\n                    if (d->desc_adjust == K_ADJUST) {\n                        ap_rvputs(r, \"</td><td>\", ar[x]->desc, NULL);\n                    }\n                    else {\n                        ap_rvputs(r, \"</td><td>\",\n                                  terminate_description(d, ar[x]->desc,\n                                                        autoindex_opts,\n                                                        desc_width), NULL);\n                    }\n                }\n            }\n            else {\n                ap_rputs(\"</td><td>&nbsp;\", r);\n            }\n            ap_rputs(\"</td></tr>\\n\", r);\n        }\n        else if (autoindex_opts & FANCY_INDEXING) {\n            if (!(autoindex_opts & SUPPRESS_ICON)) {\n                if (autoindex_opts & ICONS_ARE_LINKS) {\n                    ap_rvputs(r, \"<a href=\\\"\", anchor, \"\\\">\", NULL);\n                }\n                if ((ar[x]->icon) || d->default_icon) {\n                    ap_rvputs(r, \"<img src=\\\"\",\n                              ap_escape_html(scratch,\n                                             ar[x]->icon ? ar[x]->icon\n                                                         : d->default_icon),\n                              \"\\\" alt=\\\"[\", (ar[x]->alt ? ar[x]->alt : \"   \"),\n                              \"]\\\"\", NULL);\n                    if (d->icon_width) {\n                        ap_rprintf(r, \" width=\\\"%d\\\"\", d->icon_width);\n                    }\n                    if (d->icon_height) {\n                        ap_rprintf(r, \" height=\\\"%d\\\"\", d->icon_height);\n                    }\n\n                    if (autoindex_opts & EMIT_XHTML) {\n                        ap_rputs(\" /\", r);\n                    }\n                    ap_rputs(\">\", r);\n                }\n                else {\n                    ap_rputs(\"     \", r);\n                }\n                if (autoindex_opts & ICONS_ARE_LINKS) {\n                    ap_rputs(\"</a> \", r);\n                }\n                else {\n                    ap_rputc(' ', r);\n                }\n            }\n            nwidth = strlen(t2);\n            if (nwidth > name_width) {\n                memcpy(name_scratch, t2, name_width - 3);\n                name_scratch[name_width - 3] = '.';\n                name_scratch[name_width - 2] = '.';\n                name_scratch[name_width - 1] = '>';\n                name_scratch[name_width] = 0;\n                t2 = name_scratch;\n                nwidth = name_width;\n            }\n            ap_rvputs(r, \"<a href=\\\"\", anchor, \"\\\">\",\n                      ap_escape_html(scratch, t2),\n                      \"</a>\", pad_scratch + nwidth, NULL);\n            /*\n             * The blank before the storm.. er, before the next field.\n             */\n            ap_rputs(\" \", r);\n            if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {\n                if (ar[x]->lm != -1) {\n                    char time_str[MAX_STRING_LEN];\n                    apr_time_exp_t ts;\n                    apr_time_exp_lt(&ts, ar[x]->lm);\n                    apr_strftime(time_str, &rv, MAX_STRING_LEN,\n                                \"%d-%b-%Y %H:%M  \", &ts);\n                    ap_rputs(time_str, r);\n                }\n                else {\n                    \n                    ap_rputs(\"                   \", r);\n                }\n            }\n            if (!(autoindex_opts & SUPPRESS_SIZE)) {\n                char buf[5];\n                ap_rputs(apr_strfsize(ar[x]->size, buf), r);\n                ap_rputs(\"  \", r);\n            }\n            if (!(autoindex_opts & SUPPRESS_DESC)) {\n                if (ar[x]->desc) {\n                    ap_rputs(terminate_description(d, ar[x]->desc,\n                                                   autoindex_opts,\n                                                   desc_width), r);\n                }\n            }\n            ap_rputc('\\n', r);\n        }\n        else {\n            ap_rvputs(r, \"<li><a href=\\\"\", anchor, \"\\\"> \", t2,\n                         \"</a></li>\\n\", NULL);\n        }\n    }\n    if (autoindex_opts & TABLE_INDEXING) {\n        ap_rvputs(r, breakrow, \"</table>\\n\", NULL);\n    }\n    else if (autoindex_opts & FANCY_INDEXING) {\n        if (!(autoindex_opts & SUPPRESS_RULES)) {\n            ap_rputs(\"<hr\", r);\n            if (autoindex_opts & EMIT_XHTML) {\n                ap_rputs(\" /\", r);\n            }\n            ap_rputs(\"></pre>\\n\", r);\n        }\n        else {\n            ap_rputs(\"</pre>\\n\", r);\n        }\n    }\n    else {\n        ap_rputs(\"</ul>\\n\", r);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8870d4c804b61960797dcdcf70bf86a12ab1ce3a_0", {
    "ID": "httpd_8870d4c804b61960797dcdcf70bf86a12ab1ce3a_0",
    "UID": "2682",
    "code": "AP_DECLARE_NONSTD(int) ap_rvputs(request_rec *r, test_snippet\n{\n    va_list va;\n    const char *s;\n    apr_size_t len;\n    apr_size_t written = 0;\n\n    if (r->connection->aborted)\n        return -1;\n\n    /* ### TODO: if the total output is large, put all the strings\n     * ### into a single brigade, rather than flushing each time we\n     * ### fill the buffer\n     */\n    va_start(va, r);\n    while (1) {\n        s = va_arg(va, const char *);\n        if (s == NULL)\n            break;\n\n        len = strlen(s);\n        if (buffer_output(r, s, len) != APR_SUCCESS) {\n            return -1;\n        }\n\n        written += len;\n    }\n    va_end(va);\n\n    return written;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n546,Suspicious Comment"
  },
  "httpd_2386858a4c3be2efddb613865c72607e5389814f_0", {
    "ID": "httpd_2386858a4c3be2efddb613865c72607e5389814f_0",
    "UID": "2683",
    "code": "static void start_connect(struct connection * test_snippet\n{\n    apr_status_t rv;\n\n#ifdef USE_SSL\n    if (ssl == 1) {\n        ssl_start_connect(test_snippet;\n        return;\n    }\n#endif\n    \n    if (!(started < requests))\n    return;\n\n    c->read = 0;\n    c->bread = 0;\n    c->keepalive = 0;\n    c->cbx = 0;\n    c->gotheader = 0;\n    c->rwrite = 0;\n    if (c->ctx)\n        apr_pool_destroy(c->ctx);\n    apr_pool_create(&c->ctx, cntxt);\n\n    if ((rv = apr_socket_create(&c->aprsock, destsa->family,\n                SOCK_STREAM, 0, c->ctx)) != APR_SUCCESS) {\n    apr_err(\"socket\", rv);\n    }\n    if ((rv = apr_socket_opt_set(c->aprsock, APR_SO_NONBLOCK, 1))\n         != APR_SUCCESS) {\n        apr_err(\"socket nonblock\", rv);\n    }\n    c->start = apr_time_now();\n    if ((rv = apr_socket_connect(c->aprsock, destsa)) != APR_SUCCESS) {\n        if (APR_STATUS_IS_EINPROGRESS(rv)) {\n            apr_pollfd_t new_pollfd;\n            c->state = STATE_CONNECTING;\n            c->rwrite = 0;\n            new_pollfd.desc_type = APR_POLL_SOCKET;\n            new_pollfd.reqevents = APR_POLLOUT;\n            new_pollfd.desc.s = c->aprsock;\n            new_pollfd.client_data = c;\n            apr_pollset_add(readbits, &new_pollfd);\n            return;\n        }\n        else {\n            apr_pollfd_t remove_pollfd;\n            remove_pollfd.desc_type = APR_POLL_SOCKET;\n            remove_pollfd.desc.s = c->aprsock;\n            apr_pollset_remove(readbits, &remove_pollfd);\n            apr_socket_close(c->aprsock);\n            err_conn++;\n            if (bad++ > 10) {\n                fprintf(stderr,\n                   \"\\nTest aborted after 10 failures\\n\\n\");\n                apr_err(\"apr_socket_connect()\", rv);\n            }\n            c->state = STATE_UNCONNECTED;\n            start_connect(test_snippet;\n            return;\n        }\n    }\n\n    \n    c->state = STATE_CONNECTED;\n    started++;\n    write_request(test_snippet;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_cc3a0be44e9fdbb3e69086e8ed97140e2594035b_0", {
    "ID": "httpd_cc3a0be44e9fdbb3e69086e8ed97140e2594035b_0",
    "UID": "2690",
    "code": "static void set_language_quality(negotiation_state *neg, var_rec test_snippet\n{\n    int forcepriority = neg->conf->forcelangpriority;\n    if (forcepriority == FLP_UNDEF) {\n        forcepriority = FLP_DEFAULT;\n    }\n\n    if (!variant->content_languages || !variant->content_languages->nelts) {\n        /* This variant has no content-language, so use the default\n         * quality factor for variants with no content-language\n         * (previously set by set_default_lang_quality()).\n         * Leave the factor alone (it remains at 1.0) when we may not fiddle\n         * with the headers.\n         */\n        if (!neg->dont_fiddle_headers) {\n            variant->lang_quality = neg->default_lang_quality;\n        }\n        if (!neg->accept_langs) {\n            return;             \n        }\n        return;\n    }\n    else {\n        /* Variant has one (or more) languages.  Look for the best\n         * match. We do this by going through each language on the\n         * variant description looking for a match on the\n         * Accept-Language header. The best match is the longest\n         * matching language on the header. The final result is the\n         * best q value from all the languages on the variant\n         * description.\n         */\n\n        if (!neg->accept_langs) {\n            \n            variant->definite = 0;\n        }\n        else {    \n            accept_rec *accs = (accept_rec *) neg->accept_langs->elts;\n            accept_rec *best = NULL, *star = NULL;\n            accept_rec *bestthistag;\n            char *lang, *p;\n            float fiddle_q = 0.0f;\n            int any_match_on_star = 0;\n            int i, j;\n            apr_size_t alen, longest_lang_range_len;\n\n            for (j = 0; j < variant->content_languages->nelts; ++j) {\n                p = NULL;\n                bestthistag = NULL;\n                longest_lang_range_len = 0;\n                alen = 0;\n\n                /* lang is the variant's language-tag, which is the one\n                 * we are allowed to use the prefix of in HTTP/1.1\n                 */\n                lang = ((char **) (variant->content_languages->elts))[j];\n\n                /* now find the best (i.e. longest) matching\n                 * Accept-Language header language. We put the best match\n                 * for this tag in bestthistag. We cannot update the\n                 * overall best (based on q value) because the best match\n                 * for this tag is the longest language item on the accept\n                 * header, not necessarily the highest q.\n                 */\n                for (i = 0; i < neg->accept_langs->nelts; ++i) {\n                    if (!strcmp(accs[i].name, \"*\")) {\n                        if (!star) {\n                            star = &accs[i];\n                        }\n                        continue;\n                    }\n                    /* Find language. We match if either the variant\n                     * language tag exactly matches the language range\n                     * from the accept header, or a prefix of the variant\n                     * language tag up to a '-' character matches the\n                     * whole of the language range in the Accept-Language\n                     * header.  Note that HTTP/1.x allows any number of\n                     * '-' characters in a tag or range, currently only\n                     * tags with zero or one '-' characters are defined\n                     * for general use (see rfc1766).\n                     *\n                     * We only use language range in the Accept-Language\n                     * header the best match for the variant language tag\n                     * if it is longer than the previous best match.\n                     */\n\n                    alen = strlen(accs[i].name);\n\n                    if ((strlen(lang) >= alen) &&\n                        !strncmp(lang, accs[i].name, alen) &&\n                        ((lang[alen] == 0) || (lang[alen] == '-')) ) {\n\n                        if (alen > longest_lang_range_len) {\n                            longest_lang_range_len = alen;\n                            bestthistag = &accs[i];\n                        }\n                    }\n\n                    if (!bestthistag && !neg->dont_fiddle_headers) {\n                        /* The next bit is a fiddle. Some browsers might\n                         * be configured to send more specific language\n                         * ranges than desirable. For example, an\n                         * Accept-Language of en-US should never match\n                         * variants with languages en or en-GB. But US\n                         * English speakers might pick en-US as their\n                         * language choice.  So this fiddle checks if the\n                         * language range has a prefix, and if so, it\n                         * matches variants which match that prefix with a\n                         * priority of 0.001. So a request for en-US would\n                         * match variants of types en and en-GB, but at\n                         * much lower priority than matches of en-US\n                         * directly, or of any other language listed on\n                         * the Accept-Language header. Note that this\n                         * fiddle does not handle multi-level prefixes.\n                         */\n                        if ((p = strchr(accs[i].name, '-'))) {\n                            int plen = p - accs[i].name;\n\n                            if (!strncmp(lang, accs[i].name, plen)) {\n                                fiddle_q = 0.001f;\n                            }\n                        }\n                    }\n                }\n                /* Finished looking at Accept-Language headers, the best\n                 * (longest) match is in bestthistag, or NULL if no match\n                 */\n                if (!best ||\n                    (bestthistag && bestthistag->quality > best->quality)) {\n                    best = bestthistag;\n                }\n\n                /* See if the tag matches on a * in the Accept-Language\n                 * header. If so, record this fact for later use\n                 */\n                if (!bestthistag && star) {\n                    any_match_on_star = 1;\n                }\n            }\n\n            /* If one of the language tags of the variant matched on *, we\n             * need to see if its q is better than that of any non-* match\n             * on any other tag of the variant.  If so the * match takes\n             * precedence and the overall match is not definite.\n             */\n            if ( any_match_on_star &&\n                ((best && star->quality > best->quality) ||\n                 (!best)) ) {\n                best = star;\n                variant->definite = 0;\n            }\n\n            variant->lang_quality = best ? best->quality : fiddle_q;\n        }\n    }\n\n    /* Handle the ForceDefaultLanguage overrides, based on the best match\n     * to LanguagePriority order.  The best match is the lowest index of\n     * any LanguagePriority match.\n     */\n    if (((forcepriority & FLP_PREFER)\n             && (variant->lang_index < 0))\n     || ((forcepriority & FLP_FALLBACK)\n             && !variant->lang_quality))\n    {\n        int bestidx = -1;\n        int j;\n\n        for (j = 0; j < variant->content_languages->nelts; ++j)\n        {\n            /* lang is the variant's language-tag, which is the one\n             * we are allowed to use the prefix of in HTTP/1.1\n             */\n            char *lang = ((char **) (variant->content_languages->elts))[j];\n            int idx = -1;\n\n            /* If we wish to fallback or\n             * we use our own LanguagePriority index.\n             */\n            idx = find_lang_index(neg->conf->language_priority, lang);\n            if ((idx >= 0) && ((bestidx == -1) || (idx < bestidx))) {\n                bestidx = idx;\n            }\n        }\n\n        if (bestidx >= 0) {\n            if (variant->lang_quality) {\n                if (forcepriority & FLP_PREFER) {\n                    variant->lang_index = bestidx;\n                }\n            }\n            else {\n                if (forcepriority & FLP_FALLBACK) {\n                    variant->lang_index = bestidx;\n                    variant->lang_quality = .0001f;\n                    variant->definite = 0;\n                }\n            }\n        }\n    }\n    return;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition"
  },
  "httpd_f27b226116d0e1c0338f9e0ba092d93c47ecd6c2_0", {
    "ID": "httpd_f27b226116d0e1c0338f9e0ba092d93c47ecd6c2_0",
    "UID": "2691",
    "code": "static int find_lang_index(apr_array_header_t *accept_langs, char test_snippet\n{\n    const char **alang;\n    int i;\n\n    if (!lang || !accept_langs) {\n        return -1;\n    }\n\n    alang = (const char **) accept_langs->elts;\n\n    for (i = 0; i < accept_langs->nelts; ++i) {\n        if (!strncmp(lang, *alang, strlen(*alang))) {\n            return i;\n        }\n        alang += (accept_langs->elt_size / sizeof(char*));\n    }\n\n    return -1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_983e642a927de52ab243ff2d6978ed237c54514a_0", {
    "ID": "httpd_983e642a927de52ab243ff2d6978ed237c54514a_0",
    "UID": "2706",
    "code": "AP_DECLARE(int) ap_unescape_url(char test_snippet\n{\n    register int badesc, badpath;\n    char *x, *y;\n\n    badesc = 0;\n    badpath = 0;\n    /* Initial scan for first '%'. Don't bother writing values before\n     * seeing a '%' */\n    y = strchr(url, '%');\n    if (y == NULL) {\n        return OK;\n    }\n    for (x = y; *y; ++x, ++y) {\n        if (*y != '%')\n            *x = *y;\n        else {\n            if (!apr_isxdigit(*(y + 1)) || !apr_isxdigit(*(y + 2))) {\n                badesc = 1;\n                *x = '%';\n            }\n            else {\n                *x = x2c(y + 1);\n                y += 2;\n                if (IS_SLASH(*x) || *x == '\\0')\n                    badpath = 1;\n            }\n        }\n    }\n    *x = '\\0';\n    if (badesc)\n        return HTTP_BAD_REQUEST;\n    else if (badpath)\n        return HTTP_NOT_FOUND;\n    else\n        return OK;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read\n20,Improper Input Validation"
  },
  "httpd_94c12415151ac414ef7280fea131dd9e001ba5d1_0", {
    "ID": "httpd_94c12415151ac414ef7280fea131dd9e001ba5d1_0",
    "UID": "2711",
    "code": "AP_DECLARE(int) ap_some_auth_required(request_rec test_snippet\n{\n    \n\n    const apr_array_header_t *reqs_arr = ap_requires(r);\n    require_line *reqs;\n    int i;\n\n    if (!reqs_arr) {\n        return 0;\n    }\n\n    reqs = (require_line *) reqs_arr->elts;\n\n    for (i = 0; i < reqs_arr->nelts; ++i) {\n        if (reqs[i].method_mask & (AP_METHOD_BIT << r->method_number)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "This code does not appear to have any flaws. Therefore, the response is: null."
  },
  "httpd_d3447a54f423c74211c5ea55022d75d1e475e71f_0", {
    "ID": "httpd_d3447a54f423c74211c5ea55022d75d1e475e71f_0",
    "UID": "2716",
    "code": "static const char *satisfy(cmd_parms *cmd, void *c_, const char test_snippet\n{\n    core_dir_config *c = c_;\n    int satisfy = SATISFY_NOSPEC;\n    int i;\n\n    if (!strcasecmp(arg, \"all\")) {\n        satisfy = SATISFY_ALL;\n    }\n    else if (!strcasecmp(arg, \"any\")) {\n        satisfy = SATISFY_ANY;\n    }\n    else {\n        return \"Satisfy either 'any' or 'all'.\";\n    }\n\n    for (i = 0; i < METHODS; ++i) {\n        if (cmd->limited & (AP_METHOD_BIT << i)) {\n            c->satisfy[i] = satisfy;\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_ab72be3d125dff9fd6a116de87acfac98da60815_0", {
    "ID": "httpd_ab72be3d125dff9fd6a116de87acfac98da60815_0",
    "UID": "2719",
    "code": "AP_DECLARE(request_rec *) ap_sub_req_lookup_dirent(const apr_finfo_t test_snippet\n                                                   const request_rec *r,\n                                                   int subtype,\n                                                   ap_filter_t *next_filter)\n{\n    request_rec *rnew;\n    int res;\n    char *fdir;\n    char *udir;\n\n    rnew = make_sub_request(r, next_filter);\n\n    /* Special case: we are looking at a relative lookup in the same directory.\n     * This is 100% safe, since dirent->name just came from the filesystem.\n     */\n    if (r->path_info && *r->path_info) {\n        /* strip path_info off the end of the uri to keep it in sync\n         * with r->filename, which has already been stripped by directory_walk,\n         * merge the dirent->name, and then, if the caller wants us to remerge\n         * the original path info, do so.  Note we never fix the path_info back\n         * to r->filename, since dir_walk would do so (but we don't expect it\n         * to happen in the usual cases)\n         */\n        udir = apr_pstrdup(rnew->pool, r->uri);\n        udir[ap_find_path_info(udir, r->path_info)] = '\\0';\n        udir = ap_make_dirstr_parent(rnew->pool, udir);\n\n        rnew->uri = ap_make_full_path(rnew->pool, udir, dirent->name);\n        if (subtype == AP_SUBREQ_MERGE_ARGS) {\n            rnew->uri = ap_make_full_path(rnew->pool, rnew->uri, r->path_info + 1);\n            rnew->path_info = apr_pstrdup(rnew->pool, r->path_info);\n        }\n        rnew->uri = ap_escape_uri(rnew->pool, rnew->uri);\n    }\n    else {\n        udir = ap_make_dirstr_parent(rnew->pool, r->uri);\n        rnew->uri = ap_escape_uri(rnew->pool, ap_make_full_path(rnew->pool,\n                                                                udir,\n                                                                dirent->name));\n    }\n\n    fdir = ap_make_dirstr_parent(rnew->pool, r->filename);\n    rnew->filename = ap_make_full_path(rnew->pool, fdir, dirent->name);\n    if (r->canonical_filename == r->filename) {\n        rnew->canonical_filename = rnew->filename;\n    }\n\n    /* XXX This is now less relevant; we will do a full location walk\n     * these days for this case.  Preserve the apr_stat results, and\n     * perhaps we also tag that symlinks were tested and/or found for\n     * r->filename.\n     */\n    rnew->per_dir_config = r->server->lookup_defaults;\n\n    if ((dirent->valid & APR_FINFO_MIN) != APR_FINFO_MIN) {\n        /*\n         * apr_dir_read isn't very complete on this platform, so\n         * we need another apr_stat (with or without APR_FINFO_LINK\n         * depending on whether we allow all symlinks here.)  If this \n         * is an APR_LNK that resolves to an APR_DIR, then we will rerun \n         * everything anyways... this should be safe.\n         */\n        apr_status_t rv;\n        if (ap_allow_options(rnew) & OPT_SYM_LINKS) {\n            if (((rv = apr_stat(&rnew->finfo, rnew->filename,\n                                APR_FINFO_MIN, rnew->pool)) != APR_SUCCESS)\n                && (rv != APR_INCOMPLETE)) {\n                rnew->finfo.filetype = 0;\n            }\n        }\n        else {\n            if (((rv = apr_stat(&rnew->finfo, rnew->filename,\n                                APR_FINFO_LINK | APR_FINFO_MIN, \n                                rnew->pool)) != APR_SUCCESS)\n                && (rv != APR_INCOMPLETE)) {\n                rnew->finfo.filetype = 0;\n            }\n        }\n    }\n    else {\n        memcpy(&rnew->finfo, dirent, sizeof(apr_finfo_t));\n    }\n\n    if (rnew->finfo.filetype == APR_LNK) {\n        /*\n         * Resolve this symlink.  We should tie this back to dir_walk's cache\n         */\n        if ((res = resolve_symlink(rnew->filename, &rnew->finfo,\n                                   ap_allow_options(rnew), rnew->pool))\n            != OK) {\n            rnew->status = res;\n            return rnew;\n        }\n    }\n\n    if (rnew->finfo.filetype == APR_DIR) {\n        /* ap_make_full_path overallocated the buffers\n         * by one character to help us out here.\n         */\n        strcpy(rnew->filename + strlen(rnew->filename), \"/\");\n        if (!rnew->path_info || !*rnew->path_info) {\n            strcpy(rnew->uri  + strlen(rnew->uri ), \"/\");\n        }\n    }\n\n    /* fill in parsed_uri values\n     */\n    if (r->args && *r->args && (subtype == AP_SUBREQ_MERGE_ARGS)) {\n        ap_parse_uri(rnew, apr_pstrcat(r->pool, rnew->uri, \"?\",\n                                       r->args, NULL));\n    }\n    else {\n        ap_parse_uri(rnew, rnew->uri);\n    }\n\n    /* We cannot return NULL without violating the API. So just turn this\n     * subrequest into a 500. */\n    if (ap_is_recursion_limit_exceeded(r)) {\n        rnew->status = HTTP_INTERNAL_SERVER_ERROR;\n        return rnew;\n    }\n\n    if ((res = ap_process_request_internal(rnew))) {\n        rnew->status = res;\n    }\n\n    return rnew;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_b92135e728b9fe38814c40d4e317ab4ac83e4d10_0", {
    "ID": "httpd_b92135e728b9fe38814c40d4e317ab4ac83e4d10_0",
    "UID": "2737",
    "code": "AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char test_snippet\n{\n    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);\n    const unsigned char *s = (const unsigned char *)segment;\n    unsigned char *d = (unsigned char *)copy;\n    unsigned c;\n\n    while ((c = *s)) {\n        if (TEST_CHAR(c, T_ESCAPE_PATH_SEGMENT)) {\n            d = c2x(c, d);\n        }\n        else {\n            *d++ = c;\n        }\n        ++s;\n    }\n    *d = '\\0';\n    return copy;\n}",
    "predicted": "120,Classic Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_d67d679cf5e6e2f851525c3fd04ef241358dc621_0", {
    "ID": "httpd_d67d679cf5e6e2f851525c3fd04ef241358dc621_0",
    "UID": "2755",
    "code": "static apr_status_t handle_fsize(include_ctx_t *ctx, ap_filter_t test_snippet\n                                 apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n\n    if (!ctx->argc) {\n        ap_log_rerror(APLOG_MARK,\n                      (ctx->flags & SSI_FLAG_PRINTING)\n                          ? APLOG_ERR : APLOG_WARNING,\n                      0, r, \"missing argument for fsize element in %s\",\n                      r->filename);\n    }\n\n    if (!(ctx->flags & SSI_FLAG_PRINTING)) {\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->argc) {\n        SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n        return APR_SUCCESS;\n    }\n\n    while (1) {\n        char *tag     = NULL;\n        char *tag_val = NULL;\n        apr_finfo_t finfo;\n        char *parsed_string;\n\n        ap_ssi_get_tag_and_value(ctx, &tag, &tag_val, SSI_VALUE_DECODED);\n        if (!tag || !tag_val) {\n            break;\n        }\n\n        parsed_string = ap_ssi_parse_string(ctx, tag_val, NULL, 0,\n                                            SSI_EXPAND_DROP_NAME);\n\n        if (!find_file(r, \"fsize\", tag, parsed_string, &finfo)) {\n            char *buf;\n            apr_size_t len;\n\n            if (!(ctx->flags & SSI_FLAG_SIZE_IN_BYTES)) {\n                buf = apr_strfsize(finfo.size, apr_palloc(ctx->pool, 5));\n                len = 4; \n            }\n            else {\n                apr_size_t l, x, pos;\n                char *tmp;\n\n                tmp = apr_psprintf(ctx->dpool, \"%\" APR_OFF_T_FMT, finfo.size);\n                len = l = strlen(tmp);\n\n                for (x = 0; x < l; ++x) {\n                    if (x && !((l - x) % 3)) {\n                        ++len;\n                    }\n                }\n\n                if (len == l) {\n                    buf = apr_pstrmemdup(ctx->pool, tmp, len);\n                }\n                else {\n                    buf = apr_palloc(ctx->pool, len);\n\n                    for (pos = x = 0; x < l; ++x) {\n                        if (x && !((l - x) % 3)) {\n                            buf[pos++] = ',';\n                        }\n                        buf[pos++] = tmp[x];\n                    }\n                }\n            }\n\n            APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(buf, len,\n                                    ctx->pool, f->c->bucket_alloc));\n        }\n        else {\n            SSI_CREATE_ERROR_BUCKET(ctx, f, bb);\n            break;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "120,Classic Buffer Overflow\n190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_a87639416c8e92f8d4cc52b4577b27e9921bced4_0", {
    "ID": "httpd_a87639416c8e92f8d4cc52b4577b27e9921bced4_0",
    "UID": "2764",
    "code": "AP_DECLARE(int) ap_allow_options(request_rec test_snippet\n{\n    core_dir_config *conf =\n      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);\n\n    return conf->opts;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b917a1e9981c7b7a979956af918ccfaf53bc2972_0", {
    "ID": "httpd_b917a1e9981c7b7a979956af918ccfaf53bc2972_0",
    "UID": "2778",
    "code": "static ap_conf_vector_t *create_server_config(apr_pool_t *p, server_rec test_snippet\n{\n    void **conf_vector = apr_pcalloc(p, sizeof(void *) *\n                                     (total_modules + DYNAMIC_MODULE_LIMIT));\n    module *modp;\n\n    for (modp = ap_top_module; modp; modp = modp->next) {\n        if (modp->create_server_config)\n            conf_vector[modp->module_index] = (*modp->create_server_config)(p, s);\n    }\n\n    return (ap_conf_vector_t *)conf_vector;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e3f84ae3214bd578034c1301b4fd6c9dfa32ed9d_0", {
    "ID": "httpd_e3f84ae3214bd578034c1301b4fd6c9dfa32ed9d_0",
    "UID": "2781",
    "code": "static int parse_url(char test_snippet\n{\n    char *cp;\n    char *h;\n    char *scope_id;\n    apr_status_t rv;\n\n    \n    fullurl = apr_pstrdup(cntxt, url);\n\n    if (strlen(url) > 7 && strncmp(url, \"http://\", 7) == 0) {\n        url += 7;\n#ifdef USE_SSL\n        ssl = 0;\n#endif\n    }\n    else\n#ifdef USE_SSL\n    if (strlen(url) > 8 && strncmp(url, \"https://\", 8) == 0) {\n        url += 8;\n        ssl = 1;\n    }\n#else\n    if (strlen(url) > 8 && strncmp(url, \"https://\", 8) == 0) {\n        fprintf(stderr, \"SSL not compiled in; no https support\\n\");\n        exit(1);\n    }\n#endif\n\n    if ((cp = strchr(url, '/')) == NULL)\n        return 1;\n    h = apr_palloc(cntxt, cp - url + 1);\n    memcpy(h, url, cp - url);\n    h[cp - url] = '\\0';\n    rv = apr_parse_addr_port(&hostname, &scope_id, &port, h, cntxt);\n    if (rv != APR_SUCCESS || !hostname || scope_id) {\n        return 1;\n    }\n    path = apr_pstrdup(cntxt, cp);\n    *cp = '\\0';\n    if (*url == '[') {      \n        host_field = apr_psprintf(cntxt, \"[%s]\", hostname);\n    }\n    else {\n        host_field = hostname;\n    }\n\n    if (port == 0) {        \n#ifdef USE_SSL\n        if (ssl == 1)\n            port = 443;\n        else\n#endif\n        port = 80;\n    }\n\n    if ((\n#ifdef USE_SSL\n         (ssl == 1) && (port != 443)) || (( ssl == 0 ) && \n#endif\n         (port != 80)))\n    {\n        colonhost = apr_psprintf(cntxt,\":%d\",port);\n    } else\n        colonhost = \"\";\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n476,NULL Pointer Dereference"
  },
  "httpd_2e450c6091908041463cb47be283abd36606d35a_0", {
    "ID": "httpd_2e450c6091908041463cb47be283abd36606d35a_0",
    "UID": "2796",
    "code": "static int index_directory(request_rec test_snippet\n                           autoindex_config_rec *autoindex_conf)\n{\n    char *title_name = ap_escape_html(r->pool, r->uri);\n    char *title_endp;\n    char *name = r->filename;\n    char *pstring = NULL;\n    apr_finfo_t dirent;\n    apr_dir_t *thedir;\n    apr_status_t status;\n    int num_ent = 0, x;\n    struct ent *head, *p;\n    struct ent **ar = NULL;\n    const char *qstring;\n    apr_int32_t autoindex_opts = autoindex_conf->opts;\n    char keyid;\n    char direction;\n    char *colargs;\n    char *fullpath;\n    apr_size_t dirpathlen;\n\n    if ((status = apr_dir_open(&thedir, name, r->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,\n                      \"Can't open directory for index: %s\", r->filename);\n        return HTTP_FORBIDDEN;\n    }\n\n#if APR_HAS_UNICODE_FS\n    ap_set_content_type(r, \"text/html;charset=utf-8\");\n#else\n    ap_set_content_type(r, \"text/html\");\n#endif\n    if (autoindex_opts & TRACK_MODIFIED) {\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n        ap_set_etag(r);\n    }\n    if (r->header_only) {\n        apr_dir_close(thedir);\n        return 0;\n    }\n\n    /*\n     * If there is no specific ordering defined for this directory,\n     * default to ascending by filename.\n     */\n    keyid = autoindex_conf->default_keyid\n                ? autoindex_conf->default_keyid : K_NAME;\n    direction = autoindex_conf->default_direction\n                ? autoindex_conf->default_direction : D_ASCENDING;\n\n    /*\n     * Figure out what sort of indexing (if any) we're supposed to use.\n     *\n     * If no QUERY_STRING was specified or client query strings have been\n     * explicitly disabled.\n     * If we are ignoring the client, suppress column sorting as well.\n     */\n    if (autoindex_opts & IGNORE_CLIENT) {\n        qstring = NULL;\n        autoindex_opts |= SUPPRESS_COLSORT;\n        colargs = \"\";\n    }\n    else {\n        char fval[5], vval[5], *ppre = \"\", *epattern = \"\";\n        fval[0] = '\\0'; vval[0] = '\\0';\n        qstring = r->args;\n\n        while (qstring && *qstring) {\n\n            \n            if (   qstring[0] == 'C' && qstring[1] == '='\n                && qstring[2] && strchr(K_VALID, qstring[2])\n                && (   qstring[3] == '&' || qstring[3] == ';'\n                    || !qstring[3])) {\n                keyid = qstring[2];\n                qstring += qstring[3] ? 4 : 3;\n            }\n\n            \n            else if (   qstring[0] == 'O' && qstring[1] == '='\n                     && (   (qstring[2] == D_ASCENDING)\n                         || (qstring[2] == D_DESCENDING))\n                     && (   qstring[3] == '&' || qstring[3] == ';'\n                         || !qstring[3])) {\n                direction = qstring[2];\n                qstring += qstring[3] ? 4 : 3;\n            }\n\n            \n            else if (   qstring[0] == 'F' && qstring[1] == '='\n                     && qstring[2] && strchr(\"012\", qstring[2])\n                     && (   qstring[3] == '&' || qstring[3] == ';'\n                         || !qstring[3])) {\n                if (qstring[2] == '0') {\n                    autoindex_opts &= ~(FANCY_INDEXING | TABLE_INDEXING);\n                }\n                else if (qstring[2] == '1') {\n                    autoindex_opts = (autoindex_opts | FANCY_INDEXING)\n                        & ~TABLE_INDEXING;\n                }\n                else if (qstring[2] == '2') {\n                    autoindex_opts |= FANCY_INDEXING | TABLE_INDEXING;\n                }\n                strcpy(fval, \";F= \");\n                fval[3] = qstring[2];\n                qstring += qstring[3] ? 4 : 3;\n            }\n\n            \n            else if (   qstring[0] == 'V' && qstring[1] == '='\n                     && (qstring[2] == '0' || qstring[2] == '1')\n                     && (   qstring[3] == '&' || qstring[3] == ';'\n                         || !qstring[3])) {\n                if (qstring[2] == '0') {\n                    autoindex_opts &= ~VERSION_SORT;\n                }\n                else if (qstring[2] == '1') {\n                    autoindex_opts |= VERSION_SORT;\n                }\n                strcpy(vval, \";V= \"); \n                vval[3] = qstring[2];\n                qstring += qstring[3] ? 4 : 3;\n            }\n\n            \n            else if (qstring[0] == 'P' && qstring[1] == '=') {\n                const char *eos = qstring += 2; \n\n                while (*eos && *eos != '&' && *eos != ';') {\n                    ++eos;\n                }\n\n                if (eos == qstring) {\n                    pstring = NULL;\n                }\n                else {\n                    pstring = apr_pstrndup(r->pool, qstring, eos - qstring);\n                    if (ap_unescape_url(pstring) != OK) {\n                        \n                        pstring = NULL;\n                    }\n                    else {\n                        ppre = \";P=\";\n                        \n                        epattern = ap_escape_uri(r->pool, pstring);\n                    }\n                }\n\n                if (*eos && *++eos) {\n                    qstring = eos;\n                }\n                else {\n                    qstring = NULL;\n                }\n            }\n\n            \n            else {\n                qstring = NULL;\n            }\n        }\n        colargs = apr_pstrcat(r->pool, fval, vval, ppre, epattern, NULL);\n    }\n\n    \n    title_endp = title_name + strlen(title_name) - 1;\n\n    while (title_endp > title_name && *title_endp == '/') {\n        *title_endp-- = '\\0';\n    }\n\n    emit_head(r, find_header(autoindex_conf, r),\n              autoindex_opts & SUPPRESS_PREAMBLE,\n              autoindex_opts & EMIT_XHTML, title_name);\n\n    /*\n     * Since we don't know how many dir. entries there are, put them into a\n     * linked list and then arrayificate them so qsort can use them.\n     */\n    head = NULL;\n    p = make_parent_entry(autoindex_opts, autoindex_conf, r, keyid, direction);\n    if (p != NULL) {\n        p->next = head;\n        head = p;\n        num_ent++;\n    }\n    fullpath = apr_palloc(r->pool, APR_PATH_MAX);\n    dirpathlen = strlen(name);\n    memcpy(fullpath, name, dirpathlen);\n\n    do {\n        status = apr_dir_read(&dirent, APR_FINFO_MIN | APR_FINFO_NAME, thedir);\n        if (APR_STATUS_IS_INCOMPLETE(status)) {\n            continue; \n        }\n        else if (status != APR_SUCCESS) {\n            break;\n        }\n\n        \n        if (dirent.filetype == APR_LNK) {\n            const char *savename;\n            apr_finfo_t fi;\n            \n            savename = dirent.name;\n            apr_cpystrn(fullpath + dirpathlen, dirent.name,\n                        APR_PATH_MAX - dirpathlen);\n            status = apr_stat(&fi, fullpath,\n                              dirent.valid & ~(APR_FINFO_NAME), r->pool);\n            if (status != APR_SUCCESS) {\n                \n                continue;\n            }\n            memcpy(&dirent, &fi, sizeof(fi));\n            dirent.name = savename;\n            dirent.valid |= APR_FINFO_NAME;\n        }\n        p = make_autoindex_entry(&dirent, autoindex_opts, autoindex_conf, r,\n                                 keyid, direction, pstring);\n        if (p != NULL) {\n            p->next = head;\n            head = p;\n            num_ent++;\n        }\n    } while (1);\n\n    if (num_ent > 0) {\n        ar = (struct ent **) apr_palloc(r->pool,\n                                        num_ent * sizeof(struct ent *));\n        p = head;\n        x = 0;\n        while (p) {\n            ar[x++] = p;\n            p = p->next;\n        }\n\n        qsort((void *) ar, num_ent, sizeof(struct ent *),\n              (int (*)(const void *, const void *)) dsortf);\n    }\n    output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts,\n                       keyid, direction, colargs);\n    apr_dir_close(thedir);\n\n    emit_tail(r, find_readme(autoindex_conf, r),\n              autoindex_opts & SUPPRESS_PREAMBLE);\n\n    return 0;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_076f76a35efcb9b8b3fb49bb6843d6510ab17c47_0", {
    "ID": "httpd_076f76a35efcb9b8b3fb49bb6843d6510ab17c47_0",
    "UID": "2802",
    "code": "static void show_overrides(const command_rec *pc, module test_snippet\n{\n    int n = 0;\n\n    printf(\"\\tAllowed in *.conf \");\n    if ((pc->req_override & (OR_OPTIONS | OR_FILEINFO | OR_INDEXES))\n        || ((pc->req_override & RSRC_CONF)\n        && ((pc->req_override & (ACCESS_CONF | OR_AUTHCFG | OR_LIMIT))))) {\n        printf(\"anywhere\");\n    }\n    else if (pc->req_override & RSRC_CONF) {\n        printf(\"only outside <Directory>, <Files> or <Location>\");\n    }\n    else {\n        printf(\"only inside <Directory>, <Files> or <Location>\");\n    }\n\n    /* Warn if the directive is allowed inside <Directory> or .htaccess\n     * but module doesn't support per-dir configuration\n     */\n    if ((pc->req_override & (OR_ALL | ACCESS_CONF)) && !pm->create_dir_config)\n        printf(\" [no per-dir config]\");\n\n    if (pc->req_override & OR_ALL) {\n        printf(\" and in .htaccess\\n\\twhen AllowOverride\");\n\n        if ((pc->req_override & OR_ALL) == OR_ALL) {\n            printf(\" isn't None\");\n        }\n        else {\n            printf(\" includes \");\n\n            if (pc->req_override & OR_AUTHCFG) {\n                if (n++)\n                    printf(\" or \");\n\n                printf(\"AuthConfig\");\n            }\n\n            if (pc->req_override & OR_LIMIT) {\n                if (n++)\n                    printf(\" or \");\n\n                printf(\"Limit\");\n            }\n\n            if (pc->req_override & OR_OPTIONS) {\n                if (n++)\n                    printf(\" or \");\n\n                printf(\"Options\");\n            }\n\n            if (pc->req_override & OR_FILEINFO) {\n                if (n++)\n                    printf(\" or \");\n\n                printf(\"FileInfo\");\n            }\n\n            if (pc->req_override & OR_INDEXES) {\n                if (n++)\n                    printf(\" or \");\n\n                printf(\"Indexes\");\n            }\n        }\n    }\n\n    printf(\"\\n\");\n}",
    "predicted": "This code does not appear to have any security vulnerabilities. It's a simple function that prints out information based on the values of certain flags. There's no user input being processed, no file operations, and no memory management, so there's no opportunity for things like buffer overflows, path traversal, or injection attacks. Therefore, the response is null."
  },
  "httpd_1e2f1d28823daa67f51048628ad9d67bb945dc8b_0", {
    "ID": "httpd_1e2f1d28823daa67f51048628ad9d67bb945dc8b_0",
    "UID": "2806",
    "code": "static char *find_fqdn(apr_pool_t *a, struct hostent test_snippet\n{\n    int x;\n\n    if (!strchr(p->h_name, '.')) {\n        if (p->h_aliases) {\n            for (x = 0; p->h_aliases[x]; ++x) {\n                if (strchr(p->h_aliases[x], '.') &&\n                    (!strncasecmp(p->h_aliases[x], p->h_name,\n                                  strlen(p->h_name))))\n                    return apr_pstrdup(a, p->h_aliases[x]);\n            }\n        }\n        return NULL;\n    }\n    return apr_pstrdup(a, (void *) p->h_name);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_624cc0e131bc28f161ccb1ffc60edff5656a70a1_0", {
    "ID": "httpd_624cc0e131bc28f161ccb1ffc60edff5656a70a1_0",
    "UID": "2808",
    "code": "AP_DECLARE(void) test_snippet\n{\n    const command_rec *pc;\n    int n;\n\n    for (n = 0; ap_loaded_modules[n]; ++n) {\n        for (pc = ap_loaded_modules[n]->cmds; pc && pc->name; ++pc) {\n            printf(\"%s (%s)\\n\", pc->name, ap_loaded_modules[n]->name);\n\n            if (pc->errmsg)\n                printf(\"\\t%s\\n\", pc->errmsg);\n\n            show_overrides(pc, ap_loaded_modules[n]);\n        }\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable\n606,Unchecked Input for Loop Condition"
  },
  "httpd_5aa136ed1106e09f93995ab0cdbae213aec6ddfd_0", {
    "ID": "httpd_5aa136ed1106e09f93995ab0cdbae213aec6ddfd_0",
    "UID": "2809",
    "code": "AP_DECLARE(void) test_snippet\n{\n    int n;\n\n    printf(\"Compiled in modules:\\n\");\n    for (n = 0; ap_loaded_modules[n]; ++n)\n        printf(\"  %s\\n\", ap_loaded_modules[n]->name);\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_054157dc18fd5b14633a71a79c223e23f861c2af_0", {
    "ID": "httpd_054157dc18fd5b14633a71a79c223e23f861c2af_0",
    "UID": "2811",
    "code": "AP_DECLARE(int) ap_exists_config_define(const char test_snippet\n{\n    char **defines;\n    int i;\n\n    defines = (char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_2d5bdd16d40c242dea98c5cc4bfdbef4fce04566_0", {
    "ID": "httpd_2d5bdd16d40c242dea98c5cc4bfdbef4fce04566_0",
    "UID": "2812",
    "code": "static const char *start_ifdefine(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    const char *endp;\n    int defined;\n    int not = 0;\n\n    endp = ap_strrchr_c(arg, '>');\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->pool, arg, endp - arg);\n\n    if (arg[0] == '!') {\n        not = 1;\n        arg++;\n    }\n\n    defined = ap_exists_config_define(arg);\n    if ((!not && defined) || (not && !defined)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, \"<IfDefine\");\n        *(ap_directive_t **)dummy = current;\n        return retval;\n    }\n    else {\n        *(ap_directive_t **)dummy = NULL;\n        return ap_soak_end_container(cmd, \"<IfDefine\");\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_9b31320ad71fa655cf5fd1906647bdaa495e5905_0", {
    "ID": "httpd_9b31320ad71fa655cf5fd1906647bdaa495e5905_0",
    "UID": "2813",
    "code": "AP_DECLARE(char *) ap_pbase64decode(apr_pool_t *p, const char test_snippet\n{\n    char *decoded;\n    int l;\n\n    decoded = (char *) apr_palloc(p, 1 + apr_base64_decode_len(bufcoded));\n    l = apr_base64_decode(decoded, bufcoded);\n    decoded[l] = '\\0'; \n\n    return decoded;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_2b8a4005c9bd1852aa356a75a9b94e0418072a73_0", {
    "ID": "httpd_2b8a4005c9bd1852aa356a75a9b94e0418072a73_0",
    "UID": "2833",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetptest_snippetbtest_snippetatest_snippetstest_snippetetest_snippet6test_snippet4test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippet,test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet)test_snippet test_snippet\ntest_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetltest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet test_snippet=test_snippet test_snippet(test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetptest_snippet,test_snippet test_snippet1test_snippet test_snippet+test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetatest_snippetstest_snippetetest_snippet6test_snippet4test_snippet_test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippet_test_snippetltest_snippetetest_snippetntest_snippet(test_snippetltest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetltest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetbtest_snippetatest_snippetstest_snippetetest_snippet6test_snippet4test_snippet_test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippet(test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet,test_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet,test_snippet test_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet[test_snippetltest_snippet]test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet test_snippet/test_snippet*test_snippet test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet test_snippetbtest_snippetitest_snippetntest_snippetatest_snippetrtest_snippetytest_snippet test_snippetstest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetntest_snippetctest_snippetetest_snippet test_snippetitest_snippetntest_snippetttest_snippetotest_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetetest_snippetntest_snippetctest_snippetotest_snippetdtest_snippetetest_snippetdtest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5d962a10744a3b817ad2cec5d3175771e948724a_0", {
    "ID": "httpd_5d962a10744a3b817ad2cec5d3175771e948724a_0",
    "UID": "2836",
    "code": "AP_DECLARE(char *) ap_escape_quotes(apr_pool_t *p, const char test_snippet\n{\n    int newlen = 0;\n    const char *inchr = instring;\n    char *outchr, *outstring;\n\n    /*\n     * Look through the input string, jogging the length of the output\n     * string up by an extra byte each time we find an unescaped \".\n     */\n    while (*inchr != '\\0') {\n        newlen++;\n        if (*inchr == '\"') {\n            newlen++;\n        }\n        /*\n         * If we find a slosh, and it's not the last byte in the string,\n         * it's escaping something - advance past both bytes.\n         */\n        if ((*inchr == '\\\\') && (inchr[1] != '\\0')) {\n            inchr++;\n            newlen++;\n        }\n        inchr++;\n    }\n    outstring = apr_palloc(p, newlen + 1);\n    inchr = instring;\n    outchr = outstring;\n    /*\n     * Now copy the input string to the output string, inserting a slosh\n     * in front of every \" that doesn't already have one.\n     */\n    while (*inchr != '\\0') {\n        if ((*inchr == '\\\\') && (inchr[1] != '\\0')) {\n            *outchr++ = *inchr++;\n            *outchr++ = *inchr++;\n        }\n        if (*inchr == '\"') {\n            *outchr++ = '\\\\';\n        }\n        if (*inchr != '\\0') {\n            *outchr++ = *inchr++;\n        }\n    }\n    *outchr = '\\0';\n    return outstring;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_194b375332cfff2a4c11699db2747a0b9bce445e_0", {
    "ID": "httpd_194b375332cfff2a4c11699db2747a0b9bce445e_0",
    "UID": "2844",
    "code": "static const char *set_server_alias(cmd_parms *cmd, void test_snippet\n                                    const char *arg)\n{\n    if (!cmd->server->names) {\n        return \"ServerAlias only used in <VirtualHost>\";\n    }\n\n    while (*arg) {\n        char **item, *name = ap_getword_conf(cmd->pool, &arg);\n\n        if (ap_is_matchexp(name)) {\n            item = (char **)apr_array_push(cmd->server->wild_names);\n        }\n        else {\n            item = (char **)apr_array_push(cmd->server->names);\n        }\n\n        *item = name;\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_d86aece9217d979e723dce15accc2e556f0168d2_0", {
    "ID": "httpd_d86aece9217d979e723dce15accc2e556f0168d2_0",
    "UID": "2850",
    "code": "static int variant_has_language(var_rec *variant, const char test_snippet\n{\n    int j, max;\n\n    \n    if (   !lang\n        || !variant->content_languages\n        || !(max = variant->content_languages->nelts)) {\n        return 0;\n    }\n\n    for (j = 0; j < max; ++j) {\n        if (!strcmp(lang,\n                    ((char **) (variant->content_languages->elts))[j])) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_87659a660d329556e000250d49ec80ca6dd1c328_0", {
    "ID": "httpd_87659a660d329556e000250d49ec80ca6dd1c328_0",
    "UID": "2861",
    "code": "static const char *include_config (cmd_parms *cmd, void test_snippet\n                                   const char *name)\n{\n    ap_directive_t *conftree = NULL;\n    const char* conffile, *error;\n    unsigned *recursion;\n    void *data;\n\n    apr_pool_userdata_get(&data, \"ap_include_sentinel\", cmd->pool);\n    if (data) {\n        recursion = data;\n    }\n    else {\n        data = recursion = apr_palloc(cmd->pool, sizeof(*recursion));\n        *recursion = 0;\n        apr_pool_userdata_setn(data, \"ap_include_sentinel\", NULL, cmd->pool);\n    }\n\n    if (++*recursion > AP_MAX_INCLUDE_DEPTH) {\n        *recursion = 0;\n        return apr_psprintf(cmd->pool, \"Exceeded maximum include depth of %u. \"\n                            \"You have probably a recursion somewhere.\",\n                            AP_MAX_INCLUDE_DEPTH);\n    }\n\n    conffile = ap_server_root_relative(cmd->pool, name);\n    if (!conffile) {\n        *recursion = 0;\n        return apr_pstrcat(cmd->pool, \"Invalid Include path \", \n                           name, NULL);\n    }\n\n    error = ap_process_resource_config(cmd->server, conffile,\n                                       &conftree, cmd->pool, cmd->temp_pool);\n    if (error) {\n        *recursion = 0;\n        return error;\n    }\n\n    *(ap_directive_t **)dummy = conftree;\n\n    \n    if (*recursion) {\n        --*recursion;\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal"
  },
  "httpd_6142abe5d7b32b9626cb59c418b3017c2abeeedb_0", {
    "ID": "httpd_6142abe5d7b32b9626cb59c418b3017c2abeeedb_0",
    "UID": "2864",
    "code": "static bndm_t *bndm_compile(apr_pool_t *pool, const char *n, apr_size_t test_snippet\n{\n    unsigned int x;\n    const char *ne = n + nl;\n    bndm_t *t = apr_palloc(pool, sizeof(*t));\n\n    memset(t->T, 0, sizeof(unsigned int) * 256);\n    t->pattern_len = nl;\n\n    for (x = 1; n < ne; x <<= 1) {\n        t->T[(unsigned char) *n++] |= x;\n    }\n\n    t->x = x - 1;\n\n    return t;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_ff50f79fefe76779761208b4d7e7e27049afb418_0", {
    "ID": "httpd_ff50f79fefe76779761208b4d7e7e27049afb418_0",
    "UID": "2866",
    "code": "static void set_neg_headers(request_rec *r, negotiation_state test_snippet\n                            int alg_result)\n{\n    apr_table_t *hdrs;\n    var_rec *avail_recs = (var_rec *) neg->avail_vars->elts;\n    const char *sample_type = NULL;\n    const char *sample_language = NULL;\n    const char *sample_encoding = NULL;\n    const char *sample_charset = NULL;\n    char *lang;\n    char *qstr;\n    apr_off_t len;\n    apr_array_header_t *arr;\n    int max_vlist_array = (neg->avail_vars->nelts * 21);\n    int first_variant = 1;\n    int vary_by_type = 0;\n    int vary_by_language = 0;\n    int vary_by_charset = 0;\n    int vary_by_encoding = 0;\n    int j;\n\n    /* In order to avoid O(n^2) memory copies in building Alternates,\n     * we preallocate a apr_table_t with the maximum substrings possible,\n     * fill it with the variant list, and then concatenate the entire array.\n     * Note that if you change the number of substrings pushed, you also\n     * need to change the calculation of max_vlist_array above.\n     */\n    if (neg->send_alternates && neg->avail_vars->nelts)\n        arr = apr_array_make(r->pool, max_vlist_array, sizeof(char *));\n    else\n        arr = NULL;\n\n    /* Put headers into err_headers_out, since send_http_header()\n     * outputs both headers_out and err_headers_out.\n     */\n    hdrs = r->err_headers_out;\n\n    for (j = 0; j < neg->avail_vars->nelts; ++j) {\n        var_rec *variant = &avail_recs[j];\n\n        if (variant->content_languages && variant->content_languages->nelts) {\n            lang = apr_array_pstrcat(r->pool, variant->content_languages, ',');\n        }\n        else {\n            lang = NULL;\n        }\n\n        \n\n        if (first_variant) {\n            sample_type     = variant->mime_type;\n            sample_charset  = variant->content_charset;\n            sample_language = lang;\n            sample_encoding = variant->content_encoding;\n        }\n        else {\n            if (!vary_by_type &&\n                strcmp(sample_type ? sample_type : \"\",\n                       variant->mime_type ? variant->mime_type : \"\")) {\n                vary_by_type = 1;\n            }\n            if (!vary_by_charset &&\n                strcmp(sample_charset ? sample_charset : \"\",\n                       variant->content_charset ?\n                       variant->content_charset : \"\")) {\n                vary_by_charset = 1;\n            }\n            if (!vary_by_language &&\n                strcmp(sample_language ? sample_language : \"\",\n                       lang ? lang : \"\")) {\n                vary_by_language = 1;\n            }\n            if (!vary_by_encoding &&\n                strcmp(sample_encoding ? sample_encoding : \"\",\n                       variant->content_encoding ?\n                       variant->content_encoding : \"\")) {\n                vary_by_encoding = 1;\n            }\n        }\n        first_variant = 0;\n\n        if (!neg->send_alternates)\n            continue;\n\n        \n\n        *((const char **) apr_array_push(arr)) = \"{\\\"\";\n        *((const char **) apr_array_push(arr)) = variant->file_name;\n        *((const char **) apr_array_push(arr)) = \"\\\" \";\n\n        qstr = (char *) apr_palloc(r->pool, 6);\n        apr_snprintf(qstr, 6, \"%1.3f\", variant->source_quality);\n\n        \n        if (qstr[4] == '0') {\n            qstr[4] = '\\0';\n            if (qstr[3] == '0') {\n                qstr[3] = '\\0';\n                if (qstr[2] == '0') {\n                    qstr[1] = '\\0';\n                }\n            }\n        }\n        *((const char **) apr_array_push(arr)) = qstr;\n\n        if (variant->mime_type && *variant->mime_type) {\n            *((const char **) apr_array_push(arr)) = \" {type \";\n            *((const char **) apr_array_push(arr)) = variant->mime_type;\n            *((const char **) apr_array_push(arr)) = \"}\";\n        }\n        if (variant->content_charset && *variant->content_charset) {\n            *((const char **) apr_array_push(arr)) = \" {charset \";\n            *((const char **) apr_array_push(arr)) = variant->content_charset;\n            *((const char **) apr_array_push(arr)) = \"}\";\n        }\n        if (lang) {\n            *((const char **) apr_array_push(arr)) = \" {language \";\n            *((const char **) apr_array_push(arr)) = lang;\n            *((const char **) apr_array_push(arr)) = \"}\";\n        }\n        if (variant->content_encoding && *variant->content_encoding) {\n            \n\n            *((const char **) apr_array_push(arr)) = \" {encoding \";\n            *((const char **) apr_array_push(arr)) = variant->content_encoding;\n            *((const char **) apr_array_push(arr)) = \"}\";\n        }\n\n        /* Note that the Alternates specification (in rfc2295) does\n         * not require that we include {length x}, so we could omit it\n         * if determining the length is too expensive.  We currently\n         * always include it though.\n         *\n         * If the variant is a CGI script, find_content_length would\n         * return the length of the script, not the output it\n         * produces, so we check for the presence of a handler and if\n         * there is one we don't add a length.\n         *\n         * XXX: TODO: This check does not detect a CGI script if we\n         * get the variant from a type map.  This needs to be fixed\n         * (without breaking things if the type map specifies a\n         * content-length, which currently leads to the correct result).\n         */\n        if (!(variant->sub_req && variant->sub_req->handler)\n            && (len = find_content_length(neg, variant)) >= 0) {\n\n            *((const char **) apr_array_push(arr)) = \" {length \";\n            *((const char **) apr_array_push(arr)) = apr_off_t_toa(r->pool,\n                                                                   len);\n            *((const char **) apr_array_push(arr)) = \"}\";\n        }\n\n        *((const char **) apr_array_push(arr)) = \"}\";\n        *((const char **) apr_array_push(arr)) = \", \"; \n    }\n\n    if (neg->send_alternates && neg->avail_vars->nelts) {\n        arr->nelts--;                                 \n        apr_table_mergen(hdrs, \"Alternates\",\n                        apr_array_pstrcat(r->pool, arr, '\\0'));\n    }\n\n    if (neg->is_transparent || vary_by_type || vary_by_language ||\n        vary_by_language || vary_by_charset || vary_by_encoding) {\n\n        apr_table_mergen(hdrs, \"Vary\", 2 + apr_pstrcat(r->pool,\n            neg->is_transparent ? \", negotiate\"       : \"\",\n            vary_by_type        ? \", accept\"          : \"\",\n            vary_by_language    ? \", accept-language\" : \"\",\n            vary_by_charset     ? \", accept-charset\"  : \"\",\n            vary_by_encoding    ? \", accept-encoding\" : \"\", NULL));\n    }\n\n    if (neg->is_transparent) { \n        apr_table_setn(hdrs, \"TCN\",\n                      alg_result == alg_list ? \"list\" : \"choice\");\n    }\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_45ad527d28d3444ca3c5a34bce77e2d95ae4d976_0", {
    "ID": "httpd_45ad527d28d3444ca3c5a34bce77e2d95ae4d976_0",
    "UID": "2876",
    "code": "static apr_size_t find_start_sequence(include_ctx_t *ctx, const char test_snippet\n                                      apr_size_t len)\n{\n    struct ssi_internal_ctx *intern = ctx->intern;\n    apr_size_t slen = intern->start_seq_pat->pattern_len;\n    apr_size_t index;\n    const char *p, *ep;\n\n    if (len < slen) {\n        p = data; \n    }\n    else {\n        /* try fast bndm search over the buffer\n         * (hopefully the whole start sequence can be found in this buffer)\n         */\n        index = bndm(intern->start_seq_pat, data, len);\n\n        \n        if (index < len) {\n            intern->state = PARSE_DIRECTIVE;\n            return index;\n        }\n        else {\n            /* ok, the pattern can't be found as whole in the buffer,\n             * check the end for a partial match\n             */\n            p = data + len - slen + 1;\n        }\n    }\n\n    ep = data + len;\n    do {\n        while (p < ep && *p != *intern->start_seq) {\n            ++p;\n        }\n\n        index = p - data;\n\n        \n        if (p < ep) {\n            apr_size_t pos = 1;\n\n            ++p;\n            while (p < ep && *p == intern->start_seq[pos]) {\n                ++p;\n                ++pos;\n            }\n\n            \n            if (p == ep) {\n                intern->state = PARSE_HEAD;\n                intern->parse_pos = pos;\n                return index;\n            }\n        }\n\n        /* we must try all combinations; consider (e.g.) SSIStartTag \"--->\"\n         * and a string data of \"--.-\" and the end of the buffer\n         */\n        p = data + index + 1;\n    } while (p < ep);\n\n    \n    return len;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_9b9a0741b9d844d3c423d6b7cb3bb5d81e7dec48_0", {
    "ID": "httpd_9b9a0741b9d844d3c423d6b7cb3bb5d81e7dec48_0",
    "UID": "2882",
    "code": "static apr_size_t find_directive(include_ctx_t *ctx, const char test_snippet\n                                 apr_size_t len, char ***store,\n                                 apr_size_t **store_len)\n{\n    struct ssi_internal_ctx *intern = ctx->intern;\n    const char *p = data;\n    const char *ep = data + len;\n    apr_size_t pos;\n\n    switch (intern->state) {\n    case PARSE_DIRECTIVE:\n        while (p < ep && !apr_isspace(*p)) {\n            /* we have to consider the case of missing space between directive\n             * and end_seq (be somewhat lenient), e.g. <!--#printenv-->\n             */\n            if (*p == *intern->end_seq) {\n                intern->state = PARSE_DIRECTIVE_TAIL;\n                intern->parse_pos = 1;\n                ++p;\n                return (p - data);\n            }\n            ++p;\n        }\n\n        if (p < ep) { \n            intern->state = PARSE_DIRECTIVE_POSTNAME;\n            *store = &intern->directive;\n            *store_len = &intern->directive_len;\n        }\n\n        break;\n\n    case PARSE_DIRECTIVE_TAIL:\n        pos = intern->parse_pos;\n\n        while (p < ep && pos < intern->end_seq_len &&\n               *p == intern->end_seq[pos]) {\n            ++p;\n            ++pos;\n        }\n\n        \n        if (pos == intern->end_seq_len) {\n            intern->state = PARSE_DIRECTIVE_POSTTAIL;\n            *store = &intern->directive;\n            *store_len = &intern->directive_len;\n            break;\n        }\n\n        \n        if (p == ep) {\n            intern->parse_pos = pos;\n            break;\n        }\n\n        \n        intern->state = PARSE_DIRECTIVE;\n        return 0;\n\n    case PARSE_DIRECTIVE_POSTTAIL:\n        intern->state = PARSE_EXECUTE;\n        intern->directive_len -= intern->end_seq_len;\n        \n\n    case PARSE_DIRECTIVE_POSTNAME:\n        if (PARSE_DIRECTIVE_POSTNAME == intern->state) {\n            intern->state = PARSE_PRE_ARG;\n        }\n        ctx->argc = 0;\n        intern->argv = NULL;\n\n        if (!intern->directive_len) {\n            intern->error = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, intern->r, \"missing \"\n                          \"directive name in parsed document %s\",\n                          intern->r->filename);\n        }\n        else {\n            char *sp = intern->directive;\n            char *sep = intern->directive + intern->directive_len;\n\n            \n            for (; sp < sep; ++sp) {\n                *sp = apr_tolower(*sp);\n            }\n        }\n\n        return 0;\n\n    default:\n        \n        break;\n    }\n\n    return (p - data);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e0c432a40f9d69dec716e11a6970d6d2d1a8632f_0", {
    "ID": "httpd_e0c432a40f9d69dec716e11a6970d6d2d1a8632f_0",
    "UID": "2883",
    "code": "static apr_size_t find_arg_or_tail(include_ctx_t *ctx, const char test_snippet\n                                   apr_size_t len)\n{\n    struct ssi_internal_ctx *intern = ctx->intern;\n    const char *p = data;\n    const char *ep = data + len;\n\n    \n    while (p < ep && apr_isspace(*p)) {\n        ++p;\n    }\n\n    \n    if (p < ep) {\n        intern->state = (*p == *intern->end_seq) ? PARSE_TAIL : PARSE_ARG;\n    }\n\n    return (p - data);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_c467d7aed30ef6fd54df92c43f31b923b44cedcf_0", {
    "ID": "httpd_c467d7aed30ef6fd54df92c43f31b923b44cedcf_0",
    "UID": "2890",
    "code": "AP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec test_snippet\n{\n    core_server_config *conf = ap_get_module_config(r->server->module_config,\n                                                    &core_module);\n    const request_rec *top = r;\n    int redirects = 0, subreqs = 0;\n    int rlimit = conf->redirect_limit\n                 ? conf->redirect_limit\n                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;\n    int slimit = conf->subreq_limit\n                 ? conf->subreq_limit\n                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;\n\n\n    while (top->prev || top->main) {\n        if (top->prev) {\n            if (++redirects >= rlimit) {\n                \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Request exceeded the limit of %d internal \"\n                              \"redirects due to probable configuration error. \"\n                              \"Use 'LimitInternalRecursion' to increase the \"\n                              \"limit if necessary. Use 'LogLevel debug' to get \"\n                              \"a backtrace.\", rlimit);\n\n                \n                log_backtrace(r);\n\n                \n                return 1;\n            }\n\n            top = top->prev;\n        }\n\n        if (!top->prev && top->main) {\n            if (++subreqs >= slimit) {\n                \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                              \"Request exceeded the limit of %d subrequest \"\n                              \"nesting levels due to probable confguration \"\n                              \"error. Use 'LimitInternalRecursion' to increase \"\n                              \"the limit if necessary. Use 'LogLevel debug' to \"\n                              \"get a backtrace.\", slimit);\n\n                \n                log_backtrace(r);\n\n                \n                return 1;\n            }\n\n            top = top->main;\n        }\n    }\n\n    \n    return 0;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_19bf8dea29a90c84b52a54e99746fb35d9e0b301_0", {
    "ID": "httpd_19bf8dea29a90c84b52a54e99746fb35d9e0b301_0",
    "UID": "2895",
    "code": "static int handle_map_file(request_rec test_snippet\n{\n    negotiation_state *neg;\n    apr_file_t *map;\n    var_rec *best;\n    int res;\n    char *udir;\n\n    if(strcmp(r->handler,MAP_FILE_MAGIC_TYPE) && strcmp(r->handler,\"type-map\"))\n        return DECLINED;\n\n    neg = parse_accept_headers(r);\n    if ((res = read_type_map(&map, neg, r))) {\n        return res;\n    }\n\n    res = do_negotiation(r, neg, &best, 0);\n    if (res != 0) return res;\n\n    if (best->body)\n    {\n        conn_rec *c = r->connection;\n        apr_bucket_brigade *bb;\n        apr_bucket *e;\n\n        ap_allow_standard_methods(r, REPLACE_ALLOW, M_GET, M_OPTIONS,\n                                  M_POST, -1);\n        /* XXX: ?\n         * if (r->method_number == M_OPTIONS) {\n         *    return ap_send_http_options(r);\n         *}\n         */\n        if (r->method_number != M_GET && r->method_number != M_POST) {\n            return HTTP_METHOD_NOT_ALLOWED;\n        }\n\n        /* ### These may be implemented by adding some 'extra' info\n         *     of the file offset onto the etag\n         * ap_update_mtime(r, r->finfo.mtime);\n         * ap_set_last_modified(r);\n         * ap_set_etag(r);\n         */\n        apr_table_setn(r->headers_out, \"Accept-Ranges\", \"bytes\");\n        ap_set_content_length(r, best->bytes);\n\n        \n        if (best->mime_type && *best->mime_type) {\n            if (best->content_charset && *best->content_charset) {\n                ap_set_content_type(r, apr_pstrcat(r->pool,\n                                                   best->mime_type,\n                                                   \"; charset=\",\n                                                   best->content_charset,\n                                                   NULL));\n            }\n            else {\n                ap_set_content_type(r, apr_pstrdup(r->pool, best->mime_type));\n            }\n        }\n\n        \n        if (best->content_languages && best->content_languages->nelts) {\n            r->content_languages = apr_array_copy(r->pool,\n                                                  best->content_languages);\n        }\n\n        \n        if (best->content_encoding && *best->content_encoding) {\n            r->content_encoding = apr_pstrdup(r->pool,\n                                              best->content_encoding);\n        }\n\n        if ((res = ap_meets_conditions(r)) != OK) {\n            return res;\n        }\n\n        if ((res = ap_discard_request_body(r)) != OK) {\n            return res;\n        }\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n        e = apr_bucket_file_create(map, best->body,\n                                   (apr_size_t)best->bytes, r->pool,\n                                   c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        return ap_pass_brigade(r->output_filters, bb);\n    }\n\n    if (r->path_info && *r->path_info) {\n        /* remove any path_info from the end of the uri before trying\n         * to change the filename.  r->path_info from the original\n         * request is passed along on the redirect.\n         */\n        r->uri[ap_find_path_info(r->uri, r->path_info)] = '\\0';\n    }\n    udir = ap_make_dirstr_parent(r->pool, r->uri);\n    udir = ap_escape_uri(r->pool, udir);\n    ap_internal_redirect(apr_pstrcat(r->pool, udir, best->file_name,\n                                     r->path_info, NULL), r);\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e2cc38f3a205f502b8ef0a88bc6f86c94411158d_0", {
    "ID": "httpd_e2cc38f3a205f502b8ef0a88bc6f86c94411158d_0",
    "UID": "2898",
    "code": "static char *make_variant_list(request_rec *r, negotiation_state test_snippet\n{\n    apr_array_header_t *arr;\n    int i;\n    int max_vlist_array = (neg->avail_vars->nelts * 15) + 2;\n\n    /* In order to avoid O(n^2) memory copies in building the list,\n     * we preallocate a apr_table_t with the maximum substrings possible,\n     * fill it with the variant list, and then concatenate the entire array.\n     */\n    arr = apr_array_make(r->pool, max_vlist_array, sizeof(char *));\n\n    *((const char **) apr_array_push(arr)) = \"Available variants:\\n<ul>\\n\";\n\n    for (i = 0; i < neg->avail_vars->nelts; ++i) {\n        var_rec *variant = &((var_rec *) neg->avail_vars->elts)[i];\n        const char *filename = variant->file_name ? variant->file_name : \"\";\n        apr_array_header_t *languages = variant->content_languages;\n        const char *description = variant->description\n                                    ? variant->description\n                                    : \"\";\n\n        /* The format isn't very neat, and it would be nice to make\n         * the tags human readable (eg replace 'language en' with 'English').\n         * Note that if you change the number of substrings pushed, you also\n         * need to change the calculation of max_vlist_array above.\n         */\n        *((const char **) apr_array_push(arr)) = \"<li><a href=\\\"\";\n        *((const char **) apr_array_push(arr)) = filename;\n        *((const char **) apr_array_push(arr)) = \"\\\">\";\n        *((const char **) apr_array_push(arr)) = filename;\n        *((const char **) apr_array_push(arr)) = \"</a> \";\n        *((const char **) apr_array_push(arr)) = description;\n\n        if (variant->mime_type && *variant->mime_type) {\n            *((const char **) apr_array_push(arr)) = \", type \";\n            *((const char **) apr_array_push(arr)) = variant->mime_type;\n        }\n        if (languages && languages->nelts) {\n            *((const char **) apr_array_push(arr)) = \", language \";\n            *((const char **) apr_array_push(arr)) = apr_array_pstrcat(r->pool,\n                                                       languages, ',');\n        }\n        if (variant->content_charset && *variant->content_charset) {\n            *((const char **) apr_array_push(arr)) = \", charset \";\n            *((const char **) apr_array_push(arr)) = variant->content_charset;\n        }\n        if (variant->content_encoding) {\n            *((const char **) apr_array_push(arr)) = \", encoding \";\n            *((const char **) apr_array_push(arr)) = variant->content_encoding;\n        }\n        *((const char **) apr_array_push(arr)) = \"</li>\\n\";\n    }\n    *((const char **) apr_array_push(arr)) = \"</ul>\\n\";\n\n    return apr_array_pstrcat(r->pool, arr, '\\0');\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_249e08c2c85fcf367d0114cc7066fca0012eba24_0", {
    "ID": "httpd_249e08c2c85fcf367d0114cc7066fca0012eba24_0",
    "UID": "2901",
    "code": "static void set_default_lang_quality(negotiation_state test_snippet\n{\n    var_rec *avail_recs = (var_rec *) neg->avail_vars->elts;\n    int j;\n\n    if (!neg->dont_fiddle_headers) {\n        for (j = 0; j < neg->avail_vars->nelts; ++j) {\n            var_rec *variant = &avail_recs[j];\n            if (variant->content_languages &&\n                variant->content_languages->nelts) {\n                neg->default_lang_quality = 0.0001f;\n                return;\n            }\n        }\n    }\n\n    neg->default_lang_quality = 1.0f;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_b19a455bb3fd314b7fba22de2a03bb9273ab7099_0", {
    "ID": "httpd_b19a455bb3fd314b7fba22de2a03bb9273ab7099_0",
    "UID": "2914",
    "code": "static apr_size_t find_argument(include_ctx_t *ctx, const char test_snippet\n                                apr_size_t len, char ***store,\n                                apr_size_t **store_len)\n{\n    struct ssi_internal_ctx *intern = ctx->intern;\n    const char *p = data;\n    const char *ep = data + len;\n\n    switch (intern->state) {\n    case PARSE_ARG:\n        /*\n         * create argument structure and append it to the current list\n         */\n        intern->current_arg = apr_palloc(ctx->dpool,\n                                         sizeof(*intern->current_arg));\n        intern->current_arg->next = NULL;\n\n        ++(ctx->argc);\n        if (!intern->argv) {\n            intern->argv = intern->current_arg;\n        }\n        else {\n            arg_item_t *newarg = intern->argv;\n\n            while (newarg->next) {\n                newarg = newarg->next;\n            }\n            newarg->next = intern->current_arg;\n        }\n\n        /* check whether it's a valid one. If it begins with a quote, we\n         * can safely assume, someone forgot the name of the argument\n         */\n        switch (*p) {\n        case '\"': case '\\'': case '`':\n            *store = NULL;\n\n            intern->state = PARSE_ARG_VAL;\n            intern->quote = *p++;\n            intern->current_arg->name = NULL;\n            intern->current_arg->name_len = 0;\n            intern->error = 1;\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, intern->r, \"missing \"\n                          \"argument name for value to tag %s in %s\",\n                          apr_pstrmemdup(intern->r->pool, intern->directive,\n                                         intern->directive_len),\n                                         intern->r->filename);\n\n            return (p - data);\n\n        default:\n            intern->state = PARSE_ARG_NAME;\n        }\n        \n\n    case PARSE_ARG_NAME:\n        while (p < ep && !apr_isspace(*p) && *p != '=') {\n            ++p;\n        }\n\n        if (p < ep) {\n            intern->state = PARSE_ARG_POSTNAME;\n            *store = &intern->current_arg->name;\n            *store_len = &intern->current_arg->name_len;\n            return (p - data);\n        }\n        break;\n\n    case PARSE_ARG_POSTNAME:\n        intern->current_arg->name = apr_pstrmemdup(ctx->dpool,\n                                                 intern->current_arg->name,\n                                                 intern->current_arg->name_len);\n        if (!intern->current_arg->name_len) {\n            intern->error = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, intern->r, \"missing \"\n                          \"argument name for value to tag %s in %s\",\n                          apr_pstrmemdup(intern->r->pool, intern->directive,\n                                         intern->directive_len),\n                                         intern->r->filename);\n        }\n        else {\n            char *sp = intern->current_arg->name;\n\n            \n            while (*sp) {\n                *sp = apr_tolower(*sp);\n                ++sp;\n            }\n        }\n\n        intern->state = PARSE_ARG_EQ;\n        \n\n    case PARSE_ARG_EQ:\n        *store = NULL;\n\n        while (p < ep && apr_isspace(*p)) {\n            ++p;\n        }\n\n        if (p < ep) {\n            if (*p == '=') {\n                intern->state = PARSE_ARG_PREVAL;\n                ++p;\n            }\n            else { \n                intern->current_arg->value = NULL;\n                intern->state = PARSE_PRE_ARG;\n            }\n\n            return (p - data);\n        }\n        break;\n\n    case PARSE_ARG_PREVAL:\n        *store = NULL;\n\n        while (p < ep && apr_isspace(*p)) {\n            ++p;\n        }\n\n        \n        if (p < ep) {\n            intern->state = PARSE_ARG_VAL;\n            switch (*p) {\n            case '\"': case '\\'': case '`':\n                intern->quote = *p++;\n                break;\n            default:\n                intern->quote = '\\0';\n                break;\n            }\n\n            return (p - data);\n        }\n        break;\n\n    case PARSE_ARG_VAL_ESC:\n        if (*p == intern->quote) {\n            ++p;\n        }\n        intern->state = PARSE_ARG_VAL;\n        \n\n    case PARSE_ARG_VAL:\n        for (; p < ep; ++p) {\n            if (intern->quote && *p == '\\\\') {\n                ++p;\n                if (p == ep) {\n                    intern->state = PARSE_ARG_VAL_ESC;\n                    break;\n                }\n\n                if (*p != intern->quote) {\n                    --p;\n                }\n            }\n            else if (intern->quote && *p == intern->quote) {\n                ++p;\n                *store = &intern->current_arg->value;\n                *store_len = &intern->current_arg->value_len;\n                intern->state = PARSE_ARG_POSTVAL;\n                break;\n            }\n            else if (!intern->quote && apr_isspace(*p)) {\n                ++p;\n                *store = &intern->current_arg->value;\n                *store_len = &intern->current_arg->value_len;\n                intern->state = PARSE_ARG_POSTVAL;\n                break;\n            }\n        }\n\n        return (p - data);\n\n    case PARSE_ARG_POSTVAL:\n        /*\n         * The value is still the raw input string. Finally clean it up.\n         */\n        --(intern->current_arg->value_len);\n\n        \n        if (intern->quote) {\n            apr_size_t shift = 0;\n            char *sp;\n\n            sp = intern->current_arg->value;\n            ep = intern->current_arg->value + intern->current_arg->value_len;\n            while (sp < ep && *sp != '\\\\') {\n                ++sp;\n            }\n            for (; sp < ep; ++sp) {\n                if (*sp == '\\\\' && sp[1] == intern->quote) {\n                    ++sp;\n                    ++shift;\n                }\n                if (shift) {\n                    *(sp-shift) = *sp;\n                }\n            }\n\n            intern->current_arg->value_len -= shift;\n        }\n\n        intern->current_arg->value[intern->current_arg->value_len] = '\\0';\n        intern->state = PARSE_PRE_ARG;\n\n        return 0;\n\n    default:\n        \n        break;\n    }\n\n    return len; \n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_f71e5296440b7b2cf7472fb92dc02d3e14b00aad_0", {
    "ID": "httpd_f71e5296440b7b2cf7472fb92dc02d3e14b00aad_0",
    "UID": "2918",
    "code": "static apr_size_t find_partial_start_sequence(include_ctx_t test_snippet\n                                              const char *data,\n                                              apr_size_t len,\n                                              apr_size_t *release)\n{\n    struct ssi_internal_ctx *intern = ctx->intern;\n    apr_size_t pos, spos = 0;\n    apr_size_t slen = intern->start_seq_pat->pattern_len;\n    const char *p, *ep;\n\n    pos = intern->parse_pos;\n    ep = data + len;\n    *release = 0;\n\n    do {\n        p = data;\n\n        while (p < ep && pos < slen && *p == intern->start_seq[pos]) {\n            ++p;\n            ++pos;\n        }\n\n        \n        if (pos == slen) {\n            intern->state = PARSE_DIRECTIVE;\n            return (p - data);\n        }\n\n        \n        if (p == ep) {\n            intern->parse_pos = pos;\n            return (p - data);\n        }\n\n        /* No match so far, but again:\n         * We must try all combinations, since the start_seq is a random\n         * user supplied string\n         *\n         * So: look if the first char of start_seq appears somewhere within\n         * the current partial match. If it does, try to start a match that\n         * begins with this offset. (This can happen, if a strange\n         * start_seq like \"---->\" spans buffers)\n         */\n        if (spos < intern->parse_pos) {\n            do {\n                ++spos;\n                ++*release;\n                p = intern->start_seq + spos;\n                pos = intern->parse_pos - spos;\n\n                while (pos && *p != *intern->start_seq) {\n                    ++p;\n                    ++spos;\n                    ++*release;\n                    --pos;\n                }\n\n                /* if a matching beginning char was found, try to match the\n                 * remainder of the old buffer.\n                 */\n                if (pos > 1) {\n                    apr_size_t t = 1;\n\n                    ++p;\n                    while (t < pos && *p == intern->start_seq[t]) {\n                        ++p;\n                        ++t;\n                    }\n\n                    if (t == pos) {\n                        /* yeah, another partial match found in the *old*\n                         * buffer, now test the *current* buffer for\n                         * continuing match\n                         */\n                        break;\n                    }\n                }\n            } while (pos > 1);\n\n            if (pos) {\n                continue;\n            }\n        }\n\n        break;\n    } while (1); \n\n    \n    *release = intern->parse_pos;\n    intern->state = PARSE_PRE_HEAD;\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_1d7693bdb865b1f3cb37fe4d0320aaca931d8b38_0", {
    "ID": "httpd_1d7693bdb865b1f3cb37fe4d0320aaca931d8b38_0",
    "UID": "2940",
    "code": "static int fix_encoding(request_rec test_snippet\n{\n    const char *enc = r->content_encoding;\n    char *x_enc = NULL;\n    apr_array_header_t *accept_encodings;\n    accept_rec *accept_recs;\n    int i;\n\n    if (!enc || !*enc) {\n        return DECLINED;\n    }\n\n    if (enc[0] == 'x' && enc[1] == '-') {\n        enc += 2;\n    }\n\n    if ((accept_encodings = do_header_line(r->pool,\n             apr_table_get(r->headers_in, \"Accept-Encoding\"))) == NULL) {\n        return DECLINED;\n    }\n\n    accept_recs = (accept_rec *) accept_encodings->elts;\n\n    for (i = 0; i < accept_encodings->nelts; ++i) {\n        char *name = accept_recs[i].name;\n\n        if (!strcmp(name, enc)) {\n            r->content_encoding = name;\n            return OK;\n        }\n\n        if (name[0] == 'x' && name[1] == '-' && !strcmp(name+2, enc)) {\n            x_enc = name;\n        }\n    }\n\n    if (x_enc) {\n        r->content_encoding = x_enc;\n        return OK;\n    }\n\n    return DECLINED;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_475c0edc625a0abc7ccf4c04a9df89c7d93b417c_0", {
    "ID": "httpd_475c0edc625a0abc7ccf4c04a9df89c7d93b417c_0",
    "UID": "2945",
    "code": "static apr_status_t includes_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    request_rec *r = f->r;\n    include_ctx_t *ctx = f->ctx;\n    request_rec *parent;\n    include_dir_config *conf = ap_get_module_config(r->per_dir_config,\n                                                    &include_module);\n\n    include_server_config *sconf= ap_get_module_config(r->server->module_config,\n                                                       &include_module);\n\n    if (!(ap_allow_options(r) & OPT_INCLUDES)) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"mod_include: Options +Includes (or IncludesNoExec) \"\n                      \"wasn't set, INCLUDES filter removed\");\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, b);\n    }\n\n    if (!f->ctx) {\n        struct ssi_internal_ctx *intern;\n\n        \n        f->ctx = ctx = apr_palloc(r->pool, sizeof(*ctx));\n        ctx->intern = intern = apr_palloc(r->pool, sizeof(*ctx->intern));\n        ctx->pool = r->pool;\n        apr_pool_create(&ctx->dpool, ctx->pool);\n\n        \n        intern->tmp_bb = apr_brigade_create(ctx->pool, f->c->bucket_alloc);\n        intern->seen_eos = 0;\n        intern->state = PARSE_PRE_HEAD;\n        ctx->flags = (SSI_FLAG_PRINTING | SSI_FLAG_COND_TRUE);\n        if (ap_allow_options(r) & OPT_INCNOEXEC) {\n            ctx->flags |= SSI_FLAG_NO_EXEC;\n        }\n\n        ctx->if_nesting_level = 0;\n        intern->re = NULL;\n\n        ctx->error_str = conf->default_error_msg;\n        ctx->time_str = conf->default_time_fmt;\n        intern->start_seq  = sconf->default_start_tag;\n        intern->start_seq_pat = bndm_compile(ctx->pool, intern->start_seq,\n                                             strlen(intern->start_seq));\n        intern->end_seq = sconf->default_end_tag;\n        intern->end_seq_len = strlen(intern->end_seq);\n        intern->undefined_echo = conf->undefined_echo;\n        intern->undefined_echo_len = strlen(conf->undefined_echo);\n    }\n\n    if ((parent = ap_get_module_config(r->request_config, &include_module))) {\n        /* Kludge --- for nested includes, we want to keep the subprocess\n         * environment of the base document (for compatibility); that means\n         * torquing our own last_modified date as well so that the\n         * LAST_MODIFIED variable gets reset to the proper value if the\n         * nested document resets <!--#config timefmt -->.\n         */\n        r->subprocess_env = r->main->subprocess_env;\n        apr_pool_join(r->main->pool, r->pool);\n        r->finfo.mtime = r->main->finfo.mtime;\n    }\n    else {\n        /* we're not a nested include, so we create an initial\n         * environment */\n        ap_add_common_vars(r);\n        ap_add_cgi_vars(r);\n        add_include_vars(r, conf->default_time_fmt);\n    }\n    /* Always unset the content-length.  There is no way to know if\n     * the content will be modified at some point by send_parsed_content.\n     * It is very possible for us to not find any content in the first\n     * 9k of the file, but still have to modify the content of the file.\n     * If we are going to pass the file through send_parsed_content, then\n     * the content-length should just be unset.\n     */\n    apr_table_unset(f->r->headers_out, \"Content-Length\");\n\n    /* Always unset the Last-Modified field - see RFC2616 - 13.3.4.\n     * We don't know if we are going to be including a file or executing\n     * a program which may change the Last-Modified header or make the \n     * content completely dynamic.  Therefore, we can't support these\n     * headers.\n     * Exception: XBitHack full means we *should* set the Last-Modified field.\n     */\n\n    \n    if ((conf->xbithack == XBITHACK_FULL)\n        && (r->finfo.valid & APR_FINFO_GPROT)\n        && (r->finfo.protection & APR_GEXECUTE)) {\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n    }\n    else {\n        apr_table_unset(f->r->headers_out, \"Last-Modified\");\n    }\n\n    \n    if (r->args) {\n        char *arg_copy = apr_pstrdup(r->pool, r->args);\n\n        apr_table_setn(r->subprocess_env, \"QUERY_STRING\", r->args);\n        ap_unescape_url(arg_copy);\n        apr_table_setn(r->subprocess_env, \"QUERY_STRING_UNESCAPED\",\n                  ap_escape_shell_cmd(r->pool, arg_copy));\n    }\n\n    return send_parsed_content(f, b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_204dd79abcdac980c88c4c8e13f518a6d73836f6_0", {
    "ID": "httpd_204dd79abcdac980c88c4c8e13f518a6d73836f6_0",
    "UID": "2952",
    "code": "static int core_create_req(request_rec test_snippet\n{\n    /* Alloc the config struct and the array of request notes in\n     * a single block for efficiency\n     */\n    core_request_config *req_cfg;\n\n    req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config) +\n                          sizeof(void *) * num_request_notes);\n    req_cfg->notes = (void **)((char *)req_cfg + sizeof(core_request_config));\n\n    \n    req_cfg->deliver_script = 1;\n\n    if (r->main) {\n        core_request_config *main_req_cfg = (core_request_config *)\n            ap_get_module_config(r->main->request_config, &core_module);\n        req_cfg->bb = main_req_cfg->bb;\n    }\n    else {\n        req_cfg->bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n        if (!r->prev) {\n            ap_add_input_filter_handle(ap_net_time_filter_handle,\n                                       NULL, r, r->connection);\n        }\n    }\n\n    ap_set_module_config(r->request_config, &core_module, req_cfg);\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_feadee5c49e3833e7bed88a56a17b2f3b1b2a315_0", {
    "ID": "httpd_feadee5c49e3833e7bed88a56a17b2f3b1b2a315_0",
    "UID": "2954",
    "code": "static const char *set_default_end_tag(cmd_parms *cmd, void test_snippet\n                                       const char *tag)\n{\n    include_server_config *conf;\n    const char *p = tag;\n\n    \n    while (*p) {\n        if (apr_isspace(*p)) {\n            return \"SSIEndTag may not contain any whitespaces\";\n        }\n        ++p;\n    }\n\n    conf= ap_get_module_config(cmd->server->module_config , &include_module);\n    conf->default_end_tag = tag;\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b679cc0557cb57ae2d668a74f7507e2da1bd2265_0", {
    "ID": "httpd_b679cc0557cb57ae2d668a74f7507e2da1bd2265_0",
    "UID": "3026",
    "code": "static int filter_lookup(ap_filter_t *f, ap_filter_rec_t test_snippet\n{\n    ap_filter_provider_t *provider;\n    int match = 0;\n    const char *err = NULL;\n    request_rec *r = f->r;\n    harness_ctx *ctx = f->ctx;\n    provider_ctx *pctx;\n#ifndef NO_PROTOCOL\n    unsigned int proto_flags;\n    mod_filter_ctx *rctx = ap_get_module_config(r->request_config,\n                                                &filter_module);\n#endif\n\n    \n    for (provider = filter->providers; provider; provider = provider->next) {\n        if (provider->expr) {\n            match = ap_expr_exec(r, provider->expr, &err);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01379)\n                              \"Error evaluating filter dispatch condition: %s\",\n                              err);\n                match = 0;\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                          \"Expression condition for '%s' %s\",\n                          provider->frec->name,\n                          match ? \"matched\" : \"did not match\");\n        }\n        else if (r->content_type) {\n            const char **type = provider->types;\n            size_t len = strcspn(r->content_type, \"; \\t\");\n            AP_DEBUG_ASSERT(type != NULL);\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                          \"Content-Type '%s' ...\", r->content_type);\n            while (*type) {\n                \n                if (strncmp(*type, r->content_type, len) == 0\n                    && (*type)[len] == '\\0') {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                                  \"... matched '%s'\", *type);\n                    match = 1;\n                    break;\n                }\n                else {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                                  \"... did not match '%s'\", *type);\n                }\n                type++;\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                          \"Content-Type condition for '%s' %s\",\n                          provider->frec->name,\n                          match ? \"matched\" : \"did not match\");\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                          \"Content-Type condition for '%s' did not match: \"\n                          \"no Content-Type\", provider->frec->name);\n        }\n\n        if (match) {\n            \n#ifndef NO_PROTOCOL\n            /* check protocol\n             *\n             * FIXME:\n             * This is a quick hack and almost certainly buggy.\n             * The idea is that by putting this in mod_filter, we relieve\n             * filter implementations of the burden of fixing up HTTP headers\n             * for cases that are routinely affected by filters.\n             *\n             * Default is ALWAYS to do nothing, so as not to tread on the\n             * toes of filters which want to do it themselves.\n             *\n             */\n            proto_flags = provider->frec->proto_flags;\n\n            \n            if (r->proxyreq) {\n                if (proto_flags & AP_FILTER_PROTO_NO_PROXY) {\n                    \n                    continue;\n                }\n\n                if (proto_flags & AP_FILTER_PROTO_TRANSFORM) {\n                    const char *str = apr_table_get(r->headers_out,\n                                                    \"Cache-Control\");\n                    if (str) {\n                        char *str1 = apr_pstrdup(r->pool, str);\n                        ap_str_tolower(str1);\n                        if (strstr(str1, \"no-transform\")) {\n                            \n                            continue;\n                        }\n                    }\n                    apr_table_addn(r->headers_out, \"Warning\",\n                                   apr_psprintf(r->pool,\n                                                \"214 %s Transformation applied\",\n                                                r->hostname));\n                }\n            }\n\n            \n            if (proto_flags & AP_FILTER_PROTO_CHANGE) {\n                apr_table_unset(r->headers_out, \"Content-MD5\");\n                apr_table_unset(r->headers_out, \"ETag\");\n                if (proto_flags & AP_FILTER_PROTO_CHANGE_LENGTH) {\n                    apr_table_unset(r->headers_out, \"Content-Length\");\n                }\n            }\n\n            \n            if (proto_flags & AP_FILTER_PROTO_NO_CACHE) {\n                apr_table_unset(r->headers_out, \"Last-Modified\");\n                apr_table_addn(r->headers_out, \"Cache-Control\", \"no-cache\");\n            }\n\n            if (proto_flags & AP_FILTER_PROTO_NO_BYTERANGE) {\n                apr_table_setn(r->headers_out, \"Accept-Ranges\", \"none\");\n            }\n            else if (rctx && rctx->range) {\n                \n                apr_table_setn(r->headers_in, \"Range\", rctx->range);\n                rctx->range = NULL;\n            }\n#endif\n            for (pctx = ctx->init_ctx; pctx; pctx = pctx->next) {\n                if (pctx->provider == provider) {\n                    ctx->fctx = pctx->ctx ;\n                }\n            }\n            ctx->func = provider->frec->filter_func.out_func;\n            return 1;\n        }\n    }\n\n    \n    return 0;\n}",
    "predicted": "546,Suspicious Comment"
  },
  "httpd_295836d8f7e2a397761cb2693f150a555778b15e_0", {
    "ID": "httpd_295836d8f7e2a397761cb2693f150a555778b15e_0",
    "UID": "3027",
    "code": "static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t test_snippet\n                     server_rec *main_server)\n{\n    apr_proc_t *procnew = NULL;\n    const char *userdata_key = \"cgid_init\";\n    module **m;\n    int ret = OK;\n    void *data;\n\n    root_server = main_server;\n    root_pool = p;\n\n    apr_pool_userdata_get(&data, userdata_key, main_server->process->pool);\n    if (!data) {\n        procnew = apr_pcalloc(main_server->process->pool, sizeof(*procnew));\n        procnew->pid = -1;\n        procnew->err = procnew->in = procnew->out = NULL;\n        apr_pool_userdata_set((const void *)procnew, userdata_key,\n                     apr_pool_cleanup_null, main_server->process->pool);\n        return ret;\n    }\n    else {\n        procnew = data;\n    }\n\n    if (ap_state_query(AP_SQ_MAIN_STATE) != AP_SQ_MS_CREATE_PRE_CONFIG) {\n        char *tmp_sockname;\n        total_modules = 0;\n        for (m = ap_preloaded_modules; *m != NULL; m++)\n            total_modules++;\n\n        parent_pid = getpid();\n        tmp_sockname = ap_runtime_dir_relative(p, sockname);\n        if (strlen(tmp_sockname) > sizeof(server_addr->sun_path) - 1) {\n            tmp_sockname[sizeof(server_addr->sun_path)] = '\\0';\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, main_server, APLOGNO(01254)\n                        \"The length of the ScriptSock path exceeds maximum, \"\n                        \"truncating to %s\", tmp_sockname);\n        }\n        sockname = tmp_sockname;\n\n        server_addr_len = APR_OFFSETOF(struct sockaddr_un, sun_path) + strlen(sockname);\n        server_addr = (struct sockaddr_un *)apr_palloc(p, server_addr_len + 1);\n        server_addr->sun_family = AF_UNIX;\n        strcpy(server_addr->sun_path, sockname);\n\n        ret = cgid_start(p, main_server, procnew);\n        if (ret != OK ) {\n            return ret;\n        }\n        cgid_pfn_reg_with_ssi = APR_RETRIEVE_OPTIONAL_FN(ap_register_include_handler);\n        cgid_pfn_gtv          = APR_RETRIEVE_OPTIONAL_FN(ap_ssi_get_tag_and_value);\n        cgid_pfn_ps           = APR_RETRIEVE_OPTIONAL_FN(ap_ssi_parse_string);\n\n        if ((cgid_pfn_reg_with_ssi) && (cgid_pfn_gtv) && (cgid_pfn_ps)) {\n            /* Required by mod_include filter. This is how mod_cgid registers\n             *   with mod_include to provide processing of the exec directive.\n             */\n            cgid_pfn_reg_with_ssi(\"exec\", handle_exec);\n        }\n    }\n    return ret;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_3ef79ebdf66674626d6603df052f64b75fae4984_0", {
    "ID": "httpd_3ef79ebdf66674626d6603df052f64b75fae4984_0",
    "UID": "3035",
    "code": "int abort_on_oom(int test_snippet\n{\n    const char *buf = \"Error: out of memory\\n\";\n    int written, count = strlen(buf);\n    do {\n        written = write(STDERR_FILENO, buf, count);\n        if (written == count)\n            break;\n        if (written > 0) {\n            buf += written;\n            count -= written;\n        }\n    } while (written >= 0 || errno == EINTR);\n    abort();\n    \n    return 0;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_d55cc1ee606ed918a71463d30496e74abb5c755a_0", {
    "ID": "httpd_d55cc1ee606ed918a71463d30496e74abb5c755a_0",
    "UID": "3038",
    "code": "static int generate_salt(char *s, size_t size, const char test_snippet\n                         apr_pool_t *pool)\n{\n    unsigned char rnd[32];\n    static const char itoa64[] =\n        \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    apr_size_t n;\n    unsigned int val = 0, bits = 0;\n    apr_status_t rv;\n\n    n = (size * 6 + 7)/8;\n    if (n > sizeof(rnd)) {\n        apr_file_printf(errfile, \"generate_salt(): BUG: Buffer too small\");\n        abort();\n    }\n    rv = apr_generate_random_bytes(rnd, n);\n    if (rv) {\n        *errstr = apr_psprintf(pool, \"Unable to generate random bytes: %pm\",\n                               &rv);\n        return ERR_RANDOM;\n    }\n    n = 0;\n    while (size > 0) {\n        if (bits < 6) {\n            val |= (rnd[n++] << bits);\n            bits += 8;\n        }\n        *s++ = itoa64[val & 0x3f];\n        size--;\n        val >>= 6;\n        bits -= 6;\n   }\n   *s = '\\0';\n   return 0;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n457,Use of Uninitialized Variable"
  },
  "httpd_52643e719724e1add3d7425ffe1fcc3864e00428_0", {
    "ID": "httpd_52643e719724e1add3d7425ffe1fcc3864e00428_0",
    "UID": "3041",
    "code": "AP_DECLARE(const char *) ap_add_module(module *m, apr_pool_t test_snippet\n                                       const char *sym_name)\n{\n    ap_module_symbol_t *sym = ap_prelinked_module_symbols;\n\n    /* This could be called from a LoadModule httpd.conf command,\n     * after the file has been linked and the module structure within it\n     * teased out...\n     */\n\n    if (m->version != MODULE_MAGIC_NUMBER_MAJOR) {\n        return apr_psprintf(p, \"Module \\\"%s\\\" is not compatible with this \"\n                            \"version of Apache (found %d, need %d). Please \"\n                            \"contact the vendor for the correct version.\",\n                            m->name, m->version, MODULE_MAGIC_NUMBER_MAJOR);\n    }\n\n    if (m->module_index == -1) {\n        if (dynamic_modules >= DYNAMIC_MODULE_LIMIT) {\n            return apr_psprintf(p, \"Module \\\"%s\\\" could not be loaded, \"\n                                \"because the dynamic module limit was \"\n                                \"reached. Please increase \"\n                                \"DYNAMIC_MODULE_LIMIT and recompile.\", m->name);\n        }\n        /*\n         * If this fails some module forgot to call ap_reserve_module_slots*.\n         */\n        ap_assert(total_modules < conf_vector_length);\n\n        m->module_index = total_modules++;\n        dynamic_modules++;\n\n    }\n    else if (!sym_name) {\n        while (sym->modp != NULL) {\n            if (sym->modp == m) {\n                sym_name = sym->name;\n                break;\n            }\n            sym++;\n        }\n    }\n\n    if (m->next == NULL) {\n        m->next = ap_top_module;\n        ap_top_module = m;\n    }\n\n    if (sym_name) {\n        int len = strlen(sym_name);\n        int slen = strlen(\"_module\");\n        if (len > slen && !strcmp(sym_name + len - slen, \"_module\")) {\n            len -= slen;\n        }\n\n        ap_module_short_names[m->module_index] = ap_malloc(len + 1);\n        memcpy(ap_module_short_names[m->module_index], sym_name, len);\n        ap_module_short_names[m->module_index][len] = '\\0';\n        merger_func_cache[m->module_index] = m->merge_dir_config;\n    }\n\n\n    /* Some C compilers put a complete path into __FILE__, but we want\n     * only the filename (e.g. mod_includes.c). So check for path\n     * components (Unix and DOS), and remove them.\n     */\n\n    if (ap_strrchr_c(m->name, '/'))\n        m->name = 1 + ap_strrchr_c(m->name, '/');\n\n    if (ap_strrchr_c(m->name, '\\\\'))\n        m->name = 1 + ap_strrchr_c(m->name, '\\\\');\n\n#ifdef _OSD_POSIX\n    /* __FILE__ =\n     * \"*POSIX(/home/martin/apache/src/modules/standard/mod_info.c)\"\n     */\n\n    \n    if (m->name[strlen(m->name)-1] == ')') {\n        char *tmp = ap_malloc(strlen(m->name)); \n        memcpy(tmp, m->name, strlen(m->name)-1);\n        tmp[strlen(m->name)-1] = '\\0';\n        m->name = tmp;\n    }\n#endif \n\n    ap_add_module_commands(m, p);\n    /*  FIXME: is this the right place to call this?\n     *  It doesn't appear to be\n     */\n    ap_register_hooks(m, p);\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n762,Mismatched Memory Management Routines"
  },
  "httpd_8a3fa195b3037b92fc34c2997d46d7bc9455de26_0", {
    "ID": "httpd_8a3fa195b3037b92fc34c2997d46d7bc9455de26_0",
    "UID": "3046",
    "code": "static int read_request_line(request_rec *r, apr_bucket_brigade test_snippet\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n\n    int major = 1, minor = 0;   \n    char http[5];\n    apr_size_t len;\n    int num_blank_lines = 0;\n    int max_blank_lines = r->server->limit_req_fields;\n\n    if (max_blank_lines <= 0) {\n        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;\n    }\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (APR_STATUS_IS_ENOSPC(rv)) {\n                r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n                r->proto_num = HTTP_VERSION(1,0);\n                r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else if (APR_STATUS_IS_EINVAL(rv)) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            return 0;\n        }\n    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));\n\n    if (APLOGrtrace5(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                      \"Request received from client: %s\",\n                      ap_escape_logitem(r->pool, r->the_request));\n    }\n\n    r->request_time = apr_time_now();\n    ll = r->the_request;\n    r->method = ap_getword_white(r->pool, &ll);\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    \n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        core_server_config *conf;\n        conf = ap_get_core_module_config(r->server->module_config);\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n        if (conf->http09_enable == AP_HTTP09_DISABLE) {\n                r->status = HTTP_VERSION_NOT_SUPPORTED;\n                r->protocol = apr_pstrmemdup(r->pool, pro, len);\n                \n                r->assbackwards = 0;\n                r->proto_num = HTTP_VERSION(0, 9);\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)\n                              \"HTTP/0.9 denied by server configuration\");\n                return 0;\n        }\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    \n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n             && (strcasecmp(\"http\", http) == 0)\n             && (minor < HTTP_VERSION(1, 0)) ) \n        r->proto_num = HTTP_VERSION(major, minor);\n    else\n        r->proto_num = HTTP_VERSION(1, 0);\n\n    return 1;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n606,Unchecked Input for Loop Condition"
  },
  "httpd_d8fe194c4aacc795f30992f205db8d9eb5571c87_0", {
    "ID": "httpd_d8fe194c4aacc795f30992f205db8d9eb5571c87_0",
    "UID": "3057",
    "code": "static const char *ifsection(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    /*\n     * Set a dummy value so that other directives notice that they are inside\n     * a config section.\n     */\n    cmd->path = \"*If\";\n    \n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    \n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n"
  },
  "httpd_748a130913799e268e04af19a7cc950fa2621782_0", {
    "ID": "httpd_748a130913799e268e04af19a7cc950fa2621782_0",
    "UID": "3065",
    "code": "static const char *log_request_duration_scaled(request_rec *r, char test_snippet\n{\n    apr_time_t duration = get_request_end_time(r) - r->request_time;\n    if (*a == '\\0' || !strcasecmp(a, \"s\")) {\n        duration = apr_time_sec(duration);\n    }\n    else if (!strcasecmp(a, \"ms\")) {\n        duration = apr_time_as_msec(duration);\n    }\n    else if (!strcasecmp(a, \"us\")) {\n    }\n    else {\n        \n        return a;\n    }\n    return apr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, duration);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_bc38f591c5b9bc60f16ab0c0936e0c51f593247b_0", {
    "ID": "httpd_bc38f591c5b9bc60f16ab0c0936e0c51f593247b_0",
    "UID": "3066",
    "code": "PROXY_DECLARE(char *) ap_proxy_define_balancer(apr_pool_t test_snippet\n                                               proxy_balancer **balancer,\n                                               proxy_server_conf *conf,\n                                               const char *url,\n                                               const char *alias,\n                                               int do_malloc)\n{\n    proxy_balancer_method *lbmethod;\n    proxy_balancer_shared *bshared;\n    char *c, *q, *uri = apr_pstrdup(p, url);\n    const char *sname;\n\n    \n\n    c = strchr(uri, ':');\n    if (c == NULL || c[1] != '/' || c[2] != '/' || c[3] == '\\0')\n        return apr_psprintf(p, \"Bad syntax for a balancer name (%s)\", uri);\n    \n    if ((q = strchr(c + 3, '/')))\n        *q = '\\0';\n\n    ap_str_tolower(uri);\n    *balancer = apr_array_push(conf->balancers);\n    memset(*balancer, 0, sizeof(proxy_balancer));\n\n    /*\n     * NOTE: The default method is byrequests - if it doesn't\n     * exist, that's OK at this time. We check when we share and sync\n     */\n    lbmethod = ap_lookup_provider(PROXY_LBMETHOD, \"byrequests\", \"0\");\n\n    (*balancer)->workers = apr_array_make(p, 5, sizeof(proxy_worker *));\n    (*balancer)->gmutex = NULL;\n    (*balancer)->tmutex = NULL;\n    (*balancer)->lbmethod = lbmethod;\n\n    if (do_malloc)\n        bshared = ap_malloc(sizeof(proxy_balancer_shared));\n    else\n        bshared = apr_palloc(p, sizeof(proxy_balancer_shared));\n\n    memset(bshared, 0, sizeof(proxy_balancer_shared));\n\n    bshared->was_malloced = (do_malloc != 0);\n    PROXY_STRNCPY(bshared->lbpname, \"byrequests\");\n    if (PROXY_STRNCPY(bshared->name, uri) != APR_SUCCESS) {\n        return apr_psprintf(p, \"balancer name (%s) too long\", uri);\n    }\n    /*\n     * We do the below for verification. The real sname will be\n     * done post_config\n     */\n    ap_pstr2_alnum(p, bshared->name + sizeof(BALANCER_PREFIX) - 1,\n                   &sname);\n    sname = apr_pstrcat(p, conf->id, \"_\", sname, NULL);\n    if (PROXY_STRNCPY(bshared->sname, sname) != APR_SUCCESS) {\n        return apr_psprintf(p, \"balancer safe-name (%s) too long\", sname);\n    }\n    bshared->hash.def = ap_proxy_hashfunc(bshared->name, PROXY_HASHFUNC_DEFAULT);\n    bshared->hash.fnv = ap_proxy_hashfunc(bshared->name, PROXY_HASHFUNC_FNV);\n    (*balancer)->hash = bshared->hash;\n\n    bshared->forcerecovery = 1;\n    bshared->sticky_separator = '.';\n    *bshared->nonce = PROXY_UNSET_NONCE;  \n\n    (*balancer)->s = bshared;\n    (*balancer)->sconf = conf;\n\n    return ap_proxy_update_balancer(p, *balancer, alias);\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference"
  },
  "httpd_1f711741543a37d3241147397cb29b49e2c076f4_0", {
    "ID": "httpd_1f711741543a37d3241147397cb29b49e2c076f4_0",
    "UID": "3070",
    "code": "AP_DECLARE(apr_status_t) ap_pstr2_alnum(apr_pool_t *p, const char test_snippet\n                                        const char **dest)\n{\n    char *new = apr_palloc(p, strlen(src)+1);\n    if (!new)\n        return APR_ENOMEM;\n    *dest = new;\n    return ap_str2_alnum(src, new);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6dce98459505264a840c896978bf0f0fb5b7c423_0", {
    "ID": "httpd_6dce98459505264a840c896978bf0f0fb5b7c423_0",
    "UID": "3071",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_strncpy(char *dst, const char test_snippet\n                                             apr_size_t dlen)\n{\n    char *thenil;\n    apr_size_t thelen;\n\n    \n    if (!dlen) {\n        \n        return APR_EGENERAL;\n    }\n    if (!src) {\n        *dst = '\\0';\n        return APR_SUCCESS;\n    }\n    thenil = apr_cpystrn(dst, src, dlen);\n    thelen = thenil - dst;\n    if (src[thelen] == '\\0') {\n        return APR_SUCCESS;\n    }\n    return APR_EGENERAL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_50ba0ef6e64be20bf2e69e7bcd6819a274b5472f_0", {
    "ID": "httpd_50ba0ef6e64be20bf2e69e7bcd6819a274b5472f_0",
    "UID": "3072",
    "code": "static char *lookup_map_dbd(request_rec *r, char *key, const char test_snippet\n{\n    apr_status_t rv;\n    apr_dbd_prepared_t *stmt;\n    const char *errmsg;\n    apr_dbd_results_t *res = NULL;\n    apr_dbd_row_t *row = NULL;\n    char *ret = NULL;\n    int n = 0;\n    ap_dbd_t *db = dbd_acquire(r);\n\n    stmt = apr_hash_get(db->prepared, label, APR_HASH_KEY_STRING);\n\n    rv = apr_dbd_pvselect(db->driver, r->pool, db->handle, &res,\n                          stmt, 0, key, NULL);\n    if (rv != 0) {\n        errmsg = apr_dbd_error(db->driver, db->handle, rv);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00657)\n                      \"rewritemap: error %s querying for %s\", errmsg, key);\n        return NULL;\n    }\n    while ((rv = apr_dbd_get_row(db->driver, r->pool, res, &row, -1)) == 0) {\n        ++n;\n        if (ret == NULL) {\n            ret = apr_pstrdup(r->pool,\n                              apr_dbd_get_entry(db->driver, row, 0));\n        }\n        else {\n            \n            if ((double)rand() < (double)RAND_MAX/(double)n) {\n                ret = apr_pstrdup(r->pool,\n                                  apr_dbd_get_entry(db->driver, row, 0));\n            }\n        }\n    }\n    if (rv != -1) {\n        errmsg = apr_dbd_error(db->driver, db->handle, rv);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00658)\n                      \"rewritemap: error %s looking up %s\", errmsg, key);\n    }\n    switch (n) {\n    case 0:\n        return NULL;\n    case 1:\n        return ret;\n    default:\n        \n        rewritelog((r, 3, NULL, \"Multiple values found for %s\", key));\n        return ret;\n    }\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_c85d5fc5fd3fa50b298c9f5f38ea04744182bd5f_0", {
    "ID": "httpd_c85d5fc5fd3fa50b298c9f5f38ea04744182bd5f_0",
    "UID": "3073",
    "code": "static const char *set_transfer_log(cmd_parms *cmd, void test_snippet\n                                    const char *fn)\n{\n    return add_custom_log(cmd, dummy, fn, NULL, NULL);\n}",
    "predicted": "15,External Control of System or Configuration Setting\n427,Uncontrolled Search Path Element"
  },
  "httpd_0d060b068a0581c6ca7cdda4c38faddd124304bd_0", {
    "ID": "httpd_0d060b068a0581c6ca7cdda4c38faddd124304bd_0",
    "UID": "3075",
    "code": "static int check_log_dir(apr_pool_t *p, server_rec *s, config_log_state test_snippet\n{\n    if (!cls->fname || cls->fname[0] == '|' || !cls->directive) {\n        return OK;\n    }\n    else {\n        char *abs = ap_server_root_relative(p, cls->fname);\n        char *dir = ap_make_dirstr_parent(p, abs);\n        apr_finfo_t finfo;\n        const ap_directive_t *directive = cls->directive;\n        apr_status_t rv = apr_stat(&finfo, dir, APR_FINFO_TYPE, p);\n        cls->directive = NULL; \n        if (rv == APR_SUCCESS && finfo.filetype != APR_DIR)\n            rv = APR_ENOTDIR;\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, rv, s,\n                         APLOGNO(02297)\n                         \"Cannot access directory '%s' for log file '%s' \"\n                         \"defined at %s:%d\", dir, cls->fname,\n                         directive->filename, directive->line_num);\n            return !OK;\n        }\n    }\n    return OK;\n}",
    "predicted": "36,Absolute Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_b58195e4b778c2d0ddda77b19b4a554ee1f219c3_0", {
    "ID": "httpd_b58195e4b778c2d0ddda77b19b4a554ee1f219c3_0",
    "UID": "3084",
    "code": "static apr_status_t decrement_busy_count(void test_snippet\n{\n    proxy_worker *worker = worker_;\n    \n    if (worker->s->busy) {\n        worker->s->busy--;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e432519e4edbd241a26d28a97f59ccd0454173ce_0", {
    "ID": "httpd_e432519e4edbd241a26d28a97f59ccd0454173ce_0",
    "UID": "3089",
    "code": "static int dumpio_output_filter (ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    apr_bucket *b;\n    conn_rec *c = f->c;\n    dumpio_conf_t *ptr = f->ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c, \"mod_dumpio: %s\", f->frec->name);\n\n    for (b = APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b = APR_BUCKET_NEXT(b)) {\n        /*\n         * If we ever see an EOS, make sure to FLUSH.\n         */\n        if (APR_BUCKET_IS_EOS(b)) {\n            apr_bucket *flush = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(b, flush);\n        }\n        dumpit(f, b, ptr);\n    }\n\n    return ap_pass_brigade(f->next, bb) ;\n}",
    "predicted": "null"
  },
  "httpd_61e93fbee47cc1449cfe20835897f0dc975e4f1d_0", {
    "ID": "httpd_61e93fbee47cc1449cfe20835897f0dc975e4f1d_0",
    "UID": "3092",
    "code": "AP_DECLARE(void) ap_relieve_child_processes(ap_reclaim_callback_fn_t test_snippet\n{\n    int i;\n    extra_process_t *cur_extra;\n    int max_daemons;\n\n    ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);\n\n    \n    for (i = 0; i < max_daemons; ++i) {\n        process_score *ps = ap_get_scoreboard_process(i);\n        pid_t pid = ps->pid;\n\n        if (pid == 0) {\n            continue; \n        }\n\n        if (reclaim_one_pid(pid, DO_NOTHING)) {\n            mpm_callback(i, 0, 0);\n        }\n    }\n\n    cur_extra = extras;\n    while (cur_extra) {\n        ap_generation_t old_gen;\n        extra_process_t *next = cur_extra->next;\n\n        if (reclaim_one_pid(cur_extra->pid, DO_NOTHING)) {\n            if (ap_unregister_extra_mpm_process(cur_extra->pid, &old_gen) == 1) {\n                mpm_callback(-1, cur_extra->pid, old_gen);\n            }\n            else {\n                AP_DEBUG_ASSERT(1 == 0);\n            }\n        }\n        cur_extra = next;\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n617,Reachable Assertion"
  },
  "httpd_2af0417f6d1c9d7bda4564424231cb5b1b721f6c_0", {
    "ID": "httpd_2af0417f6d1c9d7bda4564424231cb5b1b721f6c_0",
    "UID": "3096",
    "code": "static void end_gen(mpm_gen_info_t test_snippet\n{\n    ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, ap_server_conf,\n                 \"end of generation %d\", gi->gen);\n    ap_run_end_generation(ap_server_conf, gi->gen);\n    APR_RING_REMOVE(gi, link);\n    APR_RING_INSERT_HEAD(unused_geninfo, gi, mpm_gen_info_t, link);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e8aea414c0b8f27c2171286fbe3e4ccb406ab98a_0", {
    "ID": "httpd_e8aea414c0b8f27c2171286fbe3e4ccb406ab98a_0",
    "UID": "3097",
    "code": "apr_status_t ap_mpm_end_gen_helper(void *unused) /* cleanup on pconf test_snippet\n{\n    int gen = ap_config_generation - 1; /* differs from MPM generation test_snippet\n    mpm_gen_info_t *cur;\n\n    if (geninfo == NULL) {\n        /* initial pconf teardown, MPM hasn't run test_snippet\n        return APR_SUCCESS;\n    }\n\n    cur = APR_RING_FIRST(geninfo);\n    while (cur != APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link) &&\n           cur->gen != gen) {\n        cur = APR_RING_NEXT(cur, link);\n    }\n\n    if (cur == APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link)) {\n        /* last child of generation already exited test_snippet\n        ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, ap_server_conf,\n                     \"no record of generation %d\", gen);\n    }\n    else {\n        cur->done = 1;\n        if (cur->active == 0) {\n            end_gen(cur);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_aeec0dc3a972452ca1825694dd60d400ed8e58c7_0", {
    "ID": "httpd_aeec0dc3a972452ca1825694dd60d400ed8e58c7_0",
    "UID": "3098",
    "code": "void ap_core_child_status(server_rec *s, pid_t test_snippet\n                          ap_generation_t gen, int slot,\n                          mpm_child_status status)\n{\n    mpm_gen_info_t *cur;\n    const char *status_msg = \"unknown status\";\n\n    if (!gen_head_init) { \n        gen_head_init = 1;\n        geninfo = apr_pcalloc(s->process->pool, sizeof *geninfo);\n        unused_geninfo = apr_pcalloc(s->process->pool, sizeof *unused_geninfo);\n        APR_RING_INIT(geninfo, mpm_gen_info_t, link);\n        APR_RING_INIT(unused_geninfo, mpm_gen_info_t, link);\n    }\n\n    cur = APR_RING_FIRST(geninfo);\n    while (cur != APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link) &&\n           cur->gen != gen) {\n        cur = APR_RING_NEXT(cur, link);\n    }\n\n    switch(status) {\n    case MPM_CHILD_STARTED:\n        status_msg = \"started\";\n        if (cur == APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link)) {\n            \n            if (!APR_RING_EMPTY(unused_geninfo, mpm_gen_info_t, link)) {\n                cur = APR_RING_FIRST(unused_geninfo);\n                APR_RING_REMOVE(cur, link);\n                cur->active = cur->done = 0;\n            }\n            else {\n                cur = apr_pcalloc(s->process->pool, sizeof *cur);\n            }\n            cur->gen = gen;\n            APR_RING_ELEM_INIT(cur, link);\n            APR_RING_INSERT_HEAD(geninfo, cur, mpm_gen_info_t, link);\n        }\n        ap_random_parent_after_fork();\n        ++cur->active;\n        break;\n    case MPM_CHILD_EXITED:\n        status_msg = \"exited\";\n        if (cur == APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link)) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00546)\n                         \"no record of generation %d of exiting child %\" APR_PID_T_FMT,\n                         gen, pid);\n        }\n        else {\n            --cur->active;\n            if (!cur->active && cur->done) { \n                end_gen(cur);\n            }\n        }\n        break;\n    case MPM_CHILD_LOST_SLOT:\n        status_msg = \"lost slot\";\n        \n        break;\n    }\n    ap_log_error(APLOG_MARK, APLOG_TRACE4, 0, s,\n                 \"mpm child %\" APR_PID_T_FMT \" (gen %d/slot %d) %s\",\n                 test_snippet gen, slot, status_msg);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_7bb4fa9ed57322aad5ec59115c9d8fca0729caf6_0", {
    "ID": "httpd_7bb4fa9ed57322aad5ec59115c9d8fca0729caf6_0",
    "UID": "3103",
    "code": "AP_DECLARE(void) ap_wait_or_timeout(apr_exit_why_e *status, int test_snippet\n                                    apr_proc_t *ret, apr_pool_t *p,\n                                    server_rec *s)\n{\n    apr_status_t rv;\n\n    ++wait_or_timeout_counter;\n    if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {\n        wait_or_timeout_counter = 0;\n        ap_run_monitor(p, s);\n    }\n\n    rv = apr_proc_wait_all_procs(ret, exitcode, status, APR_NOWAIT, p);\n    if (APR_STATUS_IS_EINTR(rv)) {\n        ret->pid = -1;\n        return;\n    }\n\n    if (APR_STATUS_IS_CHILD_DONE(rv)) {\n        return;\n    }\n\n    apr_sleep(apr_time_from_sec(1));\n    ret->pid = -1;\n    return;\n}",
    "predicted": "This code does not appear to have any specific vulnerabilities from the provided list. Therefore, the response is null."
  },
  "httpd_cfe28b3b1c3f98f95a9d75d2139340a039316bac_0", {
    "ID": "httpd_cfe28b3b1c3f98f95a9d75d2139340a039316bac_0",
    "UID": "3107",
    "code": "static apr_status_t ap_session_load(request_rec * r, session_rec ** test_snippet\n{\n\n    session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,\n                                                   &session_module);\n    apr_time_t now;\n    session_rec *zz = NULL;\n    int rv = 0;\n\n    \n    if (!dconf || !dconf->enabled) {\n        return APR_SUCCESS;\n    }\n\n    \n    if (!session_included(r, dconf)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01814)\n                      \"excluded by configuration for: %s\", r->uri);\n        return APR_SUCCESS;\n    }\n\n    \n    rv = ap_run_session_load(r, &ztest_snippet;\n    if (DECLINED == rv) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01815)\n                      \"session is enabled but no session modules have been configured, \"\n                      \"session not loaded: %s\", r->uri);\n        return APR_EGENERAL;\n    }\n    else if (OK != rv) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01816)\n                      \"error while loading the session, \"\n                      \"session not loaded: %s\", r->uri);\n        return rv;\n    }\n\n    \n    now = apr_time_now();\n    if (!zz || (zz->expiry && zz->expiry < now)) {\n\n        \n        zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));\n        zz->pool = r->pool;\n        zz->entries = apr_table_make(zz->pool, 10);\n\n    }\n    else {\n        rv = ap_run_session_decode(r, ztest_snippet;\n        if (OK != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01817)\n                          \"error while decoding the session, \"\n                          \"session not loaded: %s\", r->uri);\n            return rv;\n        }\n    }\n\n    \n    if (dconf->maxage) {\n        if (!zz->expiry) {\n            zz->expiry = now + dconf->maxage * APR_USEC_PER_SEC;\n        }\n        zz->maxage = dconf->maxage;\n    }\n\n    *z = zz;\n\n    return APR_SUCCESS;\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f226fd3fde53bc52d7010472bbef3dbdc3e687f0_0", {
    "ID": "httpd_f226fd3fde53bc52d7010472bbef3dbdc3e687f0_0",
    "UID": "3108",
    "code": "static int get_now(rotate_config_t *config, apr_int32_t test_snippet\n{\n    apr_time_t tNow = apr_time_now();\n    int utc_offset;\n\n    if (config->use_localtime) {\n        /* Check for our UTC offset before using it, since it might\n         * change if there's a switch between standard and daylight\n         * savings time.\n         */\n        apr_time_exp_t lt;\n        apr_time_exp_lt(&lt, tNow);\n        utc_offset = lt.tm_gmtoff;\n    }\n    else {\n        utc_offset = config->utc_offset;\n    }\n\n    if (offset)\n        *offset = utc_offset;\n\n    return (int)apr_time_sec(tNow) + utc_offset;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_dee325bb8bcd290a3d952d01aa9f21b463b73f40_0", {
    "ID": "httpd_dee325bb8bcd290a3d952d01aa9f21b463b73f40_0",
    "UID": "3109",
    "code": "static apr_status_t ap_session_save(request_rec * r, session_rec * test_snippet\n{\n    if (test_snippet {\n        apr_time_t now = apr_time_now();\n        int rv = 0;\n\n        session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,\n                                                       &session_module);\n\n        \n        if (z->written) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01818)\n                          \"attempt made to save the session twice, \"\n                          \"session not saved: %s\", r->uri);\n            return APR_EGENERAL;\n        }\n        if (z->expiry && z->expiry < now) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01819)\n                          \"attempt made to save a session when the session had already expired, \"\n                          \"session not saved: %s\", r->uri);\n            return APR_EGENERAL;\n        }\n\n        \n        if (dconf->maxage) {\n            z->expiry = now + dconf->maxage * APR_USEC_PER_SEC;\n            z->maxage = dconf->maxage;\n        }\n\n        \n        if (z->dirty && z->maxage) {\n            z->expiry = now + z->maxage * APR_USEC_PER_SEC;\n        } \n\n        \n        rv = ap_run_session_encode(r, test_snippet;\n        if (OK != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01820)\n                          \"error while encoding the session, \"\n                          \"session not saved: %s\", r->uri);\n            return rv;\n        }\n\n        \n        rv = ap_run_session_save(r, test_snippet;\n        if (DECLINED == rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01821)\n                          \"session is enabled but no session modules have been configured, \"\n                          \"session not saved: %s\", r->uri);\n            return APR_EGENERAL;\n        }\n        else if (OK != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01822)\n                          \"error while saving the session, \"\n                          \"session not saved: %s\", r->uri);\n            return rv;\n        }\n        else {\n            z->written = 1;\n        }\n    }\n\n    return APR_SUCCESS;\n\n}",
    "predicted": "The code provided has a flaw in the category:\n476,NULL Pointer Dereference\n\nThe function does not check if the pointer \"test_snippet\" is NULL before it is used, which can lead to a NULL pointer dereference."
  },
  "httpd_1f3cbc3b62bacec7f69b56eb15a8f1b3ebd39170_0", {
    "ID": "httpd_1f3cbc3b62bacec7f69b56eb15a8f1b3ebd39170_0",
    "UID": "3117",
    "code": "static int rewrite_url(request_rec *r, proxy_worker test_snippet\n                        char **url)\n{\n    const char *scheme = strstr(*url, \"://\");\n    const char *path = NULL;\n\n    if (scheme)\n        path = ap_strchr_c(scheme + 3, '/');\n\n    \n    if (!worker) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST, apr_pstrcat(r->pool,\n                             \"missing worker. URI cannot be parsed: \", *url,\n                             NULL));\n    }\n\n    *url = apr_pstrcat(r->pool, worker->s->name, path, NULL);\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_13f1a7e287372bf2d1aca55504868ad269df7515_0", {
    "ID": "httpd_13f1a7e287372bf2d1aca55504868ad269df7515_0",
    "UID": "3124",
    "code": "static void get_notes_auth(request_rec test_snippet\n                           const char **user, const char **pw,\n                           const char **method, const char **mimetype)\n{\n    const char *authname;\n    request_rec *m = r;\n\n    \n    while (m->main) {\n        m = m->main;\n    }\n    \n    while (m->prev) {\n        m = m->prev;\n    }\n\n    \n    authname = ap_auth_name(m);\n    if (user) {\n        *user = (char *) apr_table_get(m->notes, apr_pstrcat(m->pool, authname, \"-user\", NULL));\n    }\n    if (pw) {\n        *pw = (char *) apr_table_get(m->notes, apr_pstrcat(m->pool, authname, \"-pw\", NULL));\n    }\n    if (method) {\n        *method = (char *) apr_table_get(m->notes, apr_pstrcat(m->pool, authname, \"-method\", NULL));\n    }\n    if (mimetype) {\n        *mimetype = (char *) apr_table_get(m->notes, apr_pstrcat(m->pool, authname, \"-mimetype\", NULL));\n    }\n\n    \n    if (user && *user) {\n        r->user = (char *) *user;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE6, 0, r,\n                  \"from notes: user: %s, pw: %s, method: %s, mimetype: %s\",\n                  user ? *user : \"<null>\", pw ? *pw : \"<null>\",\n                  method ? *method : \"<null>\", mimetype ? *mimetype : \"<null>\");\n\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n526,Cleartext Storage of Sensitive Information in an Environment Variable"
  },
  "httpd_ba0a58404f40be0ae977893c65383bcb6fd09460_0", {
    "ID": "httpd_ba0a58404f40be0ae977893c65383bcb6fd09460_0",
    "UID": "3129",
    "code": "static apr_status_t dav_finish_multistatus(request_rec test_snippet\n                                           apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n\n    ap_fputs(r->output_filters, bb, \"</D:multistatus>\" DEBUG_CR);\n\n    \n    b = apr_bucket_eos_create(r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    \n    return ap_pass_brigade(r->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_c560bf0cdf112bf5ed45c1402ae6baf18be280bc_0", {
    "ID": "httpd_c560bf0cdf112bf5ed45c1402ae6baf18be280bc_0",
    "UID": "3134",
    "code": "static void doRotate(rotate_config_t *config, rotate_status_t test_snippet\n{\n    apr_int32_t offset;\n    int now;\n    int tLogStart;\n    apr_status_t rv;\n    struct logfile newlog;\n    int thisLogNum = -1;\n\n    \n    now = get_now(config, &offset);\n\n    status->rotateReason = ROTATE_NONE;\n\n    if (config->tRotation) {\n        int tLogEnd;\n        tLogStart = (now / config->tRotation) * config->tRotation;\n        tLogEnd = tLogStart + config->tRotation;\n        /*\n         * Check if rotation was forced and the last rotation\n         * interval is not yet over. Use the value of now instead\n         * of the time interval boundary for the file name then.\n         */\n        if (tLogStart < status->tLogEnd) {\n            tLogStart = now;\n        }\n        status->tLogEnd = tLogEnd;\n    }\n    else {\n        tLogStart = now;\n    }\n\n    if (config->use_strftime) {\n        apr_time_t tNow = apr_time_from_sec(tLogStart);\n        apr_time_exp_t e;\n        apr_size_t rs;\n\n        /* Explode the local-time-adjusted-Unix-time into a struct tm,\n         * first *reversing* local-time-adjustment applied by\n         * get_now() if we are using localtime. */\n        if (config->use_localtime)\n            apr_time_exp_lt(&e, tNow - apr_time_from_sec(offset));\n        else\n            apr_time_exp_gmt(&e, tNow);\n        apr_strftime(newlog.name, &rs, sizeof(newlog.name), config->szLogRoot, &e);\n    }\n    else {\n        if (config->truncate) {\n            apr_snprintf(newlog.name, sizeof(newlog.name), \"%s\", config->szLogRoot);\n        }\n        else if (config->num_files > 0) { \n            if (status->fileNum == -1 || status->fileNum == (config->num_files - 1)) {\n                thisLogNum = 0;\n                apr_snprintf(newlog.name, sizeof(newlog.name), \"%s\", config->szLogRoot);\n            }\n            else { \n                thisLogNum = status->fileNum + 1;\n                apr_snprintf(newlog.name, sizeof(newlog.name), \"%s.%d\", config->szLogRoot, thisLogNum);\n            }\n        }\n        else {\n            apr_snprintf(newlog.name, sizeof(newlog.name), \"%s.%010d\", config->szLogRoot,\n                         tLogStart);\n        }\n    }\n    apr_pool_create(&newlog.pool, status->pool);\n    if (config->verbose) {\n        fprintf(stderr, \"Opening file %s\\n\", newlog.name);\n    }\n    rv = apr_file_open(&newlog.fd, newlog.name, APR_WRITE | APR_CREATE | APR_APPEND\n                       | (config->truncate || (config->num_files > 0 && status->current.fd) ? APR_TRUNCATE : 0), \n                       APR_OS_DEFAULT, newlog.pool);\n    if (rv == APR_SUCCESS) {\n        \n        post_rotate(newlog.pool, &newlog, config, status);\n\n        status->fileNum = thisLogNum;\n        \n        if (status->current.fd) {\n            close_logfile(config, &status->current);\n        }\n\n        \n        status->current = newlog;\n    }\n    else {\n        char error[120];\n\n        apr_strerror(rv, error, sizeof error);\n\n        /* Uh-oh. Failed to open the new log file. Try to clear\n         * the previous log file, note the lost log entries,\n         * and keep on truckin'. */\n        if (status->current.fd == NULL) {\n            fprintf(stderr, \"Could not open log file '%s' (%s)\\n\", newlog.name, error);\n            exit(2);\n        }\n\n        \n        apr_pool_destroy(newlog.pool);\n\n        /* Try to keep this error message constant length\n         * in case it occurs several times. */\n        apr_snprintf(status->errbuf, sizeof status->errbuf,\n                     \"Resetting log file due to error opening \"\n                     \"new log file, %10d messages lost: %-25.25s\\n\",\n                     status->nMessCount, error);\n\n        truncate_and_write_error(status);\n    }\n\n    status->nMessCount = 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_00d98f044413bdb9360e922a3cea08891f10c816_0", {
    "ID": "httpd_00d98f044413bdb9360e922a3cea08891f10c816_0",
    "UID": "3138",
    "code": "static int display_info(request_rec * test_snippet\n{\n    module *modp = NULL;\n    const char *more_info;\n    const command_rec *cmd;\n    apr_array_header_t *modules = NULL;\n    int i;\n\n    if (strcmp(r->handler, \"server-info\")) {\n        return DECLINED;\n    }\n\n    r->allowed |= (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET) {\n        return DECLINED;\n    }\n\n    ap_set_content_type(r, \"text/html; charset=ISO-8859-1\");\n\n    ap_rputs(DOCTYPE_XHTML_1_0T\n             \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n\"\n             \"<head>\\n\"\n             \"  <title>Server Information</title>\\n\" \"</head>\\n\", test_snippet;\n    ap_rputs(\"<body><h1 style=\\\"text-align: center\\\">\"\n             \"Apache Server Information</h1>\\n\", test_snippet;\n    if (!r->args || strcasecmp(r->args, \"list\")) {\n        if (!r->args) {\n            ap_rputs(\"<dl><dt><tt>Subpages:<br />\", test_snippet;\n            ap_rputs(\"<a href=\\\"?config\\\">Configuration Files</a>, \"\n                     \"<a href=\\\"?server\\\">Server Settings</a>, \"\n                     \"<a href=\\\"?list\\\">Module List</a>, \"\n                     \"<a href=\\\"?hooks\\\">Active Hooks</a>, \"\n                     \"<a href=\\\"?providers\\\">Available Providers</a>\", test_snippet;\n            ap_rputs(\"</tt></dt></dl><hr />\", test_snippet;\n\n            ap_rputs(\"<dl><dt><tt>Sections:<br />\", test_snippet;\n            ap_rputs(\"<a href=\\\"#modules\\\">Loaded Modules</a>, \"\n                     \"<a href=\\\"#server\\\">Server Settings</a>, \"\n                     \"<a href=\\\"#startup_hooks\\\">Startup Hooks</a>, \"\n                     \"<a href=\\\"#request_hooks\\\">Request Hooks</a>, \"\n                     \"<a href=\\\"#other_hooks\\\">Other Hooks</a>, \"\n                     \"<a href=\\\"#providers\\\">Providers</a>\", test_snippet;\n            ap_rputs(\"</tt></dt></dl><hr />\", test_snippet;\n\n            ap_rputs(\"<h2><a name=\\\"modules\\\">Loaded Modules</a></h2>\"\n                    \"<dl><dt><tt>\", test_snippet;\n\n            modules = get_sorted_modules(r->pool);\n            for (i = 0; i < modules->nelts; i++) {\n                modp = APR_ARRAY_IDX(modules, i, module *);\n                ap_rprintf(r, \"<a href=\\\"#%s\\\">%s</a>\", modp->name,\n                           modp->name);\n                if (i < modules->nelts) {\n                    ap_rputs(\", \", test_snippet;\n                }\n            }\n            ap_rputs(\"</tt></dt></dl><hr />\", test_snippet;\n        }\n\n        if (!r->args || !strcasecmp(r->args, \"server\")) {\n            show_server_settings(test_snippet;\n        }\n\n        if (!r->args || !strcasecmp(r->args, \"hooks\")) {\n            show_active_hooks(test_snippet;\n        }\n\n        if (!r->args || !strcasecmp(r->args, \"providers\")) {\n            show_providers(test_snippet;\n        }\n\n        if (r->args && 0 == strcasecmp(r->args, \"config\")) {\n            ap_rputs(\"<dl><dt><strong>Configuration:</strong>\\n\", test_snippet;\n            mod_info_module_cmds(r, NULL, ap_conftree, 0, 0);\n            ap_rputs(\"</dl><hr />\", test_snippet;\n        }\n        else {\n            int comma = 0;\n            if (!modules)\n                 modules = get_sorted_modules(r->pool);\n            for (i = 0; i < modules->nelts; i++) {\n                modp = APR_ARRAY_IDX(modules, i, module *);\n                if (!r->args || !strcasecmp(modp->name, r->args)) {\n                    ap_rprintf(r,\n                               \"<dl><dt><a name=\\\"%s\\\"><strong>Module Name:</strong></a> \"\n                               \"<font size=\\\"+1\\\"><tt><a href=\\\"?%s\\\">%s</a></tt></font></dt>\\n\",\n                               modp->name, modp->name, modp->name);\n                    ap_rputs(\"<dt><strong>Content handlers:</strong> \", test_snippet;\n\n                    if (module_find_hook(modp, ap_hook_get_handletest_snippet) {\n                        ap_rputs(\"<tt> <em>yes</em></tt>\", test_snippet;\n                    }\n                    else {\n                        ap_rputs(\"<tt> <em>none</em></tt>\", test_snippet;\n                    }\n\n                    ap_rputs(\"</dt>\", test_snippet;\n                    ap_rputs\n                        (\"<dt><strong>Configuration Phase Participation:</strong>\\n\",\n                         test_snippet;\n                    if (modp->create_dir_config) {\n                        if (comma) {\n                            ap_rputs(\", \", test_snippet;\n                        }\n                        ap_rputs(\"<tt>Create Directory Config</tt>\", test_snippet;\n                        comma = 1;\n                    }\n                    if (modp->merge_dir_config) {\n                        if (comma) {\n                            ap_rputs(\", \", test_snippet;\n                        }\n                        ap_rputs(\"<tt>Merge Directory Configs</tt>\", test_snippet;\n                        comma = 1;\n                    }\n                    if (modp->create_server_config) {\n                        if (comma) {\n                            ap_rputs(\", \", test_snippet;\n                        }\n                        ap_rputs(\"<tt>Create Server Config</tt>\", test_snippet;\n                        comma = 1;\n                    }\n                    if (modp->merge_server_config) {\n                        if (comma) {\n                            ap_rputs(\", \", test_snippet;\n                        }\n                        ap_rputs(\"<tt>Merge Server Configs</tt>\", test_snippet;\n                        comma = 1;\n                    }\n                    if (!comma)\n                        ap_rputs(\"<tt> <em>none</em></tt>\", test_snippet;\n                    comma = 0;\n                    ap_rputs(\"</dt>\", test_snippet;\n\n                    module_request_hook_participate(r, modp);\n\n                    cmd = modp->cmds;\n                    if (cmd) {\n                        ap_rputs\n                            (\"<dt><strong>Module Directives:</strong></dt>\",\n                             test_snippet;\n                        while (cmd) {\n                            if (cmd->name) {\n                                ap_rprintf(r, \"<dd><tt>%s%s - <i>\",\n                                           ap_escape_html(r->pool, cmd->name),\n                                           cmd->name[0] == '<' ? \"&gt;\" : \"\");\n                                if (cmd->errmsg) {\n                                    ap_rputs(ap_escape_html(r->pool, cmd->errmsg), test_snippet;\n                                }\n                                ap_rputs(\"</i></tt></dd>\\n\", test_snippet;\n                            }\n                            else {\n                                break;\n                            }\n                            cmd++;\n                        }\n                        ap_rputs\n                            (\"<dt><strong>Current Configuration:</strong></dt>\\n\",\n                             test_snippet;\n                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,\n                                             0);\n                    }\n                    else {\n                        ap_rputs\n                            (\"<dt><strong>Module Directives:</strong> <tt>none</tt></dt>\",\n                             test_snippet;\n                    }\n                    more_info = find_more_info(r->server, modp->name);\n                    if (more_info) {\n                        ap_rputs\n                            (\"<dt><strong>Additional Information:</strong>\\n</dt><dd>\",\n                             test_snippet;\n                        ap_rputs(more_info, test_snippet;\n                        ap_rputs(\"</dd>\", test_snippet;\n                    }\n                    ap_rputs(\"</dl><hr />\\n\", test_snippet;\n                    if (r->args) {\n                        break;\n                    }\n                }\n            }\n            if (!modp && r->args && strcasecmp(r->args, \"server\")) {\n                ap_rputs(\"<p><b>No such module</b></p>\\n\", test_snippet;\n            }\n        }\n    }\n    else {\n        ap_rputs(\"<dl><dt>Server Module List</dt>\", test_snippet;\n        modules = get_sorted_modules(r->pool);\n        for (i = 0; i < modules->nelts; i++) {\n            modp = APR_ARRAY_IDX(modules, i, module *);\n            ap_rputs(\"<dd>\", test_snippet;\n            ap_rputs(modp->name, test_snippet;\n            ap_rputs(\"</dd>\", test_snippet;\n        }\n        ap_rputs(\"</dl><hr />\", test_snippet;\n    }\n    ap_rputs(ap_psignature(\"\", test_snippet, test_snippet;\n    ap_rputs(\"</body></html>\\n\", test_snippet;\n    \n    return 0;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_30709499b383eecbc3a2331740c7fed16b378103_0", {
    "ID": "httpd_30709499b383eecbc3a2331740c7fed16b378103_0",
    "UID": "3141",
    "code": "static void reduce_uri(request_rec test_snippet\n{\n    char *cp;\n    apr_size_t l;\n\n    cp = (char *)ap_http_scheme(r);\n    l  = strlen(cp);\n    if (   strlen(r->filename) > l+3\n        && strncasecmp(r->filename, cp, l) == 0\n        && r->filename[l]   == ':'\n        && r->filename[l+1] == '/'\n        && r->filename[l+2] == '/' ) {\n\n        unsigned short port;\n        char *portp, *host, *url, *scratch;\n\n        scratch = apr_pstrdup(r->pool, r->filename); \n\n        \n        cp = host = scratch + l + 3;    \n        while (*cp && *cp != '/' && *cp != ':') {\n            ++cp;\n        }\n\n        if (*cp == ':') {      \n            *cp++ = '\\0';\n            portp = cp;\n            while (*cp && *cp != '/') {\n                ++cp;\n            }\n            *cp = '\\0';\n\n            port = atoi(portp);\n            url = r->filename + (cp - scratch);\n            if (!*url) {\n                url = \"/\";\n            }\n        }\n        else if (*cp == '/') { \n            *cp = '\\0';\n\n            port = ap_default_port(r);\n            url = r->filename + (cp - scratch);\n        }\n        else {\n            port = ap_default_port(r);\n            url = \"/\";\n        }\n\n        \n        if (ap_matches_request_vhost(r, host, port)) {\n            rewritelog((r, 3, NULL, \"reduce %s -> %s\", r->filename, url));\n            r->filename = apr_pstrdup(r->pool, url);\n        }\n    }\n\n    return;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n20,Improper Input Validation"
  },
  "httpd_ae1f8e0abfc59dc648f5ffd6b18aa9f55e50f44b_0", {
    "ID": "httpd_ae1f8e0abfc59dc648f5ffd6b18aa9f55e50f44b_0",
    "UID": "3142",
    "code": "static int dav_method_get(request_rec test_snippet\n{\n    dav_resource *resource;\n    dav_error *err;\n    int status;\n\n    /* This method should only be called when the resource is not\n     * visible to Apache. We will fetch the resource from the repository,\n     * then create a subrequest for Apache to handle.\n     */\n    err = dav_get_resource(r, 1 , 0 /* use_checked_in */,\n                           &resource);\n    if (err != NULL)\n        return dav_handle_err(r, err, NULL);\n\n    if (!resource->exists) {\n        \n        return HTTP_NOT_FOUND;\n    }\n\n    \n    if ((err = (*resource->hooks->set_headers)(r, resource)) != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             \"Unable to set up HTTP headers.\",\n                             err);\n        return dav_handle_err(r, err, NULL);\n    }\n\n    \n    status = ap_meets_conditions(r);\n    if (status) {\n      return status;\n    }\n\n    if (r->header_only) {\n        return DONE;\n    }\n\n    \n    if ((err = (*resource->hooks->deliver)(resource,\n                                           r->output_filters)) != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             \"Unable to deliver content.\",\n                             err);\n        return dav_handle_err(r, err, NULL);\n    }\n\n    return DONE;\n}",
    "predicted": "This code seems to be fine, there is no obvious flaw in it. So, the response is null."
  },
  "httpd_342109bd49d9186818e47ec75c268c818454e142_0", {
    "ID": "httpd_342109bd49d9186818e47ec75c268c818454e142_0",
    "UID": "3145",
    "code": "static int dav_method_delete(request_rec test_snippet\n{\n    dav_resource *resource;\n    dav_auto_version_info av_info;\n    dav_error *err;\n    dav_error *err2;\n    dav_response *multi_response;\n    int result;\n    int depth;\n\n    \n    if ((result = ap_discard_request_body(r)) != OK) {\n        return result;\n    }\n\n    \n    err = dav_get_resource(r, 0 , 0 /* use_checked_in */,\n                           &resource);\n    if (err != NULL)\n        return dav_handle_err(r, err, NULL);\n    if (!resource->exists) {\n        \n        return HTTP_NOT_FOUND;\n    }\n\n    /* 2518 says that depth must be infinity only for collections.\n     * For non-collections, depth is ignored, unless it is an illegal value (1).\n     */\n    depth = dav_get_depth(r, DAV_INFINITY);\n\n    if (resource->collection && depth != DAV_INFINITY) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00582)\n                      \"Depth must be \\\"infinity\\\" for DELETE of a collection.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (!resource->collection && depth == 1) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00583)\n                      \"Depth of \\\"1\\\" is not allowed for DELETE.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /*\n    ** If any resources fail the lock/If: conditions, then we must fail\n    ** the delete. Each of the failing resources will be listed within\n    ** a DAV:multistatus body, wrapped into a 424 response.\n    **\n    ** Note that a failure on the resource itself does not generate a\n    ** multistatus response -- only internal members/collections.\n    */\n    if ((err = dav_validate_request(r, resource, depth, NULL,\n                                    &multi_response,\n                                    DAV_VALIDATE_PARENT\n                                    | DAV_VALIDATE_USE_424, NULL)) != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not DELETE %s due to a failed \"\n                                          \"precondition (e.g. locks).\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, multi_response);\n    }\n\n    /* ### RFC 2518 s. 8.10.5 says to remove _all_ locks, not just those\n     *     locked by the token(s) in the if_header.\n     */\n    if ((result = dav_unlock(r, resource, NULL)) != OK) {\n        return result;\n    }\n\n    \n    if ((err = dav_auto_checkout(r, resource, 1 ,\n                                 &av_info)) != NULL) {\n        \n        return dav_handle_err(r, err, NULL);\n    }\n\n    \n    err = (*resource->hooks->remove_resource)(resource, &multi_response);\n\n    \n    err2 = dav_auto_checkin(r, NULL, err != NULL ,\n                            0 , &av_info);\n\n    \n    if (err != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not DELETE %s.\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, multi_response);\n    }\n    if (err2 != NULL) {\n        \n        err = dav_push_error(r->pool, err2->status, 0,\n                             \"The DELETE was successful, but there \"\n                             \"was a problem automatically checking in \"\n                             \"the parent collection.\",\n                             err2);\n        dav_log_err(r, err, APLOG_WARNING);\n    }\n\n    \n\n    \n    return HTTP_NO_CONTENT;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_acfaac92485d64bc3f6475572e9af7224f11f8de_0", {
    "ID": "httpd_acfaac92485d64bc3f6475572e9af7224f11f8de_0",
    "UID": "3162",
    "code": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char test_snippet\n                                     apr_size_t bufsiz)\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n\n    if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n        return 0;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv != APR_SUCCESS) {\n        apr_bucket *e;\n\n        /* work around our silent swallowing of error messages by mapping\n         * error codes at this point, and sending an error bucket back\n         * upstream.\n         */\n        apr_brigade_cleanup(bb);\n\n        e = ap_bucket_error_create(\n                ap_map_http_request_error(rv, HTTP_BAD_REQUEST), NULL, r->pool,\n                r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (APR_SUCCESS != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r, APLOGNO(02484)\n                          \"Error while writing error response\");\n        }\n\n        /* if we actually fail here, we want to just return and\n         * stop trying to read data from the client.\n         */\n        r->connection->keepalive = AP_CONN_CLOSE;\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        if (r->read_chunked) {\n            r->remaining = -1;\n        }\n        else {\n            r->remaining = 0;\n        }\n    }\n\n    rv = apr_brigade_flatten(bb, buffer, &bufsiz);\n    if (rv != APR_SUCCESS) {\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    \n    r->read_length += bufsiz;\n\n    apr_brigade_destroy(bb);\n    return bufsiz;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_24a7f0ac50ca8d001f9e5bf4a5686b99a20ec0b3_0", {
    "ID": "httpd_24a7f0ac50ca8d001f9e5bf4a5686b99a20ec0b3_0",
    "UID": "3167",
    "code": "PROXY_DECLARE(proxy_worker *) ap_proxy_get_worker(apr_pool_t test_snippet\n                                                  proxy_balancer *balancer,\n                                                  proxy_server_conf *conf,\n                                                  const char *url)\n{\n    proxy_worker *worker;\n    proxy_worker *max_worker = NULL;\n    int max_match = 0;\n    int url_length;\n    int min_match;\n    int worker_name_length;\n    const char *c;\n    char *url_copy;\n    int i;\n\n    c = ap_strchr_c(url, ':');\n    if (c == NULL || c[1] != '/' || c[2] != '/' || c[3] == '\\0') {\n        return NULL;\n    }\n\n    url_length = strlen(url);\n    url_copy = apr_pstrmemdup(p, url, url_length);\n\n    /*\n     * We need to find the start of the path and\n     * therefore we know the length of the scheme://hostname/\n     * part to we can force-lowercase everything up to\n     * the start of the path.\n     */\n    c = ap_strchr_c(c+3, '/');\n    if (c) {\n        char *pathstart;\n        pathstart = url_copy + (c - url);\n        *pathstart = '\\0';\n        ap_str_tolower(url_copy);\n        min_match = strlen(url_copy);\n        *pathstart = '/';\n    }\n    else {\n        ap_str_tolower(url_copy);\n        min_match = strlen(url_copy);\n    }\n    /*\n     * Do a \"longest match\" on the worker name to find the worker that\n     * fits best to the URL, but keep in mind that we must have at least\n     * a minimum matching of length min_match such that\n     * scheme://hostname[:port] matches between worker and url.\n     */\n\n    if (balancer) {\n        proxy_worker **workers = (proxy_worker **)balancer->workers->elts;\n        for (i = 0; i < balancer->workers->nelts; i++, workers++) {\n            worker = *workers;\n            if ( ((worker_name_length = strlen(worker->s->name)) <= url_length)\n                && (worker_name_length >= min_match)\n                && (worker_name_length > max_match)\n                && (strncmp(url_copy, worker->s->name, worker_name_length) == 0) ) {\n                max_worker = worker;\n                max_match = worker_name_length;\n            }\n\n        }\n    } else {\n        worker = (proxy_worker *)conf->workers->elts;\n        for (i = 0; i < conf->workers->nelts; i++, worker++) {\n            if ( ((worker_name_length = strlen(worker->s->name)) <= url_length)\n                && (worker_name_length >= min_match)\n                && (worker_name_length > max_match)\n                && (strncmp(url_copy, worker->s->name, worker_name_length) == 0) ) {\n                max_worker = worker;\n                max_match = worker_name_length;\n            }\n        }\n    }\n\n    return max_worker;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_ca1a0bc24085589d8644cb25d19954bcfab8baf0_0", {
    "ID": "httpd_ca1a0bc24085589d8644cb25d19954bcfab8baf0_0",
    "UID": "3168",
    "code": "static dav_prop_insert dav_fs_insert_prop(const dav_resource test_snippet\n                                          int propid, dav_prop_insert what,\n                                          apr_text_header *phdr)\n{\n    const char *value;\n    const char *s;\n    apr_pool_t *p = resource->info->pool;\n    const dav_liveprop_spec *info;\n    int global_ns;\n\n    \n    \n    char buf[DAV_TIMEBUF_SIZE];\n\n    /*\n    ** None of FS provider properties are defined if the resource does not\n    ** exist. Just bail for this case.\n    **\n    ** Even though we state that the FS properties are not defined, the\n    ** client cannot store dead values -- we deny that thru the is_writable\n    ** hook function.\n    */\n    if (!resource->exists)\n        return DAV_PROP_INSERT_NOTDEF;\n\n    switch (propid) {\n    case DAV_PROPID_creationdate:\n        /*\n        ** Closest thing to a creation date. since we don't actually\n        ** perform the operations that would modify ctime (after we\n        ** create the file), then we should be pretty safe here.\n        */\n        dav_format_time(DAV_STYLE_ISO8601,\n                        resource->info->finfo.ctime,\n                        buf, sizeof(buf));\n        value = buf;\n        break;\n\n    case DAV_PROPID_getcontentlength:\n        \n        if (resource->collection)\n            return DAV_PROP_INSERT_NOTDEF;\n\n        apr_snprintf(buf, sizeof(buf), \"%\" APR_OFF_T_FMT, resource->info->finfo.size);\n        value = buf;\n        break;\n\n    case DAV_PROPID_getetag:\n        value = dav_fs_getetag(resource);\n        break;\n\n    case DAV_PROPID_getlastmodified:\n        dav_format_time(DAV_STYLE_RFC822,\n                        resource->info->finfo.mtime,\n                        buf, sizeof(buf));\n        value = buf;\n        break;\n\n    case DAV_PROPID_FS_executable:\n        \n        if (resource->collection)\n            return DAV_PROP_INSERT_NOTDEF;\n\n        \n        if (!(resource->info->finfo.valid & APR_FINFO_UPROT))\n            return DAV_PROP_INSERT_NOTDEF;\n\n        \n        if (resource->info->finfo.protection & APR_UEXECUTE)\n            value = \"T\";\n        else\n            value = \"F\";\n        break;\n\n    default:\n        \n        return DAV_PROP_INSERT_NOTDEF;\n    }\n\n    \n\n    \n    global_ns = dav_get_liveprop_info(propid, &dav_fs_liveprop_group, &info);\n\n    \n\n    \n\n    if (what == DAV_PROP_INSERT_VALUE) {\n        s = apr_psprintf(p, \"<lp%d:%s>%s</lp%d:%s>\" DEBUG_CR,\n                         global_ns, info->name, value, global_ns, info->name);\n    }\n    else if (what == DAV_PROP_INSERT_NAME) {\n        s = apr_psprintf(p, \"<lp%d:%s/>\" DEBUG_CR, global_ns, info->name);\n    }\n    else {\n        \n        s = apr_psprintf(p,\n                         \"<D:supported-live-property D:name=\\\"%s\\\" \"\n                         \"D:namespace=\\\"%s\\\"/>\" DEBUG_CR,\n                         info->name, dav_fs_namespace_uris[info->ns]);\n    }\n    apr_text_append(p, phdr, s);\n\n    \n    return what;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_fdded0e3b4f0b6f5b507a6e3af832d6f313baa77_0", {
    "ID": "httpd_fdded0e3b4f0b6f5b507a6e3af832d6f313baa77_0",
    "UID": "3174",
    "code": "static const char *add_member(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    server_rec *s = cmd->server;\n    proxy_server_conf *conf =\n    ap_get_module_config(s->module_config, &proxy_module);\n    proxy_balancer *balancer;\n    proxy_worker *worker;\n    char *path = cmd->path;\n    char *name = NULL;\n    char *word;\n    apr_table_t *params = apr_table_make(cmd->pool, 5);\n    const apr_array_header_t *arr;\n    const apr_table_entry_t *elts;\n    int reuse = 0;\n    int i;\n    \n    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);\n    if (err)\n        return err;\n\n    if (cmd->path)\n        path = apr_pstrdup(cmd->pool, cmd->path);\n\n    while (test_snippet {\n        char *val;\n        word = ap_getword_conf(cmd->pool, &arg);\n        val = strchr(word, '=');\n\n        if (!val) {\n            if (!path)\n                path = word;\n            else if (!name)\n                name = word;\n            else {\n                if (cmd->path)\n                    return \"BalancerMember can not have a balancer name when defined in a location\";\n                else\n                    return \"Invalid BalancerMember parameter. Parameter must \"\n                           \"be in the form 'key=value'\";\n            }\n        } else {\n            *val++ = '\\0';\n            apr_table_setn(params, word, val);\n        }\n    }\n    if (!path)\n        return \"BalancerMember must define balancer name when outside <Proxy > section\";\n    if (!name)\n        return \"BalancerMember must define remote proxy server\";\n\n    ap_str_tolower(path);   \n\n    \n    balancer = ap_proxy_get_balancer(cmd->temp_pool, conf, path, 0);\n    if (!balancer) {\n        err = ap_proxy_define_balancer(cmd->pool, &balancer, conf, path, \"/\", 0);\n        if (err)\n            return apr_pstrcat(cmd->temp_pool, \"BalancerMember \", err, NULL);\n    }\n\n    \n    worker = ap_proxy_get_worker(cmd->temp_pool, balancer, conf, name);\n    if (!worker) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01147)\n                     \"Defining worker '%s' for balancer '%s'\",\n                     name, balancer->s->name);\n        if ((err = ap_proxy_define_worker(cmd->pool, &worker, balancer, conf, name, 0)) != NULL)\n            return apr_pstrcat(cmd->temp_pool, \"BalancerMember \", err, NULL);\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01148)\n                     \"Defined worker '%s' for balancer '%s'\",\n                     ap_proxy_worker_name(cmd->pool, worker), balancer->s->name);\n        PROXY_COPY_CONF_PARAMS(worker, conf);\n    } else {\n        reuse = 1;\n        ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server, APLOGNO(01149)\n                     \"Sharing worker '%s' instead of creating new worker '%s'\",\n                     ap_proxy_worker_name(cmd->pool, worker), name);\n    }\n\n    arr = apr_table_elts(params);\n    elts = (const apr_table_entry_t *)arr->elts;\n    for (i = 0; i < arr->nelts; i++) {\n        if (reuse) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(01150)\n                         \"Ignoring parameter '%s=%s' for worker '%s' because of worker sharing\",\n                         elts[i].key, elts[i].val, ap_proxy_worker_name(cmd->pool, worker));\n        } else {\n            err = set_worker_param(cmd->pool, worker, elts[i].key,\n                                               elts[i].val);\n            if (err)\n                return apr_pstrcat(cmd->temp_pool, \"BalancerMember \", err, NULL);\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_5cc46a2ae80ab793a18f06eff61824c2bc2d76e4_0", {
    "ID": "httpd_5cc46a2ae80ab793a18f06eff61824c2bc2d76e4_0",
    "UID": "3175",
    "code": "static int dav_fs_is_writable(const dav_resource *resource, int test_snippet\n{\n    const dav_liveprop_spec *info;\n\n#ifdef DAV_FS_HAS_EXECUTABLE\n    /* if we have the executable property, and this isn't a collection,\n       then the property is writable. */\n    if (propid == DAV_PROPID_FS_executable && !resource->collection)\n        return 1;\n#endif\n\n    (void) dav_get_liveprop_info(propid, &dav_fs_liveprop_group, &info);\n    return info->is_writable;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_cf33b4fa0075220420799e4a5ae56b40049cc2d4_0", {
    "ID": "httpd_cf33b4fa0075220420799e4a5ae56b40049cc2d4_0",
    "UID": "3176",
    "code": "static int dav_method_proppatch(request_rec test_snippet\n{\n    dav_error *err;\n    dav_resource *resource;\n    int result;\n    apr_xml_doc *doc;\n    apr_xml_elem *child;\n    dav_propdb *propdb;\n    int failure = 0;\n    dav_response resp = { 0 };\n    apr_text *propstat_text;\n    apr_array_header_t *ctx_list;\n    dav_prop_ctx *ctx;\n    dav_auto_version_info av_info;\n\n    \n    err = dav_get_resource(r, 0 , 0 /* use_checked_in */,\n                           &resource);\n    if (err != NULL)\n        return dav_handle_err(r, err, NULL);\n    if (!resource->exists) {\n        \n        return HTTP_NOT_FOUND;\n    }\n\n    if ((result = ap_xml_parse_input(r, &doc)) != OK) {\n        return result;\n    }\n    \n\n    if (doc == NULL || !dav_validate_root(doc, \"propertyupdate\")) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00587)\n                      \"The request body does not contain \"\n                      \"a \\\"propertyupdate\\\" element.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    \n    \n    if ((err = dav_validate_request(r, resource, 0, NULL, NULL,\n                                    DAV_VALIDATE_RESOURCE, NULL)) != NULL) {\n        \n        return dav_handle_err(r, err, NULL);\n    }\n\n    \n    if ((err = dav_auto_checkout(r, resource,\n                                 0 ,\n                                 &av_info)) != NULL) {\n        \n        return dav_handle_err(r, err, NULL);\n    }\n\n    if ((err = dav_open_propdb(r, NULL, resource, 0, doc->namespaces,\n                               &propdb)) != NULL) {\n        \n        dav_auto_checkin(r, resource, 1 , 0 /*unlock*/, &av_info);\n\n        err = dav_push_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not open the property \"\n                                          \"database for %s.\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, NULL);\n    }\n    \n\n    \n\n    \n    ctx_list = apr_array_make(r->pool, 10, sizeof(dav_prop_ctx));\n\n    \n    for (child = doc->root->first_child; child; child = child->next) {\n        int is_remove;\n        apr_xml_elem *prop_group;\n        apr_xml_elem *one_prop;\n\n        \n        if (child->ns != APR_XML_NS_DAV_ID\n            || (!(is_remove = (strcmp(child->name, \"remove\") == 0))\n                && strcmp(child->name, \"set\") != 0)) {\n            continue;\n        }\n\n        \n        if ((prop_group = dav_find_child(child, \"prop\")) == NULL) {\n            dav_close_propdb(propdb);\n\n            \n            dav_auto_checkin(r, resource, 1 , 0 /*unlock*/, &av_info);\n\n            \n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00588)\n                          \"A \\\"prop\\\" element is missing inside \"\n                          \"the propertyupdate command.\");\n            return HTTP_BAD_REQUEST;\n        }\n\n        for (one_prop = prop_group->first_child; one_prop;\n             one_prop = one_prop->next) {\n\n            ctx = (dav_prop_ctx *)apr_array_push(ctx_list);\n            ctx->propdb = propdb;\n            ctx->operation = is_remove ? DAV_PROP_OP_DELETE : DAV_PROP_OP_SET;\n            ctx->prop = one_prop;\n\n            ctx->r = r;         \n\n            dav_prop_validate(ctx);\n\n            if ( DAV_PROP_CTX_HAS_ERR(*ctx) ) {\n                failure = 1;\n            }\n        }\n    }\n\n    \n\n    \n    if (!failure && dav_process_ctx_list(dav_prop_exec, ctx_list, 1, 0)) {\n        failure = 1;\n    }\n\n    \n    if (failure) {\n        (void)dav_process_ctx_list(dav_prop_rollback, ctx_list, 0, 1);\n        propstat_text = dav_failed_proppatch(r->pool, ctx_list);\n    }\n    else {\n        (void)dav_process_ctx_list(dav_prop_commit, ctx_list, 0, 0);\n        propstat_text = dav_success_proppatch(r->pool, ctx_list);\n    }\n\n    \n    dav_close_propdb(propdb);\n\n    \n    dav_auto_checkin(r, resource, failure, 0 , &av_info);\n\n    \n    (void)dav_process_ctx_list(dav_prop_log_errors, ctx_list, 0, 0);\n\n    resp.href = resource->uri;\n\n    \n    resp.propresult.propstats = propstat_text;\n\n    dav_send_multistatus(r, HTTP_MULTI_STATUS, &resp, doc->namespaces);\n\n    \n    return DONE;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_5ab6f20a81141d4211b350b66c604b00877eb185_0", {
    "ID": "httpd_5ab6f20a81141d4211b350b66c604b00877eb185_0",
    "UID": "3179",
    "code": "static int dav_method_copymove(request_rec *r, int test_snippet\n{\n    dav_resource *resource;\n    dav_resource *resnew;\n    dav_auto_version_info src_av_info = { 0 };\n    dav_auto_version_info dst_av_info = { 0 };\n    const char *body;\n    const char *dest;\n    dav_error *err;\n    dav_error *err2;\n    dav_error *err3;\n    dav_response *multi_response;\n    dav_lookup_result lookup;\n    int is_dir;\n    int overwrite;\n    int depth;\n    int result;\n    dav_lockdb *lockdb;\n    int replace_dest;\n    int resnew_state;\n\n    \n    err = dav_get_resource(r, !is_move ,\n                           0 , &resource);\n    if (err != NULL)\n        return dav_handle_err(r, err, NULL);\n\n    if (!resource->exists) {\n        \n        return HTTP_NOT_FOUND;\n    }\n\n    \n    \n    if (resource->type != DAV_RESOURCE_TYPE_REGULAR) {\n        body = apr_psprintf(r->pool,\n                            \"Cannot COPY/MOVE resource %s.\",\n                            ap_escape_html(r->pool, r->uri));\n        return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED, body);\n    }\n\n    \n    dest = apr_table_get(r->headers_in, \"Destination\");\n    if (dest == NULL) {\n        \n        const char *nscp_host = apr_table_get(r->headers_in, \"Host\");\n        const char *nscp_path = apr_table_get(r->headers_in, \"New-uri\");\n\n        if (nscp_host != NULL && nscp_path != NULL)\n            dest = apr_psprintf(r->pool, \"http://%s%s\", nscp_host, nscp_path);\n    }\n    if (dest == NULL) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00591)\n                      \"The request is missing a Destination header.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    lookup = dav_lookup_uri(dest, r, 1 );\n    if (lookup.rnew == NULL) {\n        if (lookup.err.status == HTTP_BAD_REQUEST) {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00592)\n                          \"%s\", lookup.err.desc);\n            return HTTP_BAD_REQUEST;\n        }\n\n        /* ### this assumes that dav_lookup_uri() only generates a status\n         * ### that Apache can provide a status line for!! */\n\n        return dav_error_response(r, lookup.err.status, lookup.err.desc);\n    }\n    if (lookup.rnew->status != HTTP_OK) {\n        const char *auth = apr_table_get(lookup.rnew->err_headers_out,\n                                        \"WWW-Authenticate\");\n        if (lookup.rnew->status == HTTP_UNAUTHORIZED && auth != NULL) {\n            /* propagate the WWW-Authorization header up from the\n             * subreq so the client sees it. */\n            apr_table_setn(r->err_headers_out, \"WWW-Authenticate\",\n                           apr_pstrdup(r->pool, auth));\n        }\n\n        \n        return dav_error_response(r, lookup.rnew->status,\n                                  \"Destination URI had an error.\");\n    }\n\n    \n    err = dav_get_resource(lookup.rnew, 0 ,\n                           0 , &resnew);\n    if (err != NULL)\n        return dav_handle_err(r, err, NULL);\n\n    \n    if (resource->hooks != resnew->hooks) {\n        \n        return dav_error_response(r, HTTP_BAD_GATEWAY,\n                                  \"Destination URI is handled by a \"\n                                  \"different repository than the source URI. \"\n                                  \"MOVE or COPY between repositories is \"\n                                  \"not possible.\");\n    }\n\n    \n    if ((overwrite = dav_get_overwrite(r)) < 0) {\n        /* dav_get_overwrite() supplies additional information for the\n         * default message. */\n        return HTTP_BAD_REQUEST;\n    }\n\n    \n    if (resnew->exists && !overwrite) {\n        \n        return dav_error_response(r, HTTP_PRECONDITION_FAILED,\n                                  \"Destination is not empty and \"\n                                  \"Overwrite is not \\\"T\\\"\");\n    }\n\n    \n    if ((*resource->hooks->is_same_resource)(resource, resnew)) {\n        \n        return dav_error_response(r, HTTP_FORBIDDEN,\n                                  \"Source and Destination URIs are the same.\");\n\n    }\n\n    is_dir = resource->collection;\n\n    \n    if ((depth = dav_get_depth(r, DAV_INFINITY)) < 0) {\n        /* dav_get_depth() supplies additional information for the\n         * default message. */\n        return HTTP_BAD_REQUEST;\n    }\n    if (depth == 1) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00593)\n                      \"Depth must be \\\"0\\\" or \\\"infinity\\\" for COPY or MOVE.\");\n        return HTTP_BAD_REQUEST;\n    }\n    if (is_move && is_dir && depth != DAV_INFINITY) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00594)\n                      \"Depth must be \\\"infinity\\\" when moving a collection.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /*\n     * Check If-Headers and existing locks for each resource in the source.\n     * We will return a 424 response with a DAV:multistatus body.\n     * The multistatus responses will contain the information about any\n     * resource that fails the validation.\n     *\n     * We check the parent resource, too, if this is a MOVE. Moving the\n     * resource effectively removes it from the parent collection, so we\n     * must ensure that we have met the appropriate conditions.\n     *\n     * If a problem occurs with the Request-URI itself, then a plain error\n     * (rather than a multistatus) will be returned.\n     */\n    if ((err = dav_validate_request(r, resource, depth, NULL,\n                                    &multi_response,\n                                    (is_move ? DAV_VALIDATE_PARENT\n                                             : DAV_VALIDATE_RESOURCE\n                                               | DAV_VALIDATE_NO_MODIFY)\n                                    | DAV_VALIDATE_USE_424,\n                                    NULL)) != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not %s %s due to a failed \"\n                                          \"precondition on the source \"\n                                          \"(e.g. locks).\",\n                                          is_move ? \"MOVE\" : \"COPY\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, multi_response);\n    }\n\n    /*\n     * Check If-Headers and existing locks for destination. Note that we\n     * use depth==infinity since the target (hierarchy) will be deleted\n     * before the move/copy is completed.\n     *\n     * Note that we are overwriting the target, which implies a DELETE, so\n     * we are subject to the error/response rules as a DELETE. Namely, we\n     * will return a 424 error if any of the validations fail.\n     * (see dav_method_delete() for more information)\n     */\n    if ((err = dav_validate_request(lookup.rnew, resnew, DAV_INFINITY, NULL,\n                                    &multi_response,\n                                    DAV_VALIDATE_PARENT\n                                    | DAV_VALIDATE_USE_424, NULL)) != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not MOVE/COPY %s due to a \"\n                                          \"failed precondition on the \"\n                                          \"destination (e.g. locks).\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, multi_response);\n    }\n\n    if (is_dir\n        && depth == DAV_INFINITY\n        && (*resource->hooks->is_parent_resource)(resource, resnew)) {\n        \n        return dav_error_response(r, HTTP_FORBIDDEN,\n                                  \"Source collection contains the \"\n                                  \"Destination.\");\n\n    }\n    if (is_dir\n        && (*resnew->hooks->is_parent_resource)(resnew, resource)) {\n        /* The destination must exist (since it contains the source), and\n         * a condition above implies Overwrite==T. Obviously, we cannot\n         * delete the Destination before the MOVE/COPY, as that would\n         * delete the Source.\n         */\n\n        \n        return dav_error_response(r, HTTP_FORBIDDEN,\n                                  \"Destination collection contains the Source \"\n                                  \"and Overwrite has been specified.\");\n    }\n\n    \n    if ((result = ap_discard_request_body(r)) != OK) {\n        return result;\n    }\n\n    if ((err = dav_open_lockdb(r, 0, &lockdb)) != NULL) {\n        \n        return dav_handle_err(r, err, NULL);\n    }\n\n    \n    /*\n     * ### this is Yet Another Traversal. if we do a rename(), then we\n     * ### really don't have to do this in some cases since the inode\n     * ### values will remain constant across the move. but we can't\n     * ### know that fact from outside the provider :-(\n     *\n     * ### note that we now have a problem atomicity in the move/copy\n     * ### since a failure after this would have removed locks (technically,\n     * ### this is okay to do, but really...)\n     */\n    if (is_move && lockdb != NULL) {\n        \n        \n        (void)dav_unlock(r, resource, NULL);\n    }\n\n    \n    if (test_snippet {\n        if ((err = dav_auto_checkout(r, resource, 1 ,\n                                     &src_av_info)) != NULL) {\n            if (lockdb != NULL)\n                (*lockdb->hooks->close_lockdb)(lockdb);\n\n            \n            return dav_handle_err(r, err, NULL);\n        }\n    }\n\n    /*\n     * Remember the initial state of the destination, so the lock system\n     * can be notified as to how it changed.\n     */\n    resnew_state = dav_get_resource_state(lookup.rnew, resnew);\n\n    /* In a MOVE operation, the destination is replaced by the source.\n     * In a COPY operation, if the destination exists, is under version\n     * control, and is the same resource type as the source,\n     * then it should not be replaced, but modified to be a copy of\n     * the source.\n     */\n    if (!resnew->exists)\n        replace_dest = 0;\n    else if (is_move || !resource->versioned)\n        replace_dest = 1;\n    else if (resource->type != resnew->type)\n        replace_dest = 1;\n    else if ((resource->collection == 0) != (resnew->collection == 0))\n        replace_dest = 1;\n    else\n        replace_dest = 0;\n\n    /* If the destination must be created or replaced,\n     * make sure the parent collection is writable\n     */\n    if (!resnew->exists || replace_dest) {\n        if ((err = dav_auto_checkout(r, resnew, 1 ,\n                                     &dst_av_info)) != NULL) {\n            /* could not make destination writable:\n             * if move, restore state of source parent\n             */\n            if (test_snippet {\n                (void)dav_auto_checkin(r, NULL, 1 ,\n                                       0 , &src_av_info);\n            }\n\n            if (lockdb != NULL)\n                (*lockdb->hooks->close_lockdb)(lockdb);\n\n            \n            return dav_handle_err(r, err, NULL);\n        }\n    }\n\n    /* If source and destination parents are the same, then\n     * use the same resource object, so status updates to one are reflected\n     * in the other, when doing auto-versioning. Otherwise,\n     * we may try to checkin the parent twice.\n     */\n    if (src_av_info.parent_resource != NULL\n        && dst_av_info.parent_resource != NULL\n        && (*src_av_info.parent_resource->hooks->is_same_resource)\n            (src_av_info.parent_resource, dst_av_info.parent_resource)) {\n\n        dst_av_info.parent_resource = src_av_info.parent_resource;\n    }\n\n    /* If destination is being replaced, remove it first\n     * (we know Ovewrite must be TRUE). Then try to copy/move the resource.\n     */\n    if (replace_dest)\n        err = (*resnew->hooks->remove_resource)(resnew, &multi_response);\n\n    if (err == NULL) {\n        if (test_snippet\n            err = (*resource->hooks->move_resource)(resource, resnew,\n                                                    &multi_response);\n        else\n            err = (*resource->hooks->copy_resource)(resource, resnew, depth,\n                                                    &multi_response);\n    }\n\n    \n    err2 = dav_auto_checkin(r, NULL, err != NULL ,\n                            0 , &dst_av_info);\n\n    if (test_snippet {\n        err3 = dav_auto_checkin(r, NULL, err != NULL ,\n                                0 , &src_av_info);\n    }\n    else\n        err3 = NULL;\n\n    \n    if (err != NULL) {\n        if (lockdb != NULL)\n            (*lockdb->hooks->close_lockdb)(lockdb);\n\n        err = dav_push_error(r->pool, err->status, 0,\n                             apr_psprintf(r->pool,\n                                          \"Could not MOVE/COPY %s.\",\n                                          ap_escape_html(r->pool, r->uri)),\n                             err);\n        return dav_handle_err(r, err, multi_response);\n    }\n\n    \n    if (err2 != NULL) {\n        \n        err = dav_push_error(r->pool, err2->status, 0,\n                             \"The MOVE/COPY was successful, but there was a \"\n                             \"problem automatically checking in the \"\n                             \"source parent collection.\",\n                             err2);\n        dav_log_err(r, err, APLOG_WARNING);\n    }\n    if (err3 != NULL) {\n        \n        err = dav_push_error(r->pool, err3->status, 0,\n                             \"The MOVE/COPY was successful, but there was a \"\n                             \"problem automatically checking in the \"\n                             \"destination or its parent collection.\",\n                             err3);\n        dav_log_err(r, err, APLOG_WARNING);\n    }\n\n    \n    if (lockdb != NULL) {\n\n        \n        err = dav_notify_created(r, lockdb, resnew, resnew_state, depth);\n\n        (*lockdb->hooks->close_lockdb)(lockdb);\n\n        if (err != NULL) {\n            \n            err = dav_push_error(r->pool, err->status, 0,\n                                 \"The MOVE/COPY was successful, but there \"\n                                 \"was a problem updating the lock \"\n                                 \"information.\",\n                                 err);\n            return dav_handle_err(r, err, NULL);\n        }\n    }\n\n    \n    return dav_created(r, lookup.rnew->unparsed_uri, \"Destination\",\n                       resnew_state == DAV_RESOURCE_EXISTS);\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n"
  },
  "httpd_d85aaff46524096a8b6d31ca85b85165de4ae1d0_0", {
    "ID": "httpd_d85aaff46524096a8b6d31ca85b85165de4ae1d0_0",
    "UID": "3180",
    "code": "DAV_DECLARE(void) dav_buffer_append(apr_pool_t *p, dav_buffer test_snippet\n                                    const char *str)\n{\n    apr_size_t len = strlen(str);\n\n    dav_check_bufsize(p, pbuf, len + 1);\n    memcpy(pbuf->buf + pbuf->cur_len, str, len + 1);\n    pbuf->cur_len += len;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n123,Write-what-where Condition\n126,Buffer Over-read"
  },
  "httpd_0c7f5a3c399ac3ead422277343d208e007ff08be_0", {
    "ID": "httpd_0c7f5a3c399ac3ead422277343d208e007ff08be_0",
    "UID": "3186",
    "code": "PROXY_DECLARE(char *) ap_proxy_define_worker(apr_pool_t test_snippet\n                                             proxy_worker **worker,\n                                             proxy_balancer *balancer,\n                                             proxy_server_conf *conf,\n                                             const char *url,\n                                             int do_malloc)\n{\n    int rv;\n    apr_uri_t uri, urisock;\n    proxy_worker_shared *wshared;\n    char *ptr, *sockpath = NULL;\n\n    /* Look to see if we are using UDS:\n       require format: http://ignored/ignored|sock:/path/foo/bar.sock\n       This results in talking http to the socket at /path/foo/bar.sock\n    */\n    ptr = ap_strchr((char *)url, '|');\n    if (ptr) {\n        *ptr = '\\0';\n        rv = apr_uri_parse(p, ptr+1, &urisock);\n        if (rv == APR_SUCCESS && !strcasecmp(urisock.scheme, \"sock\")) {\n            sockpath = urisock.path;\n        }\n        else {\n            *ptr = '|';\n        }\n    }\n    rv = apr_uri_parse(p, url, &uri);\n\n    if (rv != APR_SUCCESS) {\n        return \"Unable to parse URL\";\n    }\n    if (!uri.scheme) {\n        return \"URL must be absolute!\";\n    }\n    \n    if (!uri.hostname && !sockpath) {\n        return \"URL must be absolute!\";\n    }\n\n    if (sockpath) {\n        uri.hostname = \"localhost\";\n        uri.path = ap_runtime_dir_relative(p, sockpath);\n        uri.query = NULL;\n        uri.fragment = NULL;\n    }\n    else {\n        ap_str_tolower(uri.hostname);\n    }\n    ap_str_tolower(uri.scheme);\n    /*\n     * Workers can be associated w/ balancers or on their\n     * own; ie: the generic reverse-proxy or a worker\n     * in a simple ProxyPass statement. eg:\n     *\n     *      ProxyPass / http://www.example.com\n     *\n     * in which case the worker goes in the conf slot.\n     */\n    if (balancer) {\n        proxy_worker **runtime;\n        \n        runtime = apr_array_push(balancer->workers);\n        *worker = *runtime = apr_palloc(p, sizeof(proxy_worker));   \n        /* we've updated the list of workers associated with\n         * this balancer *locally* */\n        balancer->wupdated = apr_time_now();\n    } else if (conf) {\n        *worker = apr_array_push(conf->workers);\n    } else {\n        \n        *worker = apr_palloc(p, sizeof(proxy_worker));\n    }\n\n    memset(*worker, 0, sizeof(proxy_worker));\n    /* right here we just want to tuck away the worker info.\n     * if called during config, we don't have shm setup yet,\n     * so just note the info for later. */\n    if (do_malloc)\n        wshared = ap_malloc(sizeof(proxy_worker_shared));  \n    else\n        wshared = apr_palloc(p, sizeof(proxy_worker_shared));\n\n    memset(wshared, 0, sizeof(proxy_worker_shared));\n\n    ptr = apr_uri_unparse(p, &uri, APR_URI_UNP_REVEALPASSWORD);\n    if (PROXY_STRNCPY(wshared->name, ptr) != APR_SUCCESS) {\n        return apr_psprintf(p, \"worker name (%s) too long\", ptr);\n    }\n    if (PROXY_STRNCPY(wshared->scheme, uri.scheme) != APR_SUCCESS) {\n        return apr_psprintf(p, \"worker scheme (%s) too long\", uri.scheme);\n    }\n    if (PROXY_STRNCPY(wshared->hostname, uri.hostname) != APR_SUCCESS) {\n        return apr_psprintf(p, \"worker hostname (%s) too long\", uri.hostname);\n    }\n    wshared->port = uri.port;\n    wshared->flush_packets = flush_off;\n    wshared->flush_wait = PROXY_FLUSH_WAIT;\n    wshared->is_address_reusable = 1;\n    wshared->lbfactor = 1;\n    wshared->smax = -1;\n    wshared->hash.def = ap_proxy_hashfunc(wshared->name, PROXY_HASHFUNC_DEFAULT);\n    wshared->hash.fnv = ap_proxy_hashfunc(wshared->name, PROXY_HASHFUNC_FNV);\n    wshared->was_malloced = (do_malloc != 0);\n    wshared->uds = (sockpath != NULL);\n\n    (*worker)->hash = wshared->hash;\n    (*worker)->context = NULL;\n    (*worker)->cp = NULL;\n    (*worker)->balancer = balancer;\n    (*worker)->s = wshared;\n\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_eb2395a7b7fa4dbefbd8825d5bd10d2aab0b811a_0", {
    "ID": "httpd_eb2395a7b7fa4dbefbd8825d5bd10d2aab0b811a_0",
    "UID": "3187",
    "code": "PROXY_DECLARE(char *) ap_proxy_worker_name(apr_pool_t test_snippet\n                                           proxy_worker *worker)\n{\n    int rv;\n    apr_uri_t uri;\n    apr_pool_t *pool = p;\n    if (!worker->s->uds) {\n        return worker->s->name;\n    }\n    if (!pool) {\n        \n        apr_pool_create(&pool, ap_server_conf->process->pool);\n        if (!pool) {\n            \n            return worker->s->name;\n        }\n    }\n    rv = apr_uri_parse(pool, worker->s->name, &uri);\n    if (rv != APR_SUCCESS) {\n        return apr_pstrcat(pool, worker->s->name, \"|\", NULL);\n    }\n    return apr_pstrcat(pool, uri.scheme, \"://localhost/|sock:\", uri.path, NULL);\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_1cc444afc8aafe99f89b87b4ba35fed8b15dd2d1_0", {
    "ID": "httpd_1cc444afc8aafe99f89b87b4ba35fed8b15dd2d1_0",
    "UID": "3193",
    "code": "static char *get_lines_till_end_token(apr_pool_t * test_snippet\n                                      ap_configfile_t * config_file,\n                                      const char *end_token,\n                                      const char *begin_token,\n                                      const char *where,\n                                      apr_array_header_t ** plines)\n{\n    apr_array_header_t *lines = apr_array_make(test_snippet 1, sizeof(char *));\n    char line[MAX_STRING_LEN];  \n    int macro_nesting = 1, any_nesting = 1;\n    int line_number_start = config_file->line_number;\n\n    while (!ap_cfg_getline(line, MAX_STRING_LEN, config_file)) {\n        char *ptr = line;\n        char *first, **new;\n        \n        if (*line == '#')\n            continue;\n        first = ap_getword_conf_nc(test_snippet &ptr);\n        if (first) {\n            \n            if (!strncmp(first, \"</\", 2)) {\n                any_nesting--;\n                if (any_nesting < 0) {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING,\n                                 0, NULL, APLOGNO(02793)\n                                 \"bad (negative) nesting on line %d of %s\",\n                                 config_file->line_number - line_number_start,\n                                 where);\n                }\n            }\n            else if (!strncmp(first, \"<\", 1)) {\n                any_nesting++;\n            }\n\n            if (!strcasecmp(first, end_token)) {\n                \n                char * endp = (char *) ap_strrchr_c(line, '>');\n\n                \n                if (endp == NULL) {\n                  return \"end directive missing closing '>'\";\n                }\n\n                warn_if_non_blank(\n                    APLOGNO(02794) \"non blank chars found after directive closing\",\n                    endp+1, config_file);\n\n                macro_nesting--;\n                if (!macro_nesting) {\n                    if (any_nesting) {\n                        ap_log_error(APLOG_MARK,\n                                     APLOG_WARNING, 0, NULL, APLOGNO(02795)\n                                     \"bad cumulated nesting (%+d) in %s\",\n                                     any_nesting, where);\n                    }\n                    *plines = lines;\n                    return NULL;\n                }\n            }\n            else if (begin_token && !strcasecmp(first, begin_token)) {\n                macro_nesting++;\n            }\n        }\n        new = apr_array_push(lines);\n        *new = apr_psprintf(test_snippet \"%s\" APR_EOL_STR, line); \n    }\n\n    return apr_psprintf(test_snippet \"expected token not found: %s\", end_token);\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_ce3ade017d2ab71fd313d275c01df75663d8e705_0", {
    "ID": "httpd_ce3ade017d2ab71fd313d275c01df75663d8e705_0",
    "UID": "3194",
    "code": "static const char *load_module(cmd_parms *cmd, void test_snippet\n                               const char *modname, const char *filename)\n{\n    apr_dso_handle_t *modhandle;\n    apr_dso_handle_sym_t modsym;\n    module *modp;\n    const char *module_file;\n    so_server_conf *sconf;\n    ap_module_symbol_t *modi;\n    ap_module_symbol_t *modie;\n    int i;\n    const char *error;\n\n    /* we need to setup this value for dummy to make sure that we don't try\n     * to add a non-existant tree into the build when we return to\n     * execute_now.\n     */\n    *(ap_directive_t **)dummy = NULL;\n\n    /*\n     * check for already existing module\n     * If it already exists, we have nothing to do\n     * Check both dynamically-loaded modules and statically-linked modules.\n     */\n    sconf = (so_server_conf *)ap_get_module_config(cmd->server->module_config,\n                                                &so_module);\n    modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;\n    for (i = 0; i < sconf->loaded_modules->nelts; i++) {\n        modi = &modie[i];\n        if (modi->name != NULL && strcmp(modi->name, modname) == 0) {\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, APLOGNO(01574)\n                          \"module %s is already loaded, skipping\",\n                          modname);\n            return NULL;\n        }\n    }\n\n    for (i = 0; ap_preloaded_modules[i]; i++) {\n        const char *preload_name;\n        apr_size_t preload_len;\n        apr_size_t thismod_len;\n\n        modp = ap_preloaded_modules[i];\n\n        /* make sure we're comparing apples with apples\n         * make sure name of preloaded module is mod_FOO.c\n         * make sure name of structure being loaded is FOO_module\n         */\n\n        if (memcmp(modp->name, \"mod_\", 4)) {\n            continue;\n        }\n\n        preload_name = modp->name + strlen(\"mod_\");\n        preload_len = strlen(preload_name) - 2;\n\n        if (strlen(modname) <= strlen(\"_module\")) {\n            continue;\n        }\n        thismod_len = strlen(modname) - strlen(\"_module\");\n        if (strcmp(modname + thismod_len, \"_module\")) {\n            continue;\n        }\n\n        if (thismod_len != preload_len) {\n            continue;\n        }\n\n        if (!memcmp(modname, preload_name, preload_len)) {\n            return apr_pstrcat(cmd->pool, \"module \", modname,\n                               \" is built-in and can't be loaded\",\n                               NULL);\n        }\n    }\n\n    modi = apr_array_push(sconf->loaded_modules);\n    modi->name = modname;\n\n    /*\n     * Load the file into the Apache address space\n     */\n    error = dso_load(cmd, &modhandle, filename, &module_file);\n    if (error)\n        return error;\n    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, APLOGNO(01575)\n                 \"loaded module %s from %s\", modname, module_file);\n\n    /*\n     * Retrieve the pointer to the module structure through the module name:\n     * First with the hidden variant (prefix `AP_') and then with the plain\n     * symbol name.\n     */\n    if (apr_dso_sym(&modsym, modhandle, modname) != APR_SUCCESS) {\n        char my_error[256];\n\n        return apr_pstrcat(cmd->pool, \"Can't locate API module structure `\",\n                          modname, \"' in file \", module_file, \": \",\n                          apr_dso_error(modhandle, my_error, sizeof(my_error)),\n                          NULL);\n    }\n    modp = (module*) modsym;\n    modp->dynamic_load_handle = (apr_dso_handle_t *)modhandle;\n    modi->modp = modp;\n\n    /*\n     * Make sure the found module structure is really a module structure\n     *\n     */\n    if (modp->magic != MODULE_MAGIC_COOKIE) {\n        return apr_psprintf(cmd->pool, \"API module structure '%s' in file %s \"\n                            \"is garbled - expected signature %08lx but saw \"\n                            \"%08lx - perhaps this is not an Apache module DSO, \"\n                            \"or was compiled for a different Apache version?\",\n                            modname, module_file,\n                            MODULE_MAGIC_COOKIE, modp->magic);\n    }\n\n    /*\n     * Add this module to the Apache core structures\n     */\n    error = ap_add_loaded_module(modp, cmd->pool, modname);\n    if (error) {\n        return error;\n    }\n\n    /*\n     * Register a cleanup in the config apr_pool_t (normally pconf). When\n     * we do a restart (or shutdown) this cleanup will cause the\n     * shared object to be unloaded.\n     */\n    apr_pool_cleanup_register(cmd->pool, modi, unload_module, apr_pool_cleanup_null);\n\n    /*\n     * Finally we need to run the configuration process for the module\n     */\n    ap_single_module_configure(cmd->pool, cmd->server, modp);\n\n    return NULL;\n}",
    "predicted": "427,Uncontrolled Search Path Element"
  },
  "httpd_f4d847cde30a4118190369d91f82e6042a4355f5_0", {
    "ID": "httpd_f4d847cde30a4118190369d91f82e6042a4355f5_0",
    "UID": "3197",
    "code": "static apr_status_t ftp_string_read(conn_rec *c, apr_bucket_brigade test_snippet\n        char *buff, apr_size_t bufflen, int *eos)\n{\n    apr_bucket *e;\n    apr_status_t rv;\n    char *pos = buff;\n    char *response;\n    int found = 0;\n    apr_size_t len;\n\n    \n    buff[0] = 0;\n    *eos = 0;\n\n    \n    while (!found) {\n        \n        if (APR_SUCCESS != (rv = ap_get_brigade(c->input_filters, bb,\n                                                AP_MODE_GETLINE,\n                                                APR_BLOCK_READ,\n                                                0))) {\n            return rv;\n        }\n        \n        while (!found) {\n            if (*eos || APR_BRIGADE_EMPTY(bb)) {\n                \n                return APR_ECONNABORTED;\n            }\n            e = APR_BRIGADE_FIRST(bb);\n            if (APR_BUCKET_IS_EOS(e)) {\n                *eos = 1;\n            }\n            else {\n                if (APR_SUCCESS != (rv = apr_bucket_read(e,\n                                                         (const char **)&response,\n                                                         &len,\n                                                         APR_BLOCK_READ))) {\n                    return rv;\n                }\n                /*\n                 * is string LF terminated?\n                 * XXX: This check can be made more efficient by simply checking\n                 * if the last character in the 'response' buffer is an ASCII_LF.\n                 * See ap_rgetline() for an example.\n                 */\n                if (memchr(response, APR_ASCII_LF, len)) {\n                    found = 1;\n                }\n                \n                if (len > ((bufflen-1)-(pos-buff))) {\n                    len = (bufflen-1)-(pos-buff);\n                }\n                if (len > 0) {\n                    memcpy(pos, response, len);\n                    pos += len;\n                }\n            }\n            apr_bucket_delete(e);\n        }\n        *pos = '\\0';\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_9c30e9bf2b765246c71881ed9b4c761ac032b815_0", {
    "ID": "httpd_9c30e9bf2b765246c71881ed9b4c761ac032b815_0",
    "UID": "3198",
    "code": "static apr_status_t send_416(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    apr_bucket *e;\n    conn_rec *c = f->r->connection;\n    ap_remove_output_filter(f);\n    f->r->status = HTTP_OK;\n    e = ap_bucket_error_create(HTTP_RANGE_NOT_SATISFIABLE, NULL,\n                               f->r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    return ap_pass_brigade(f->next, tmpbb);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_30baa9dd2b0ec1edffae9df8d00e48d358ce820c_0", {
    "ID": "httpd_30baa9dd2b0ec1edffae9df8d00e48d358ce820c_0",
    "UID": "3199",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t test_snippet\n                                                         apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_bucket_brigade *tmpbb;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n    int num_ranges;\n    char *bound_head = NULL;\n    apr_array_header_t *indexes;\n    indexes_t *idx;\n    int i;\n    int original_status;\n    int max_ranges, max_overlaps, max_reversals;\n    int overlaps = 0, reversals = 0;\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n    max_ranges = ( (core_conf->max_ranges >= 0 || core_conf->max_ranges == AP_MAXRANGES_UNLIMITED)\n                   ? core_conf->max_ranges\n                   : AP_DEFAULT_MAX_RANGES );\n    max_overlaps = ( (core_conf->max_overlaps >= 0 || core_conf->max_overlaps == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_overlaps\n                  : AP_DEFAULT_MAX_OVERLAPS );\n    max_reversals = ( (core_conf->max_reversals >= 0 || core_conf->max_reversals == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_reversals\n                  : AP_DEFAULT_MAX_REVERSALS );\n    /*\n     * Iterate through the brigade until reaching EOS or a bucket with\n     * unknown length.\n     */\n    for (e = APR_BRIGADE_FIRST(bb);\n         (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n          && e->length != (apr_size_t)-1);\n         e = APR_BUCKET_NEXT(e)) {\n        clength += e->length;\n    }\n\n    /*\n     * Don't attempt to do byte range work if this brigade doesn't\n     * contain an EOS, or if any of the buckets has an unknown length;\n     * this avoids the cases where it is expensive to perform\n     * byteranging (i.e. may require arbitrary amounts of memory).\n     */\n    if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    original_status = r->status;\n    num_ranges = ap_set_byterange(r, clength, &indexes, &overlaps, &reversals);\n\n    \n    if (num_ranges == 0 ||\n        (max_ranges >= 0 && num_ranges > max_ranges) ||\n        (max_overlaps >= 0 && overlaps > max_overlaps) ||\n        (max_reversals >= 0 && reversals > max_reversals)) {\n        r->status = original_status;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    \n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    if (num_ranges < 0)\n        return send_416(f, bsend);\n\n    if (num_ranges > 1) {\n        \n        const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n        ap_set_content_type(r, apr_pstrcat(r->pool,\n                                           \"multipart/byteranges; boundary=\",\n                                           ap_multipart_boundary, NULL));\n\n        if (orig_ct) {\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-type: \",\n                                     orig_ct,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        else {\n            \n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    }\n\n    tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n\n        rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n        if (rv != APR_SUCCESS ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)\n                          \"copy_brigade_range() failed [%\" APR_OFF_T_FMT\n                          \"-%\" APR_OFF_T_FMT \",%\" APR_OFF_T_FMT \"]\",\n                          range_start, range_end, clength);\n            continue;\n        }\n        found = 1;\n\n        /*\n         * For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        APR_BRIGADE_CONCAT(bsend, tmpbb);\n        if (i && !(i & 0x1F)) {\n            /*\n             * Every now and then, pass what we have down the filter chain.\n             * In this case, the content-length filter cannot calculate and\n             * set the content length and we must remove any Content-Length\n             * header already present.\n             */\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            if ((rv = ap_pass_brigade(f->next, bsend)) != APR_SUCCESS)\n                return rv;\n            apr_brigade_cleanup(bsend);\n        }\n    }\n\n    if (found == 0) {\n        \n        return send_416(f, bsend);\n    }\n\n    if (num_ranges > 1) {\n        char *end;\n\n        \n        end = apr_pstrcat(r->pool, CRLF \"--\", ap_multipart_boundary, \"--\" CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    \n    apr_brigade_cleanup(bb);\n    apr_brigade_destroy(tmpbb);\n\n    \n    return ap_pass_brigade(f->next, bsend);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_430eb49dfb2eac4c4fd330e2a4f0aef4b8fab59e_0", {
    "ID": "httpd_430eb49dfb2eac4c4fd330e2a4f0aef4b8fab59e_0",
    "UID": "3200",
    "code": "static char *substitute(char test_snippet\n                        const int bufsize,\n                        const char *name,\n                        const char *replacement, const int do_esc)\n{\n    int lbuf = strlen(buf),\n        lname = strlen(name),\n        lrepl = strlen(replacement),\n        lsubs = lrepl +\n        (do_esc ? (2 + number_of_escapes(DELIM, replacement)) : 0),\n        shift = lsubs - lname, size = lbuf + shift, i, j;\n\n    \n    ap_assert(!strncmp(buf, name, lname));\n\n    \n    if (!strcmp(name, replacement))\n        return NULL;\n\n    debug(fprintf(stderr,\n                  \"substitute(%s,%s,%s,%d,sh=%d,lbuf=%d,lrepl=%d,lsubs=%d)\\n\",\n                  buf, name, replacement, do_esc, shift, lbuf, lrepl, lsubs));\n\n    if (size >= bufsize) {\n        \n        return \"cannot substitute, buffer size too small\";\n    }\n\n    \n    if (shift != 0) {\n        memmove(buf + lname + shift, buf + lname, lbuf - lname + 1);\n    }\n\n    \n    j = 0;\n    if (do_esc)\n        buf[j++] = DELIM;\n    for (i = 0; i < lrepl; i++, j++) {\n        if (do_esc && (replacement[i] == DELIM || replacement[i] == ESCAPE))\n            buf[j++] = ESCAPE;\n        buf[j] = replacement[i];\n    }\n    if (do_esc)\n        buf[j++] = DELIM;\n\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_f63871794820b248adf1cb7f2332915c8701ab05_0", {
    "ID": "httpd_f63871794820b248adf1cb7f2332915c8701ab05_0",
    "UID": "3202",
    "code": "static void warn_if_non_blank(const char * test_snippet\n                              char * ptr,\n                              ap_configfile_t * cfg)\n{\n    char * p;\n    for (p=ptr; *p; p++) {\n        if (*p == '#')\n            break;\n        if (*p != ' ' && *p != '\\t') {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,\n                         \"%s on line %d of %s: %s\",\n                         test_snippet cfg->line_number, cfg->name, ptr);\n            break;\n        }\n    }\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_96071bdd301b4e95ab928d7a0aadc74be13c2171_0", {
    "ID": "httpd_96071bdd301b4e95ab928d7a0aadc74be13c2171_0",
    "UID": "3206",
    "code": "static test_snippet\nproxy_ftp_command(const char *cmd, request_rec *r, conn_rec *ftp_ctrl,\n                  apr_bucket_brigade *bb, char **pmessage)\n{\n    char *crlf;\n    test_snippet rc;\n    char message[HUGE_STRING_LEN];\n\n    \n    if (cmd != NULL) {\n        conn_rec *c = r->connection;\n        APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(cmd, strlen(cmd), r->pool, c->bucket_alloc));\n        APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_flush_create(c->bucket_alloc));\n        ap_pass_brigade(ftp_ctrl->output_filters, bb);\n\n        \n        apr_cpystrn(message, cmd, sizeof(message));\n        if ((crlf = strchr(message, '\\r')) != NULL ||\n            (crlf = strchr(message, '\\n')) != NULL)\n            *crlf = '\\0';\n        if (strncmp(message,\"PASS \", 5) == 0)\n            strcpy(&message[5], \"****\");\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \">%s\", message);\n    }\n\n    rc = ftp_getrc_msg(ftp_ctrl, bb, message, sizeof message);\n    if (rc == -1 || rc == 421)\n        strcpy(message,\"<unable to read result>\");\n    if ((crlf = strchr(message, '\\r')) != NULL ||\n        (crlf = strchr(message, '\\n')) != NULL)\n        *crlf = '\\0';\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"<%3.3u %s\", rc, message);\n\n    if (pmessage != NULL)\n        *pmessage = apr_pstrdup(r->pool, message);\n\n    return rc;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_d504fa6712ec6fc2d14bab91292d4809d8c6670f_0", {
    "ID": "httpd_d504fa6712ec6fc2d14bab91292d4809d8c6670f_0",
    "UID": "3215",
    "code": "static apr_status_t regsub_core(apr_pool_t *p, char test_snippet\n                                struct ap_varbuf *vb, const char *input,\n                                const char *source, apr_size_t nmatch,\n                                ap_regmatch_t pmatch[], apr_size_t maxlen)\n{\n    const char *src = input;\n    char *dst;\n    char c;\n    apr_size_t no;\n    apr_size_t len = 0;\n\n    AP_DEBUG_ASSERT((result && p && !vb) || (vb && !p && !result));\n    if (!source || nmatch>AP_MAX_REG_MATCH)\n        return APR_EINVAL;\n    if (!nmatch) {\n        len = strlen(src);\n        if (maxlen > 0 && len >= maxlen)\n            return APR_ENOMEM;\n        if (!vb) {\n            *result = apr_pstrmemdup(p, src, len);\n            return APR_SUCCESS;\n        }\n        else {\n            ap_varbuf_strmemcat(vb, src, len);\n            return APR_SUCCESS;\n        }\n    }\n\n    \n    while ((c = *src++) != '\\0') {\n        if (c == '$' && apr_isdigit(*src))\n            no = *src++ - '0';\n        else\n            no = AP_MAX_REG_MATCH;\n\n        if (no >= AP_MAX_REG_MATCH) {  \n            if (c == '\\\\' && *src)\n                src++;\n            len++;\n        }\n        else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {\n            if (APR_SIZE_MAX - len <= pmatch[no].rm_eo - pmatch[no].rm_so)\n                return APR_ENOMEM;\n            len += pmatch[no].rm_eo - pmatch[no].rm_so;\n        }\n\n    }\n\n    if (len >= maxlen && maxlen > 0)\n        return APR_ENOMEM;\n\n    if (!vb) {\n        *result = dst = apr_palloc(p, len + 1);\n    }\n    else {\n        if (vb->strlen == AP_VARBUF_UNKNOWN)\n            vb->strlen = strlen(vb->buf);\n        ap_varbuf_grow(vb, vb->strlen + len);\n        dst = vb->buf + vb->strlen;\n        vb->strlen += len;\n    }\n\n    \n\n    src = input;\n\n    while ((c = *src++) != '\\0') {\n        if (c == '$' && apr_isdigit(*src))\n            no = *src++ - '0';\n        else\n            no = AP_MAX_REG_MATCH;\n\n        if (no >= AP_MAX_REG_MATCH) {  \n            if (c == '\\\\' && *src)\n                c = *src++;\n            *dst++ = c;\n        }\n        else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {\n            len = pmatch[no].rm_eo - pmatch[no].rm_so;\n            memcpy(dst, source + pmatch[no].rm_so, len);\n            dst += len;\n        }\n\n    }\n    *dst = '\\0';\n\n    return APR_SUCCESS;\n}",
    "predicted": "120,Classic Buffer Overflow\n190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_6cebcc9b5634b3986710ac3d4b867e8d22716713_0", {
    "ID": "httpd_6cebcc9b5634b3986710ac3d4b867e8d22716713_0",
    "UID": "3216",
    "code": "static void enable_listensocks(int test_snippet\n{\n    int i;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00457)\n                 \"Accepting new connections again: \"\n                 \"%u active conns (%u lingering/%u clogged/%u suspended), \"\n                 \"%u idle workers\",\n                 apr_atomic_read32(&connection_count),\n                 apr_atomic_read32(&lingering_count),\n                 apr_atomic_read32(&clogged_count),\n                 apr_atomic_read32(&suspended_count),\n                 ap_queue_info_get_idlers(worker_queue_info));\n    for (i = 0; i < num_listensocks; i++)\n        apr_pollset_add(event_pollset, &listener_pollfd[i]);\n    /*\n     * XXX: This is not yet optimal. If many workers suddenly become available,\n     * XXX: the parent may kill some processes off too soon.\n     */\n    ap_scoreboard_image->parent[process_slot].not_accepting = 0;\n}",
    "predicted": "546,Suspicious Comment"
  },
  "httpd_99537dcb5b8f0665bc34b271a6050d257ca30c40_0", {
    "ID": "httpd_99537dcb5b8f0665bc34b271a6050d257ca30c40_0",
    "UID": "3221",
    "code": "static int start_lingering_close_common(event_conn_state_t test_snippet\n{\n    apr_status_t rv;\n    struct timeout_queue *q;\n    apr_socket_t *csd = cs->pfd.desc.s;\n#ifdef AP_DEBUG\n    {\n        rv = apr_socket_timeout_set(csd, 0);\n        AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n    }\n#else\n    apr_socket_timeout_set(csd, 0);\n#endif\n    /*\n     * If some module requested a shortened waiting period, only wait for\n     * 2s (SECONDS_TO_LINGER). This is useful for mitigating certain\n     * DoS attacks.\n     */\n    if (apr_table_get(cs->c->notes, \"short-lingering-close\")) {\n        cs->expiration_time =\n            apr_time_now() + apr_time_from_sec(SECONDS_TO_LINGER);\n        q = &short_linger_q;\n        cs->pub.state = CONN_STATE_LINGER_SHORT;\n    }\n    else {\n        cs->expiration_time =\n            apr_time_now() + apr_time_from_sec(MAX_SECS_TO_LINGER);\n        q = &linger_q;\n        cs->pub.state = CONN_STATE_LINGER_NORMAL;\n    }\n    apr_atomic_inc32(&lingering_count);\n    apr_thread_mutex_lock(timeout_mutex);\n    TO_QUEUE_APPEND(*q, cs);\n    cs->pfd.reqevents = APR_POLLIN | APR_POLLHUP | APR_POLLERR;\n    rv = apr_pollset_add(event_pollset, &cs->pfd);\n    apr_thread_mutex_unlock(timeout_mutex);\n    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,\n                     \"start_lingering_close: apr_pollset_add failure\");\n        apr_thread_mutex_lock(timeout_mutex);\n        TO_QUEUE_REMOVE(*q, cs);\n        apr_thread_mutex_unlock(timeout_mutex);\n        apr_socket_close(cs->pfd.desc.s);\n        apr_pool_clear(cs->p);\n        ap_push_pool(worker_queue_info, cs->p);\n        return 0;\n    }\n    return 1;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_91c1b1d8431815fdc0267a4fae05b60c2d4dfea7_0", {
    "ID": "httpd_91c1b1d8431815fdc0267a4fae05b60c2d4dfea7_0",
    "UID": "3224",
    "code": "static apr_status_t ap_cfg_getline_core(char *buf, apr_size_t test_snippet\n                                        ap_configfile_t *cfp)\n{\n    apr_status_t rc;\n    \n    if (cfp->getstr != NULL) {\n        char *cp;\n        char *cbuf = buf;\n        apr_size_t cbufsize = bufsize;\n\n        while (1) {\n            ++cfp->line_number;\n            rc = cfp->getstr(cbuf, ctest_snippet cfp->param);\n            if (rc == APR_EOF) {\n                if (cbuf != buf) {\n                    *cbuf = '\\0';\n                    break;\n                }\n                else {\n                    return APR_EOF;\n                }\n            }\n            if (rc != APR_SUCCESS) {\n                return rc;\n            }\n\n            /*\n             *  check for line continuation,\n             *  i.e. match [^\\\\]\\\\[\\r]\\n only\n             */\n            cp = cbuf;\n            cp += strlen(cp);\n            if (cp > cbuf && cp[-1] == LF) {\n                cp--;\n                if (cp > cbuf && cp[-1] == CR)\n                    cp--;\n                if (cp > cbuf && cp[-1] == '\\\\') {\n                    cp--;\n                    /*\n                     * line continuation requested -\n                     * then remove backslash and continue\n                     */\n                    cbufsize -= (cp-cbuf);\n                    cbuf = cp;\n                    continue;\n                }\n            }\n            else if (cp - buf >= bufsize - 1) {\n                return APR_ENOSPC;\n            }\n            break;\n        }\n    } else {\n        \n        apr_size_t i = 0;\n\n        if (bufsize < 2) {\n            \n            return APR_EINVAL;\n        }\n        buf[0] = '\\0';\n\n        while (1) {\n            char c;\n            rc = cfp->getch(&c, cfp->param);\n            if (rc == APR_EOF) {\n                if (i > 0)\n                    break;\n                else\n                    return APR_EOF;\n            }\n            if (rc != APR_SUCCESS)\n                return rc;\n            if (c == LF) {\n                ++cfp->line_number;\n                \n                if (i > 0 && buf[i-1] == '\\\\') {\n                    i--;\n                    continue;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (i >= bufsize - 2) {\n                return APR_ENOSPC;\n            }\n            buf[i] = c;\n            ++i;\n        }\n        buf[i] = '\\0';\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5cff33cfdc70e04505def053f1ba5ab1e86dda2c_0", {
    "ID": "httpd_5cff33cfdc70e04505def053f1ba5ab1e86dda2c_0",
    "UID": "3231",
    "code": "AP_DECLARE(void) ap_varbuf_grow(struct ap_varbuf *vb, apr_size_t test_snippet\n{\n    apr_memnode_t *new_node = NULL;\n    apr_allocator_t *allocator;\n    struct ap_varbuf_info *new_info;\n    char *new;\n\n    AP_DEBUG_ASSERT(vb->strlen == AP_VARBUF_UNKNOWN || vb->avail >= vb->strlen);\n\n    if (new_len <= vb->avail)\n        return;\n\n    if (new_len < 2 * vb->avail && vb->avail < VARBUF_MAX_SIZE/2) {\n        \n        new_len = 2 * vb->avail;\n    }\n    else if (new_len > VARBUF_MAX_SIZE) {\n        apr_abortfunc_t abort_fn = apr_pool_abort_get(vb->pool);\n        ap_assert(abort_fn != NULL);\n        abort_fn(APR_ENOMEM);\n        return;\n    }\n\n    new_len++;  \n    if (new_len <= VARBUF_SMALL_SIZE) {\n        new_len = APR_ALIGN_DEFAULT(test_snippet;\n        new = apr_palloc(vb->pool, test_snippet;\n        if (vb->avail && vb->strlen != 0) {\n            AP_DEBUG_ASSERT(vb->buf != NULL);\n            AP_DEBUG_ASSERT(vb->buf != varbuf_empty);\n            if (new == vb->buf + vb->avail + 1) {\n                /* We are lucky: the new memory lies directly after our old\n                 * buffer, we can now use both.\n                 */\n                vb->avail += new_len;\n                return;\n            }\n            else {\n                \n                memcpy(new, vb->buf, vb->strlen == AP_VARBUF_UNKNOWN ?\n                                     vb->avail + 1 : vb->strlen + 1);\n            }\n        }\n        else {\n            *new = '\\0';\n        }\n        vb->avail = new_len - 1;\n        vb->buf = new;\n        return;\n    }\n\n    /* The required block is rather larger. Use allocator directly so that\n     * the memory can be freed independently from the pool. */\n    allocator = apr_pool_allocator_get(vb->pool);\n    if (new_len <= VARBUF_MAX_SIZE)\n        new_node = apr_allocator_alloc(allocator,\n                                       new_len + APR_ALIGN_DEFAULT(sizeof(*new_info)));\n    if (!new_node) {\n        apr_abortfunc_t abort_fn = apr_pool_abort_get(vb->pool);\n        ap_assert(abort_fn != NULL);\n        abort_fn(APR_ENOMEM);\n        return;\n    }\n    new_info = (struct ap_varbuf_info *)new_node->first_avail;\n    new_node->first_avail += APR_ALIGN_DEFAULT(sizeof(*new_info));\n    new_info->node = new_node;\n    new_info->allocator = allocator;\n    new = new_node->first_avail;\n    AP_DEBUG_ASSERT(new_node->endp - new_node->first_avail >= test_snippet;\n    new_len = new_node->endp - new_node->first_avail;\n\n    if (vb->avail && vb->strlen != 0)\n        memcpy(new, vb->buf, vb->strlen == AP_VARBUF_UNKNOWN ?\n                             vb->avail + 1 : vb->strlen + 1);\n    else\n        *new = '\\0';\n    if (vb->info)\n        apr_pool_cleanup_run(vb->pool, vb->info, varbuf_cleanup);\n    apr_pool_cleanup_register(vb->pool, new_info, varbuf_cleanup,\n                              apr_pool_cleanup_null);\n    vb->info = new_info;\n    vb->buf = new;\n    vb->avail = new_len - 1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_41c55d400a7d9ca5f3bcd01f88daecffdfa5d7f2_0", {
    "ID": "httpd_41c55d400a7d9ca5f3bcd01f88daecffdfa5d7f2_0",
    "UID": "3232",
    "code": "AP_DECLARE(apr_status_t) ap_varbuf_cfg_getline(struct ap_varbuf test_snippet\n                                               ap_configfile_t *cfp,\n                                               apr_size_t max_len)\n{\n    apr_status_t rc;\n    apr_size_t new_len;\n    vb->strlen = 0;\n    *vb->buf = '\\0';\n\n    if (vb->strlen == AP_VARBUF_UNKNOWN)\n        vb->strlen = strlen(vb->buf);\n    if (vb->avail - vb->strlen < 3) {\n        new_len = vb->avail * 2;\n        if (new_len > max_len)\n            new_len = max_len;\n        else if (new_len < 3)\n            new_len = 3;\n        ap_varbuf_grow(vb, new_len);\n    }\n\n    for (;;) {\n        rc = ap_cfg_getline_core(vb->buf + vb->strlen, vb->avail - vb->strlen, cfp);\n        if (rc == APR_ENOSPC || rc == APR_SUCCESS)\n            vb->strlen += strlen(vb->buf + vb->strlen);\n        if (rc != APR_ENOSPC)\n            break;\n        if (vb->avail >= max_len)\n            return APR_ENOSPC;\n        new_len = vb->avail * 2;\n        if (new_len > max_len)\n            new_len = max_len;\n        ap_varbuf_grow(vb, new_len);\n        --cfp->line_number;\n    }\n    if (vb->strlen > max_len)\n        return APR_ENOSPC;\n    if (rc == APR_SUCCESS)\n        vb->strlen = cfg_trim_line(vb->buf);\n    return rc;\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9e330c33366cf1d3ad0a424360c87fae8337fa3b_0", {
    "ID": "httpd_9e330c33366cf1d3ad0a424360c87fae8337fa3b_0",
    "UID": "3247",
    "code": "static apr_status_t event_register_timed_callback(apr_time_t test_snippet\n                                                  ap_mpm_callback_fn_t *cbfn,\n                                                  void *baton)\n{\n    int inserted = 0;\n    timer_event_t *ep;\n    timer_event_t *te;\n    \n    apr_thread_mutex_lock(g_timer_ring_mtx);\n\n    if (!APR_RING_EMPTY(&timer_free_ring, timer_event_test_snippet link)) {\n        te = APR_RING_FIRST(&timer_free_ring);\n        APR_RING_REMOVE(te, link);\n    }\n    else {\n        \n        te = ap_malloc(sizeof(timer_event_t));\n        APR_RING_ELEM_INIT(te, link);\n    }\n\n    te->cbfunc = cbfn;\n    te->baton = baton;\n    \n    te->when = t + apr_time_now();\n\n    \n    for (ep = APR_RING_FIRST(&timer_ring);\n         ep != APR_RING_SENTINEL(&timer_ring,\n                                 timer_event_test_snippet link);\n         ep = APR_RING_NEXT(ep, link))\n    {\n        if (ep->when > te->when) {\n            inserted = 1;\n            APR_RING_INSERT_BEFORE(ep, te, link);\n            break;\n        }\n    }\n\n    if (!inserted) {\n        APR_RING_INSERT_TAIL(&timer_ring, te, timer_event_test_snippet link);\n    }\n\n    apr_thread_mutex_unlock(g_timer_ring_mtx);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_3f0e413b7fc4df406875eb818914ff71a3601d69_0", {
    "ID": "httpd_3f0e413b7fc4df406875eb818914ff71a3601d69_0",
    "UID": "3251",
    "code": "static test_snippet\nrate_limit_filter(ap_filter_t *f, apr_bucket_brigade *bb)\n{\n    test_snippet rv = APR_SUCCESS;\n    rl_ctx_t *ctx = f->ctx;\n    apr_bucket_alloc_t *ba = f->r->connection->bucket_alloc;\n\n    \n    if (ctx == NULL) {\n\n        const char *rl = NULL;\n        int ratelimit;\n        int burst = 0;\n\n        \n        if (f->r->main != NULL) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        \n        rl = apr_table_get(f->r->subprocess_env, \"rate-limit\");\n\n        if (rl == NULL) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n        \n        \n        ratelimit = atoi(rl) * 1024;\n        if (ratelimit <= 0) {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                          APLOGNO(03488) \"rl: disabling: rate-limit = %s (too high?)\", rl);\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        \n        rl = apr_table_get(f->r->subprocess_env, \"rate-initial-burst\");\n        if (rl != NULL) {\n            burst = atoi(rl) * 1024;\n            if (burst <= 0) {\n               ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                             APLOGNO(03489) \"rl: disabling burst: rate-initial-burst = %s (too high?)\", rl);\n               burst = 0;\n            }\n        }\n\n        \n        ctx = apr_palloc(f->r->pool, sizeof(rl_ctx_t));\n        f->ctx = ctx;\n        ctx->state = RATE_LIMIT;\n        ctx->speed = ratelimit;\n        ctx->burst = burst;\n        ctx->do_sleep = 0;\n\n        \n        \n        ctx->chunk_size = (ctx->speed / (1000 / RATE_INTERVAL_MS));\n        ctx->tmpbb = apr_brigade_create(f->r->pool, ba);\n        ctx->holdingbb = apr_brigade_create(f->r->pool, ba);\n    }\n    else {\n        APR_BRIGADE_PREPEND(bb, ctx->holdingbb);\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *e;\n\n        if (ctx->state == RATE_FULLSPEED) {\n            \n            for (e = APR_BRIGADE_FIRST(bb);\n                 e != APR_BRIGADE_SENTINEL(bb); e = APR_BUCKET_NEXT(e)) {\n                if (AP_RL_BUCKET_IS_END(e)) {\n                    apr_brigade_split_ex(bb, e, ctx->holdingbb);\n                    ctx->state = RATE_LIMIT;\n                    break;\n                }\n            }\n\n            e = apr_bucket_flush_create(ba);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            rv = ap_pass_brigade(f->next, bb);\n            apr_brigade_cleanup(bb);\n\n            if (rv != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, f->r, APLOGNO(01455)\n                              \"rl: full speed brigade pass failed.\");\n                return rv;\n            }\n        }\n        else {\n            for (e = APR_BRIGADE_FIRST(bb);\n                 e != APR_BRIGADE_SENTINEL(bb); e = APR_BUCKET_NEXT(e)) {\n                if (AP_RL_BUCKET_IS_START(e)) {\n                    apr_brigade_split_ex(bb, e, ctx->holdingbb);\n                    ctx->state = RATE_FULLSPEED;\n                    break;\n                }\n            }\n\n            while (!APR_BRIGADE_EMPTY(bb)) {\n                apr_off_t len = ctx->chunk_size + ctx->burst;\n\n                APR_BRIGADE_CONCAT(ctx->tmpbb, bb);\n\n                /*\n                 * Pull next chunk of data; the initial amount is our\n                 * burst allotment (if any) plus a chunk.  All subsequent\n                 * iterations are just chunks with whatever remaining\n                 * burst amounts we have left (in case not done in the\n                 * first bucket).\n                 */\n                rv = apr_brigade_partition(ctx->tmpbb, len, &e);\n                if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01456)\n                                  \"rl: partition failed.\");\n                    return rv;\n                }\n                \n                while (e != APR_BRIGADE_SENTINEL(ctx->tmpbb)\n                       && APR_BUCKET_IS_METADATA(e)) {\n                    e = APR_BUCKET_NEXT(e);\n                }\n                if (e != APR_BRIGADE_SENTINEL(ctx->tmpbb)) {\n                    apr_brigade_split_ex(ctx->tmpbb, e, bb);\n                }\n                else {\n                    apr_brigade_length(ctx->tmpbb, 1, &len);\n                }\n\n                /*\n                 * Adjust the burst amount depending on how much\n                 * we've done up to now.\n                 */\n                if (ctx->burst) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,\n                        APLOGNO(03485) \"rl: burst %d; len %\"APR_OFF_T_FMT, ctx->burst, len);\n                    if (len < ctx->burst) {\n                        ctx->burst -= len;\n                    }\n                    else {\n                        ctx->burst = 0;\n                    }\n                }\n\n                e = APR_BRIGADE_LAST(ctx->tmpbb);\n                if (APR_BUCKET_IS_EOS(e)) {\n                    ap_remove_output_filter(f);\n                }\n                else if (!APR_BUCKET_IS_FLUSH(e)) {\n                    if (APR_BRIGADE_EMPTY(bb)) {\n                        \n                        break;\n                    }\n                    e = apr_bucket_flush_create(ba);\n                    APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, e);\n                }\n\n#if defined(RLFDEBUG)\n                brigade_dump(f->r, ctx->tmpbb);\n                brigade_dump(f->r, bb);\n#endif \n\n                if (ctx->do_sleep) {\n                    apr_sleep(RATE_INTERVAL_MS * 1000);\n                }\n                else {\n                    ctx->do_sleep = 1;\n                }\n\n                rv = ap_pass_brigade(f->next, ctx->tmpbb);\n                apr_brigade_cleanup(ctx->tmpbb);\n\n                if (rv != APR_SUCCESS) {\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, f->r, APLOGNO(01457)\n                                  \"rl: brigade pass failed.\");\n                    return rv;\n                }\n            }\n        }\n\n        if (!APR_BRIGADE_EMPTY(ctx->holdingbb)) {\n            /* Any rate-limited data in tmpbb is sent unlimited along\n             * with the rest.\n             */\n            APR_BRIGADE_CONCAT(bb, ctx->tmpbb);\n            APR_BRIGADE_CONCAT(bb, ctx->holdingbb);\n        }\n    }\n\n#if defined(RLFDEBUG)\n    brigade_dump(f->r, ctx->tmpbb);\n#endif \n\n    \n    return ap_save_brigade(f, &ctx->holdingbb, &ctx->tmpbb, f->r->pool);\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_6c865eb8e3de47694977a568d9c6260bd862b724_0", {
    "ID": "httpd_6c865eb8e3de47694977a568d9c6260bd862b724_0",
    "UID": "3259",
    "code": "PROXY_DECLARE(apr_status_t) test_snippet\n                                                       request_rec *r,\n                                                       conn_rec *c_i,\n                                                       conn_rec *c_o,\n                                                       apr_bucket_brigade *bb_i,\n                                                       apr_bucket_brigade *bb_o,\n                                                       const char *name,\n                                                       int *sent,\n                                                       apr_off_t bsize,\n                                                       int after)\n{\n    apr_status_t rv;\n#ifdef DEBUGGING\n    apr_off_t len;\n#endif\n\n    do {\n        apr_brigade_cleanup(bb_i);\n        rv = ap_get_brigade(c_i->input_filters, bb_i, AP_MODE_READBYTES,\n                            APR_NONBLOCK_READ, bsize);\n        if (rv == APR_SUCCESS) {\n            if (c_o->aborted) {\n                return APR_EPIPE;\n            }\n            if (APR_BRIGADE_EMPTY(bb_i)) {\n                break;\n            }\n#ifdef DEBUGGING\n            len = -1;\n            apr_brigade_length(bb_i, 0, &len);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03306)\n                          \"ap_proxy_transfer_between_connections: \"\n                          \"read %\" APR_OFF_T_FMT\n                          \" bytes from %s\", len, name);\n#endif\n            if (sent) {\n                *sent = 1;\n            }\n            ap_proxy_buckets_lifetime_transform(r, bb_i, bb_o);\n            if (!after) {\n                apr_bucket *b;\n\n                /*\n                 * Do not use ap_fflush here since this would cause the flush\n                 * bucket to be sent in a separate brigade afterwards which\n                 * causes some filters to set aside the buckets from the first\n                 * brigade and process them when the flush arrives in the second\n                 * brigade. As set asides of our transformed buckets involve\n                 * memory copying we try to avoid this. If we have the flush\n                 * bucket in the first brigade they directly process the\n                 * buckets without setting them aside.\n                 */\n                b = apr_bucket_flush_create(bb_o->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb_o, b);\n            }\n            rv = ap_pass_brigade(c_o->output_filters, bb_o);\n            if (rv != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(03307)\n                              \"ap_proxy_transfer_between_connections: \"\n                              \"error on %s - ap_pass_brigade\",\n                              name);\n            }\n        } else if (!APR_STATUS_IS_EAGAIN(rv) && !APR_STATUS_IS_EOF(rv)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(03308)\n                          \"ap_proxy_transfer_between_connections: \"\n                          \"error on %s - ap_get_brigade\",\n                          name);\n        }\n    } while (rv == APR_SUCCESS);\n\n    if (after) {\n        ap_fflush(c_o->output_filters, bb_o);\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, rv, r,\n                  \"ap_proxy_transfer_between_connections complete\");\n\n    if (APR_STATUS_IS_EAGAIN(rv)) {\n        rv = APR_SUCCESS;\n    }\n\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_8fdfab9c797baa02036987eb8cd7524c0bf7a1c6_0", {
    "ID": "httpd_8fdfab9c797baa02036987eb8cd7524c0bf7a1c6_0",
    "UID": "3260",
    "code": "AP_DECLARE(int) test_snippet\n{\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);\n\n    scoreboard_size = sizeof(global_score);\n    scoreboard_size += sizeof(process_score) * server_limit;\n    scoreboard_size += sizeof(worker_score) * server_limit * thread_limit;\n\n    pfn_ap_logio_get_last_bytes = APR_RETRIEVE_OPTIONAL_FN(ap_logio_get_last_bytes);\n\n    return scoreboard_size;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_5738e462c04b13600d7dee2e016aaf1fe314df67_0", {
    "ID": "httpd_5738e462c04b13600d7dee2e016aaf1fe314df67_0",
    "UID": "3278",
    "code": "DAV_DECLARE(dav_get_props_result) dav_get_props(dav_propdb test_snippet\n                                                apr_xml_doc *doc)\n{\n    const dav_hooks_db *db_hooks = propdb->db_hooks;\n    apr_xml_elem *elem = dav_find_child(doc->root, \"prop\");\n    apr_text_header hdr_good = { 0 };\n    apr_text_header hdr_bad = { 0 };\n    apr_text_header hdr_ns = { 0 };\n    int have_good = 0;\n    dav_get_props_result result = { 0 };\n    char *marks_liveprop;\n    dav_xmlns_info *xi;\n    int xi_filled = 0;\n\n    /* ### NOTE: we should pass in TWO buffers -- one for keys, one for\n       the marks */\n\n    \n    apr_text_append(propdb->p, &hdr_good,\n                   \"<D:propstat>\" DEBUG_CR\n                   \"<D:prop>\" DEBUG_CR);\n\n    \n    /* allocate zeroed-memory for the marks. These marks indicate which\n       liveprop namespaces we've generated into the output xmlns buffer */\n\n    \n    marks_liveprop = apr_pcalloc(propdb->p, dav_get_liveprop_ns_count() + 1);\n\n    xi = dav_xmlns_create(propdb->p);\n\n    for (elem = elem->first_child; elem; elem = elem->next) {\n        dav_elem_private *priv;\n        dav_error *err;\n        dav_prop_insert inserted;\n        dav_prop_name name;\n\n        /*\n        ** First try live property providers; if they don't handle\n        ** the property, then try looking it up in the propdb.\n        */\n\n        if (elem->priv == NULL) {\n            elem->priv = apr_pcalloc(propdb->p, sizeof(*priv));\n        }\n        priv = elem->priv;\n\n        \n        if (priv->propid == 0)\n            dav_find_liveprop(propdb, elem);\n\n        if (priv->propid != DAV_PROPID_CORE_UNKNOWN) {\n\n            \n            if ((err = dav_insert_liveprop(propdb, elem, DAV_PROP_INSERT_VALUE,\n                                           &hdr_good, &inserted)) != NULL) {\n                \n                \n            }\n            if (inserted == DAV_PROP_INSERT_VALUE) {\n                have_good = 1;\n\n                /*\n                ** Add the liveprop's namespace URIs. Note that provider==NULL\n                ** for core properties.\n                */\n                if (priv->provider != NULL) {\n                    const char * const * scan_ns_uri;\n\n                    for (scan_ns_uri = priv->provider->namespace_uris;\n                         *scan_ns_uri != NULL;\n                         ++scan_ns_uri) {\n                        long ns;\n\n                        ns = dav_get_liveprop_ns_index(*scan_ns_uri);\n                        if (marks_liveprop[ns])\n                            continue;\n                        marks_liveprop[ns] = 1;\n\n                        dav_insert_xmlns(propdb->p, \"lp\", ns, *scan_ns_uri,\n                                         &hdr_ns);\n                    }\n                }\n\n                \n                continue;\n            }\n            else if (inserted == DAV_PROP_INSERT_NOTDEF) {\n                /* nothing to do. fall thru to allow property to be handled\n                   as a dead property */\n            }\n#if DAV_DEBUG\n            else {\n#if 0\n                \n                return dav_new_error(propdb->p, HTTP_INTERNAL_SERVER_ERROR, 0,\n                                     0,\n                                     \"INTERNAL DESIGN ERROR: insert_liveprop \"\n                                     \"did not insert what was asked for.\");\n#endif\n            }\n#endif\n        }\n\n        /* The property wasn't a live property, so look in the dead property\n           database. */\n\n        \n        if (propdb->deferred) {\n            \n            (void) dav_really_open_db(propdb, 1 );\n        }\n\n        if (elem->ns == APR_XML_NS_NONE)\n            name.ns = \"\";\n        else\n            name.ns = APR_XML_GET_URI_ITEM(propdb->ns_xlate, elem->ns);\n        name.name = elem->name;\n\n        \n        if (propdb->db != NULL) {\n            int found;\n\n            if ((err = (*db_hooks->output_value)(propdb->db, &name,\n                                                 xi, &hdr_good,\n                                                 &found)) != NULL) {\n                \n                continue;\n            }\n\n            if (found) {\n                have_good = 1;\n\n                \n                if (!xi_filled) {\n                    (void) (*db_hooks->define_namespaces)(propdb->db, xi);\n                    xi_filled = 1;\n                }\n                continue;\n            }\n        }\n\n        /* not found as a live OR dead property. add a record to the \"bad\"\n           propstats */\n\n        \n        if (hdr_bad.first == NULL) {\n            apr_text_append(propdb->p, &hdr_bad,\n                            \"<D:propstat>\" DEBUG_CR\n                            \"<D:prop>\" DEBUG_CR);\n        }\n\n        \n        dav_output_prop_name(propdb->p, &name, xi, &hdr_bad);\n    }\n\n    apr_text_append(propdb->p, &hdr_good,\n                    \"</D:prop>\" DEBUG_CR\n                    \"<D:status>HTTP/1.1 200 OK</D:status>\" DEBUG_CR\n                    \"</D:propstat>\" DEBUG_CR);\n\n    \n    result.propstats = hdr_good.first;\n\n    \n    if (hdr_bad.first != NULL) {\n        \n        apr_text_append(propdb->p, &hdr_bad,\n                        \"</D:prop>\" DEBUG_CR\n                        \"<D:status>HTTP/1.1 404 Not Found</D:status>\" DEBUG_CR\n                        \"</D:propstat>\" DEBUG_CR);\n\n        \n        if (!have_good) {\n            result.propstats = hdr_bad.first;\n        }\n        else {\n            \n            hdr_good.last->next = hdr_bad.first;\n        }\n    }\n\n    \n    dav_xmlns_generate(xi, &hdr_ns);\n    result.xmlns = hdr_ns.first;\n\n    return result;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_a7ccaf5355b0aa5e2de090f20dc6d5bcfe9234d6_0", {
    "ID": "httpd_a7ccaf5355b0aa5e2de090f20dc6d5bcfe9234d6_0",
    "UID": "3282",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_connect_uds(apr_socket_t test_snippet\n                                                 const char *uds_path,\n                                                 apr_pool_t *p)\n{\n    apr_status_t rv;\n    apr_os_sock_t rawsock;\n    apr_interval_time_t t;\n    struct sockaddr_un *sa;\n    apr_socklen_t addrlen, pathlen;\n\n    rv = apr_os_sock_get(&rawsock, sock);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    rv = apr_socket_timeout_get(sock, &t);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    pathlen = strlen(uds_path);\n    \n    addrlen = APR_OFFSETOF(struct sockaddr_un, sun_path) + pathlen;\n    sa = (struct sockaddr_un *)apr_palloc(p, addrlen + 1);\n    memcpy(sa->sun_path, uds_path, pathlen + 1);\n    sa->sun_family = AF_UNIX;\n\n    do {\n        rv = connect(rawsock, (struct sockaddr*)sa, addrlen);\n    } while (rv == -1 && (rv = errno) == EINTR);\n\n    if (rv && rv != EISCONN) {\n        if ((rv == EINPROGRESS || rv == EALREADY) && (t > 0))  {\n#if APR_MAJOR_VERSION < 2\n            rv = apr_wait_for_io_or_timeout(NULL, sock, 0);\n#else\n            rv = apr_socket_wait(sock, APR_WAIT_WRITE);\n#endif\n        }\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_66aab6e9334672a547db35216c467585efb52a7f_0", {
    "ID": "httpd_66aab6e9334672a547db35216c467585efb52a7f_0",
    "UID": "3296",
    "code": "static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf test_snippet\n                             request_rec *r, apr_pool_t *setaside_pool,\n                             apr_uint16_t request_id,\n                             const char **err)\n{\n    apr_bucket_brigade *ib, *ob;\n    int seen_end_of_headers = 0, done = 0;\n    apr_status_t rv = APR_SUCCESS;\n    int script_error_status = HTTP_OK;\n    conn_rec *c = r->connection;\n    struct iovec vec[2];\n    ap_fcgi_header header;\n    unsigned char farray[AP_FCGI_HEADER_LEN];\n    apr_pollfd_t pfd;\n    int header_state = HDR_STATE_READING_HEADERS;\n    char stack_iobuf[AP_IOBUFSIZE];\n    apr_size_t iobuf_size = AP_IOBUFSIZE;\n    char *iobuf = stack_iobuf;\n\n    *err = NULL;\n    if (conn->worker->s->io_buffer_size_set) {\n        iobuf_size = conn->worker->s->io_buffer_size;\n        iobuf = apr_palloc(r->pool, iobuf_size);\n    }\n\n    pfd.desc_type = APR_POLL_SOCKET;\n    pfd.desc.s = conn->sock;\n    pfd.p = r->pool;\n    pfd.reqevents = APR_POLLIN | APR_POLLOUT;\n\n    ib = apr_brigade_create(r->pool, c->bucket_alloc);\n    ob = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    while (! done) {\n        apr_interval_time_t timeout;\n        apr_size_t len;\n        int n;\n\n        /* We need SOME kind of timeout here, or virtually anything will\n         * cause timeout errors. */\n        apr_socket_timeout_get(conn->sock, &timeout);\n\n        rv = apr_poll(&pfd, 1, &n, timeout);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            *err = \"polling\";\n            break;\n        }\n\n        if (pfd.rtnevents & APR_POLLOUT) {\n            apr_size_t to_send, writebuflen;\n            int last_stdin = 0;\n            char *iobuf_cursor;\n\n            rv = ap_get_brigade(r->input_filters, ib,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                iobuf_size);\n            if (rv != APR_SUCCESS) {\n                *err = \"reading input brigade\";\n                break;\n            }\n\n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(ib))) {\n                last_stdin = 1;\n            }\n\n            writebuflen = iobuf_size;\n\n            rv = apr_brigade_flatten(ib, iobuf, &writebuflen);\n\n            apr_brigade_cleanup(ib);\n\n            if (rv != APR_SUCCESS) {\n                *err = \"flattening brigade\";\n                break;\n            }\n\n            to_send = writebuflen;\n            iobuf_cursor = iobuf;\n            while (to_send > 0) {\n                int nvec = 0;\n                apr_size_t write_this_time;\n\n                write_this_time =\n                    to_send < AP_FCGI_MAX_CONTENT_LEN ? to_send : AP_FCGI_MAX_CONTENT_LEN;\n\n                ap_fcgi_fill_in_header(&header, AP_FCGI_STDIN, request_id,\n                                       (apr_uint16_t)write_this_time, 0);\n                ap_fcgi_header_to_array(&header, farray);\n\n                vec[nvec].iov_base = (void *)farray;\n                vec[nvec].iov_len = sizeof(farray);\n                ++nvec;\n                if (writebuflen) {\n                    vec[nvec].iov_base = iobuf_cursor;\n                    vec[nvec].iov_len = write_this_time;\n                    ++nvec;\n                }\n\n                rv = send_data(conn, vec, nvec, &len);\n                if (rv != APR_SUCCESS) {\n                    *err = \"sending stdin\";\n                    break;\n                }\n\n                to_send -= write_this_time;\n                iobuf_cursor += write_this_time;\n            }\n\n            if (last_stdin) {\n                pfd.reqevents = APR_POLLIN; \n\n                \n                ap_fcgi_fill_in_header(&header, AP_FCGI_STDIN, request_id,\n                                       0, 0);\n                ap_fcgi_header_to_array(&header, farray);\n\n                vec[0].iov_base = (void *)farray;\n                vec[0].iov_len = sizeof(farray);\n\n                rv = send_data(conn, vec, 1, &len);\n                if (rv != APR_SUCCESS) {\n                    *err = \"sending empty stdin\";\n                    break;\n                }\n            }\n        }\n\n        if (pfd.rtnevents & APR_POLLIN) {\n            apr_size_t readbuflen;\n            apr_uint16_t clen, rid;\n            apr_bucket *b;\n            unsigned char plen;\n            unsigned char type, version;\n\n            \n            rv = get_data_full(conn, (char *) farray, AP_FCGI_HEADER_LEN);\n            if (rv != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01067)\n                              \"Failed to read FastCGI header\");\n                break;\n            }\n\n#ifdef FCGI_DUMP_HEADERS\n            ap_log_rdata(APLOG_MARK, APLOG_DEBUG, r, \"FastCGI header\",\n                         farray, AP_FCGI_HEADER_LEN, 0);\n#endif\n\n            ap_fcgi_header_fields_from_array(&version, &type, &rid,\n                                             &clen, &plen, farray);\n\n            if (version != AP_FCGI_VERSION_1) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01068)\n                              \"Got bogus version %d\", (int)version);\n                rv = APR_EINVAL;\n                break;\n            }\n\n            if (rid != request_id) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01069)\n                              \"Got bogus rid %d, expected %d\",\n                              rid, request_id);\n                rv = APR_EINVAL;\n                break;\n            }\n\nrecv_again:\n            if (clen > iobuf_size) {\n                readbuflen = iobuf_size;\n            } else {\n                readbuflen = clen;\n            }\n\n            /* Now get the actual data.  Yes it sucks to do this in a second\n             * recv call, this will eventually change when we move to real\n             * nonblocking recv calls. */\n            if (readbuflen != 0) {\n                rv = get_data(conn, iobuf, &readbuflen);\n                if (rv != APR_SUCCESS) {\n                    *err = \"reading response body\";\n                    break;\n                }\n            }\n\n            switch (type) {\n            case AP_FCGI_STDOUT:\n                if (clen != 0) {\n                    b = apr_bucket_transient_create(iobuf,\n                                                    readbuflen,\n                                                    c->bucket_alloc);\n\n                    APR_BRIGADE_INSERT_TAIL(ob, b);\n\n                    if (! seen_end_of_headers) {\n                        int st = handle_headers(r, &header_state, iobuf);\n\n                        if (st == 1) {\n                            int status;\n                            seen_end_of_headers = 1;\n\n                            status = ap_scan_script_header_err_brigade_ex(r, ob,\n                                NULL, APLOG_MODULE_INDEX);\n                            \n                            if (status != OK) {\n                                apr_bucket *tmp_b;\n                                apr_brigade_cleanup(ob);\n                                tmp_b = apr_bucket_eos_create(c->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(ob, tmp_b);\n                                r->status = status;\n                                ap_pass_brigade(r->output_filters, ob);\n                                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01070)\n                                              \"Error parsing script headers\");\n                                rv = APR_EINVAL;\n                                break;\n                            }\n\n                            if (conf->error_override &&\n                                ap_is_HTTP_ERROR(r->status)) {\n                                /*\n                                 * set script_error_status to discard\n                                 * everything after the headers\n                                 */\n                                script_error_status = r->status;\n                                /*\n                                 * prevent ap_die() from treating this as a\n                                 * recursive error, initially:\n                                 */\n                                r->status = HTTP_OK;\n                            }\n\n                            if (script_error_status == HTTP_OK\n                                && !APR_BRIGADE_EMPTY(ob)) {\n                                /* Send the part of the body that we read while\n                                 * reading the headers.\n                                 */\n                                rv = ap_pass_brigade(r->output_filters, ob);\n                                if (rv != APR_SUCCESS) {\n                                    *err = \"passing brigade to output filters\";\n                                    break;\n                                }\n                            }\n                            apr_brigade_cleanup(ob);\n\n                            apr_pool_clear(setaside_pool);\n                        }\n                        else {\n                            /* We're still looking for the end of the\n                             * headers, so this part of the data will need\n                             * to persist. */\n                            apr_bucket_setaside(b, setaside_pool);\n                        }\n                    } else {\n                        /* we've already passed along the headers, so now pass\n                         * through the content.  we could simply continue to\n                         * setaside the content and not pass until we see the\n                         * 0 content-length (below, where we append the EOS),\n                         * but that could be a huge amount of data; so we pass\n                         * along smaller chunks\n                         */\n                        if (script_error_status == HTTP_OK) {\n                            rv = ap_pass_brigade(r->output_filters, ob);\n                            if (rv != APR_SUCCESS) {\n                                *err = \"passing brigade to output filters\";\n                                break;\n                            }\n                        }\n                        apr_brigade_cleanup(ob);\n                    }\n\n                    /* If we didn't read all the data go back and get the\n                     * rest of it. */\n                    if (clen > readbuflen) {\n                        clen -= readbuflen;\n                        goto recv_again;\n                    }\n                } else {\n                    \n\n                    if (script_error_status == HTTP_OK) {\n                        b = apr_bucket_eos_create(c->bucket_alloc);\n                        APR_BRIGADE_INSERT_TAIL(ob, b);\n                        rv = ap_pass_brigade(r->output_filters, ob);\n                        if (rv != APR_SUCCESS) {\n                            *err = \"passing brigade to output filters\";\n                            break;\n                        }\n                    }\n\n                    \n                }\n                break;\n\n            case AP_FCGI_STDERR:\n                \n                if (clen) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01071)\n                                  \"Got error '%s'\", iobuf);\n                }\n\n                if (clen > readbuflen) {\n                    clen -= readbuflen;\n                    goto recv_again;\n                }\n                break;\n\n            case AP_FCGI_END_REQUEST:\n                done = 1;\n                break;\n\n            default:\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01072)\n                              \"Got bogus record %d\", type);\n                break;\n            }\n\n            if (plen) {\n                rv = get_data_full(conn, iobuf, plen);\n                if (rv != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                                  APLOGNO(02537) \"Error occurred reading padding\");\n                    break;\n                }\n            }\n        }\n    }\n\n    apr_brigade_destroy(ib);\n    apr_brigade_destroy(ob);\n\n    if (script_error_status != HTTP_OK) {\n        ap_die(script_error_status, r); \n    }\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0b6f10736014008f2646518fec27f015fba387dc_0", {
    "ID": "httpd_0b6f10736014008f2646518fec27f015fba387dc_0",
    "UID": "3299",
    "code": "static const char *ap_expr_eval_word(ap_expr_eval_ctx_t test_snippet\n                                     const ap_expr_t *node)\n{\n    const char *result = \"\";\n    if (inc_rec(ctx))\n        return result;\n    switch (node->node_op) {\n    case op_Digit:\n    case op_String:\n        result = node->node_arg1;\n        break;\n    case op_Var:\n        result = ap_expr_eval_var(ctx, (ap_expr_var_func_t *)node->node_arg1,\n                                  node->node_arg2);\n        break;\n    case op_Concat:\n        if (((ap_expr_t *)node->node_arg2)->node_op != op_Concat &&\n            ((ap_expr_t *)node->node_arg1)->node_op != op_Concat) {\n            const char *s1 = ap_expr_eval_word(ctx, node->node_arg1);\n            const char *s2 = ap_expr_eval_word(ctx, node->node_arg2);\n            if (!*s1)\n                result = s2;\n            else if (!*s2)\n                result = s1;\n            else\n                result = apr_pstrcat(ctx->p, s1, s2, NULL);\n        }\n        else if (((ap_expr_t *)node->node_arg1)->node_op == op_Concat) {\n            const ap_expr_t *nodep = node;\n            int n;\n            int i = 1;\n            struct iovec *vec;\n            do {\n                nodep = nodep->node_arg1;\n                i++;\n            } while (nodep->node_op == op_Concat);\n            vec = apr_palloc(ctx->p, i * sizeof(struct iovec));\n            n = i;\n            nodep = node;\n            i--;\n            do {\n                vec[i].iov_base = (void *)ap_expr_eval_word(ctx,\n                                                            nodep->node_arg2);\n                vec[i].iov_len = strlen(vec[i].iov_base);\n                i--;\n                nodep = nodep->node_arg1;\n            } while (nodep->node_op == op_Concat);\n            vec[i].iov_base = (void *)ap_expr_eval_word(ctx, nodep);\n            vec[i].iov_len = strlen(vec[i].iov_base);\n            result = apr_pstrcatv(ctx->p, vec, n, NULL);\n        }\n        else {\n            const ap_expr_t *nodep = node;\n            int i = 1;\n            struct iovec *vec;\n            do {\n                nodep = nodep->node_arg2;\n                i++;\n            } while (nodep->node_op == op_Concat);\n            vec = apr_palloc(ctx->p, i * sizeof(struct iovec));\n            nodep = node;\n            i = 0;\n            do {\n                vec[i].iov_base = (void *)ap_expr_eval_word(ctx,\n                                                            nodep->node_arg1);\n                vec[i].iov_len = strlen(vec[i].iov_base);\n                i++;\n                nodep = nodep->node_arg2;\n            } while (nodep->node_op == op_Concat);\n            vec[i].iov_base = (void *)ap_expr_eval_word(ctx, nodep);\n            vec[i].iov_len = strlen(vec[i].iov_base);\n            i++;\n            result = apr_pstrcatv(ctx->p, vec, i, NULL);\n        }\n        break;\n    case op_StringFuncCall: {\n        const ap_expr_t *info = node->node_arg1;\n        const ap_expr_t *args = node->node_arg2;\n        result = ap_expr_eval_string_func(ctx, info, args);\n        break;\n    }\n    case op_RegexBackref: {\n        const unsigned int *np = node->node_arg1;\n        result = ap_expr_eval_re_backref(ctx, *np);\n        break;\n    }\n    default:\n        *ctx->err = \"Internal evaluation error: Unknown word expression node\";\n        break;\n    }\n    if (!result)\n        result = \"\";\n    ctx->reclvl--;\n    return result;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_da2e2958e40e177c49f3983172cdbeb679e46543_0", {
    "ID": "httpd_da2e2958e40e177c49f3983172cdbeb679e46543_0",
    "UID": "3306",
    "code": "static int stream_reqbody_cl(apr_pool_t test_snippet\n                                      request_rec *r,\n                                      proxy_conn_rec *p_conn,\n                                      conn_rec *origin,\n                                      apr_bucket_brigade *header_brigade,\n                                      apr_bucket_brigade *input_brigade,\n                                      char *old_cl_val, int flushall)\n{\n    int seen_eos = 0, rv = 0;\n    apr_status_t status = APR_SUCCESS;\n    apr_bucket_alloc_t *bucket_alloc = r->connection->bucket_alloc;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n    apr_off_t cl_val = 0;\n    apr_off_t bytes;\n    apr_off_t bytes_streamed = 0;\n\n    if (old_cl_val) {\n        char *endstr;\n\n        add_cl(p, bucket_alloc, header_brigade, old_cl_val);\n        status = apr_strtoff(&cl_val, old_cl_val, &endstr, 10);\n\n        if (status || *endstr || endstr == old_cl_val || cl_val < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01085)\n                          \"could not parse request Content-Length (%s)\",\n                          old_cl_val);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    terminate_headers(bucket_alloc, header_brigade);\n\n    while (APR_BRIGADE_EMPTY(input_brigade)\n           || !APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(input_brigade)))\n    {\n        int flush = flushall;\n\n        if (!APR_BRIGADE_EMPTY(input_brigade)) {\n            apr_brigade_length(input_brigade, 1, &bytes);\n            bytes_streamed += bytes;\n\n            \n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                seen_eos = 1;\n\n                \n                flush = 1;\n\n                \n                e = APR_BRIGADE_LAST(input_brigade);\n                apr_bucket_delete(e);\n\n                if (apr_table_get(r->subprocess_env, \"proxy-sendextracrlf\")) {\n                    e = apr_bucket_immortal_create(ASCII_CRLF, 2,\n                                                   bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n                }\n            }\n\n            /* C-L < bytes streamed?!?\n             * We will error out after the body is completely\n             * consumed, but we can't stream more bytes at the\n             * back end since they would in part be interpreted\n             * as another request!  If nothing is sent, then\n             * just send nothing.\n             *\n             * Prevents HTTP Response Splitting.\n             */\n            if (bytes_streamed > cl_val) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01086)\n                              \"read more bytes of request body than expected \"\n                              \"(got %\" APR_OFF_T_FMT \", expected \"\n                              \"%\" APR_OFF_T_FMT \")\",\n                              bytes_streamed, cl_val);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        if (header_brigade) {\n            /* we never sent the header brigade, so go ahead and\n             * take care of that now\n             */\n            bb = header_brigade;\n\n            /* Flush now since we have the header and (enough of) the prefeched\n             * body already.\n             */\n            flush = 1;\n\n            /*\n             * Save input_brigade in bb brigade. (At least) in the SSL case\n             * input_brigade contains transient buckets whose data would get\n             * overwritten during the next call of ap_get_brigade in the loop.\n             * ap_save_brigade ensures these buckets to be set aside.\n             * Calling ap_save_brigade with NULL as filter is OK, because\n             * bb brigade already has been created and does not need to get\n             * created by ap_save_brigade.\n             */\n            status = ap_save_brigade(NULL, &bb, &input_brigade, p);\n            if (status != APR_SUCCESS) {\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            header_brigade = NULL;\n        }\n        else {\n            bb = input_brigade;\n        }\n\n        rv = ap_proxy_pass_brigade(bucket_alloc, r, p_conn, origin, bb, flush);\n        if (rv != OK) {\n            return rv;\n        }\n\n        if (seen_eos) {\n            break;\n        }\n\n        status = ap_get_brigade(r->input_filters, input_brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                HUGE_STRING_LEN);\n\n        if (status != APR_SUCCESS) {\n            conn_rec *c = r->connection;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02609)\n                          \"read request body failed to %pI (%s)\"\n                          \" from %s (%s)\", p_conn->addr,\n                          p_conn->hostname ? p_conn->hostname: \"\",\n                          c->client_ip, c->remote_host ? c->remote_host: \"\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (bytes_streamed != cl_val) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01087)\n                      \"client %s given Content-Length did not match\"\n                      \" number of body bytes read\", r->connection->client_ip);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (header_brigade) {\n        /* we never sent the header brigade since there was no request\n         * body; send it now with the flush flag\n         */\n        bb = header_brigade;\n        return(ap_proxy_pass_brigade(bucket_alloc, r, p_conn, origin, bb, 1));\n    }\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_32a29688d10530c511dd5ee5df9f5ae8a163e89a_0", {
    "ID": "httpd_32a29688d10530c511dd5ee5df9f5ae8a163e89a_0",
    "UID": "3312",
    "code": "static int ap_proxy_http_prefetch(apr_pool_t *p, request_rec test_snippet\n                                  proxy_conn_rec *p_conn, proxy_worker *worker,\n                                  proxy_server_conf *conf,\n                                  apr_uri_t *uri,\n                                  char *url, char *server_portstr,\n                                  apr_bucket_brigade *header_brigade,\n                                  apr_bucket_brigade *input_brigade,\n                                  char **old_cl_val, char **old_te_val,\n                                  enum rb_methods *rb_method, int flushall)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_alloc_t *bucket_alloc = c->bucket_alloc;\n    apr_bucket_brigade *temp_brigade;\n    apr_bucket *e;\n    char *buf;\n    apr_status_t status;\n    apr_off_t bytes_read = 0;\n    apr_off_t bytes;\n    int force10, rv;\n    apr_read_type_e block;\n    conn_rec *origin = p_conn->connection;\n\n    if (apr_table_get(r->subprocess_env, \"force-proxy-request-1.0\")) {\n        if (r->expecting_100) {\n            return HTTP_EXPECTATION_FAILED;\n        }\n        force10 = 1;\n    } else {\n        force10 = 0;\n    }\n\n    rv = ap_proxy_create_hdrbrgd(p, header_brigade, r, p_conn,\n                                 worker, conf, uri, url, server_portstr,\n                                 old_cl_val, old_te_val);\n    if (rv != OK) {\n        return rv;\n    }\n\n    /* sub-requests never use keepalives, and mustn't pass request bodies.\n     * Because the new logic looks at input_brigade, we will self-terminate\n     * input_brigade and jump past all of the request body logic...\n     * Reading anything with ap_get_brigade is likely to consume the\n     * main request's body or read beyond EOS - which would be unplesant.\n     *\n     * An exception: when a kept_body is present, then subrequest CAN use\n     * pass request bodies, and we DONT skip the body.\n     */\n    if (!r->kept_body && r->main) {\n        \n        p_conn->close = 1;\n        *old_cl_val = NULL;\n        *old_te_val = NULL;\n        *rb_method = RB_STREAM_CL;\n        e = apr_bucket_eos_create(input_brigade->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n        goto skip_body;\n    }\n\n    /* WE only understand chunked.  Other modules might inject\n     * (and therefore, decode) other flavors but we don't know\n     * that the can and have done so unless they they remove\n     * their decoding from the headers_in T-E list.\n     * XXX: Make this extensible, but in doing so, presume the\n     * encoding has been done by the extensions' handler, and\n     * do not modify add_te_chunked's logic\n     */\n    if (*old_te_val && strcasecmp(*old_te_val, \"chunked\") != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01093)\n                      \"%s Transfer-Encoding is not supported\", *old_te_val);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (*old_cl_val && *old_te_val) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01094)\n                      \"client %s (%s) requested Transfer-Encoding \"\n                      \"chunked body with Content-Length (C-L ignored)\",\n                      c->client_ip, c->remote_host ? c->remote_host: \"\");\n        *old_cl_val = NULL;\n        origin->keepalive = AP_CONN_CLOSE;\n        p_conn->close = 1;\n    }\n\n    /* Prefetch MAX_MEM_SPOOL bytes\n     *\n     * This helps us avoid any election of C-L v.s. T-E\n     * request bodies, since we are willing to keep in\n     * memory this much data, in any case.  This gives\n     * us an instant C-L election if the body is of some\n     * reasonable size.\n     */\n    temp_brigade = apr_brigade_create(p, bucket_alloc);\n    block = (flushall) ? APR_NONBLOCK_READ : APR_BLOCK_READ;\n    do {\n        status = ap_get_brigade(r->input_filters, temp_brigade,\n                                AP_MODE_READBYTES, block,\n                                MAX_MEM_SPOOL - bytes_read);\n        /* ap_get_brigade may return success with an empty brigade\n         * for a non-blocking read which would block\n         */\n        if (block == APR_NONBLOCK_READ\n            && ((status == APR_SUCCESS && APR_BRIGADE_EMPTY(temp_brigade))\n                || APR_STATUS_IS_EAGAIN(status))) {\n            break;\n        }\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01095)\n                          \"prefetch request body failed to %pI (%s)\"\n                          \" from %s (%s)\",\n                          p_conn->addr, p_conn->hostname ? p_conn->hostname: \"\",\n                          c->client_ip, c->remote_host ? c->remote_host: \"\");\n            return HTTP_BAD_REQUEST;\n        }\n\n        apr_brigade_length(temp_brigade, 1, &bytes);\n        bytes_read += bytes;\n\n        /*\n         * Save temp_brigade in input_brigade. (At least) in the SSL case\n         * temp_brigade contains transient buckets whose data would get\n         * overwritten during the next call of ap_get_brigade in the loop.\n         * ap_save_brigade ensures these buckets to be set aside.\n         * Calling ap_save_brigade with NULL as filter is OK, because\n         * input_brigade already has been created and does not need to get\n         * created by ap_save_brigade.\n         */\n        status = ap_save_brigade(NULL, &input_brigade, &temp_brigade, p);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01096)\n                          \"processing prefetched request body failed\"\n                          \" to %pI (%s) from %s (%s)\",\n                          p_conn->addr, p_conn->hostname ? p_conn->hostname: \"\",\n                          c->client_ip, c->remote_host ? c->remote_host: \"\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n    /* Ensure we don't hit a wall where we have a buffer too small\n     * for ap_get_brigade's filters to fetch us another bucket,\n     * surrender once we hit 80 bytes less than MAX_MEM_SPOOL\n     * (an arbitrary value.)\n     */\n    } while ((bytes_read < MAX_MEM_SPOOL - 80)\n              && !APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))\n              && block == APR_BLOCK_READ);\n\n    /* Use chunked request body encoding or send a content-length body?\n     *\n     * Prefer C-L when:\n     *\n     *   We have no request body (handled by RB_STREAM_CL)\n     *\n     *   We have a request body length <= MAX_MEM_SPOOL\n     *\n     *   The administrator has setenv force-proxy-request-1.0\n     *\n     *   The client sent a C-L body, and the administrator has\n     *   not setenv proxy-sendchunked or has set setenv proxy-sendcl\n     *\n     *   The client sent a T-E body, and the administrator has\n     *   setenv proxy-sendcl, and not setenv proxy-sendchunked\n     *\n     * If both proxy-sendcl and proxy-sendchunked are set, the\n     * behavior is the same as if neither were set, large bodies\n     * that can't be read will be forwarded in their original\n     * form of C-L, or T-E.\n     *\n     * To ensure maximum compatibility, setenv proxy-sendcl\n     * To reduce server resource use,   setenv proxy-sendchunked\n     *\n     * Then address specific servers with conditional setenv\n     * options to restore the default behavior where desireable.\n     *\n     * We have to compute content length by reading the entire request\n     * body; if request body is not small, we'll spool the remaining\n     * input to a temporary file.  Chunked is always preferable.\n     *\n     * We can only trust the client-provided C-L if the T-E header\n     * is absent, and the filters are unchanged (the body won't\n     * be resized by another content filter).\n     */\n    if (!APR_BRIGADE_EMPTY(input_brigade)\n        && APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n        /* The whole thing fit, so our decision is trivial, use\n         * the filtered bytes read from the client for the request\n         * body Content-Length.\n         *\n         * If we expected no body, and read no body, do not set\n         * the Content-Length.\n         */\n        if (*old_cl_val || *old_te_val || bytes_read) {\n            *old_cl_val = apr_off_t_toa(r->pool, bytes_read);\n        }\n        *rb_method = RB_STREAM_CL;\n    }\n    else if (*old_te_val) {\n        if (force10\n             || (apr_table_get(r->subprocess_env, \"proxy-sendcl\")\n                  && !apr_table_get(r->subprocess_env, \"proxy-sendchunks\")\n                  && !apr_table_get(r->subprocess_env, \"proxy-sendchunked\"))) {\n            *rb_method = RB_SPOOL_CL;\n        }\n        else {\n            *rb_method = RB_STREAM_CHUNKED;\n        }\n    }\n    else if (*old_cl_val) {\n        if (r->input_filters == r->proto_input_filters) {\n            *rb_method = RB_STREAM_CL;\n        }\n        else if (!force10\n                  && (apr_table_get(r->subprocess_env, \"proxy-sendchunks\")\n                      || apr_table_get(r->subprocess_env, \"proxy-sendchunked\"))\n                  && !apr_table_get(r->subprocess_env, \"proxy-sendcl\")) {\n            *rb_method = RB_STREAM_CHUNKED;\n        }\n        else {\n            *rb_method = RB_SPOOL_CL;\n        }\n    }\n    else {\n        /* This is an appropriate default; very efficient for no-body\n         * requests, and has the behavior that it will not add any C-L\n         * when the *old_cl_val is NULL.\n         */\n        *rb_method = RB_SPOOL_CL;\n    }\n\n    /* If we have to spool the body, do it now, before connecting or\n     * reusing the backend connection.\n     */\n    if (*rb_method == RB_SPOOL_CL) {\n        rv = spool_reqbody_cl(p, r, header_brigade, input_brigade,\n                              (bytes_read > 0)\n                              || (*old_cl_val != NULL)\n                              || (*old_te_val != NULL));\n        if (rv != OK) {\n            return rv;\n        }\n    }\n\n\nskip_body:\n    /*\n     * Handle Connection: header if we do HTTP/1.1 request:\n     * If we plan to close the backend connection sent Connection: close\n     * otherwise sent Connection: Keep-Alive.\n     */\n    if (!force10) {\n        if (p_conn->close) {\n            buf = apr_pstrdup(p, \"Connection: close\" CRLF);\n        }\n        else {\n            buf = apr_pstrdup(p, \"Connection: Keep-Alive\" CRLF);\n        }\n        ap_xlate_proto_to_ascii(buf, strlen(buf));\n        e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_422c4e6ace57d813cba9c320e193ff7053f825d2_0", {
    "ID": "httpd_422c4e6ace57d813cba9c320e193ff7053f825d2_0",
    "UID": "3327",
    "code": "static dav_prop_insert dav_core_insert_prop(const dav_resource test_snippet\n                                            int propid, dav_prop_insert what,\n                                            apr_text_header *phdr)\n{\n    const char *value = NULL;\n    const char *s;\n    apr_pool_t *p = resource->pool;\n    const dav_liveprop_spec *info;\n    long global_ns;\n\n    switch (propid)\n    {\n    case DAV_PROPID_resourcetype:\n        { \n            int i;\n\n            apr_array_header_t *extensions =\n                ap_list_provider_names(p, DAV_RESOURCE_TYPE_GROUP, \"0\");\n            ap_list_provider_names_t *entry =\n                (ap_list_provider_names_t *)extensions->elts;\n\n            for (i = 0; i < extensions->nelts; i++, entry++) {\n                const dav_resource_type_provider *res_hooks =\n                    dav_get_resource_type_providers(entry->provider_name);\n                const char *name = NULL, *uri = NULL;\n\n                if (!res_hooks || !res_hooks->get_resource_type)\n                    continue;\n\n                if (!res_hooks->get_resource_type(resource, &name, &uri) &&\n                    name) {\n\n                    if (!uri || !strcasecmp(uri, \"DAV:\"))\n                        value = apr_pstrcat(p, value ? value : \"\",\n                                            \"<D:\", name, \"/>\", NULL);\n                    else\n                        value = apr_pstrcat(p, value ? value : \"\",\n                                            \"<x:\", name,\n                                            \" xmlns:x=\\\"\", uri,\n                                            \"\\\"/>\", NULL);\n                }\n            }\n        }\n        switch (resource->type) {\n        case DAV_RESOURCE_TYPE_VERSION:\n            if (resource->baselined) {\n                value = apr_pstrcat(p, value ? value : \"\", \"<D:baseline/>\", NULL);\n                break;\n            }\n            \n        case DAV_RESOURCE_TYPE_REGULAR:\n        case DAV_RESOURCE_TYPE_WORKING:\n            if (resource->collection) {\n                value = apr_pstrcat(p, value ? value : \"\", \"<D:collection/>\", NULL);\n            }\n            else {\n                \n                if (value == NULL) {\n                    value = \"\";        \n                }\n            }\n            break;\n        case DAV_RESOURCE_TYPE_HISTORY:\n            value = apr_pstrcat(p, value ? value : \"\", \"<D:version-history/>\", NULL);\n            break;\n        case DAV_RESOURCE_TYPE_WORKSPACE:\n            value = apr_pstrcat(p, value ? value : \"\", \"<D:collection/>\", NULL);\n            break;\n        case DAV_RESOURCE_TYPE_ACTIVITY:\n            value = apr_pstrcat(p, value ? value : \"\", \"<D:activity/>\", NULL);\n            break;\n\n        default:\n            \n            return DAV_PROP_INSERT_NOTDEF;\n        }\n        break;\n\n    case DAV_PROPID_comment:\n    case DAV_PROPID_creator_displayname:\n    case DAV_PROPID_displayname:\n    case DAV_PROPID_source:\n    default:\n        /*\n        ** This property is known, but not defined as a liveprop. However,\n        ** it may be a dead property.\n        */\n        return DAV_PROP_INSERT_NOTDEF;\n    }\n\n    \n\n    \n    global_ns = dav_get_liveprop_info(propid, &dav_core_liveprop_group, &info);\n\n    \n\n    if (what == DAV_PROP_INSERT_SUPPORTED) {\n        s = apr_pstrcat(p,\n                         \"<D:supported-live-property D:name=\\\"\", info->name,\n                         \"\\\" D:namespace=\\\"\", dav_core_namespace_uris[info->ns],\n                         \"\\\"/>\" DEBUG_CR, NULL);\n    }\n    else if (what == DAV_PROP_INSERT_VALUE && *value != '\\0') {\n        s = apr_psprintf(p, \"<lp%ld:%s>%s</lp%ld:%s>\" DEBUG_CR,\n                         global_ns, info->name, value, global_ns, info->name);\n    }\n    else {\n        s = apr_psprintf(p, \"<lp%ld:%s/>\" DEBUG_CR, global_ns, info->name);\n    }\n    apr_text_append(p, phdr, s);\n\n    \n    return what;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_923a043a81c6ca1ae4fb7da06498a0677056e670_0", {
    "ID": "httpd_923a043a81c6ca1ae4fb7da06498a0677056e670_0",
    "UID": "3330",
    "code": "static void check_args(int argc, const char *const test_snippet\n                       struct passwd_ctx *ctx, unsigned *mask, char **user,\n                       char **pwfilename)\n{\n    const char *arg;\n    int args_left = 2;\n    int i, ret;\n    apr_getopt_t *state;\n    apr_status_t rv;\n    char opt;\n    const char *opt_arg;\n    apr_pool_t *pool = ctx->pool;\n\n    rv = apr_getopt_init(&state, pool, argc, argv);\n    if (rv != APR_SUCCESS)\n        exit(ERR_SYNTAX);\n\n    while ((rv = apr_getopt(state, \"cnmspdBbDi25C:r:v\", &opt, &opt_arg)) == APR_SUCCESS) {\n        switch (opt) {\n        case 'c':\n            *mask |= APHTP_NEWFILE;\n            break;\n        case 'n':\n            args_left--;\n            *mask |= APHTP_NOFILE;\n            break;\n        case 'D':\n            *mask |= APHTP_DELUSER;\n            break;\n        case 'v':\n            *mask |= APHTP_VERIFY;\n            break;\n        default:\n            ret = parse_common_options(ctx, opt, opt_arg);\n            if (ret) {\n                apr_file_printf(errfile, \"%s: %s\" NL, argv[0], ctx->errstr);\n                exit(ret);\n            }\n        }\n    }\n    if (ctx->passwd_src == PW_ARG)\n        args_left++;\n    if (rv != APR_EOF)\n        usage();\n\n    if ((*mask) & (*mask - 1)) {\n        \n        apr_file_printf(errfile, \"%s: only one of -c -n -v -D may be specified\" NL,\n            argv[0]);\n        exit(ERR_SYNTAX);\n    }\n    if ((*mask & APHTP_VERIFY) && ctx->passwd_src == PW_PROMPT)\n        ctx->passwd_src = PW_PROMPT_VERIFY;\n\n    /*\n     * Make sure we still have exactly the right number of arguments left\n     * (the filename, the username, and possibly the password if -b was\n     * specified).\n     */\n    i = state->ind;\n    if ((argc - i) != args_left) {\n        usage();\n    }\n\n    if (!(*mask & APHTP_NOFILE)) {\n        if (strlen(argv[i]) > (APR_PATH_MAX - 1)) {\n            apr_file_printf(errfile, \"%s: filename too long\" NL, argv[0]);\n            exit(ERR_OVERFLOW);\n        }\n        *pwfilename = apr_pstrdup(pool, argv[i++]);\n    }\n    if (strlen(argv[i]) > (MAX_STRING_LEN - 1)) {\n        apr_file_printf(errfile, \"%s: username too long (> %d)\" NL,\n                        argv[0], MAX_STRING_LEN - 1);\n        exit(ERR_OVERFLOW);\n    }\n    *user = apr_pstrdup(pool, argv[i++]);\n    if ((arg = strchr(*user, ':')) != NULL) {\n        apr_file_printf(errfile, \"%s: username contains illegal \"\n                        \"character '%c'\" NL, argv[0], *arg);\n        exit(ERR_BADUSER);\n    }\n    if (ctx->passwd_src == PW_ARG) {\n        if (strlen(argv[i]) > (MAX_STRING_LEN - 1)) {\n            apr_file_printf(errfile, \"%s: password too long (> %d)\" NL,\n                argv[0], MAX_STRING_LEN);\n            exit(ERR_OVERFLOW);\n        }\n        ctx->passwd = apr_pstrdup(pool, argv[i]);\n    }\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_74d2f2e13bce63ce5eb6a5f96c45a2b7922940a4_0", {
    "ID": "httpd_74d2f2e13bce63ce5eb6a5f96c45a2b7922940a4_0",
    "UID": "3337",
    "code": "static dav_error * dav_insert_coreprop(dav_propdb test_snippet\n                                       int propid, const char *name,\n                                       dav_prop_insert what,\n                                       apr_text_header *phdr,\n                                       dav_prop_insert *inserted)\n{\n    const char *value = NULL;\n    dav_error *err;\n\n    *inserted = DAV_PROP_INSERT_NOTDEF;\n\n    \n    if (propid == DAV_PROPID_CORE_UNKNOWN)\n        return NULL;\n\n    switch (propid) {\n\n    case DAV_PROPID_CORE_lockdiscovery:\n        if (propdb->lockdb != NULL) {\n            dav_lock *locks;\n\n            if ((err = dav_lock_query(propdb->lockdb, propdb->resource,\n                                      &locks)) != NULL) {\n                return dav_push_error(propdb->p, err->status, 0,\n                                      \"DAV:lockdiscovery could not be \"\n                                      \"determined due to a problem fetching \"\n                                      \"the locks for this resource.\",\n                                      err);\n            }\n\n            \n            if (locks == NULL) {\n                value = \"\";\n            }\n            else {\n                /*\n                ** This may modify the buffer. value may point to\n                ** wb_lock.pbuf or a string constant.\n                */\n                value = dav_lock_get_activelock(propdb->r, locks,\n                                                &propdb->wb_lock);\n\n                \n                value = apr_pstrdup(propdb->p, propdb->wb_lock.buf);\n            }\n        }\n        break;\n\n    case DAV_PROPID_CORE_supportedlock:\n        if (propdb->lockdb != NULL) {\n            value = (*propdb->lockdb->hooks->get_supportedlock)(propdb->resource);\n        }\n        break;\n\n    case DAV_PROPID_CORE_getcontenttype:\n        if (propdb->subreq == NULL) {\n            dav_do_prop_subreq(propdb);\n        }\n        if (propdb->subreq->content_type != NULL) {\n            value = propdb->subreq->content_type;\n        }\n        break;\n\n    case DAV_PROPID_CORE_getcontentlanguage:\n    {\n        const char *lang;\n\n        if (propdb->subreq == NULL) {\n            dav_do_prop_subreq(propdb);\n        }\n        if ((lang = apr_table_get(propdb->subreq->headers_out,\n                                 \"Content-Language\")) != NULL) {\n            value = lang;\n        }\n        break;\n    }\n\n    default:\n        \n        break;\n    }\n\n    \n    if (value != NULL) {\n        const char *s;\n\n        if (what == DAV_PROP_INSERT_SUPPORTED) {\n            /* use D: prefix to refer to the DAV: namespace URI,\n             * and let the namespace attribute default to \"DAV:\"\n             */\n            s = apr_pstrcat(propdb->p,\n                            \"<D:supported-live-property D:name=\\\"\",\n                            name, \"\\\"/>\" DEBUG_CR, NULL);\n        }\n        else if (what == DAV_PROP_INSERT_VALUE && *value != '\\0') {\n            \n            s = apr_pstrcat(propdb->p, \"<D:\", name, \">\", value, \"</D:\", name,\n                            \">\" DEBUG_CR, NULL);\n        }\n        else {\n            \n            s = apr_pstrcat(propdb->p, \"<D:\", name, \"/>\" DEBUG_CR, NULL);\n        }\n        apr_text_append(propdb->p, phdr, s);\n\n        *inserted = what;\n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_8f5080b8c24b7f02f0e7bc59d3905aa25f72e7aa_0", {
    "ID": "httpd_8f5080b8c24b7f02f0e7bc59d3905aa25f72e7aa_0",
    "UID": "3339",
    "code": "static int hc_get_backend(const char *proxy_function, proxy_conn_rec test_snippet\n                          proxy_worker *hc, sctx_t *ctx, apr_pool_t *ptemp)\n{\n    int status;\n    status = ap_proxy_acquire_connection(proxy_function, backend, hc, ctx->s);\n    if (status == OK) {\n        (*backend)->addr = hc->cp->addr;\n        (*backend)->hostname = hc->s->hostname_ex;\n        if (strcmp(hc->s->scheme, \"https\") == 0) {\n            if (!ap_proxy_ssl_enable(NULL)) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ctx->s, APLOGNO(03252)\n                              \"mod_ssl not configured?\");\n                return !OK;\n            }\n            (*backend)->is_ssl = 1;\n        }\n\n    }\n    return hc_determine_connection(ctx, hc, &(*backend)->addr, ptemp);\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d0eb832dd57c06e3c3fe5a44b93025c65144dede_0", {
    "ID": "httpd_d0eb832dd57c06e3c3fe5a44b93025c65144dede_0",
    "UID": "3340",
    "code": "static int hc_send(request_rec *r, const char *out, apr_bucket_brigade test_snippet\n{\n    apr_status_t rv;\n    conn_rec *c = r->connection;\n    apr_bucket_alloc_t *ba = c->bucket_alloc;\n    ap_log_error(APLOG_MARK, APLOG_TRACE7, 0, r->server, \"%s\", out);\n    APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(out, strlen(out),\n                                                       r->pool, ba));\n    APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_flush_create(ba));\n    rv = ap_pass_brigade(c->output_filters, bb);\n    apr_brigade_cleanup(bb);\n    return (rv) ? !OK : OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_90b171bf3cfee36b0043eb330c27a494ee30e214_0", {
    "ID": "httpd_90b171bf3cfee36b0043eb330c27a494ee30e214_0",
    "UID": "3349",
    "code": "static timer_event_t * event_get_timer_event(apr_time_t test_snippet\n                                             ap_mpm_callback_fn_t *cbfn,\n                                             void *baton,\n                                             int insertest_snippet \n                                             apr_array_header_t *remove)\n{\n    timer_event_t *te;\n    apr_time_t now = (t < 0) ? 0 : apr_time_now();\n\n    \n\n    apr_thread_mutex_lock(g_timer_skiplist_mtx);\n\n    if (!APR_RING_EMPTY(&timer_free_ring, timer_event_test_snippet link)) {\n        te = APR_RING_FIRST(&timer_free_ring);\n        APR_RING_REMOVE(te, link);\n    }\n    else {\n        te = apr_skiplist_alloc(timer_skiplistest_snippet sizeof(timer_event_t));\n        APR_RING_ELEM_INIT(te, link);\n    }\n\n    te->cbfunc = cbfn;\n    te->baton = baton;\n    te->canceled = 0;\n    te->when = now + t;\n    te->remove = remove;\n\n    if (insert) { \n        apr_time_t next_expiry;\n\n        \n        apr_skiplist_insert(timer_skiplistest_snippet te);\n\n        /* Cheaply update the overall timers' next expiry according to\n         * this eventest_snippet if necessary.\n         */\n        next_expiry = timers_next_expiry;\n        if (!next_expiry || next_expiry > te->when + EVENT_FUDGE_FACTOR) {\n            timers_next_expiry = te->when;\n            \n            if (listener_is_wakeable) {\n                apr_pollset_wakeup(event_pollset);\n            }\n        }\n    }\n    apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n\n    return te;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6b4e699d186ddf50c19341aa09eed6f4844c81e6_0", {
    "ID": "httpd_6b4e699d186ddf50c19341aa09eed6f4844c81e6_0",
    "UID": "3354",
    "code": "static const dav_provider *dav_get_provider(request_rec test_snippet\n{\n    dav_dir_conf *conf;\n\n    conf = ap_get_module_config(r->per_dir_config, &dav_module);\n    /* assert: conf->provider_name != NULL\n       (otherwise, DAV is disabled, and we wouldn't be here) */\n\n    /* assert: conf->provider != NULL\n       (checked when conf->provider_name is set) */\n    return conf->provider;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_c25a452d60a8244b26c27aa97cf20a2cd160e8f4_0", {
    "ID": "httpd_c25a452d60a8244b26c27aa97cf20a2cd160e8f4_0",
    "UID": "3356",
    "code": "static void * APR_THREAD_FUNC listener_thread(apr_thread_t * thd, void test_snippet\n{\n    apr_status_t rc;\n    proc_info *ti = dummy;\n    int process_slot = ti->pslot;\n    struct process_score *ps = ap_get_scoreboard_process(process_slot);\n    int closed = 0;\n    int have_idle_worker = 0;\n    apr_time_t last_log;\n\n    last_log = apr_time_now();\n    free(ti);\n\n#if HAVE_SERF\n    init_serf(apr_thread_pool_get(thd));\n#endif\n\n    /* Unblock the signal used to wake this thread up, and set a handler for\n     * it.\n     */\n    unblock_signal(LISTENER_SIGNAL);\n    apr_signal(LISTENER_SIGNAL, dummy_signal_handler);\n\n    for (;;) {\n        timer_event_t *te;\n        const apr_pollfd_t *out_pfd;\n        apr_int32_t num = 0;\n        apr_interval_time_t timeout_interval;\n        apr_time_t now, timeout_time;\n        int workers_were_busy = 0;\n\n        if (conns_this_child <= 0)\n            check_infinite_requests();\n\n        if (listener_may_exit) {\n            close_listeners(&closed);\n            if (terminate_mode == ST_UNGRACEFUL\n                || apr_atomic_read32(&connection_count) == 0)\n                break;\n        }\n\n        if (APLOGtrace6(ap_server_conf)) {\n            now = apr_time_now();\n            \n            if (now - last_log > apr_time_from_sec(1)) {\n                last_log = now;\n                apr_thread_mutex_lock(timeout_mutex);\n                ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, ap_server_conf,\n                             \"connections: %u (clogged: %u write-completion: %d \"\n                             \"keep-alive: %d lingering: %d suspended: %u)\",\n                             apr_atomic_read32(&connection_count),\n                             apr_atomic_read32(&clogged_count),\n                             *(volatile apr_uint32_t*)write_completion_q->total,\n                             *(volatile apr_uint32_t*)keepalive_q->total,\n                             apr_atomic_read32(&lingering_count),\n                             apr_atomic_read32(&suspended_count));\n                if (dying) {\n                    ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, ap_server_conf,\n                                 \"%u/%u workers shutdown\",\n                                 apr_atomic_read32(&threads_shutdown),\n                                 threads_per_child);\n                }\n                apr_thread_mutex_unlock(timeout_mutex);\n            }\n        }\n\n#if HAVE_SERF\n        rc = serf_context_prerun(g_serf);\n        if (rc != APR_SUCCESS) {\n            \n        }\n#endif\n\n        now = apr_time_now();\n\n        /* Start with an infinite poll() timeout and update it according to\n         * the next expiring timer or queue entry. If there are none, either\n         * the listener is wakeable and it can poll() indefinitely until a wake\n         * up occurs, otherwise periodic checks (maintenance, shutdown, ...)\n         * must be performed.\n         */\n        timeout_interval = -1;\n\n        /* Push expired timers to a worker, the first remaining one determines\n         * the maximum time to poll() below, if any.\n         */\n        timeout_time = timers_next_expiry;\n        if (timeout_time && timeout_time < now + EVENT_FUDGE_FACTOR) {\n            apr_thread_mutex_lock(g_timer_skiplist_mtx);\n            while ((te = apr_skiplist_peek(timer_skiplist))) {\n                if (te->when > now + EVENT_FUDGE_FACTOR) {\n                    timers_next_expiry = te->when;\n                    timeout_interval = te->when - now;\n                    break;\n                }\n                apr_skiplist_pop(timer_skiplist, NULL);\n                if (!te->canceled) { \n                    if (te->remove) {\n                        int i;\n                        for (i = 0; i < te->remove->nelts; i++) {\n                            apr_pollfd_t *pfd;\n                            pfd = (apr_pollfd_t *)te->remove->elts + i;\n                            apr_pollset_remove(event_pollset, pfd);\n                        }\n                    }\n                    push_timer2worker(te);\n                }\n                else {\n                    APR_RING_INSERT_TAIL(&timer_free_ring, te,\n                                         timer_event_t, link);\n                }\n            }\n            if (!te) {\n                timers_next_expiry = 0;\n            }\n            apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n        }\n\n        \n        timeout_time = queues_next_expiry;\n        if (timeout_time\n                && (timeout_interval < 0\n                    || timeout_time <= now\n                    || timeout_interval > timeout_time - now)) {\n            timeout_interval = timeout_time > now ? timeout_time - now : 1;\n        }\n\n        \n#define NON_WAKEABLE_POLL_TIMEOUT apr_time_from_msec(100)\n        if (!listener_is_wakeable\n                && (timeout_interval < 0\n                    || timeout_interval > NON_WAKEABLE_POLL_TIMEOUT)) {\n            timeout_interval = NON_WAKEABLE_POLL_TIMEOUT;\n        }\n\n        rc = apr_pollset_poll(event_pollset, timeout_interval, &num, &out_pfd);\n        if (rc != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rc)) {\n                /* Woken up, if we are exiting or listeners are disabled we\n                 * must fall through to kill kept-alive connections or test\n                 * whether listeners should be re-enabled. Otherwise we only\n                 * need to update timeouts (logic is above, so simply restart\n                 * the loop).\n                 */\n                if (!listener_may_exit && !listeners_disabled()) {\n                    continue;\n                }\n                timeout_time = 0;\n            }\n            else if (!APR_STATUS_IS_TIMEUP(rc)) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT, rc, ap_server_conf,\n                             APLOGNO(03267)\n                             \"apr_pollset_poll failed.  Attempting to \"\n                             \"shutdown process gracefully\");\n                signal_threads(ST_GRACEFUL);\n            }\n            num = 0;\n        }\n\n        if (listener_may_exit) {\n            close_listeners(&closed);\n            if (terminate_mode == ST_UNGRACEFUL\n                || apr_atomic_read32(&connection_count) == 0)\n                break;\n        }\n\n        for (; num; --num, ++out_pfd) {\n            listener_poll_type *pt = (listener_poll_type *) out_pfd->client_data;\n            if (pt->type == PT_CSD) {\n                \n                event_conn_state_t *cs = (event_conn_state_t *) pt->baton;\n                struct timeout_queue *remove_from_q = NULL;\n                /* don't wait for a worker for a keepalive request or\n                 * lingering close processing. */\n                int blocking = 0;\n\n                switch (cs->pub.state) {\n                case CONN_STATE_WRITE_COMPLETION:\n                    remove_from_q = cs->sc->wc_q;\n                    blocking = 1;\n                    break;\n\n                case CONN_STATE_CHECK_REQUEST_LINE_READABLE:\n                    cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n                    remove_from_q = cs->sc->ka_q;\n                    break;\n\n                case CONN_STATE_LINGER_NORMAL:\n                    remove_from_q = linger_q;\n                    break;\n\n                case CONN_STATE_LINGER_SHORT:\n                    remove_from_q = short_linger_q;\n                    break;\n\n                default:\n                    ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                 ap_server_conf, APLOGNO(03096)\n                                 \"event_loop: unexpected state %d\",\n                                 cs->pub.state);\n                    ap_assert(0);\n                }\n\n                if (remove_from_q) {\n                    apr_thread_mutex_lock(timeout_mutex);\n                    TO_QUEUE_REMOVE(remove_from_q, cs);\n                    rc = apr_pollset_remove(event_pollset, &cs->pfd);\n                    apr_thread_mutex_unlock(timeout_mutex);\n                    /*\n                     * Some of the pollset backends, like KQueue or Epoll\n                     * automagically remove the FD if the socket is closed,\n                     * therefore, we can accept _SUCCESS or _NOTFOUND,\n                     * and we still want to keep going\n                     */\n                    if (rc != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rc)) {\n                        AP_DEBUG_ASSERT(0);\n                        ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf,\n                                     APLOGNO(03094) \"pollset remove failed\");\n                        start_lingering_close_nonblocking(cs);\n                        break;\n                    }\n\n                    /* If we don't get a worker immediately (nonblocking), we\n                     * close the connection; the client can re-connect to a\n                     * different process for keepalive, and for lingering close\n                     * the connection will be reset so the choice is to favor\n                     * incoming/alive connections.\n                     */\n                    get_worker(&have_idle_worker, blocking,\n                               &workers_were_busy);\n                    if (!have_idle_worker) {\n                        if (remove_from_q == cs->sc->ka_q) {\n                            start_lingering_close_nonblocking(cs);\n                        }\n                        else {\n                            stop_lingering_close(cs);\n                        }\n                    }\n                    else if (push2worker(cs, NULL, NULL) == APR_SUCCESS) {\n                        have_idle_worker = 0;\n                    }\n                }\n            }\n            else if (pt->type == PT_ACCEPT && !listeners_disabled()) {\n                \n                if (workers_were_busy) {\n                    disable_listensocks();\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                                 APLOGNO(03268)\n                                 \"All workers busy, not accepting new conns \"\n                                 \"in this process\");\n                }\n                else if (connections_above_limit()) {\n                    disable_listensocks();\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                                 APLOGNO(03269)\n                                 \"Too many open connections (%u), \"\n                                 \"not accepting new conns in this process\",\n                                 apr_atomic_read32(&connection_count));\n                    ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, ap_server_conf,\n                                 \"Idle workers: %u\",\n                                 ap_queue_info_num_idlers(worker_queue_info));\n                    workers_were_busy = 1;\n                }\n                else if (!listener_may_exit) {\n                    void *csd = NULL;\n                    ap_listen_rec *lr = (ap_listen_rec *) pt->baton;\n                    apr_pool_t *ptrans;         \n                    ap_queue_info_pop_pool(worker_queue_info, &ptrans);\n\n                    if (ptrans == NULL) {\n                        \n                        apr_allocator_t *allocator = NULL;\n\n                        rc = apr_allocator_create(&allocator);\n                        if (rc == APR_SUCCESS) {\n                            apr_allocator_max_free_set(allocator,\n                                                       ap_max_mem_free);\n                            rc = apr_pool_create_ex(&ptrans, pconf, NULL,\n                                                    allocator);\n                            if (rc == APR_SUCCESS) {\n                                apr_pool_tag(ptrans, \"transaction\");\n                                apr_allocator_owner_set(allocator, ptrans);\n                            }\n                        }\n                        if (rc != APR_SUCCESS) {\n                            ap_log_error(APLOG_MARK, APLOG_CRIT, rc,\n                                         ap_server_conf, APLOGNO(03097)\n                                         \"Failed to create transaction pool\");\n                            if (allocator) {\n                                apr_allocator_destroy(allocator);\n                            }\n                            resource_shortage = 1;\n                            signal_threads(ST_GRACEFUL);\n                            continue;\n                        }\n                    }\n\n                    get_worker(&have_idle_worker, 1, &workers_were_busy);\n                    rc = lr->accept_func(&csd, lr, ptrans);\n\n                    /* later we trash rv and rely on csd to indicate\n                     * success/failure\n                     */\n                    AP_DEBUG_ASSERT(rc == APR_SUCCESS || !csd);\n\n                    if (rc == APR_EGENERAL) {\n                        \n                        resource_shortage = 1;\n                        signal_threads(ST_GRACEFUL);\n                    }\n                    else if (ap_accept_error_is_nonfatal(rc)) { \n                        ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, ap_server_conf, \n                                     \"accept() on client socket failed\");\n                    }\n\n                    if (csd != NULL) {\n                        conns_this_child--;\n                        if (push2worker(NULL, csd, ptrans) == APR_SUCCESS) {\n                            have_idle_worker = 0;\n                        }\n                    }\n                    else {\n                        ap_queue_info_push_pool(worker_queue_info, ptrans);\n                    }\n                }\n            }               \n#if HAVE_SERF\n            else if (pt->type == PT_SERF) {\n                \n                \n                serf_event_trigger(g_serf, pt->baton, out_pfd);\n            }\n\n#endif\n            else if (pt->type == PT_USER) {\n                \n                int i = 0;\n                socket_callback_baton_t *baton = (socket_callback_baton_t *) pt->baton;\n                if (baton->cancel_event) {\n                    baton->cancel_event->canceled = 1;\n                }\n\n                \n                if (!(baton->signaled)) { \n                    baton->signaled = 1;\n                    te = event_get_timer_event(-1 , \n                                               baton->cbfunc, \n                                               baton->user_baton, \n                                               0, \n                                               NULL );\n                    \n                    for (i = 0; i < baton->pfds->nelts; i++) {\n                        apr_pollfd_t *pfd = (apr_pollfd_t *)baton->pfds->elts + i;\n                        apr_pollset_remove(event_pollset, pfd);\n                        pfd->client_data = NULL;\n                    }\n\n                    push_timer2worker(te);\n                }\n            }\n        } \n\n        /* XXX possible optimization: stash the current time for use as\n         * r->request_time for new requests\n         */\n        /* We process the timeout queues here only when their overall next\n         * expiry (read once above) is over. This happens accurately since\n         * adding to the queues (in workers) can only decrease this expiry,\n         * while latest ones are only taken into account here (in listener)\n         * during queues' processing, with the lock held. This works both\n         * with and without wake-ability.\n         */\n        if (timeout_time && timeout_time < (now = apr_time_now())) {\n            timeout_time = now + TIMEOUT_FUDGE_FACTOR;\n\n            \n            apr_thread_mutex_lock(timeout_mutex);\n\n            \n            queues_next_expiry = 0;\n\n            \n            if (workers_were_busy || dying) {\n                process_keepalive_queue(0); \n            }\n            else {\n                process_keepalive_queue(timeout_time);\n            }\n            \n            process_timeout_queue(write_completion_q, timeout_time,\n                                  start_lingering_close_nonblocking);\n            \n            process_timeout_queue(linger_q, timeout_time,\n                                  stop_lingering_close);\n            \n            process_timeout_queue(short_linger_q, timeout_time,\n                                  stop_lingering_close);\n\n            apr_thread_mutex_unlock(timeout_mutex);\n\n            ps->keep_alive = *(volatile apr_uint32_t*)keepalive_q->total;\n            ps->write_completion = *(volatile apr_uint32_t*)write_completion_q->total;\n            ps->connections = apr_atomic_read32(&connection_count);\n            ps->suspended = apr_atomic_read32(&suspended_count);\n            ps->lingering_close = apr_atomic_read32(&lingering_count);\n        }\n        else if ((workers_were_busy || dying)\n                 && *(volatile apr_uint32_t*)keepalive_q->total) {\n            apr_thread_mutex_lock(timeout_mutex);\n            process_keepalive_queue(0); \n            apr_thread_mutex_unlock(timeout_mutex);\n            ps->keep_alive = 0;\n        }\n\n        /* If there are some lingering closes to defer (to a worker), schedule\n         * them now. We might wakeup a worker spuriously if another one empties\n         * defer_linger_chain in the meantime, but there also may be no active\n         * or all busy workers for an undefined time.  In any case a deferred\n         * lingering close can't starve if we do that here since the chain is\n         * filled only above in the listener and it's emptied only in the\n         * worker(s); thus a NULL here means it will stay so while the listener\n         * waits (possibly indefinitely) in poll().\n         */\n        if (defer_linger_chain) {\n            get_worker(&have_idle_worker, 0, &workers_were_busy);\n            if (have_idle_worker\n                    && defer_linger_chain \n                    && push2worker(NULL, NULL, NULL) == APR_SUCCESS) {\n                have_idle_worker = 0;\n            }\n        }\n\n        if (listeners_disabled()\n                && !workers_were_busy\n                && !connections_above_limit()) {\n            enable_listensocks();\n        }\n    } \n\n    close_listeners(&closed);\n    ap_queue_term(worker_queue);\n\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_ec992804de0dbff52af874f1d62451389c3b79d0_0", {
    "ID": "httpd_ec992804de0dbff52af874f1d62451389c3b79d0_0",
    "UID": "3358",
    "code": "static void test_snippet\n{\n    apr_status_t rv;\n    ap_listen_rec *lr;\n    apr_pool_t *pskip = NULL;\n    int max_recycled_pools = -1, i;\n    const int good_methods[] = { APR_POLLSET_KQUEUE,\n                                 APR_POLLSET_PORT,\n                                 APR_POLLSET_EPOLL };\n    \n    const apr_uint32_t async_factor = worker_factor / WORKER_FACTOR_SCALE;\n    const apr_uint32_t pollset_size = (apr_uint32_t)num_listensocks +\n                                      (apr_uint32_t)threads_per_child *\n                                      (async_factor > 2 ? async_factor : 2);\n    int pollset_flags;\n\n    /* Event's skiplist operations will happen concurrently with other modules'\n     * runtime so they need their own pool for allocations, and its lifetime\n     * should be at least the one of the connections (ptrans). Thus pskip is\n     * created as a subpool of pconf like/before ptrans (before so that it's\n     * destroyed after). In forked mode pconf is never destroyed so we are good\n     * anyway, but in ONE_PROCESS mode this ensures that the skiplist works\n     * from connection/ptrans cleanups (even after pchild is destroyed).\n     */\n    apr_pool_create(&pskip, pconf);\n    apr_pool_tag(pskip, \"mpm_skiplist\");\n    apr_thread_mutex_create(&g_timer_skiplist_mtx, APR_THREAD_MUTEX_DEFAULT, pskip);\n    APR_RING_INIT(&timer_free_ring, timer_event_t, link);\n    apr_skiplist_init(&timer_skiplist, pskip);\n    apr_skiplist_set_compare(timer_skiplist, timer_comp, timer_comp);\n\n    /* All threads (listener, workers) and synchronization objects (queues,\n     * pollset, mutexes...) created here should have at least the lifetime of\n     * the connections they handle (i.e. ptrans). We can't use this thread's\n     * self pool because all these objects survive it, nor use pchild or pconf\n     * directly because this starter thread races with other modules' runtime,\n     * nor finally pchild (or subpool thereof) because it is killed explicitely\n     * before pconf (thus connections/ptrans can live longer, which matters in\n     * ONE_PROCESS mode). So this leaves us with a subpool of pconf, created\n     * before any ptrans hence destroyed after.\n     */\n    apr_pool_create(&pruntime, pconf);\n    apr_pool_tag(pruntime, \"mpm_runtime\");\n\n    /* We must create the fd queues before we start up the listener\n     * and worker threads. */\n    rv = ap_queue_create(&worker_queue, threads_per_child, pruntime);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(03100)\n                     \"ap_queue_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) {\n        /* If we want to conserve memory, let's not keep an unlimited number of\n         * pools & allocators.\n         * XXX: This should probably be a separate config directive\n         */\n        max_recycled_pools = threads_per_child * 3 / 4 ;\n    }\n    rv = ap_queue_info_create(&worker_queue_info, pruntime,\n                              threads_per_child, max_recycled_pools);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(03101)\n                     \"ap_queue_info_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the timeout mutex and main pollset before the listener\n     * thread starts.\n     */\n    rv = apr_thread_mutex_create(&timeout_mutex, APR_THREAD_MUTEX_DEFAULT,\n                                 pruntime);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03102)\n                     \"creation of the timeout mutex failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    \n    pollset_flags = APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY |\n                    APR_POLLSET_NODEFAULT | APR_POLLSET_WAKEABLE;\n    for (i = 0; i < sizeof(good_methods) / sizeof(good_methods[0]); i++) {\n        rv = apr_pollset_create_ex(&event_pollset, pollset_size, pruntime,\n                                   pollset_flags, good_methods[i]);\n        if (rv == APR_SUCCESS) {\n            listener_is_wakeable = 1;\n            break;\n        }\n    }\n    if (rv != APR_SUCCESS) {\n        pollset_flags &= ~APR_POLLSET_WAKEABLE;\n        for (i = 0; i < sizeof(good_methods) / sizeof(good_methods[0]); i++) {\n            rv = apr_pollset_create_ex(&event_pollset, pollset_size, pruntime,\n                                       pollset_flags, good_methods[i]);\n            if (rv == APR_SUCCESS) {\n                break;\n            }\n        }\n    }\n    if (rv != APR_SUCCESS) {\n        pollset_flags &= ~APR_POLLSET_NODEFAULT;\n        rv = apr_pollset_create(&event_pollset, pollset_size, pruntime,\n                                pollset_flags);\n    }\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03103)\n                     \"apr_pollset_create with Thread Safety failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    \n    listener_pollfd = apr_pcalloc(pruntime, num_listensocks *\n                                            sizeof(apr_pollfd_t));\n    for (i = 0, lr = my_bucket->listeners; lr; lr = lr->next, i++) {\n        apr_pollfd_t *pfd;\n        listener_poll_type *pt;\n\n        AP_DEBUG_ASSERT(i < num_listensocks);\n        pfd = &listener_pollfd[i];\n\n        pfd->reqevents = APR_POLLIN;\n        pfd->desc_type = APR_POLL_SOCKET;\n        pfd->desc.s = lr->sd;\n\n        pt = apr_pcalloc(pruntime, sizeof(*pt));\n        pfd->client_data = pt;\n        pt->type = PT_ACCEPT;\n        pt->baton = lr;\n\n        apr_socket_opt_set(pfd->desc.s, APR_SO_NONBLOCK, 1);\n        apr_pollset_add(event_pollset, pfd);\n\n        lr->accept_func = ap_unixd_accept;\n    }\n\n    worker_sockets = apr_pcalloc(pruntime, threads_per_child *\n                                           sizeof(apr_socket_t *));\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a307406d7f8fa7d17bf90b654d9577587c654d60_0", {
    "ID": "httpd_a307406d7f8fa7d17bf90b654d9577587c654d60_0",
    "UID": "3363",
    "code": "static int core_override_type(request_rec test_snippet\n{\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    /* Check for overrides with ForceType / SetHandler\n     */\n    if (conf->mime_type && strcmp(conf->mime_type, \"none\"))\n        ap_set_content_type(r, (char*) conf->mime_type);\n\n    if (conf->expr_handler) { \n        const char *err;\n        const char *val;\n        val = ap_expr_str_exec(r, conf->expr_handler, &err);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03154)\n                          \"Can't evaluate handler expression: %s\", err);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (val != ap_strstr_c(val, \"proxy:unix\")) { \n            \n            char *tmp = apr_pstrdup(r->pool, val);\n            ap_str_tolower(tmp);\n            val = tmp;\n        }\n\n        if (strcmp(val, \"none\")) { \n            r->handler = val;\n        }\n    }\n    else if (conf->handler && strcmp(conf->handler, \"none\")) { \n        r->handler = conf->handler;\n    }\n\n    /* Deal with the poor soul who is trying to force path_info to be\n     * accepted within the core_handler, where they will let the subreq\n     * address its contents.  This is toggled by the user in the very\n     * beginning of the fixup phase (here!), so modules should override the user's\n     * discretion in their own module fixup phase.  It is tristate, if\n     * the user doesn't specify, the result is AP_REQ_DEFAULT_PATH_INFO.\n     * (which the module may interpret to its own customary behavior.)\n     * It won't be touched if the value is no longer AP_ACCEPT_PATHINFO_UNSET,\n     * so any module changing the value prior to the fixup phase\n     * OVERRIDES the user's choice.\n     */\n    if ((r->used_path_info == AP_REQ_DEFAULT_PATH_INFO)\n        && (conf->accept_path_info != AP_ACCEPT_PATHINFO_UNSET)) {\n        \n        r->used_path_info = conf->accept_path_info;\n    }\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_f8d98c7e35ca268441c106067af24293ba815e14_0", {
    "ID": "httpd_f8d98c7e35ca268441c106067af24293ba815e14_0",
    "UID": "3369",
    "code": "static apr_status_t read_array(request_rec *r, apr_array_header_t test_snippet\n        unsigned char *buffer, apr_size_t buffer_len, apr_size_t *slider)\n{\n    apr_size_t val = *slider;\n\n    while (*slider < buffer_len) {\n        if (buffer[*slider] == '\\r') {\n            if (val == *slider) {\n                (*slider)++;\n                return APR_SUCCESS;\n            }\n            *((const char **) apr_array_push(arr)) = apr_pstrndup(r->pool,\n                    (const char *) buffer + val, *slider - val);\n            (*slider)++;\n            if (buffer[*slider] == '\\n') {\n                (*slider)++;\n            }\n            val = *slider;\n        }\n        else if (buffer[*slider] == '\\0') {\n            (*slider)++;\n            return APR_SUCCESS;\n        }\n        else {\n            (*slider)++;\n        }\n    }\n\n    return APR_EOF;\n}",
    "predicted": "126,Buffer Over-read\n122,Heap-based Buffer Overflow"
  },
  "httpd_d10312dd0034aa9bc4b54a947e8f03bfc0d5eca3_0", {
    "ID": "httpd_d10312dd0034aa9bc4b54a947e8f03bfc0d5eca3_0",
    "UID": "3371",
    "code": "static apr_status_t store_array(apr_array_header_t *arr, unsigned char test_snippet\n        apr_size_t buffer_len, apr_size_t *slider)\n{\n    int i, len;\n    const char **elts;\n\n    elts = (const char **) arr->elts;\n\n    for (i = 0; i < arr->nelts; i++) {\n        len = strlen(elts[i]);\n        if (len + 3 >= buffer_len - *slider) {\n            return APR_EOF;\n        }\n        len = apr_snprintf(buffer ? (char *) buffer + *slider : NULL,\n                buffer ? buffer_len - *slider : 0, \"%s\" CRLF, elts[i]);\n        *slider += len;\n    }\n    if (buffer) {\n        memcpy(buffer + *slider, CRLF, sizeof(CRLF) - 1);\n    }\n    *slider += sizeof(CRLF) - 1;\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_10027976fd9c6a01f40251e5c28f1a4befbdf170_0", {
    "ID": "httpd_10027976fd9c6a01f40251e5c28f1a4befbdf170_0",
    "UID": "3378",
    "code": "static apr_status_t read_table(cache_handle_t *handle, request_rec test_snippet\n        apr_table_t *table, unsigned char *buffer, apr_size_t buffer_len,\n        apr_size_t *slider)\n{\n    apr_size_t key = *slider, colon = 0, len = 0;\n    ;\n\n    while (*slider < buffer_len) {\n        if (buffer[*slider] == ':') {\n            if (!colon) {\n                colon = *slider;\n            }\n            (*slider)++;\n        }\n        else if (buffer[*slider] == '\\r') {\n            len = colon;\n            if (key == *slider) {\n                (*slider)++;\n                if (buffer[*slider] == '\\n') {\n                    (*slider)++;\n                }\n                return APR_SUCCESS;\n            }\n            if (!colon || buffer[colon++] != ':') {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02344)\n                        \"Premature end of cache headers.\");\n                return APR_EGENERAL;\n            }\n            while (apr_isspace(buffer[colon])) {\n                colon++;\n            }\n            apr_table_addn(table, apr_pstrndup(r->pool, (const char *) buffer\n                    + key, len - key), apr_pstrndup(r->pool,\n                    (const char *) buffer + colon, *slider - colon));\n            (*slider)++;\n            if (buffer[*slider] == '\\n') {\n                (*slider)++;\n            }\n            key = *slider;\n            colon = 0;\n        }\n        else if (buffer[*slider] == '\\0') {\n            (*slider)++;\n            return APR_SUCCESS;\n        }\n        else {\n            (*slider)++;\n        }\n    }\n\n    return APR_EOF;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n190,Integer Overflow or Wraparound\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_68d96f309c04be85863c6b17781c9c7b4938b129_0", {
    "ID": "httpd_68d96f309c04be85863c6b17781c9c7b4938b129_0",
    "UID": "3382",
    "code": "static apr_status_t store_table(apr_table_t *table, unsigned char test_snippet\n        apr_size_t buffer_len, apr_size_t *slider)\n{\n    int i, len;\n    apr_table_entry_t *elts;\n\n    elts = (apr_table_entry_t *) apr_table_elts(table)->elts;\n    for (i = 0; i < apr_table_elts(table)->nelts; ++i) {\n        if (elts[i].key != NULL) {\n            apr_size_t key_len = strlen(elts[i].key);\n            apr_size_t val_len = strlen(elts[i].val);\n            if (key_len + val_len + 5 >= buffer_len - *slider) {\n                return APR_EOF;\n            }\n            len = apr_snprintf(buffer ? (char *) buffer + *slider : NULL,\n                    buffer ? buffer_len - *slider : 0, \"%s: %s\" CRLF,\n                    elts[i].key, elts[i].val);\n            *slider += len;\n        }\n    }\n    if (3 >= buffer_len - *slider) {\n        return APR_EOF;\n    }\n    if (buffer) {\n        memcpy(buffer + *slider, CRLF, sizeof(CRLF) - 1);\n    }\n    *slider += sizeof(CRLF) - 1;\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_8888101a2d4941da138cc6631b59bea6455c5856_0", {
    "ID": "httpd_8888101a2d4941da138cc6631b59bea6455c5856_0",
    "UID": "3389",
    "code": "static void store_slotmem(ap_slotmem_instance_t test_snippet\n{\n    apr_file_t *fp;\n    apr_status_t rv;\n    apr_size_t nbytes;\n    const char *storename;\n\n    storename = slotmem_filename(slotmem->gpool, slotmem->name, 1);\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02334)\n                 \"storing %s\", storename);\n\n    if (storename) {\n        rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                           APR_OS_DEFAULT, slotmem->gpool);\n        if (APR_STATUS_IS_EEXIST(rv)) {\n            apr_file_remove(storename, slotmem->gpool);\n            rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                               APR_OS_DEFAULT, slotmem->gpool);\n        }\n        if (rv != APR_SUCCESS) {\n            return;\n        }\n        if (AP_SLOTMEM_IS_CLEARINUSE(slotmem)) {\n            slotmem_clearinuse(slotmem);\n        }\n        nbytes = (slotmem->desc.size * slotmem->desc.num) +\n                 (slotmem->desc.num * sizeof(char)) + AP_UNSIGNEDINT_OFFSET;\n        \n        apr_file_write_full(fp, slotmem->persist, nbytes, NULL);\n        apr_file_close(fp);\n    }\n}",
    "predicted": "775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_998d2a9bfa5c0b39f7d379a7f2ca647f7cc02ee5_0", {
    "ID": "httpd_998d2a9bfa5c0b39f7d379a7f2ca647f7cc02ee5_0",
    "UID": "3394",
    "code": "static const char *slotmem_filename(apr_pool_t *pool, const char test_snippet\n                                    int persist)\n{\n    const char *fname;\n    if (!slotmemname || strcasecmp(slotmemname, \"none\") == 0) {\n        return NULL;\n    }\n    else if (slotmemname[0] != '/') {\n        const char *filenm = apr_pstrcat(pool, DEFAULT_SLOTMEM_PREFIX,\n                                         slotmemname, DEFAULT_SLOTMEM_SUFFIX,\n                                         NULL);\n        fname = ap_runtime_dir_relative(pool, filenm);\n    }\n    else {\n        fname = slotmemname;\n    }\n\n    if (persist) {\n        return apr_pstrcat(pool, fname, DEFAULT_SLOTMEM_PERSIST_SUFFIX,\n                           NULL);\n    }\n    return fname;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_ee3d0e6c9232e098d9a5dbe6a9aa6e3dee914a7f_0", {
    "ID": "httpd_ee3d0e6c9232e098d9a5dbe6a9aa6e3dee914a7f_0",
    "UID": "3398",
    "code": "static int open_entity(cache_handle_t *h, request_rec *r, const char test_snippet\n{\n    cache_socache_dir_conf *dconf =\n            ap_get_module_config(r->per_dir_config, &cache_socache_module);\n    cache_socache_conf *conf = ap_get_module_config(r->server->module_config,\n            &cache_socache_module);\n    apr_uint32_t format;\n    apr_size_t slider;\n    unsigned int buffer_len;\n    const char *nkey;\n    apr_status_t rc;\n    cache_object_t *obj;\n    cache_info *info;\n    cache_socache_object_t *sobj;\n    apr_size_t len;\n\n    h->cache_obj = NULL;\n\n    if (!conf->provider || !conf->provider->socache_instance) {\n        return DECLINED;\n    }\n\n    \n    obj = apr_pcalloc(r->pool, sizeof(cache_object_t));\n    sobj = apr_pcalloc(r->pool, sizeof(cache_socache_object_t));\n\n    info = &(obj->info);\n\n    /* Create a temporary pool for the buffer, and destroy it if something\n     * goes wrong so we don't have large buffers of unused memory hanging\n     * about for the lifetime of the response.\n     */\n    apr_pool_create(&sobj->pool, r->pool);\n\n    sobj->buffer = apr_palloc(sobj->pool, dconf->max + 1);\n    sobj->buffer_len = dconf->max + 1;\n\n    \n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_lock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02350)\n                    \"could not acquire lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n    }\n    buffer_len = sobj->buffer_len;\n    rc = conf->provider->socache_provider->retrieve(\n            conf->provider->socache_instance, r->server, (unsigned char *) key,\n            strlen(key), sobj->buffer, &buffer_len, r->pool);\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02351)\n                    \"could not release lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n    }\n    if (rc != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02352)\n                \"Key not found in cache: %s\", key);\n        apr_pool_destroy(sobj->pool);\n        sobj->pool = NULL;\n        return DECLINED;\n    }\n    if (buffer_len >= sobj->buffer_len) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02353)\n                \"Key found in cache but too big, ignoring: %s\", key);\n        apr_pool_destroy(sobj->pool);\n        sobj->pool = NULL;\n        return DECLINED;\n    }\n\n    \n    memcpy(&format, sobj->buffer, sizeof(format));\n    slider = sizeof(format);\n\n    if (format == CACHE_SOCACHE_VARY_FORMAT_VERSION) {\n        apr_array_header_t* varray;\n        apr_time_t expire;\n\n        memcpy(&expire, sobj->buffer + slider, sizeof(expire));\n        slider += sizeof(expire);\n\n        varray = apr_array_make(r->pool, 5, sizeof(char*));\n        rc = read_array(r, varray, sobj->buffer, buffer_len, &slider);\n        if (rc != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02354)\n                    \"Cannot parse vary entry for key: %s\", key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n\n        nkey = regen_key(r->pool, r->headers_in, varray, key);\n\n        \n        if (socache_mutex) {\n            apr_status_t status = apr_global_mutex_lock(socache_mutex);\n            if (status != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02355)\n                        \"could not acquire lock, ignoring: %s\", obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return DECLINED;\n            }\n        }\n        buffer_len = sobj->buffer_len;\n        rc = conf->provider->socache_provider->retrieve(\n                conf->provider->socache_instance, r->server,\n                (unsigned char *) nkey, strlen(nkey), sobj->buffer,\n                &buffer_len, r->pool);\n        if (socache_mutex) {\n            apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n            if (status != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02356)\n                        \"could not release lock, ignoring: %s\", obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return DECLINED;\n            }\n        }\n        if (rc != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02357)\n                    \"Key not found in cache: %s\", key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n        if (buffer_len >= sobj->buffer_len) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02358)\n                    \"Key found in cache but too big, ignoring: %s\", key);\n            goto fail;\n        }\n\n    }\n    else if (format != CACHE_SOCACHE_DISK_FORMAT_VERSION) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02359)\n                \"Key '%s' found in cache has version %d, expected %d, ignoring\",\n                key, format, CACHE_SOCACHE_DISK_FORMAT_VERSION);\n        goto fail;\n    }\n    else {\n        nkey = key;\n    }\n\n    obj->key = nkey;\n    sobj->key = nkey;\n    sobj->name = key;\n\n    if (buffer_len >= sizeof(cache_socache_info_t)) {\n        memcpy(&sobj->socache_info, sobj->buffer, sizeof(cache_socache_info_t));\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02360)\n                \"Cache entry for key '%s' too short, removing\", nkey);\n        goto fail;\n    }\n    slider = sizeof(cache_socache_info_t);\n\n    \n    info->status = sobj->socache_info.status;\n    info->date = sobj->socache_info.date;\n    info->expire = sobj->socache_info.expire;\n    info->request_time = sobj->socache_info.request_time;\n    info->response_time = sobj->socache_info.response_time;\n\n    memcpy(&info->control, &sobj->socache_info.control, sizeof(cache_control_t));\n\n    if (sobj->socache_info.name_len <= buffer_len - slider) {\n        if (strncmp((const char *) sobj->buffer + slider, sobj->name,\n                sobj->socache_info.name_len)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02361)\n                    \"Cache entry for key '%s' URL mismatch, ignoring\", nkey);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n        slider += sobj->socache_info.name_len;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02362)\n                \"Cache entry for key '%s' too short, removing\", nkey);\n        goto fail;\n    }\n\n    \n    if (sobj->socache_info.header_only && !r->header_only) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02363)\n                \"HEAD request cached, non-HEAD requested, ignoring: %s\",\n                sobj->key);\n        apr_pool_destroy(sobj->pool);\n        sobj->pool = NULL;\n        return DECLINED;\n    }\n\n    h->req_hdrs = apr_table_make(r->pool, 20);\n    h->resp_hdrs = apr_table_make(r->pool, 20);\n\n    \n    if (APR_SUCCESS != read_table(h, r, h->resp_hdrs, sobj->buffer, buffer_len,\n            &slider)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02364)\n                \"Cache entry for key '%s' response headers unreadable, removing\", nkey);\n        goto fail;\n    }\n    if (APR_SUCCESS != read_table(h, r, h->req_hdrs, sobj->buffer, buffer_len,\n            &slider)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02365)\n                \"Cache entry for key '%s' request headers unreadable, removing\", nkey);\n        goto fail;\n    }\n\n    \n    sobj->body = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    len = buffer_len - slider;\n\n    /*\n     *  Optimisation: if the body is small, we want to make a\n     *  copy of the body and free the temporary pool, as we\n     *  don't want large blocks of unused memory hanging around\n     *  to the end of the response. In contrast, if the body is\n     *  large, we would rather leave the body where it is in the\n     *  temporary pool, and save ourselves the copy.\n     */\n    if (len * 2 > dconf->max) {\n        apr_bucket *e;\n\n        \n        e = apr_bucket_immortal_create((const char *) sobj->buffer + slider,\n                len, r->connection->bucket_alloc);\n\n        APR_BRIGADE_INSERT_TAIL(sobj->body, e);\n    }\n    else {\n\n        \n        apr_brigade_write(sobj->body, NULL, NULL, (const char *) sobj->buffer\n                + slider, len);\n\n        \n        apr_pool_destroy(sobj->pool);\n        sobj->pool = NULL;\n    }\n\n    \n    h->cache_obj = obj;\n    obj->vobj = sobj;\n\n    return OK;\n\nfail:\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_lock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02366)\n                    \"could not acquire lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n    }\n    conf->provider->socache_provider->remove(\n            conf->provider->socache_instance, r->server,\n            (unsigned char *) nkey, strlen(nkey), r->pool);\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02367)\n                    \"could not release lock, ignoring: %s\", obj->key);\n        }\n    }\n    apr_pool_destroy(sobj->pool);\n    sobj->pool = NULL;\n    return DECLINED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_856fda4dd2ebaf60d5e207d28f4fc5cb44ea955c_0", {
    "ID": "httpd_856fda4dd2ebaf60d5e207d28f4fc5cb44ea955c_0",
    "UID": "3401",
    "code": "static const char* regen_key(apr_pool_t *p, apr_table_t test_snippet\n        apr_array_header_t *varray, const char *oldkey)\n{\n    struct iovec *iov;\n    int i, k;\n    int nvec;\n    const char *header;\n    const char **elts;\n\n    nvec = (varray->nelts * 2) + 1;\n    iov = apr_palloc(p, sizeof(struct iovec) * nvec);\n    elts = (const char **) varray->elts;\n\n    /* TODO:\n     *    - Handle multiple-value headers better. (sort them?)\n     *    - Handle Case in-sensitive Values better.\n     *        This isn't the end of the world, since it just lowers the cache\n     *        hit rate, but it would be nice to fix.\n     *\n     * The majority are case insenstive if they are values (encoding etc).\n     * Most of rfc2616 is case insensitive on header contents.\n     *\n     * So the better solution may be to identify headers which should be\n     * treated case-sensitive?\n     *  HTTP URI's (3.2.3) [host and scheme are insensitive]\n     *  HTTP method (5.1.1)\n     *  HTTP-date values (3.3.1)\n     *  3.7 Media Types [exerpt]\n     *     The type, subtype, and parameter attribute names are case-\n     *     insensitive. Parameter values might or might not be case-sensitive,\n     *     depending on the semantics of the parameter name.\n     *  4.20 Except [exerpt]\n     *     Comparison of expectation values is case-insensitive for unquoted\n     *     tokens (including the 100-continue token), and is case-sensitive for\n     *     quoted-string expectation-extensions.\n     */\n\n    for (i = 0, k = 0; i < varray->nelts; i++) {\n        header = apr_table_get(headers, elts[i]);\n        if (!header) {\n            header = \"\";\n        }\n        iov[k].iov_base = (char*) elts[i];\n        iov[k].iov_len = strlen(elts[i]);\n        k++;\n        iov[k].iov_base = (char*) header;\n        iov[k].iov_len = strlen(header);\n        k++;\n    }\n    iov[k].iov_base = (char*) oldkey;\n    iov[k].iov_len = strlen(oldkey);\n    k++;\n\n    return apr_pstrcatv(p, iov, k, NULL);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d820ac1b1b867a983dfd9facad4cb3d4cc3f98e3_0", {
    "ID": "httpd_d820ac1b1b867a983dfd9facad4cb3d4cc3f98e3_0",
    "UID": "3425",
    "code": "apr_status_t ajp_msg_append_uint16(ajp_msg_t *msg, apr_uint16_t test_snippet\n{\n    apr_size_t len = msg->len;\n\n    if ((len + 2) > msg->max_size) {\n        return ajp_log_overflow(msg, \"ajp_msg_append_uint16\");\n    }\n\n    msg->buf[len]     = (apr_byte_t)((value >> 8) & 0xFF);\n    msg->buf[len + 1] = (apr_byte_t)(value & 0xFF);\n\n    msg->len += 2;\n\n    return APR_SUCCESS;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_bd2dc1bd28ec2fb548c3207e77b5300f38e58101_0", {
    "ID": "httpd_bd2dc1bd28ec2fb548c3207e77b5300f38e58101_0",
    "UID": "3430",
    "code": "PROXY_DECLARE(unsigned test_snippet\nap_proxy_hashfunc(const char *str, proxy_hash_t method)\n{\n    if (method == PROXY_HASHFUNC_APR) {\n        apr_ssize_t slen = strlen(str);\n        return apr_hashfunc_default(str, &slen);\n    }\n    else if (method == PROXY_HASHFUNC_FNV) {\n        \n        unsigned int hash;\n        const unsigned int fnv_prime = 0x811C9DC5;\n        for (hash = 0; *str; str++) {\n            hash *= fnv_prime;\n            hash ^= (*str);\n        }\n        return hash;\n    }\n    else { \n        \n        unsigned int hash;\n        for (hash = 0; *str; str++) {\n            hash = (*str) + (hash << 6) + (hash << 16) - hash;\n        }\n        return hash;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b9d6932be590d13d0de422f893fd5b5ca851baa8_0", {
    "ID": "httpd_b9d6932be590d13d0de422f893fd5b5ca851baa8_0",
    "UID": "3431",
    "code": "static int balancer_post_config(apr_pool_t *pconf, apr_pool_t test_snippet\n                         apr_pool_t *ptemp, server_rec *s)\n{\n    apr_status_t rv;\n    proxy_server_conf *conf;\n    ap_slotmem_instance_t *new = NULL;\n    apr_time_t tstamp;\n\n    /* balancer_post_config() will be called twice during startup.  So, don't\n     * set up the static data the 1st time through. */\n    if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG) {\n        return OK;\n    }\n\n    if (!ap_proxy_retry_worker_fn) {\n        ap_proxy_retry_worker_fn =\n                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_retry_worker);\n        if (!ap_proxy_retry_worker_fn) {\n            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(02230)\n                         \"mod_proxy must be loaded for mod_proxy_balancer\");\n            return !OK;\n        }\n    }\n\n    /*\n     * Get slotmem setups\n     */\n    storage = ap_lookup_provider(AP_SLOTMEM_PROVIDER_GROUP, \"shm\",\n                                 AP_SLOTMEM_PROVIDER_VERSION);\n    if (!storage) {\n        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01177)\n                     \"Failed to lookup provider 'shm' for '%s': is \"\n                     \"mod_slotmem_shm loaded??\",\n                     AP_SLOTMEM_PROVIDER_GROUP);\n        return !OK;\n    }\n\n    tstamp = apr_time_now();\n    /*\n     * Go thru each Vhost and create the shared mem slotmem for\n     * each balancer's workers\n     */\n    while (s) {\n        int i,j;\n        char *id;\n        proxy_balancer *balancer;\n        ap_slotmem_type_t type;\n        void *sconf = s->module_config;\n        conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);\n        /*\n         * During create_proxy_config() we created a dummy id. Now that\n         * we have identifying info, we can create the real id\n         */\n        id = apr_psprintf(pconf, \"%s.%s.%d.%s.%s.%u.%s\",\n                          (s->server_scheme ? s->server_scheme : \"????\"),\n                          (s->server_hostname ? s->server_hostname : \"???\"),\n                          (int)s->port,\n                          (s->server_admin ? s->server_admin : \"??\"),\n                          (s->defn_name ? s->defn_name : \"?\"),\n                          s->defn_line_number,\n                          (s->error_fname ? s->error_fname : DEFAULT_ERRORLOG));\n        conf->id = apr_psprintf(pconf, \"p%x\",\n                                ap_proxy_hashfunc(id, PROXY_HASHFUNC_DEFAULT));\n        if (conf->bslot) {\n            /* Shared memory already created for this proxy_server_conf.\n             */\n            s = s->next;\n            continue;\n        }\n        if (conf->bal_persist) {\n            type = AP_SLOTMEM_TYPE_PREGRAB | AP_SLOTMEM_TYPE_PERSIST;\n        } else {\n            type = AP_SLOTMEM_TYPE_PREGRAB;\n        }\n        if (conf->balancers->nelts) {\n            conf->max_balancers = conf->balancers->nelts + conf->bgrowth;\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01178) \"Doing balancers create: %d, %d (%d)\",\n                         (int)ALIGNED_PROXY_BALANCER_SHARED_SIZE,\n                         (int)conf->balancers->nelts, conf->max_balancers);\n\n            rv = storage->create(&new, conf->id,\n                                 ALIGNED_PROXY_BALANCER_SHARED_SIZE,\n                                 conf->max_balancers, type, pconf);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01179) \"balancer slotmem_create failed\");\n                return !OK;\n            }\n            conf->bslot = new;\n        }\n        conf->storage = storage;\n\n        \n        balancer = (proxy_balancer *)conf->balancers->elts;\n        for (i = 0; i < conf->balancers->nelts; i++, balancer++) {\n            proxy_worker **workers;\n            proxy_worker *worker;\n            proxy_balancer_shared *bshm;\n            const char *sname;\n\n            \n            ap_pstr2_alnum(pconf, balancer->s->name + sizeof(BALANCER_PREFIX) - 1,\n                           &sname);\n            sname = apr_pstrcat(pconf, conf->id, \"_\", sname, NULL);\n            PROXY_STRNCPY(balancer->s->sname, sname); \n\n            balancer->max_workers = balancer->workers->nelts + balancer->growth;\n\n            \n            rv = ap_global_mutex_create(&(balancer->gmutex), NULL, balancer_mutex_type,\n                                        balancer->s->sname, s, pconf, 0);\n            if (rv != APR_SUCCESS || !balancer->gmutex) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01180)\n                             \"mutex creation of %s : %s failed\", balancer_mutex_type,\n                             balancer->s->sname);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            apr_pool_cleanup_register(pconf, (void *)s, lock_remove,\n                                      apr_pool_cleanup_null);\n\n            \n            if ((rv = storage->fgrab(conf->bslot, i)) != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01181) \"balancer slotmem_grab failed\");\n                return !OK;\n\n            }\n            if ((rv = storage->dptr(conf->bslot, i, (void *)&bshm)) != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01182) \"balancer slotmem_dptr failed\");\n                return !OK;\n            }\n            if ((rv = ap_proxy_share_balancer(balancer, bshm, i)) != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01183) \"Cannot share balancer\");\n                return !OK;\n            }\n\n            \n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01184) \"Doing workers create: %s (%s), %d, %d [%u]\",\n                         balancer->s->name, balancer->s->sname,\n                         (int)ALIGNED_PROXY_WORKER_SHARED_SIZE,\n                         (int)balancer->max_workers, i);\n\n            rv = storage->create(&new, balancer->s->sname,\n                                 ALIGNED_PROXY_WORKER_SHARED_SIZE,\n                                 balancer->max_workers, type, pconf);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01185) \"worker slotmem_create failed\");\n                return !OK;\n            }\n            balancer->wslot = new;\n            balancer->storage = storage;\n\n            \n            balancer->wupdated = balancer->s->wupdated = tstamp;\n\n            \n            workers = (proxy_worker **)balancer->workers->elts;\n            for (j = 0; j < balancer->workers->nelts; j++, workers++) {\n                proxy_worker_shared *shm;\n\n                worker = *workers;\n                if ((rv = storage->fgrab(balancer->wslot, j)) != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01186) \"worker slotmem_grab failed\");\n                    return !OK;\n\n                }\n                if ((rv = storage->dptr(balancer->wslot, j, (void *)&shm)) != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01187) \"worker slotmem_dptr failed\");\n                    return !OK;\n                }\n                if ((rv = ap_proxy_share_worker(worker, shm, j)) != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01188) \"Cannot share worker\");\n                    return !OK;\n                }\n                worker->s->updated = tstamp;\n            }\n            if (conf->bal_persist) {\n                \n                balancer->wupdated--;\n                ap_proxy_sync_balancer(balancer, s, conf);\n            }\n        }\n        s = s->next;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d5d4403ad36832f6a2e48157f83e2f39db1af63c_0", {
    "ID": "httpd_d5d4403ad36832f6a2e48157f83e2f39db1af63c_0",
    "UID": "3434",
    "code": "static apr_status_t recall_body(cache_handle_t *h, apr_pool_t test_snippet\n        apr_bucket_brigade *bb)\n{\n    cache_socache_object_t *sobj = (cache_socache_object_t*) h->cache_obj->vobj;\n    apr_bucket *e;\n\n    e = APR_BRIGADE_FIRST(sobj->body);\n\n    if (e != APR_BRIGADE_SENTINEL(sobj->body)) {\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free"
  },
  "httpd_bd3bf52a8528b6a5294755b70f55b60309adb6c4_0", {
    "ID": "httpd_bd3bf52a8528b6a5294755b70f55b60309adb6c4_0",
    "UID": "3435",
    "code": "static apr_status_t store_headers(cache_handle_t *h, request_rec test_snippet\n        cache_info *info)\n{\n    cache_socache_dir_conf *dconf =\n            ap_get_module_config(r->per_dir_config, &cache_socache_module);\n    cache_socache_conf *conf = ap_get_module_config(r->server->module_config,\n            &cache_socache_module);\n    apr_size_t slider;\n    apr_status_t rv;\n    cache_object_t *obj = h->cache_obj;\n    cache_socache_object_t *sobj = (cache_socache_object_t*) obj->vobj;\n    cache_socache_info_t *socache_info;\n\n    memcpy(&h->cache_obj->info, info, sizeof(cache_info));\n\n    if (r->headers_out) {\n        sobj->headers_out = ap_cache_cacheable_headers_out(r);\n    }\n\n    if (r->headers_in) {\n        sobj->headers_in = ap_cache_cacheable_headers_in(r);\n    }\n\n    sobj->expire\n            = obj->info.expire > r->request_time + dconf->maxtime ? r->request_time\n                    + dconf->maxtime\n                    : obj->info.expire + dconf->mintime;\n\n    apr_pool_create(&sobj->pool, r->pool);\n\n    sobj->buffer = apr_palloc(sobj->pool, dconf->max);\n    sobj->buffer_len = dconf->max;\n    socache_info = (cache_socache_info_t *) sobj->buffer;\n\n    if (sobj->headers_out) {\n        const char *vary;\n\n        vary = apr_table_get(sobj->headers_out, \"Vary\");\n\n        if (vary) {\n            apr_array_header_t* varray;\n            apr_uint32_t format = CACHE_SOCACHE_VARY_FORMAT_VERSION;\n\n            memcpy(sobj->buffer, &format, sizeof(format));\n            slider = sizeof(format);\n\n            memcpy(sobj->buffer + slider, &obj->info.expire,\n                    sizeof(obj->info.expire));\n            slider += sizeof(obj->info.expire);\n\n            varray = apr_array_make(r->pool, 6, sizeof(char*));\n            tokens_to_array(r->pool, vary, varray);\n\n            if (APR_SUCCESS != (rv = store_array(varray, sobj->buffer,\n                    sobj->buffer_len, &slider))) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02370)\n                        \"buffer too small for Vary array, caching aborted: %s\",\n                        obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return rv;\n            }\n            if (socache_mutex) {\n                apr_status_t status = apr_global_mutex_lock(socache_mutex);\n                if (status != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02371)\n                            \"could not acquire lock, ignoring: %s\", obj->key);\n                    apr_pool_destroy(sobj->pool);\n                    sobj->pool = NULL;\n                    return status;\n                }\n            }\n            rv = conf->provider->socache_provider->store(\n                    conf->provider->socache_instance, r->server,\n                    (unsigned char *) obj->key, strlen(obj->key), sobj->expire,\n                    (unsigned char *) sobj->buffer, (unsigned int) slider,\n                    sobj->pool);\n            if (socache_mutex) {\n                apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n                if (status != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02372)\n                            \"could not release lock, ignoring: %s\", obj->key);\n                }\n            }\n            if (rv != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(02373)\n                        \"Vary not written to cache, ignoring: %s\", obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return rv;\n            }\n\n            obj->key = sobj->key = regen_key(r->pool, sobj->headers_in, varray,\n                    sobj->name);\n        }\n    }\n\n    socache_info->format = CACHE_SOCACHE_DISK_FORMAT_VERSION;\n    socache_info->date = obj->info.date;\n    socache_info->expire = obj->info.expire;\n    socache_info->entity_version = sobj->socache_info.entity_version++;\n    socache_info->request_time = obj->info.request_time;\n    socache_info->response_time = obj->info.response_time;\n    socache_info->status = obj->info.status;\n    socache_info->header_only = r->header_only;\n\n    socache_info->name_len = strlen(sobj->name);\n\n    memcpy(&socache_info->control, &obj->info.control, sizeof(cache_control_t));\n    slider = sizeof(cache_socache_info_t);\n\n    if (slider + socache_info->name_len >= sobj->buffer_len) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02374)\n                \"cache buffer too small for name: %s\",\n                sobj->name);\n        apr_pool_destroy(sobj->pool);\n        sobj->pool = NULL;\n        return APR_EGENERAL;\n    }\n    memcpy(sobj->buffer + slider, sobj->name, socache_info->name_len);\n    slider += socache_info->name_len;\n\n    if (sobj->headers_out) {\n        if (APR_SUCCESS != store_table(sobj->headers_out, sobj->buffer,\n                sobj->buffer_len, &slider)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02375)\n                    \"out-headers didn't fit in buffer: %s\", sobj->name);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n    }\n\n    \n    \n    if (sobj->headers_in) {\n        if (APR_SUCCESS != store_table(sobj->headers_in, sobj->buffer,\n                sobj->buffer_len, &slider)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(02376)\n                    \"in-headers didn't fit in buffer %s\",\n                    sobj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n    }\n\n    sobj->body_offset = slider;\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_2a31a0c7df59eb683ffcbce8cab10c53c4826cb5_0", {
    "ID": "httpd_2a31a0c7df59eb683ffcbce8cab10c53c4826cb5_0",
    "UID": "3452",
    "code": "static void push2table(const char *input, apr_table_t test_snippet\n                       const char *allowed[], apr_pool_t *p)\n{\n    char *args;\n    char *tok, *val;\n    char *key;\n\n    if (input == NULL) {\n        return;\n    }\n    args = apr_pstrdup(p, input);\n\n    key = apr_strtok(args, \"&\", &tok);\n    while (key) {\n        val = strchr(key, '=');\n        if (val) {\n            *val++ = '\\0';\n        }\n        else {\n            val = \"\";\n        }\n        ap_unescape_url(key);\n        ap_unescape_url(val);\n        if (allowed == NULL) { \n            apr_table_set(params, key, val);\n        }\n        else {\n            const char **ok = allowed;\n            while (*ok) {\n                if (strcmp(*ok, key) == 0) {\n                    apr_table_set(params, key, val);\n                    break;\n                }\n                ok++;\n            }\n        }\n        key = apr_strtok(NULL, \"&\", &tok);\n    }\n}",
    "predicted": "20,Improper Input Validation\n73,External Control of File Name or Path\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n88,Argument Injection or Modification\n113,Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')\n117,Improper Output Neutralization for Logs\n120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n134,Use of Externally-Controlled Format String\n190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n400,Uncontrolled Resource Consumption\n601,URL Redirection to Untrusted Site ('Open Redirect')\n680,Integer Overflow to Buffer Overflow\n"
  },
  "httpd_43e9ddc4bd56c98d64162f1eb6c9fe12648ba819_0", {
    "ID": "httpd_43e9ddc4bd56c98d64162f1eb6c9fe12648ba819_0",
    "UID": "3454",
    "code": "static apr_status_t commit_entity(cache_handle_t *h, request_rec test_snippet\n{\n    cache_socache_conf *conf = ap_get_module_config(r->server->module_config,\n            &cache_socache_module);\n    cache_object_t *obj = h->cache_obj;\n    cache_socache_object_t *sobj = (cache_socache_object_t *) obj->vobj;\n    apr_status_t rv;\n    apr_size_t len;\n\n    \n    len = sobj->buffer_len - sobj->body_offset;\n    rv = apr_brigade_flatten(sobj->body, (char *) sobj->buffer\n            + sobj->body_offset, &len);\n    if (APR_SUCCESS != rv) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02382)\n                \"could not flatten brigade, not caching: %s\",\n                sobj->key);\n        goto fail;\n    }\n    apr_brigade_cleanup(sobj->body);\n    if (len >= sobj->buffer_len - sobj->body_offset) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02383)\n                \"body too big for the cache buffer, not caching: %s\",\n                h->cache_obj->key);\n        goto fail;\n    }\n\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_lock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02384)\n                    \"could not acquire lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return rv;\n        }\n    }\n    rv = conf->provider->socache_provider->store(\n            conf->provider->socache_instance, r->server,\n            (unsigned char *) sobj->key, strlen(sobj->key), sobj->expire,\n            sobj->buffer, (unsigned int) sobj->body_offset + len, sobj->pool);\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02385)\n                    \"could not release lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return DECLINED;\n        }\n    }\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(02386)\n                \"could not write to cache, ignoring: %s\", sobj->key);\n        goto fail;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02387)\n            \"commit_entity: Headers and body for URL %s cached for maximum of %d seconds.\",\n            sobj->name, (apr_uint32_t)apr_time_sec(sobj->expire - r->request_time));\n\n    apr_pool_destroy(sobj->pool);\n    sobj->pool = NULL;\n\n    return APR_SUCCESS;\n\nfail:\n    /* For safety, remove any existing entry on failure, just in case it could not\n     * be revalidated successfully.\n     */\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_lock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02388)\n                    \"could not acquire lock, ignoring: %s\", obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return rv;\n        }\n    }\n    conf->provider->socache_provider->remove(conf->provider->socache_instance,\n            r->server, (unsigned char *) sobj->key, strlen(sobj->key), r->pool);\n    if (socache_mutex) {\n        apr_status_t status = apr_global_mutex_unlock(socache_mutex);\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02389)\n                    \"could not release lock, ignoring: %s\", obj->key);\n        }\n    }\n\n    apr_pool_destroy(sobj->pool);\n    sobj->pool = NULL;\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_effe39a7852bf6bf10af15cf8cad613d29bca9ea_0", {
    "ID": "httpd_effe39a7852bf6bf10af15cf8cad613d29bca9ea_0",
    "UID": "3460",
    "code": "static const char *set_cache_maxtime(cmd_parms *parms, void test_snippet\n        const char *arg)\n{\n    cache_socache_dir_conf *dconf = (cache_socache_dir_conf *) in_struct_ptr;\n    apr_off_t seconds;\n\n    if (apr_strtoff(&seconds, arg, NULL, 10) != APR_SUCCESS || seconds < 0) {\n        return \"CacheSocacheMaxTime argument must be the maximum amount of time in seconds to cache an entry.\";\n    }\n    dconf->maxtime = apr_time_from_sec(seconds);\n    dconf->maxtime_set = 1;\n    return NULL;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n190,Integer Overflow or Wraparound"
  },
  "httpd_57777a57ffdeba4ee566c9054f37d1010e37e14a_0", {
    "ID": "httpd_57777a57ffdeba4ee566c9054f37d1010e37e14a_0",
    "UID": "3463",
    "code": "static const char *set_cache_readtime(cmd_parms *parms, void test_snippet\n        const char *arg)\n{\n    cache_socache_dir_conf *dconf = (cache_socache_dir_conf *) in_struct_ptr;\n    apr_off_t milliseconds;\n\n    if (apr_strtoff(&milliseconds, arg, NULL, 10) != APR_SUCCESS\n            || milliseconds < 0) {\n        return \"CacheSocacheReadTime argument must be a non-negative integer representing the max amount of time taken to cache in go.\";\n    }\n    dconf->readtime = apr_time_from_msec(milliseconds);\n    dconf->readtime_set = 1;\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_c53ca4d8e0f392ffabca2ef3b210677f66a89f41_0", {
    "ID": "httpd_c53ca4d8e0f392ffabca2ef3b210677f66a89f41_0",
    "UID": "3465",
    "code": "static int socache_post_config(apr_pool_t *pconf, apr_pool_t test_snippet\n        apr_pool_t *ptmp, server_rec *base_server)\n{\n    server_rec *s;\n    apr_status_t rv;\n    const char *errmsg;\n    static struct ap_socache_hints socache_hints =\n    { 64, 32, 60000000 };\n\n    for (s = base_server; s; s = s->next) {\n        cache_socache_conf *conf =\n                ap_get_module_config(s->module_config, &cache_socache_module);\n\n        if (!conf->provider) {\n            continue;\n        }\n\n        if (!socache_mutex && conf->provider->socache_provider->flags\n                & AP_SOCACHE_FLAG_NOTMPSAFE) {\n\n            rv = ap_global_mutex_create(&socache_mutex, NULL, cache_socache_id,\n                    NULL, s, pconf, 0);\n            if (rv != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(02391)\n                \"failed to create %s mutex\", cache_socache_id);\n                return 500; \n            }\n            apr_pool_cleanup_register(pconf, NULL, remove_lock,\n                    apr_pool_cleanup_null);\n        }\n\n        errmsg = conf->provider->socache_provider->create(\n                &conf->provider->socache_instance, conf->provider->args, ptmp,\n                pconf);\n        if (errmsg) {\n            ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog,\n                    APLOGNO(02392) \"%s\", errmsg);\n            return 500; \n        }\n\n        rv = conf->provider->socache_provider->init(\n                conf->provider->socache_instance, cache_socache_id,\n                &socache_hints, s, pconf);\n        if (rv != APR_SUCCESS) {\n            ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(02393)\n            \"failed to initialise %s cache\", cache_socache_id);\n            return 500; \n        }\n        apr_pool_cleanup_register(pconf, (void *) s, destroy_cache,\n                apr_pool_cleanup_null);\n\n    }\n\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_c2cee240e43afd2f063ac96ffc237ed6674d967f_0", {
    "ID": "httpd_c2cee240e43afd2f063ac96ffc237ed6674d967f_0",
    "UID": "3488",
    "code": "static apr_status_t do_pattmatch(ap_filter_t *f, apr_bucket test_snippet\n                                 apr_bucket_brigade *mybb,\n                                 apr_pool_t *pool)\n{\n    int i;\n    int force_quick = 0;\n    ap_regmatch_t regm[AP_MAX_REG_MATCH];\n    apr_size_t bytes;\n    apr_size_t len;\n    const char *buff;\n    struct ap_varbuf vb;\n    apr_bucket *b;\n    apr_bucket *tmp_b;\n\n    subst_dir_conf *cfg =\n    (subst_dir_conf *) ap_get_module_config(f->r->per_dir_config,\n                                             &substitute_module);\n    subst_pattern_t *script;\n\n    APR_BRIGADE_INSERT_TAIL(mybb, inb);\n    ap_varbuf_init(pool, &vb, 0);\n\n    script = (subst_pattern_t *) cfg->patterns->elts;\n    /*\n     * Simple optimization. If we only have one pattern, then\n     * we can safely avoid the overhead of flattening\n     */\n    if (cfg->patterns->nelts == 1) {\n       force_quick = 1;\n    }\n    for (i = 0; i < cfg->patterns->nelts; i++) {\n        for (b = APR_BRIGADE_FIRST(mybb);\n             b != APR_BRIGADE_SENTINEL(mybb);\n             b = APR_BUCKET_NEXT(b)) {\n            if (APR_BUCKET_IS_METADATA(b)) {\n                /*\n                 * we should NEVER see this, because we should never\n                 * be passed any, but \"handle\" it just in case.\n                 */\n                continue;\n            }\n            if (apr_bucket_read(b, &buff, &bytes, APR_BLOCK_READ)\n                    == APR_SUCCESS) {\n                int have_match = 0;\n                vb.strlen = 0;\n                if (script->pattern) {\n                    const char *repl;\n                    /*\n                     * space_left counts how many bytes we have left until the\n                     * line length reaches max_line_length.\n                     */\n                    apr_size_t space_left = cfg->max_line_length;\n                    apr_size_t repl_len = strlen(script->replacement);\n                    while ((repl = apr_strmatch(script->pattern, buff, bytes)))\n                    {\n                        have_match = 1;\n                        \n                        len = (apr_size_t) (repl - buff);\n                        if (script->flatten && !force_quick) {\n                            /*\n                             * We are flattening the buckets here, meaning\n                             * that we don't do the fast bucket splits.\n                             * Instead we copy over what the buckets would\n                             * contain and use them. This is slow, since we\n                             * are constanting allocing space and copying\n                             * strings.\n                             */\n                            if (vb.strlen + len + repl_len > cfg->max_line_length)\n                                return APR_ENOMEM;\n                            ap_varbuf_strmemcat(&vb, buff, len);\n                            ap_varbuf_strmemcat(&vb, script->replacement, repl_len);\n                        }\n                        else {\n                            /*\n                             * The string before the match but after the\n                             * previous match (if any) has length 'len'.\n                             * Check if we still have space for this string and\n                             * the replacement string.\n                             */\n                            if (space_left < len + repl_len)\n                                return APR_ENOMEM;\n                            space_left -= len + repl_len;\n                            /*\n                             * We now split off the string before the match\n                             * as its own bucket, then isolate the matched\n                             * string and delete it.\n                             */\n                            SEDRMPATBCKT(b, len, tmp_b, script->patlen);\n                            /*\n                             * Finally, we create a bucket that contains the\n                             * replacement...\n                             */\n                            tmp_b = apr_bucket_transient_create(script->replacement,\n                                      script->replen,\n                                      f->r->connection->bucket_alloc);\n                            \n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                        }\n                        \n                        len += script->patlen;\n                        bytes -= len;\n                        buff += len;\n                    }\n                    if (have_match) {\n                        if (script->flatten && !force_quick) {\n                            /* XXX: we should check for AP_MAX_BUCKETS here and\n                             * XXX: call ap_pass_brigade accordingly\n                             */\n                            char *copy = ap_varbuf_pdup(pool, &vb, NULL, 0,\n                                                        buff, bytes, &len);\n                            tmp_b = apr_bucket_pool_create(copy, len, pool,\n                                                           f->r->connection->bucket_alloc);\n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                            apr_bucket_delete(b);\n                            b = tmp_b;\n                        }\n                        else {\n                            /*\n                             * We want the behaviour to be predictable.\n                             * Therefore we try to always error out if the\n                             * line length is larger than the limit,\n                             * regardless of the content of the line. So,\n                             * let's check if the remaining non-matching\n                             * string does not exceed the limit.\n                             */\n                            if (space_left < b->length)\n                                return APR_ENOMEM;\n                        }\n                    }\n                }\n                else if (script->regexp) {\n                    int left = bytes;\n                    const char *pos = buff;\n                    char *repl;\n                    apr_size_t space_left = cfg->max_line_length;\n                    while (!ap_regexec_len(script->regexp, pos, left,\n                                       AP_MAX_REG_MATCH, regm, 0)) {\n                        apr_status_t rv;\n                        have_match = 1;\n                        if (script->flatten && !force_quick) {\n                            \n                            /* Note that the last param in ap_varbuf_regsub below\n                             * must stay positive. If it gets 0, it would mean\n                             * unlimited space available. */\n                            if (vb.strlen + regm[0].rm_so >= cfg->max_line_length)\n                                return APR_ENOMEM;\n                            \n                            if (regm[0].rm_so > 0)\n                                ap_varbuf_strmemcat(&vb, pos, regm[0].rm_so);\n                            \n                            rv = ap_varbuf_regsub(&vb, script->replacement, pos,\n                                                  AP_MAX_REG_MATCH, regm,\n                                                  cfg->max_line_length - vb.strlen);\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                        }\n                        else {\n                            apr_size_t repl_len;\n                            \n                            if (space_left <= regm[0].rm_so)\n                                return APR_ENOMEM;\n                            space_left -= regm[0].rm_so;\n                            rv = ap_pregsub_ex(pool, &repl,\n                                               script->replacement, pos,\n                                               AP_MAX_REG_MATCH, regm,\n                                               space_left);\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            repl_len = strlen(repl);\n                            space_left -= repl_len;\n                            len = (apr_size_t) (regm[0].rm_eo - regm[0].rm_so);\n                            SEDRMPATBCKT(b, regm[0].rm_so, tmp_b, len);\n                            tmp_b = apr_bucket_transient_create(repl, repl_len,\n                                                f->r->connection->bucket_alloc);\n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                        }\n                        /*\n                         * reset to past what we just did. pos now maps to b\n                         * again\n                         */\n                        pos += regm[0].rm_eo;\n                        left -= regm[0].rm_eo;\n                    }\n                    if (have_match && script->flatten && !force_quick) {\n                        char *copy;\n                        /* Copy result plus the part after the last match into\n                         * a bucket.\n                         */\n                        copy = ap_varbuf_pdup(pool, &vb, NULL, 0, pos, left,\n                                              &len);\n                        tmp_b = apr_bucket_pool_create(copy, len, pool,\n                                           f->r->connection->bucket_alloc);\n                        APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                        apr_bucket_delete(b);\n                        b = tmp_b;\n                    }\n                }\n                else {\n                    ap_assert(0);\n                    continue;\n                }\n            }\n        }\n        script++;\n    }\n    ap_varbuf_free(&vb);\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n"
  },
  "httpd_57c10c5c763b3e2b13363fc5322eec8e244fae6b_0", {
    "ID": "httpd_57c10c5c763b3e2b13363fc5322eec8e244fae6b_0",
    "UID": "3489",
    "code": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    core_server_config *conf;\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    int again;\n\n    conf = (core_server_config *)\n        ap_get_module_config(f->r->server->module_config, &core_module);\n\n    \n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (strcasecmp(tenc, \"chunked\") == 0 \n                    || ap_find_last_token(f->r->pool, tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n            else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n                /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n                 * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n                 * present in a response and the chunked transfer coding is not\n                 * the final encoding, the message body length is determined by\n                 * reading the connection until it is closed by the server.\"\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                              \"Unknown Transfer-Encoding: %s; \"\n                              \"using read-until-close\", tenc);\n                tenc = NULL;\n            }\n            else {\n                /* Something that isn't a HTTP request, unless some future\n                 * edition defines new transfer encodings, is unsupported.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                              \"Unknown Transfer-Encoding: %s\", tenc);\n                return APR_EGENERAL;\n            }\n            lenp = NULL;\n        }\n        if (lenp) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. */\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                    || endstr == lenp || *endstr || ctx->remaining < 0) {\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                              \"Invalid Content-Length\");\n\n                return APR_EINVAL;\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                return APR_ENOSPC;\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        /* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. */\n        if ((ctx->state == BODY_CHUNK\n                || (ctx->state == BODY_LENGTH && ctx->remaining > 0))\n                && f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)\n                && !(f->r->eos_sent || f->r->bytes_sent)) {\n            if (!ap_is_HTTP_SUCCESS(f->r->status)) {\n                ctx->state = BODY_NONE;\n                ctx->eos_sent = 1;\n            }\n            else {\n                char *tmp;\n                int len;\n                apr_bucket_brigade *bb;\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n                /* if we send an interim response, we're no longer\n                 * in a state of expecting one.\n                 */\n                f->r->expecting_100 = 0;\n                tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL \" \",\n                        ap_get_status_line(HTTP_CONTINUE), CRLF CRLF, NULL);\n                len = strlen(tmp);\n                ap_xlate_proto_to_ascii(tmp, len);\n                e = apr_bucket_pool_create(tmp, len, f->r->pool,\n                        f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_HEAD(bb, e);\n                e = apr_bucket_flush_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n\n                rv = ap_pass_brigade(f->c->output_filters, bb);\n                if (rv != APR_SUCCESS) {\n                    return AP_FILTER_ERROR;\n                }\n            }\n        }\n    }\n\n    \n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    do {\n        apr_brigade_cleanup(b);\n        again = 0; \n\n        \n        switch (ctx->state) {\n        case BODY_CHUNK:\n        case BODY_CHUNK_PART:\n        case BODY_CHUNK_EXT:\n        case BODY_CHUNK_LF:\n        case BODY_CHUNK_END:\n        case BODY_CHUNK_END_LF: {\n\n            rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n\n            \n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv == APR_EOF) {\n                return APR_INCOMPLETE;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            e = APR_BRIGADE_FIRST(b);\n            while (e != APR_BRIGADE_SENTINEL(b)) {\n                const char *buffer;\n                apr_size_t len;\n\n                if (!APR_BUCKET_IS_METADATA(e)) {\n                    rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\n\n                    if (rv == APR_SUCCESS) {\n                        rv = parse_chunk_size(ctx, buffer, len,\n                                f->r->server->limit_req_fieldsize);\n                    }\n                    if (rv != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n                                      \"Error reading/parsing chunk %s \",\n                                      (APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\n                        return rv;\n                    }\n                }\n\n                apr_bucket_delete(e);\n                e = APR_BRIGADE_FIRST(b);\n            }\n            again = 1; \n\n            if (ctx->state == BODY_CHUNK_TRAILER) {\n                \n                return read_chunked_trailers(ctx, f, b,\n                            conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE);\n            }\n\n            break;\n        }\n        case BODY_NONE:\n        case BODY_LENGTH:\n        case BODY_CHUNK_DATA: {\n\n            \n            if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\n                readbytes = ctx->remaining;\n            }\n            if (readbytes > 0) {\n                apr_off_t totalread;\n\n                rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n                \n                if (block == APR_NONBLOCK_READ\n                        && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                                || (APR_STATUS_IS_EAGAIN(rv)))) {\n                    return APR_EAGAIN;\n                }\n\n                if (rv == APR_EOF && ctx->state != BODY_NONE\n                        && ctx->remaining > 0) {\n                    return APR_INCOMPLETE;\n                }\n\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n\n                \n                apr_brigade_length(b, 0, &totalread);\n\n                /* If this happens, we have a bucket of unknown length.  Die because\n                 * it means our assumptions have changed. */\n                AP_DEBUG_ASSERT(totalread >= 0);\n\n                if (ctx->state != BODY_NONE) {\n                    ctx->remaining -= totalread;\n                    if (ctx->remaining > 0) {\n                        e = APR_BRIGADE_LAST(b);\n                        if (APR_BUCKET_IS_EOS(e)) {\n                            apr_bucket_delete(e);\n                            return APR_INCOMPLETE;\n                        }\n                    }\n                    else if (ctx->state == BODY_CHUNK_DATA) {\n                        \n                        ctx->state = BODY_CHUNK_END;\n                        ctx->chunk_used = 0;\n                    }\n                }\n\n                \n                if (ctx->limit) {\n                    /* FIXME: Note that we might get slightly confused on\n                     * chunked inputs as we'd need to compensate for the chunk\n                     * lengths which may not really count.  This seems to be up\n                     * for interpretation.\n                     */\n                    ctx->limit_used += totalread;\n                    if (ctx->limit < ctx->limit_used) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                                      APLOGNO(01591) \"Read content length of \"\n                                      \"%\" APR_OFF_T_FMT \" is larger than the \"\n                                      \"configured limit of %\" APR_OFF_T_FMT,\n                                      ctx->limit_used, ctx->limit);\n                        return APR_ENOSPC;\n                    }\n                }\n            }\n\n            /* If we have no more bytes remaining on a C-L request,\n             * save the caller a round trip to discover EOS.\n             */\n            if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n            }\n\n            break;\n        }\n        case BODY_CHUNK_TRAILER: {\n\n            rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n            \n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            break;\n        }\n        default: {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02901)\n                          \"Unexpected body state (%i)\", (int)ctx->state);\n            return APR_EGENERAL;\n        }\n        }\n\n    } while (again);\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_bd1a29aeccae171125e0d972365b405c6c84164a_0", {
    "ID": "httpd_bd1a29aeccae171125e0d972365b405c6c84164a_0",
    "UID": "3490",
    "code": "static apr_status_t substitute_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    apr_size_t bytes;\n    apr_size_t len;\n    apr_size_t fbytes;\n    const char *buff;\n    const char *nl = NULL;\n    char *bflat;\n    apr_bucket *b;\n    apr_bucket *tmp_b;\n    apr_bucket_brigade *tmp_bb = NULL;\n    apr_status_t rv;\n    subst_dir_conf *cfg =\n    (subst_dir_conf *) ap_get_module_config(f->r->per_dir_config,\n                                             &substitute_module);\n\n    substitute_module_ctx *ctx = f->ctx;\n\n    /*\n     * First time around? Create the saved bb that we used for each pass\n     * through. Note that we can also get here when we explicitly clear ctx,\n     * for error handling\n     */\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        /*\n         * Create all the temporary brigades we need and reuse them to avoid\n         * creating them over and over again from r->pool which would cost a\n         * lot of memory in some cases.\n         */\n        ctx->linebb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        ctx->linesbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        ctx->pattbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        /*\n         * Everything to be passed to the next filter goes in\n         * here, our pass brigade.\n         */\n        ctx->passbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        \n        apr_pool_create(&(ctx->tpool), f->r->pool);\n        apr_table_unset(f->r->headers_out, \"Content-Length\");\n    }\n\n    /*\n     * Shortcircuit processing\n     */\n    if (APR_BRIGADE_EMPTY(bb))\n        return APR_SUCCESS;\n\n    /*\n     * Here's the concept:\n     *  Read in the data and look for newlines. Once we\n     *  find a full \"line\", add it to our working brigade.\n     *  If we've finished reading the brigade and we have\n     *  any left over data (not a \"full\" line), store that\n     *  for the next pass.\n     *\n     * Note: anything stored in ctx->linebb for sure does not have\n     * a newline char, so we don't concat that bb with the\n     * new bb, since we would spending time searching for the newline\n     * in data we know it doesn't exist. So instead, we simply scan\n     * our current bb and, if we see a newline, prepend ctx->linebb\n     * to the front of it. This makes the code much less straight-\n     * forward (otherwise we could APR_BRIGADE_CONCAT(ctx->linebb, bb)\n     * and just scan for newlines and not bother with needing to know\n     * when ctx->linebb needs to be reset) but also faster. We'll take\n     * the speed.\n     *\n     * Note: apr_brigade_split_line would be nice here, but we\n     * really can't use it since we need more control and we want\n     * to re-use already read bucket data.\n     *\n     * See mod_include if still confused :)\n     */\n\n    while ((b = APR_BRIGADE_FIRST(bb)) && (b != APR_BRIGADE_SENTINEL(bb))) {\n        if (APR_BUCKET_IS_EOS(b)) {\n            /*\n             * if we see the EOS, then we need to pass along everything we\n             * have. But if the ctx->linebb isn't empty, then we need to add\n             * that to the end of what we'll be passing.\n             */\n            if (!APR_BRIGADE_EMPTY(ctx->linebb)) {\n                rv = apr_brigade_pflatten(ctx->linebb, &bflat,\n                                          &fbytes, ctx->tpool);\n                if (rv != APR_SUCCESS)\n                    goto err;\n                if (fbytes > cfg->max_line_length) {\n                    rv = APR_ENOMEM;\n                    goto err;\n                }\n                tmp_b = apr_bucket_transient_create(bflat, fbytes,\n                                                f->r->connection->bucket_alloc);\n                rv = do_pattmatch(f, tmp_b, ctx->pattbb, ctx->tpool);\n                if (rv != APR_SUCCESS)\n                    goto err;\n                APR_BRIGADE_CONCAT(ctx->passbb, ctx->pattbb);\n                apr_brigade_cleanup(ctx->linebb);\n            }\n            APR_BUCKET_REMOVE(b);\n            APR_BRIGADE_INSERT_TAIL(ctx->passbb, b);\n        }\n        /*\n         * No need to handle FLUSH buckets separately as we call\n         * ap_pass_brigade anyway at the end of the loop.\n         */\n        else if (APR_BUCKET_IS_METADATA(b)) {\n            APR_BUCKET_REMOVE(b);\n            APR_BRIGADE_INSERT_TAIL(ctx->passbb, b);\n        }\n        else {\n            /*\n             * We have actual \"data\" so read in as much as we can and start\n             * scanning and splitting from our read buffer\n             */\n            rv = apr_bucket_read(b, &buff, &bytes, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS || bytes == 0) {\n                apr_bucket_delete(b);\n            }\n            else {\n                int num = 0;\n                while (bytes > 0) {\n                    nl = memchr(buff, APR_ASCII_LF, bytes);\n                    if (nl) {\n                        len = (apr_size_t) (nl - buff) + 1;\n                        \n                        apr_bucket_split(b, len);\n                        /*\n                         * We've likely read more data, so bypass rereading\n                         * bucket data and continue scanning through this\n                         * buffer\n                         */\n                        bytes -= len;\n                        buff += len;\n                        /*\n                         * we need b to be updated for future potential\n                         * splitting\n                         */\n                        tmp_b = APR_BUCKET_NEXT(b);\n                        APR_BUCKET_REMOVE(b);\n                        /*\n                         * Hey, we found a newline! Don't forget the old\n                         * stuff that needs to be added to the front. So we\n                         * add the split bucket to the end, flatten the whole\n                         * bb, morph the whole shebang into a bucket which is\n                         * then added to the tail of the newline bb.\n                         */\n                        if (!APR_BRIGADE_EMPTY(ctx->linebb)) {\n                            APR_BRIGADE_INSERT_TAIL(ctx->linebb, b);\n                            rv = apr_brigade_pflatten(ctx->linebb, &bflat,\n                                                      &fbytes, ctx->tpool);\n                            if (rv != APR_SUCCESS)\n                                goto err;\n                            if (fbytes > cfg->max_line_length) {\n                                /* Avoid pflattening further lines, we will\n                                 * abort later on anyway.\n                                 */\n                                rv = APR_ENOMEM;\n                                goto err;\n                            }\n                            b = apr_bucket_transient_create(bflat, fbytes,\n                                            f->r->connection->bucket_alloc);\n                            apr_brigade_cleanup(ctx->linebb);\n                        }\n                        rv = do_pattmatch(f, b, ctx->pattbb, ctx->tpool);\n                        if (rv != APR_SUCCESS)\n                            goto err;\n                        /*\n                         * Count how many buckets we have in ctx->passbb\n                         * so far. Yes, this is correct we count ctx->passbb\n                         * and not ctx->pattbb as we do not reset num on every\n                         * iteration.\n                         */\n                        for (b = APR_BRIGADE_FIRST(ctx->pattbb);\n                             b != APR_BRIGADE_SENTINEL(ctx->pattbb);\n                             b = APR_BUCKET_NEXT(b)) {\n                            num++;\n                        }\n                        APR_BRIGADE_CONCAT(ctx->passbb, ctx->pattbb);\n                        /*\n                         * If the number of buckets in ctx->passbb reaches an\n                         * \"insane\" level, we consume much memory for all the\n                         * buckets as such. So lets flush them down the chain\n                         * in this case and thus clear ctx->passbb. This frees\n                         * the buckets memory for further processing.\n                         * Usually this condition should not become true, but\n                         * it is a safety measure for edge cases.\n                         */\n                        if (num > AP_MAX_BUCKETS) {\n                            b = apr_bucket_flush_create(\n                                                f->r->connection->bucket_alloc);\n                            APR_BRIGADE_INSERT_TAIL(ctx->passbb, b);\n                            rv = ap_pass_brigade(f->next, ctx->passbb);\n                            apr_brigade_cleanup(ctx->passbb);\n                            num = 0;\n                            apr_pool_clear(ctx->tpool);\n                            if (rv != APR_SUCCESS)\n                                goto err;\n                        }\n                        b = tmp_b;\n                    }\n                    else {\n                        /*\n                         * no newline in whatever is left of this buffer so\n                         * tuck data away and get next bucket\n                         */\n                        APR_BUCKET_REMOVE(b);\n                        APR_BRIGADE_INSERT_TAIL(ctx->linebb, b);\n                        bytes = 0;\n                    }\n                }\n            }\n        }\n        if (!APR_BRIGADE_EMPTY(ctx->passbb)) {\n            rv = ap_pass_brigade(f->next, ctx->passbb);\n            apr_brigade_cleanup(ctx->passbb);\n            if (rv != APR_SUCCESS)\n                goto err;\n        }\n        apr_pool_clear(ctx->tpool);\n    }\n\n    \n    if (!APR_BRIGADE_EMPTY(ctx->linebb)) {\n        /*\n         * Provide ap_save_brigade with an existing empty brigade\n         * (ctx->linesbb) to avoid creating a new one.\n         */\n        ap_save_brigade(f, &(ctx->linesbb), &(ctx->linebb), f->r->pool);\n        tmp_bb = ctx->linebb;\n        ctx->linebb = ctx->linesbb;\n        ctx->linesbb = tmp_bb;\n    }\n\n    return APR_SUCCESS;\nerr:\n    if (rv == APR_ENOMEM)\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01328) \"Line too long, URI %s\",\n                      f->r->uri);\n    apr_pool_clear(ctx->tpool);\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_21f29a1c3ec177837f39a78275ec699491f184d2_0", {
    "ID": "httpd_21f29a1c3ec177837f39a78275ec699491f184d2_0",
    "UID": "3498",
    "code": "AP_DECLARE(apr_status_t) ap_password_validate(request_rec test_snippet\n                                              const char *username,\n                                              const char *passwd,\n                                              const char *hash)\n{\n    struct pw_cache *cache;\n    apr_size_t hashlen;\n\n    cache = (struct pw_cache *)apr_table_get(r->connection->notes, pw_cache_note_name);\n    if (cache != NULL) {\n        if (strncmp(passwd, cache->vb.buf, cache->pwlen) == 0\n            && strcmp(hash, cache->vb.buf + cache->pwlen) == 0) {\n            return cache->result;\n        }\n        \n        cache->vb.strlen = 0;\n    }\n    else {\n        cache = apr_palloc(r->connection->pool, sizeof(struct pw_cache));\n        ap_varbuf_init(r->connection->pool, &cache->vb, 0);\n        apr_table_setn(r->connection->notes, pw_cache_note_name, (void *)cache);\n    }\n    cache->pwlen = strlen(passwd);\n    hashlen = strlen(hash);\n    ap_varbuf_grow(&cache->vb, cache->pwlen + hashlen + 1);\n    memcpy(cache->vb.buf, passwd, cache->pwlen);\n    memcpy(cache->vb.buf + cache->pwlen, hash, hashlen + 1);\n    cache->result = apr_password_validate(passwd, hash);\n    return cache->result;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_bc4e7800d75ec7aef2e3d8c01c7abb29c1f6669b_0", {
    "ID": "httpd_bc4e7800d75ec7aef2e3d8c01c7abb29c1f6669b_0",
    "UID": "3504",
    "code": "static apr_status_t copy_brigade_range(apr_bucket_brigade test_snippet\n                                       apr_bucket_brigade *bbout,\n                                       apr_off_t start,\n                                       apr_off_t end)\n{\n    apr_bucket *first = NULL, *last = NULL, *out_first = NULL, *e;\n    apr_uint64_t pos = 0, off_first = 0, off_last = 0;\n    apr_status_t rv;\n    apr_uint64_t start64, end64;\n    apr_off_t pofft = 0;\n\n    /*\n     * Once we know that start and end are >= 0 convert everything to apr_uint64_t.\n     * See the comments in apr_brigade_partition why.\n     * In short apr_off_t (for values >= 0)and apr_size_t fit into apr_uint64_t.\n     */\n    start64 = (apr_uint64_t)start;\n    end64 = (apr_uint64_t)end;\n\n    if (start < 0 || end < 0 || start64 > end64)\n        return APR_EINVAL;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_uint64_t elen64;\n        \n        AP_DEBUG_ASSERT(e->length != (apr_size_t)(-1));\n        elen64 = (apr_uint64_t)e->length;\n        if (!first && (elen64 + pos > start64)) {\n            first = e;\n            off_first = pos;\n        }\n        if (elen64 + pos > end64) {\n            last = e;\n            off_last = pos;\n            break;\n        }\n        pos += elen64;\n    }\n    if (!first || !last)\n        return APR_EINVAL;\n\n    e = first;\n    while (1)\n    {\n        apr_bucket *copy;\n        AP_DEBUG_ASSERT(e != APR_BRIGADE_SENTINEL(bb));\n        rv = apr_bucket_copy(e, &copy);\n        if (rv != APR_SUCCESS) {\n            apr_brigade_cleanup(bbout);\n            return rv;\n        }\n\n        APR_BRIGADE_INSERT_TAIL(bbout, copy);\n        if (e == first) {\n            if (off_first != start64) {\n                rv = apr_bucket_split(copy, (apr_size_t)(start64 - off_first));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                out_first = APR_BUCKET_NEXT(copy);\n                APR_BUCKET_REMOVE(copy);\n                apr_bucket_destroy(copy);\n            }\n            else {\n                out_first = copy;\n            }\n        }\n        if (e == last) {\n            if (e == first) {\n                off_last += start64 - off_first;\n                copy = out_first;\n            }\n            if (end64 - off_last != (apr_uint64_t)e->length) {\n                rv = apr_bucket_split(copy, (apr_size_t)(end64 + 1 - off_last));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                copy = APR_BUCKET_NEXT(copy);\n                if (copy != APR_BRIGADE_SENTINEL(bbout)) {\n                    APR_BUCKET_REMOVE(copy);\n                    apr_bucket_destroy(copy);\n                }\n            }\n            break;\n        }\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    AP_DEBUG_ASSERT(APR_SUCCESS == apr_brigade_length(bbout, 1, &pofft));\n    pos = (apr_uint64_t)pofft;\n    AP_DEBUG_ASSERT(pos == end64 - start64 + 1);\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_a8f39d091c889c48ed4640ce32cca15c45612727_0", {
    "ID": "httpd_a8f39d091c889c48ed4640ce32cca15c45612727_0",
    "UID": "3505",
    "code": "static APR_INLINE int check_headers(request_rec test_snippet\n{\n    const char *loc;\n    struct check_header_ctx ctx = { 0, 0 };\n\n    ctx.r = r;\n    apr_table_do(check_header, &ctx, r->headers_out, NULL);\n    if (ctx.error)\n        return 0; \n\n    if ((loc = apr_table_get(r->headers_out, \"Location\")) != NULL) {\n        const char *scheme_end = ap_strchr_c(loc, ':');\n        const char *s = loc;\n\n        /*\n         * Check that the URI has a valid scheme and is absolute\n         * XXX Should we do a full uri parse here?\n         */\n        if (scheme_end == NULL || scheme_end == loc)\n            goto bad;\n\n        do {\n            if ((!apr_isalnum(*s) && *s != '.' && *s != '+' && *s != '-')\n                || !apr_isascii(*s) ) {\n                goto bad;\n            }\n        } while (++s < scheme_end);\n\n        if (scheme_end[1] != '/' || scheme_end[2] != '/')\n            goto bad;\n    }\n\n    return 1;\n\nbad:\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02431)\n                  \"Bad Location header in response: '%s', aborting request\",\n                  loc);\n    return 0;\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_e0d57a45d72f0615f8e9cec928aea3146dec430a_0", {
    "ID": "httpd_e0d57a45d72f0615f8e9cec928aea3146dec430a_0",
    "UID": "3520",
    "code": "static apr_status_t fix_hostname_v6_literal(request_rec *r, char test_snippet\n{\n    char *dst;\n    int double_colon = 0;\n\n    for (dst = host; *dst; dst++) {\n        if (apr_isxdigit(*dst)) {\n            if (apr_isupper(*dst)) {\n                *dst = apr_tolower(*dst);\n            }\n        }\n        else if (*dst == ':') {\n            if (*(dst + 1) == ':') {\n                if (double_colon)\n                    return APR_EINVAL;\n                double_colon = 1;\n            }\n            else if (*(dst + 1) == '.') {\n                return APR_EINVAL;\n            }\n        }\n        else if (*dst == '.') {\n            \n            if (*(dst + 1) == ':' || *(dst + 1) == '.')\n                return APR_EINVAL;\n        }\n        else {\n            return APR_EINVAL;\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_b71ed043ab7cc432ecbaec2936c3cce9e6d8d843_0", {
    "ID": "httpd_b71ed043ab7cc432ecbaec2936c3cce9e6d8d843_0",
    "UID": "3522",
    "code": "static apr_status_t fix_hostname_non_v6(request_rec *r, char test_snippet\n{\n    char *dst;\n\n    for (dst = host; *dst; dst++) {\n        if (apr_islower(*dst)) {\n            \n        }\n        else if (*dst == '.') {\n            if (*(dst + 1) == '.') {\n                return APR_EINVAL;\n            }\n        }\n        else if (apr_isupper(*dst)) {\n            *dst = apr_tolower(*dst);\n        }\n        else if (*dst == '/' || *dst == '\\\\') {\n            return APR_EINVAL;\n        }\n    }\n    \n    if (dst > host && dst[-1] == '.') {\n        dst[-1] = '\\0';\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal"
  },
  "httpd_b171e2f0274650bb28adc53afdad864d943456fe_0", {
    "ID": "httpd_b171e2f0274650bb28adc53afdad864d943456fe_0",
    "UID": "3533",
    "code": "static apr_status_t strict_hostname_check(request_rec *r, char test_snippet\n                                          int logonly)\n{\n    char *ch;\n    int is_dotted_decimal = 1, leading_zeroes = 0, dots = 0;\n\n    for (ch = host; *ch; ch++) {\n        if (!apr_isascii(*ch)) {\n            goto bad;\n        }\n        else if (apr_isalpha(*ch) || *ch == '-') {\n            is_dotted_decimal = 0;\n        }\n        else if (ch[0] == '.') {\n            dots++;\n            if (ch[1] == '0' && apr_isdigit(ch[2]))\n                leading_zeroes = 1;\n        }\n        else if (!apr_isdigit(*ch)) {\n           \n            goto bad;\n        }\n    }\n    if (is_dotted_decimal) {\n        if (host[0] == '.' || (host[0] == '0' && apr_isdigit(host[1])))\n            leading_zeroes = 1;\n        if (leading_zeroes || dots != 3) {\n            \n            goto bad;\n        }\n    }\n    else {\n        \n        while (ch > host && *ch != '.')\n            ch--;\n        if (ch[0] == '.' && ch[1] != '\\0' && !apr_isalpha(ch[1]))\n            goto bad;\n    }\n    return APR_SUCCESS;\n\nbad:\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02415)\n                  \"[strict] Invalid host name '%s'%s%.6s\",\n                  host, *ch ? \", problem near: \" : \"\", ch);\n    if (logonly)\n        return APR_SUCCESS;\n    return APR_EINVAL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_d02332480e590d6129e5edfa859b0bfbf83f6e9e_0", {
    "ID": "httpd_d02332480e590d6129e5edfa859b0bfbf83f6e9e_0",
    "UID": "3534",
    "code": "static int fix_hostname(request_rec *r, const char test_snippet\n                        unsigned http_conformance)\n{\n    const char *src;\n    char *host, *scope_id;\n    apr_port_t port;\n    apr_status_t rv;\n    const char *c;\n    int is_v6literal = 0;\n    int strict = http_conformance & AP_HTTP_CONFORMANCE_STRICT;\n    int strict_logonly = http_conformance & AP_HTTP_CONFORMANCE_LOGONLY;\n\n    src = host_header ? host_header : r->hostname;\n\n    \n    if (!*src) {\n        return is_v6literal;\n    }\n\n    /* apr_parse_addr_port will interpret a bare integer as a port\n     * which is incorrect in this context.  So treat it separately.\n     */\n    for (c = src; apr_isdigit(*c); ++c);\n    if (!*c) {\n        \n        if (strict) {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02416)\n                         \"[strict] purely numeric host names not allowed: %s\",\n                         src);\n            if (!strict_logonly)\n                goto bad_nolog;\n        }\n        r->hostname = src;\n        return is_v6literal;\n    }\n\n    if (host_header) {\n        rv = apr_parse_addr_port(&host, &scope_id, &port, src, r->pool);\n        if (rv != APR_SUCCESS || scope_id)\n            goto bad;\n        if (port) {\n            /* Don't throw the Host: header's port number away:\n               save it in parsed_uri -- ap_get_server_port() needs it! */\n            /* @@@ XXX there should be a better way to pass the port.\n             *         Like r->hostname, there should be a r->portno\n             */\n            r->parsed_uri.port = port;\n            r->parsed_uri.port_str = apr_itoa(r->pool, (int)port);\n        }\n        if (host_header[0] == '[')\n            is_v6literal = 1;\n    }\n    else {\n        /*\n         * Already parsed, surrounding [ ] (if IPv6 literal) and :port have\n         * already been removed.\n         */\n        host = apr_pstrdup(r->pool, r->hostname);\n        if (ap_strchr(host, ':') != NULL)\n            is_v6literal = 1;\n    }\n\n    if (is_v6literal) {\n        rv = fix_hostname_v6_literal(r, host);\n    }\n    else {\n        rv = fix_hostname_non_v6(r, host);\n        if (strict && rv == APR_SUCCESS)\n            rv = strict_hostname_check(r, host, strict_logonly);\n    }\n    if (rv != APR_SUCCESS)\n        goto bad;\n\n    r->hostname = host;\n    return is_v6literal;\n\nbad:\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00550)\n                  \"Client sent malformed Host header: %s\",\n                  src);\nbad_nolog:\n    r->status = HTTP_BAD_REQUEST;\n    return is_v6literal;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_2108224e85cc79146d77742adbc8f1fa87eea80a_0", {
    "ID": "httpd_2108224e85cc79146d77742adbc8f1fa87eea80a_0",
    "UID": "3541",
    "code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec test_snippet\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal, have_hostname_from_url = 0;\n\n    if (r->hostname) {\n        /*\n         * If there was a host part in the Request-URI, ignore the 'Host'\n         * header.\n         */\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n\n    if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) {\n        /*\n         * If we have both hostname from an absoluteURI and a Host header,\n         * we must ignore the Host header (RFC 2616 5.2).\n         * To enforce this, we reset the Host header to the value from the\n         * request line.\n         */\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *info = \"Would replace\";\n            const char *new = construct_host_header(r, is_v6literal);\n            if (!(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY)) {\n                apr_table_set(r->headers_in, \"Host\", r->hostname);\n                info = \"Replacing\";\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"%s Host header '%s' with host from request uri: \"\n                          \"'%s'\", info, host_header, new);\n        }\n    }\n\n    \n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_e060391f84cd2b74e93478cc8af660e64a2ceee3_0", {
    "ID": "httpd_e060391f84cd2b74e93478cc8af660e64a2ceee3_0",
    "UID": "3550",
    "code": "AP_DECLARE(int) ap_has_cntrl(const char test_snippet\n{\n    while (test_snippet {\n        if (apr_iscntrl(test_snippet)\n            return 1;\n        str++;\n    }\n    return 0;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_5aad6a67a3b9cd658a50d25997a3233e94781331_0", {
    "ID": "httpd_5aad6a67a3b9cd658a50d25997a3233e94781331_0",
    "UID": "3562",
    "code": "apr_status_t ajp_msg_dump(apr_pool_t *pool, ajp_msg_t *msg, char test_snippet\n                          apr_size_t count, char **buf)\n{\n    apr_size_t  i, j;\n    char        *current;\n    apr_size_t  bl, rl;\n    apr_byte_t  x;\n    apr_size_t  len = msg->len;\n    apr_size_t  line_len;\n\n    \n    if (len > count)\n        len = count;\n         \n    bl = strlen(err) + 3 * (strlen(\" XXX=\") + 20) + 1 +\n         \n         (len + 15) / 16 * AJP_MSG_DUMP_LINE_LENGTH;\n    *buf = apr_palloc(pool, bl);\n    if (!*buf)\n        return APR_ENOMEM;\n    apr_snprintf(*buf, bl,\n                 \"%s pos=%\" APR_SIZE_T_FMT\n                 \" len=%\" APR_SIZE_T_FMT \" max=%\" APR_SIZE_T_FMT \"\\n\",\n                 err, msg->pos, msg->len, msg->max_size);\n    current = *buf + strlen(*buf);\n    for (i = 0; i < len; i += AJP_MSG_DUMP_BYTES_PER_LINE) {\n        \n        rl = bl - (current - *buf);\n        if (AJP_MSG_DUMP_LINE_LENGTH > rl) {\n            *(current - 1) = '\\0';\n            return APR_ENOMEM;\n        }\n        apr_snprintf(current, rl, \"%.4lx    \", (unsigned long)i);\n        current += AJP_MSG_DUMP_PREFIX_LENGTH;\n        line_len = len - i;\n        if (line_len > AJP_MSG_DUMP_BYTES_PER_LINE) {\n            line_len = AJP_MSG_DUMP_BYTES_PER_LINE;\n        }\n        for (j = 0; j < line_len; j++) {\n            x = msg->buf[i + j];\n\n            *current++ = hex_table[x >> 4];\n            *current++ = hex_table[x & 0x0f];\n            *current++ = ' ';\n        }\n        *current++ = ' ';\n        *current++ = '-';\n        *current++ = ' ';\n        for (j = 0; j < line_len; j++) {\n            x = msg->buf[i + j];\n\n            if (x > 0x20 && x < 0x7F) {\n                *current++ = x;\n            }\n            else {\n                *current++ = '.';\n            }\n        }\n        *current++ = '\\n';\n    }\n    *(current - 1) = '\\0';\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n400,Uncontrolled Resource Consumption"
  },
  "httpd_b930249ab2693b467789a8b760a088cfb733fe33_0", {
    "ID": "httpd_b930249ab2693b467789a8b760a088cfb733fe33_0",
    "UID": "3564",
    "code": "static int slotmem_filenames(apr_pool_t test_snippet\n                             const char *slotname,\n                             const char **filename,\n                             const char **persistname)\n{\n    const char *fname = NULL, *pname = NULL;\n\n    if (slotname && *slotname && strcasecmp(slotname, \"none\") != 0) {\n        if (slotname[0] != '/') {\n#if !SLOTMEM_UNLINK_SEMANTIC\n            \n            int generation = 0;\n            ap_mpm_query(AP_MPMQ_GENERATION, &generation);\n            fname = apr_psprintf(pool, \"%s%s_%x%s\", DEFAULT_SLOTMEM_PREFIX,\n                                 slotname, generation, DEFAULT_SLOTMEM_SUFFIX);\n#else\n            \n            fname = apr_pstrcat(pool, DEFAULT_SLOTMEM_PREFIX,\n                                slotname, DEFAULT_SLOTMEM_SUFFIX,\n                                NULL);\n#endif\n            fname = ap_runtime_dir_relative(pool, fname);\n        }\n        else {\n            /* Don't mangle the file name if given an absolute path, it's\n             * up to the caller to provide a unique name when necessary.\n             */\n            fname = slotname;\n        }\n\n        if (persistname) {\n            \n#if !SLOTMEM_UNLINK_SEMANTIC\n            if (slotname[0] != '/') {\n                pname = apr_pstrcat(pool, DEFAULT_SLOTMEM_PREFIX,\n                                    slotname, DEFAULT_SLOTMEM_SUFFIX,\n                                    DEFAULT_SLOTMEM_PERSIST_SUFFIX,\n                                    NULL);\n                pname = ap_runtime_dir_relative(pool, pname);\n            }\n            else\n#endif\n            pname = apr_pstrcat(pool, fname,\n                                DEFAULT_SLOTMEM_PERSIST_SUFFIX,\n                                NULL);\n        }\n    }\n\n    *filename = fname;\n    if (persistname) {\n        *persistname = pname;\n    }\n    return (fname != NULL);\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_12f8cf0c5e818d0ab5fb8b9ad14e0ed721fb5202_0", {
    "ID": "httpd_12f8cf0c5e818d0ab5fb8b9ad14e0ed721fb5202_0",
    "UID": "3565",
    "code": "APREQ_DECLARE(apreq_parser_function_t)apreq_parser(const char test_snippet\n{\n    apreq_parser_function_t *f;\n    apr_size_t tlen = 0;\n\n    if (enctype == NULL || default_parsers_lock == 0)\n        return NULL;\n\n    while (enctype[tlen] && enctype[tlen] != ';')\n        ++tlen;\n\n    f = apr_hash_get(default_parsers, enctype, tlen);\n\n    if (f != NULL)\n        return *f;\n    else\n        return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_cd419018cd3fa93aab4fd54564deb4656aac38ce_0", {
    "ID": "httpd_cd419018cd3fa93aab4fd54564deb4656aac38ce_0",
    "UID": "3566",
    "code": "apr_status_t ajp_msg_get_string(ajp_msg_t *msg, const char test_snippet\n{\n    apr_uint16_t size;\n    apr_size_t   start;\n    apr_status_t status;\n\n    status = ajp_msg_get_uint16(msg, &size);\n    start = msg->pos;\n\n    if ((status != APR_SUCCESS) || (size + start > msg->max_size)) {\n        return ajp_log_overflow(msg, \"ajp_msg_get_string\");\n    }\n\n    msg->pos += (apr_size_t)size;\n    msg->pos++;                   \n\n    *rvalue = (const char *)(msg->buf + start);\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_8bc3b0174d16b59f9b24307a9e44293655d70c5a_0", {
    "ID": "httpd_8bc3b0174d16b59f9b24307a9e44293655d70c5a_0",
    "UID": "3572",
    "code": "static apr_status_t logio_ttfb_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    request_rec *r = f->r;\n    logio_dirconf_t *conf = ap_get_module_config(r->per_dir_config,\n                                                 &logio_module);\n    if (conf && conf->track_ttfb) { \n        logio_req_t *rconf = ap_get_module_config(r->request_config, \n                                                  &logio_module);\n        if (rconf == NULL) { \n            rconf = apr_pcalloc(r->pool, sizeof(logio_req_t));\n            rconf->ttfb = apr_time_now() - r->request_time;\n            ap_set_module_config(r->request_config, &logio_module, rconf);\n        }\n    }\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8cc57a8f5dc089541f9f7da22b12ce79fe82db5e_0", {
    "ID": "httpd_8cc57a8f5dc089541f9f7da22b12ce79fe82db5e_0",
    "UID": "3578",
    "code": "static apr_status_t slotmem_create(ap_slotmem_instance_t test_snippet\n                                   const char *name, apr_size_t item_size,\n                                   unsigned int item_num,\n                                   ap_slotmem_type_t type, apr_pool_t *pool)\n{\n    int fbased = 1;\n    int restored = 0;\n    char *ptr;\n    sharedslotdesc_t desc;\n    ap_slotmem_instance_t *res;\n    ap_slotmem_instance_t *next = globallistmem;\n    const char *fname, *pname = NULL;\n    apr_shm_t *shm;\n    apr_size_t basesize = (item_size * item_num);\n    apr_size_t size = AP_SLOTMEM_OFFSET + AP_UNSIGNEDINT_OFFSET +\n                      (item_num * sizeof(char)) + basesize;\n    int persist = (type & AP_SLOTMEM_TYPE_PERSIST) != 0;\n    apr_status_t rv;\n\n    if (gpool == NULL) {\n        return APR_ENOSHMAVAIL;\n    }\n    if (slotmem_filenames(pool, name, &fname, persist ? &pname : NULL)) {\n        \n        if (next) {\n            for (;;) {\n                if (strcmp(next->name, fname) == 0) {\n                    \n                    *new = next;\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02603)\n                                 \"create found %s in global list\", fname);\n                    return APR_SUCCESS;\n                }\n                if (!next->next) {\n                     break;\n                }\n                next = next->next;\n            }\n        }\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02602)\n                     \"create didn't find %s in global list\", fname);\n    }\n    else {\n        fbased = 0;\n        fname = \"none\";\n    }\n\n    \n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02300)\n                 \"create %s: %\"APR_SIZE_T_FMT\"/%u\", fname, item_size,\n                 item_num);\n    if (fbased) {\n        rv = apr_shm_attach(&shm, fname, gpool);\n    }\n    else {\n        rv = APR_EINVAL;\n    }\n    if (rv == APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02598)\n                     \"apr_shm_attach() succeeded\");\n\n        \n        if (apr_shm_size_get(shm) != size) {\n            apr_shm_detach(shm);\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(02599)\n                         \"existing shared memory for %s could not be used (failed size check)\",\n                         fname);\n            return APR_EINVAL;\n        }\n        ptr = (char *)apr_shm_baseaddr_get(shm);\n        memcpy(&desc, ptr, sizeof(desc));\n        if (desc.size != item_size || desc.num != item_num) {\n            apr_shm_detach(shm);\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(02600)\n                         \"existing shared memory for %s could not be used (failed contents check)\",\n                         fname);\n            return APR_EINVAL;\n        }\n        ptr += AP_SLOTMEM_OFFSET;\n    }\n    else {\n        apr_size_t dsize = size - AP_SLOTMEM_OFFSET;\n        if (fbased) {\n            apr_shm_remove(fname, gpool);\n            rv = apr_shm_create(&shm, size, fname, gpool);\n        }\n        else {\n            rv = apr_shm_create(&shm, size, NULL, gpool);\n        }\n        ap_log_error(APLOG_MARK, rv == APR_SUCCESS ? APLOG_DEBUG : APLOG_ERR,\n                     rv, ap_server_conf, APLOGNO(02611)\n                     \"create: apr_shm_create(%s) %s\",\n                     fname ? fname : \"\",\n                     rv == APR_SUCCESS ? \"succeeded\" : \"failed\");\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        ptr = (char *)apr_shm_baseaddr_get(shm);\n        desc.size = item_size;\n        desc.num = item_num;\n        desc.type = type;\n        memcpy(ptr, &desc, sizeof(desc));\n        ptr += AP_SLOTMEM_OFFSET;\n        memset(ptr, 0, dsize);\n        /*\n         * TODO: Error check the below... What error makes\n         * sense if the restore fails? Any?\n         */\n        if (persist) {\n            rv = restore_slotmem(ptr, pname, dsize, pool);\n            if (rv == APR_SUCCESS) {\n                restored = 1;\n            }\n            else {\n                \n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             APLOGNO(02554) \"could not restore %s\", fname);\n                memset(ptr, 0, dsize);\n            }\n        }\n    }\n\n    \n    res = (ap_slotmem_instance_t *) apr_pcalloc(gpool,\n                                                sizeof(ap_slotmem_instance_t));\n    res->name = apr_pstrdup(gpool, fname);\n    res->pname = apr_pstrdup(gpool, pname);\n    res->fbased = fbased;\n    res->shm = shm;\n    res->num_free = (unsigned int *)ptr;\n    if (!restored) {\n        *res->num_free = item_num;\n    }\n    res->persist = (void *)ptr;\n    ptr += AP_UNSIGNEDINT_OFFSET;\n    res->base = (void *)ptr;\n    res->desc = desc;\n    res->gpool = gpool;\n    res->next = NULL;\n    res->inuse = ptr + basesize;\n    if (globallistmem == NULL) {\n        globallistmem = res;\n    }\n    else {\n        next->next = res;\n    }\n\n    *new = res;\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6bb3fe769e35a169b5cf84ee9b89345568869174_0", {
    "ID": "httpd_6bb3fe769e35a169b5cf84ee9b89345568869174_0",
    "UID": "3582",
    "code": "static apr_status_t ajp_unmarshal_response(ajp_msg_t test_snippet\n                                           request_rec *r,\n                                           proxy_dir_conf *dconf)\n{\n    apr_uint16_t status;\n    apr_status_t rc;\n    const char *ptr;\n    apr_uint16_t  num_headers;\n    int i;\n\n    rc = ajp_msg_get_uint16(msg, &status);\n\n    if (rc != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00983)\n                \"ajp_unmarshal_response: Null status\");\n        return rc;\n    }\n    r->status = status;\n\n    rc = ajp_msg_get_string(msg, &ptr);\n    if (rc == APR_SUCCESS) {\n#if APR_CHARSET_EBCDIC \n        ptr = apr_pstrdup(r->pool, ptr);\n        ap_xlate_proto_from_ascii(ptr, strlen(ptr));\n#endif\n        r->status_line =  apr_psprintf(r->pool, \"%d %s\", status, ptr);\n    }\n    else {\n        r->status_line = NULL;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n           \"ajp_unmarshal_response: status = %d\", status);\n\n    rc = ajp_msg_get_uint16(msg, &num_headers);\n    if (rc == APR_SUCCESS) {\n        apr_table_t *save_table;\n\n        \n        /*\n         * Could optimize here, but just in case we want to\n         * also save other headers, keep this logic.\n         */\n        save_table = apr_table_make(r->pool, num_headers + 2);\n        apr_table_do(addit_dammit, save_table, r->headers_out,\n                     \"Set-Cookie\", NULL);\n        r->headers_out = save_table;\n    }\n    else {\n        r->headers_out = NULL;\n        num_headers = 0;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n           \"ajp_unmarshal_response: Number of headers is = %d\",\n           num_headers);\n\n    for (i = 0; i < (int)num_headers; i++) {\n        apr_uint16_t name;\n        const char *stringname;\n        const char *value;\n        rc  = ajp_msg_peek_uint16(msg, &name);\n        if (rc != APR_SUCCESS) {\n            return rc;\n        }\n\n        if ((name & 0XFF00) == 0XA000) {\n            ajp_msg_get_uint16(msg, &name);\n            stringname = long_res_header_for_sc(name);\n            if (stringname == NULL) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00984)\n                       \"ajp_unmarshal_response: \"\n                       \"No such sc (%08x)\",\n                       name);\n                return AJP_EBAD_HEADER;\n            }\n        }\n        else {\n            name = 0;\n            rc = ajp_msg_get_string(msg, &stringname);\n            if (rc != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00985)\n                       \"ajp_unmarshal_response: \"\n                       \"Null header name\");\n                return rc;\n            }\n            ap_xlate_proto_from_ascii(stringname, strlen(stringname));\n        }\n\n        rc = ajp_msg_get_string(msg, &value);\n        if (rc != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00986)\n                   \"ajp_unmarshal_response: \"\n                   \"Null header value\");\n            return rc;\n        }\n\n        \n        if (!strcasecmp(stringname, \"Set-Cookie\")) {\n            value = ap_proxy_cookie_reverse_map(r, dconf, value);\n        }\n        /* Location, Content-Location, URI and Destination need additional\n         * processing */\n        else if (!strcasecmp(stringname, \"Location\")\n                 || !strcasecmp(stringname, \"Content-Location\")\n                 || !strcasecmp(stringname, \"URI\")\n                 || !strcasecmp(stringname, \"Destination\"))\n        {\n          value = ap_proxy_location_reverse_map(r, dconf, value);\n        }\n\n        ap_xlate_proto_from_ascii(value, strlen(value));\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n               \"ajp_unmarshal_response: Header[%d] [%s] = [%s]\",\n                       i, stringname, value);\n\n        apr_table_add(r->headers_out, stringname, value);\n\n        \n        if (strcasecmp(stringname, \"Content-Type\") == 0) {\n             \n            ap_set_content_type(r, apr_pstrdup(r->pool, value));\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n               \"ajp_unmarshal_response: ap_set_content_type to '%s'\", value);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n20,Improper Input Validation"
  },
  "httpd_902625e85ad4a50ec6be9a780ecdeeb1699fc6a0_0", {
    "ID": "httpd_902625e85ad4a50ec6be9a780ecdeeb1699fc6a0_0",
    "UID": "3583",
    "code": "static apr_status_t read_array(request_rec *r, apr_array_header_t* test_snippet\n                               apr_file_t *file)\n{\n    char w[MAX_STRING_LEN];\n    int p;\n    apr_status_t rv;\n\n    while (1) {\n        rv = apr_file_gets(w, MAX_STRING_LEN - 1, file);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00716)\n                          \"Premature end of vary array.\");\n            return rv;\n        }\n\n        p = strlen(w);\n        if (p > 0 && w[p - 1] == '\\n') {\n            if (p > 1 && w[p - 2] == CR) {\n                w[p - 2] = '\\0';\n            }\n            else {\n                w[p - 1] = '\\0';\n            }\n        }\n\n        \n        if (w[0] == '\\0') {\n            break;\n        }\n\n        *((const char **) apr_array_push(arr)) = apr_pstrdup(r->pool, w);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f48216c0f36a25f3a060f2b8f571852a34ac75e0_0", {
    "ID": "httpd_f48216c0f36a25f3a060f2b8f571852a34ac75e0_0",
    "UID": "3586",
    "code": "AP_DECLARE(const char *)ap_make_content_type(request_rec *r, const char test_snippet\n{\n    const apr_strmatch_pattern **pcset;\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    core_request_config *request_conf;\n    apr_size_t type_len;\n\n    if (!type || *type == '\\0') {\n        return NULL;\n    }\n\n    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {\n        return type;\n    }\n\n    request_conf = ap_get_core_module_config(r->request_config);\n    if (request_conf->suppress_charset) {\n        return type;\n    }\n\n    type_len = strlen(type);\n\n    if (apr_strmatch(charset_pattern, type, type_len) != NULL) {\n        \n        \n        ;\n    }\n    else {\n        /* see if it makes sense to add the charset. At present,\n         * we only add it if the Content-type is one of needcset[]\n         */\n        for (pcset = needcset_patterns; *pcset ; pcset++) {\n            if (apr_strmatch(*pcset, type, type_len) != NULL) {\n                struct iovec concat[3];\n                concat[0].iov_base = (void *)type;\n                concat[0].iov_len = type_len;\n                concat[1].iov_base = (void *)\"; charset=\";\n                concat[1].iov_len = sizeof(\"; charset=\") - 1;\n                concat[2].iov_base = (void *)(conf->add_default_charset_name);\n                concat[2].iov_len = strlen(conf->add_default_charset_name);\n                type = apr_pstrcatv(r->pool, concat, 3, NULL);\n                break;\n            }\n        }\n    }\n\n    return type;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow"
  },
  "httpd_c5ea62ba0c5c98588c3137d05871d1b6b50bacaa_0", {
    "ID": "httpd_c5ea62ba0c5c98588c3137d05871d1b6b50bacaa_0",
    "UID": "3587",
    "code": "static apr_off_t get_body(char *buffer, apr_size_t *len, const char test_snippet\n                          apr_file_t *map)\n{\n    char *endbody;\n    apr_size_t bodylen;\n    apr_off_t pos;\n\n\n    /* We are at the first character following a body:tag\\n entry\n     * Suck in the body, then backspace to the first char after the\n     * closing tag entry.  If we fail to read, find the tag or back\n     * up then we have a hosed file, so give up already\n     */\n    --*len; \n    if (apr_file_read(map, buffer, len) != APR_SUCCESS) {\n        return -1;\n    }\n    buffer[*len] = '\\0';\n\n    endbody = ap_strstr(buffer, tag);\n    if (!endbody) {\n        return -1;\n    }\n    bodylen = endbody - buffer;\n    endbody += strlen(tag);\n    \n    while (*endbody) {\n        if (*endbody == '\\n') {\n            ++endbody;\n            break;\n        }\n        ++endbody;\n    }\n\n    pos = -(apr_off_t)(*len - (endbody - buffer));\n    if (apr_file_seek(map, APR_CUR, &pos) != APR_SUCCESS) {\n        return -1;\n    }\n\n    \n    *len = bodylen;\n    return pos - (endbody - buffer);\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_f2d07eeef84dab7b49ca272e9af024485140e8fc_0", {
    "ID": "httpd_f2d07eeef84dab7b49ca272e9af024485140e8fc_0",
    "UID": "3588",
    "code": "static int log_ctime(const ap_errorlog_info *info, const char test_snippet\n                     char *buf, int buflen)\n{\n    int time_len = buflen;\n    int option = AP_CTIME_OPTION_NONE;\n\n    while (arg && *arg) {\n        switch (*arg) {\n            case 'u':   option |= AP_CTIME_OPTION_USEC;\n                        break;\n            case 'c':   option |= AP_CTIME_OPTION_COMPACT;\n                        break;\n        }\n        arg++;\n    }\n\n    ap_recent_ctime_ex(buf, apr_time_now(), option, &time_len);\n\n    \n    return time_len - 1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_6f3f08c8914d5edad8b2579bbbb2ae66e81d1239_0", {
    "ID": "httpd_6f3f08c8914d5edad8b2579bbbb2ae66e81d1239_0",
    "UID": "3597",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetitest_snippetntest_snippetttest_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetitest_snippetntest_snippetdtest_snippetetest_snippetxtest_snippet(test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetstest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetstest_snippetttest_snippetatest_snippetrtest_snippetttest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetatest_snippetrtest_snippetttest_snippet test_snippet>test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetatest_snippetrtest_snippetttest_snippet;test_snippet test_snippetitest_snippet test_snippet<test_snippet test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet;test_snippet test_snippetitest_snippet+test_snippet+test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetAtest_snippetRtest_snippetRtest_snippetAtest_snippetYtest_snippet_test_snippetItest_snippetDtest_snippetXtest_snippet(test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet,test_snippet test_snippetitest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetptest_snippet,test_snippet test_snippetstest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippet-test_snippet1test_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code is not readable or understandable. It seems to be obfuscated or corrupted. Please provide a valid piece of C/C++ code."
  },
  "httpd_3f71298daae5b87216cdb75b163574d454f7b9f0_0", {
    "ID": "httpd_3f71298daae5b87216cdb75b163574d454f7b9f0_0",
    "UID": "3598",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet(test_snippetctest_snippetotest_snippetntest_snippetntest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetctest_snippet,test_snippet test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetrtest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetstest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetotest_snippetotest_snippetltest_snippet test_snippet=test_snippet test_snippetrtest_snippet?test_snippet test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet test_snippet:test_snippet test_snippetctest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetrtest_snippetetest_snippet_test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet test_snippet*test_snippetctest_snippetotest_snippetntest_snippetftest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetctest_snippetotest_snippetrtest_snippetetest_snippet_test_snippetmtest_snippetotest_snippetdtest_snippetutest_snippetltest_snippetetest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet(test_snippetstest_snippet-test_snippet>test_snippetmtest_snippetotest_snippetdtest_snippetutest_snippetltest_snippetetest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet,test_snippet test_snippet*test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetctest_snippetdtest_snippetetest_snippetbtest_snippetutest_snippetgtest_snippet(test_snippetctest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet,test_snippet test_snippet'test_snippet,test_snippet'test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetDtest_snippetEtest_snippetBtest_snippetUtest_snippetGtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetstest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet test_snippet%test_snippetstest_snippet,test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet=test_snippet%test_snippetstest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippet,test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet,test_snippet test_snippet'test_snippet,test_snippet'test_snippet)test_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippethtest_snippetotest_snippetstest_snippetttest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet<test_snippet=test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippetttest_snippethtest_snippetitest_snippetntest_snippetgtest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippetutest_snippetrtest_snippetetest_snippetdtest_snippet,test_snippet test_snippetbtest_snippetytest_snippet test_snippetdtest_snippetetest_snippetftest_snippetatest_snippetutest_snippetltest_snippetttest_snippet,test_snippet test_snippetwtest_snippetetest_snippet test_snippetotest_snippetntest_snippetltest_snippetytest_snippet test_snippetatest_snippetltest_snippetltest_snippetotest_snippetwtest_snippet test_snippethtest_snippetttest_snippetttest_snippetptest_snippet/test_snippet1test_snippet.test_snippet1test_snippet test_snippethtest_snippetetest_snippetrtest_snippetetest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetFtest_snippetotest_snippetrtest_snippet test_snippetntest_snippetotest_snippetwtest_snippet.test_snippet.test_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet(test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet,test_snippet test_snippetAtest_snippetPtest_snippet_test_snippetPtest_snippetRtest_snippetOtest_snippetTtest_snippetOtest_snippetCtest_snippetOtest_snippetLtest_snippet_test_snippetHtest_snippetTtest_snippetTtest_snippetPtest_snippet1test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippet_test_snippetPtest_snippetRtest_snippetOtest_snippetTtest_snippetOtest_snippetCtest_snippetOtest_snippetLtest_snippet_test_snippetHtest_snippetTtest_snippetTtest_snippetPtest_snippet1test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet+test_snippet test_snippet1test_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetrtest_snippetutest_snippetntest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetetest_snippet(test_snippetctest_snippet,test_snippet test_snippetrtest_snippet,test_snippet test_snippetstest_snippet,test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetItest_snippetftest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippethtest_snippetatest_snippetstest_snippet test_snippetntest_snippetotest_snippetttest_snippet test_snippetbtest_snippetetest_snippetetest_snippetntest_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetetest_snippetdtest_snippet,test_snippet test_snippetbtest_snippetutest_snippetttest_snippet test_snippetitest_snippetstest_snippet test_snippetatest_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetatest_snippetdtest_snippetdtest_snippet test_snippetitest_snippetttest_snippet test_snippetttest_snippetotest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet test_snippetitest_snippetmtest_snippetptest_snippetltest_snippetitest_snippetctest_snippetitest_snippetttest_snippetltest_snippetytest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet(test_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet(test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet,test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet&test_snippet&test_snippet test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet(test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet,test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetAtest_snippetRtest_snippetRtest_snippetAtest_snippetYtest_snippet_test_snippetPtest_snippetUtest_snippetStest_snippetHtest_snippet(test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet*test_snippet)test_snippet test_snippet=test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet>test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetDtest_snippetetest_snippetftest_snippetatest_snippetutest_snippetltest_snippetttest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet_test_snippethtest_snippetotest_snippetntest_snippetotest_snippetrtest_snippet_test_snippetotest_snippetrtest_snippetdtest_snippetetest_snippetrtest_snippet test_snippetitest_snippetstest_snippet test_snippet'test_snippetotest_snippetntest_snippet'test_snippet test_snippetotest_snippetrtest_snippet test_snippet!test_snippet=test_snippet test_snippet0test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet_test_snippethtest_snippetotest_snippetntest_snippetotest_snippetrtest_snippet_test_snippetotest_snippetrtest_snippetdtest_snippetetest_snippetrtest_snippet test_snippet=test_snippet=test_snippet test_snippet0test_snippet test_snippet&test_snippet&test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet>test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetstest_snippet test_snippet=test_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippetstest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetstest_snippet test_snippet=test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetStest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetmtest_snippetotest_snippetstest_snippetttest_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetetest_snippetrtest_snippetrtest_snippetetest_snippetdtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetctest_snippetdtest_snippetetest_snippetbtest_snippetutest_snippetgtest_snippet(test_snippetctest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetDtest_snippetEtest_snippetBtest_snippetUtest_snippetGtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetstest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet=test_snippet%test_snippetstest_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetetest_snippetrtest_snippetetest_snippetntest_snippetctest_snippetetest_snippetstest_snippet=test_snippet%test_snippetstest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippetutest_snippetrtest_snippetetest_snippetdtest_snippet=test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet,test_snippet test_snippet'test_snippet,test_snippet'test_snippet)test_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetstest_snippet,test_snippet test_snippet'test_snippet,test_snippet'test_snippet)test_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet,test_snippet test_snippet'test_snippet,test_snippet'test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet test_snippetitest_snippet test_snippet<test_snippet test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet;test_snippet test_snippet+test_snippet+test_snippetitest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetAtest_snippetRtest_snippetRtest_snippetAtest_snippetYtest_snippet_test_snippetItest_snippetDtest_snippetXtest_snippet(test_snippetptest_snippetrtest_snippetotest_snippetptest_snippetotest_snippetstest_snippetatest_snippetltest_snippetstest_snippet,test_snippet test_snippetitest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet,test_snippet test_snippetptest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippetttest_snippet test_snippetatest_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippetutest_snippetrtest_snippetetest_snippetdtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippethtest_snippetetest_snippetrtest_snippetetest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetttest_snippetitest_snippetntest_snippetutest_snippetetest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet|test_snippet|test_snippet test_snippet(test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetctest_snippetmtest_snippetptest_snippet(test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetstest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet,test_snippet test_snippetptest_snippet)test_snippet test_snippet<test_snippet test_snippet0test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippetntest_snippetetest_snippet test_snippetstest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippetetest_snippetdtest_snippet test_snippetytest_snippetetest_snippetttest_snippet test_snippetotest_snippetrtest_snippet test_snippetttest_snippethtest_snippetitest_snippetstest_snippet test_snippetotest_snippetntest_snippetetest_snippet test_snippethtest_snippetatest_snippetstest_snippet test_snippetptest_snippetrtest_snippetetest_snippetftest_snippetetest_snippetrtest_snippetetest_snippetntest_snippetctest_snippetetest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippet=test_snippet test_snippetptest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetctest_snippetdtest_snippetetest_snippetbtest_snippetutest_snippetgtest_snippet(test_snippetctest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetDtest_snippetEtest_snippetBtest_snippetUtest_snippetGtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippet\"test_snippetstest_snippetetest_snippetltest_snippetetest_snippetctest_snippetttest_snippetetest_snippetdtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet=test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet?test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet test_snippet:test_snippet test_snippet\"test_snippet(test_snippetntest_snippetotest_snippetntest_snippetetest_snippet)test_snippet\"test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": ""
  },
  "httpd_c40074e89f9ce083d93b5343091b4a3fcd32c31f_0", {
    "ID": "httpd_c40074e89f9ce083d93b5343091b4a3fcd32c31f_0",
    "UID": "3622",
    "code": "static apr_status_t event_register_timed_callback_ex(apr_time_t test_snippet\n                                                  ap_mpm_callback_fn_t *cbfn,\n                                                  void *baton, \n                                                  apr_pollfd_t **remove)\n{\n    event_get_timer_event(t + apr_time_now(), cbfn, baton, 1, remove);\n    return APR_SUCCESS;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_8c146a9d0f10b4e1b6dd01d1bc90e9e7509104a5_0", {
    "ID": "httpd_8c146a9d0f10b4e1b6dd01d1bc90e9e7509104a5_0",
    "UID": "3623",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetgtest_snippetitest_snippetstest_snippetttest_snippetetest_snippetrtest_snippet_test_snippetstest_snippetotest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetctest_snippetatest_snippetltest_snippetltest_snippetbtest_snippetatest_snippetctest_snippetktest_snippet_test_snippetetest_snippetxtest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetotest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetttest_snippet test_snippet*test_snippet*test_snippetstest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetftest_snippetotest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetatest_snippetdtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetmtest_snippetptest_snippetmtest_snippet_test_snippetctest_snippetatest_snippetltest_snippetltest_snippetbtest_snippetatest_snippetctest_snippetktest_snippet_test_snippetftest_snippetntest_snippet_test_snippetttest_snippet test_snippet*test_snippetctest_snippetbtest_snippetftest_snippetntest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetmtest_snippetptest_snippetmtest_snippet_test_snippetctest_snippetatest_snippetltest_snippetltest_snippetbtest_snippetatest_snippetctest_snippetktest_snippet_test_snippetftest_snippetntest_snippet_test_snippetttest_snippet test_snippet*test_snippetttest_snippetotest_snippetftest_snippetntest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippet*test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetttest_snippetitest_snippetmtest_snippetetest_snippet_test_snippetttest_snippet test_snippetttest_snippetitest_snippetmtest_snippetetest_snippetotest_snippetutest_snippetttest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetrtest_snippetctest_snippet,test_snippet test_snippetftest_snippetitest_snippetntest_snippetatest_snippetltest_snippet_test_snippetrtest_snippetctest_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet,test_snippet test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetotest_snippetctest_snippetktest_snippetetest_snippetttest_snippet_test_snippetctest_snippetatest_snippetltest_snippetltest_snippetbtest_snippetatest_snippetctest_snippetktest_snippet_test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet_test_snippetttest_snippet test_snippet*test_snippetstest_snippetctest_snippetbtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetctest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetptest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippet*test_snippetstest_snippetctest_snippetbtest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetitest_snippetstest_snippetttest_snippetetest_snippetntest_snippetetest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippet_test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet*test_snippetptest_snippetttest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetptest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippet*test_snippetptest_snippetttest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippetftest_snippetdtest_snippet_test_snippetttest_snippet test_snippet*test_snippet*test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetwtest_snippethtest_snippetitest_snippetltest_snippetetest_snippet(test_snippetstest_snippet[test_snippetitest_snippet]test_snippet test_snippet!test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippet+test_snippet+test_snippet;test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet test_snippet=test_snippet test_snippetitest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetctest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetptest_snippet,test_snippet test_snippet(test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet+test_snippet1test_snippet)test_snippet test_snippet*test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippetftest_snippetdtest_snippet_test_snippetttest_snippet*test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetttest_snippet-test_snippet>test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetPtest_snippetTtest_snippet_test_snippetUtest_snippetStest_snippetEtest_snippetRtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetttest_snippet-test_snippet>test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet test_snippet=test_snippet test_snippetstest_snippetctest_snippetbtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetctest_snippetbtest_snippet-test_snippet>test_snippetctest_snippetbtest_snippetftest_snippetutest_snippetntest_snippetctest_snippet test_snippet=test_snippet test_snippetctest_snippetbtest_snippetftest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetctest_snippetbtest_snippet-test_snippet>test_snippetutest_snippetstest_snippetetest_snippetrtest_snippet_test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet test_snippet=test_snippet test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetctest_snippetbtest_snippet-test_snippet>test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet test_snippet=test_snippet test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetctest_snippetbtest_snippet-test_snippet>test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet test_snippet=test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet test_snippetitest_snippet<test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet;test_snippet test_snippetitest_snippet+test_snippet+test_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetctest_snippetatest_snippetltest_snippetltest_snippetotest_snippetctest_snippet(test_snippetptest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippetftest_snippetdtest_snippet_test_snippetttest_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet-test_snippet>test_snippetdtest_snippetetest_snippetstest_snippetctest_snippet_test_snippetttest_snippetytest_snippetptest_snippetetest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetOtest_snippetLtest_snippetLtest_snippet_test_snippetStest_snippetOtest_snippetCtest_snippetKtest_snippetEtest_snippetTtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet-test_snippet>test_snippetrtest_snippetetest_snippetqtest_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippetstest_snippet test_snippet=test_snippet test_snippet(test_snippetftest_snippetotest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetatest_snippetdtest_snippet test_snippet?test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetOtest_snippetLtest_snippetLtest_snippetItest_snippetNtest_snippet test_snippet:test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetOtest_snippetLtest_snippetLtest_snippetOtest_snippetUtest_snippetTtest_snippet)test_snippet test_snippet|test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetOtest_snippetLtest_snippetLtest_snippetEtest_snippetRtest_snippetRtest_snippet test_snippet|test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetPtest_snippetOtest_snippetLtest_snippetLtest_snippetHtest_snippetUtest_snippetPtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet-test_snippet>test_snippetdtest_snippetetest_snippetstest_snippetctest_snippet.test_snippetstest_snippet test_snippet=test_snippet test_snippetstest_snippet[test_snippetitest_snippet]test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet-test_snippet>test_snippetptest_snippet test_snippet=test_snippet test_snippetptest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet-test_snippet>test_snippetctest_snippetltest_snippetitest_snippetetest_snippetntest_snippetttest_snippet_test_snippetdtest_snippetatest_snippetttest_snippetatest_snippet test_snippet=test_snippet test_snippetptest_snippetttest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetttest_snippetitest_snippetmtest_snippetetest_snippetotest_snippetutest_snippetttest_snippet test_snippet>test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetXtest_snippetXtest_snippetXtest_snippet:test_snippet test_snippet test_snippetTtest_snippethtest_snippetitest_snippetstest_snippet test_snippetctest_snippetatest_snippetntest_snippetctest_snippetetest_snippetltest_snippet test_snippetttest_snippetitest_snippetmtest_snippetetest_snippetrtest_snippet test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet test_snippetctest_snippetotest_snippetutest_snippetntest_snippetttest_snippet test_snippetftest_snippetitest_snippetrtest_snippetetest_snippet test_snippetbtest_snippetetest_snippetftest_snippetotest_snippetrtest_snippetetest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetptest_snippetotest_snippetltest_snippetltest_snippetstest_snippetetest_snippetttest_snippet test_snippetitest_snippetstest_snippet test_snippetutest_snippetptest_snippetdtest_snippetatest_snippetttest_snippetetest_snippetdtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetctest_snippetbtest_snippet-test_snippet>test_snippetctest_snippetatest_snippetntest_snippetctest_snippetetest_snippetltest_snippet_test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetttest_snippetitest_snippetmtest_snippetetest_snippetrtest_snippet_test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet(test_snippetttest_snippetitest_snippetmtest_snippetetest_snippetotest_snippetutest_snippetttest_snippet test_snippet+test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetttest_snippetitest_snippetmtest_snippetetest_snippet_test_snippetntest_snippetotest_snippetwtest_snippet(test_snippet)test_snippet,test_snippet test_snippetttest_snippetotest_snippetftest_snippetntest_snippet,test_snippet test_snippetbtest_snippetatest_snippetttest_snippetotest_snippetntest_snippet,test_snippet test_snippet1test_snippet,test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet test_snippetitest_snippet<test_snippetntest_snippetstest_snippetotest_snippetctest_snippetktest_snippet;test_snippet test_snippetitest_snippet+test_snippet+test_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippetstest_snippetetest_snippetttest_snippet_test_snippetatest_snippetdtest_snippetdtest_snippet(test_snippetetest_snippetvtest_snippetetest_snippetntest_snippetttest_snippet_test_snippetptest_snippetotest_snippetltest_snippetltest_snippetstest_snippetetest_snippetttest_snippet,test_snippet test_snippetptest_snippetftest_snippetdtest_snippetstest_snippet[test_snippetitest_snippet]test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetctest_snippet test_snippet!test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippetftest_snippetitest_snippetntest_snippetatest_snippetltest_snippet_test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetrtest_snippetctest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetftest_snippetitest_snippetntest_snippetatest_snippetltest_snippet_test_snippetrtest_snippetctest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_870eadde0693cead2d821b70ba4ec8c787c63641_0", {
    "ID": "httpd_870eadde0693cead2d821b70ba4ec8c787c63641_0",
    "UID": "3630",
    "code": "static apr_status_t event_resume_suspended (conn_rec *c) test_snippet\n    event_conn_state_t* cs = (event_conn_state_t*) c->suspended_baton;\n    if (cs == NULL) test_snippet\n        ap_log_cerror (APLOG_MARK, LOG_WARNING, 0, c, APLOGNO(02615)\n                \"event_resume_suspended: suspended_baton is NULL\");\n        return APR_EGENERAL;\n    } else if (!cs->suspended) test_snippet\n        ap_log_cerror (APLOG_MARK, LOG_WARNING, 0, c, APLOGNO(02616)\n                \"event_resume_suspended: Thread isn't suspended\");\n        return APR_EGENERAL;\n    }\n    apr_atomic_dec32(&suspended_count);\n    c->suspended_baton = NULL;\n\n    apr_thread_mutex_lock(timeout_mutex);\n    TO_QUEUE_APPEND(write_completion_q, cs);\n    cs->pfd.reqevents = (\n            cs->pub.sense == CONN_SENSE_WANT_READ ? APR_POLLIN :\n                    APR_POLLOUT) | APR_POLLHUP | APR_POLLERR;\n    cs->pub.sense = CONN_SENSE_DEFAULT;\n    apr_pollset_add(event_pollset, &cs->pfd);\n    apr_thread_mutex_unlock(timeout_mutex);\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e2f6ba98d5f52a7684e106a854b2f11369507ac5_0", {
    "ID": "httpd_e2f6ba98d5f52a7684e106a854b2f11369507ac5_0",
    "UID": "3636",
    "code": "cache_provider_list *cache_get_providers(request_rec test_snippet\n                                         cache_server_conf *conf)\n{\n    cache_dir_conf *dconf = ap_get_module_config(r->per_dir_config, &cache_module);\n    cache_provider_list *providers = NULL;\n    int i;\n\n    \n    if (dconf->disable) {\n        return NULL;\n    }\n\n    \n    for (i = 0; i < conf->cachedisable->nelts; i++) {\n        struct cache_disable *ent =\n                               (struct cache_disable *)conf->cachedisable->elts;\n        if (uri_meets_conditions(&ent[i].url, ent[i].pathlen, r)) {\n            \n            return NULL;\n        }\n    }\n\n    \n    for (i = 0; i < dconf->cacheenable->nelts; i++) {\n        struct cache_enable *ent =\n                                (struct cache_enable *)dconf->cacheenable->elts;\n        providers = get_provider(r, &ent[i], providers);\n    }\n\n    \n    for (i = 0; i < conf->cacheenable->nelts; i++) {\n        struct cache_enable *ent =\n                                (struct cache_enable *)conf->cacheenable->elts;\n        if (uri_meets_conditions(&ent[i].url, ent[i].pathlen, r)) {\n            providers = get_provider(r, &ent[i], providers);\n        }\n    }\n\n    return providers;\n}",
    "predicted": "476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_3b8cfbf4ca84cef8758c8dbd2c7a1c23ba876afe_0", {
    "ID": "httpd_3b8cfbf4ca84cef8758c8dbd2c7a1c23ba876afe_0",
    "UID": "3638",
    "code": "static int allowed_port(connect_conf *conf, int test_snippet\n{\n    int i;\n    port_range *list = (port_range *) conf->allowed_connect_ports->elts;\n\n    if (apr_is_empty_array(conf->allowed_connect_ports)) {\n        return port == APR_URI_HTTPS_DEFAULT_PORT\n               || port == APR_URI_SNEWS_DEFAULT_PORT;\n    }\n\n    for (i = 0; i < conf->allowed_connect_ports->nelts; i++) {\n        if (port >= list[i].first && port <= list[i].last)\n            return 1;\n    }\n    return 0;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_fc5c4bdd0a78c98ca25a5bf1f408264add9aa632_0", {
    "ID": "httpd_fc5c4bdd0a78c98ca25a5bf1f408264add9aa632_0",
    "UID": "3639",
    "code": "AP_DECLARE(int) ap_cstr_casecmp(const char *s1, const char test_snippet\n{\n    const unsigned char *str1 = (const unsigned char *)s1;\n    const unsigned char *str2 = (const unsigned char *)s2;\n    for (;;)\n    {\n        const int c1 = (int)(*str1);\n        const int c2 = (int)(*str2);\n        const int cmp = ucharmap[c1] - ucharmap[c2];\n        \n        if (cmp || !c1)\n            return cmp;\n        str1++;\n        str2++;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_73a4cca1e0de6cf6bd100b98e21ee2946e09b3fc_0", {
    "ID": "httpd_73a4cca1e0de6cf6bd100b98e21ee2946e09b3fc_0",
    "UID": "3641",
    "code": "AP_DECLARE(apr_status_t) ap_check_pipeline(conn_rec *c, apr_bucket_brigade test_snippet\n                                           unsigned int max_blank_lines)\n{\n    apr_status_t rv = APR_EOF;\n    ap_input_mode_t mode = AP_MODE_SPECULATIVE;\n    unsigned int num_blank_lines = 0;\n    apr_size_t cr = 0;\n    char buf[2];\n\n    while (c->keepalive != AP_CONN_CLOSE && !c->aborted) {\n        apr_size_t len = cr + 1;\n\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c->input_filters, bb, mode,\n                            APR_NONBLOCK_READ, len);\n        if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb) || !max_blank_lines) {\n            if (mode == AP_MODE_READBYTES) {\n                \n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(02967)\n                              \"Can't consume pipelined empty lines\");\n                c->keepalive = AP_CONN_CLOSE;\n                rv = APR_EGENERAL;\n            }\n            else if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n                if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n                    \n                    c->keepalive = AP_CONN_CLOSE;\n                }\n                else {\n                    \n                    rv = APR_EAGAIN;\n                }\n            }\n            else {\n                apr_off_t n = 0;\n                \n                rv = apr_brigade_length(bb, 0, &n);\n                if (rv == APR_SUCCESS && n <= 0) {\n                    rv = APR_EAGAIN;\n                }\n            }\n            break;\n        }\n\n        \n        rv = apr_brigade_flatten(bb, buf, &len);\n        if (rv != APR_SUCCESS || len != cr + 1) {\n            int log_level;\n            if (mode == AP_MODE_READBYTES) {\n                \n                c->keepalive = AP_CONN_CLOSE;\n                log_level = APLOG_ERR;\n                rv = APR_EGENERAL;\n            }\n            else {\n                /* Let outside (non-speculative/blocking) read determine\n                 * where this possible failure comes from (metadata,\n                 * morphed EOF socket, ...). Debug only here.\n                 */\n                log_level = APLOG_DEBUG;\n                rv = APR_SUCCESS;\n            }\n            ap_log_cerror(APLOG_MARK, log_level, rv, c, APLOGNO(02968)\n                          \"Can't check pipelined data\");\n            break;\n        }\n\n        if (mode == AP_MODE_READBYTES) {\n            \n            mode = AP_MODE_SPECULATIVE;\n            cr = 0;\n        }\n        else if (cr) {\n            AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n            if (buf[1] == APR_ASCII_LF) {\n                \n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else {\n                \n                break;\n            }\n        }\n        else {\n            if (buf[0] == APR_ASCII_LF) {\n                \n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else if (buf[0] == APR_ASCII_CR) {\n                cr = 1;\n            }\n            else {\n                \n                break;\n            }\n        }\n        if (num_blank_lines > max_blank_lines) {\n            /* Enough blank lines with this connection,\n             * stop and don't recycle it.\n             */\n            c->keepalive = AP_CONN_CLOSE;\n            rv = APR_NOTFOUND;\n            break;\n        }\n    }\n\n    return rv;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n253,Incorrect Check of Function Return Value"
  },
  "httpd_08bfddb03e8be02bbbd718a02556ce7c0a348da4_0", {
    "ID": "httpd_08bfddb03e8be02bbbd718a02556ce7c0a348da4_0",
    "UID": "3645",
    "code": "AP_DECLARE(void) ap_process_request_after_handler(request_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n    apr_status_t rv;\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    bb = apr_brigade_create(c->pool, c->bucket_alloc);\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    ap_pass_brigade(r->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occured before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    rv = ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n    c->data_in_input_filters = (rv == APR_SUCCESS);\n    apr_brigade_destroy(bb);\n\n    if (c->cs)\n        c->cs->state = (c->aborted) ? CONN_STATE_LINGER\n                                    : CONN_STATE_WRITE_COMPLETION;\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
    "predicted": "416,Use After Free"
  },
  "httpd_916ce950fd5808396ba75c950e9554a5fe682d41_0", {
    "ID": "httpd_916ce950fd5808396ba75c950e9554a5fe682d41_0",
    "UID": "3651",
    "code": "static apr_status_t cache_canonicalise_key(request_rec *r, apr_pool_t* test_snippet\n                                           const char *uri, const char *query,\n                                           apr_uri_t *parsed_uri,\n                                           const char **key)\n{\n    cache_server_conf *conf;\n    char *port_str, *hn, *lcs;\n    const char *hostname, *scheme;\n    int i;\n    const char *path;\n    char *querystring;\n\n    if (*key) {\n        /*\n         * We have been here before during the processing of this request.\n         */\n        return APR_SUCCESS;\n    }\n\n    /*\n     * Get the module configuration. We need this for the CacheIgnoreQueryString\n     * option below.\n     */\n    conf = (cache_server_conf *) ap_get_module_config(r->server->module_config,\n            &cache_module);\n\n    /*\n     * Use the canonical name to improve cache hit rate, but only if this is\n     * not a proxy request or if this is a reverse proxy request.\n     * We need to handle both cases in the same manner as for the reverse proxy\n     * case we have the following situation:\n     *\n     * If a cached entry is looked up by mod_cache's quick handler r->proxyreq\n     * is still unset in the reverse proxy case as it only gets set in the\n     * translate name hook (either by ProxyPass or mod_rewrite) which is run\n     * after the quick handler hook. This is different to the forward proxy\n     * case where it gets set before the quick handler is run (in the\n     * post_read_request hook).\n     * If a cache entry is created by the CACHE_SAVE filter we always have\n     * r->proxyreq set correctly.\n     * So we must ensure that in the reverse proxy case we use the same code\n     * path and using the canonical name seems to be the right thing to do\n     * in the reverse proxy case.\n     */\n    if (!r->proxyreq || (r->proxyreq == PROXYREQ_REVERSE)) {\n        if (conf->base_uri && conf->base_uri->hostname) {\n            hostname = conf->base_uri->hostname;\n        }\n        else {\n            \n            hostname = ap_get_server_name(r);\n            if (!hostname) {\n                hostname = \"_default_\";\n            }\n        }\n    }\n    else if (parsed_uri->hostname) {\n        \n        hn = apr_pstrdup(test_snippet parsed_uri->hostname);\n        ap_str_tolower(hn);\n        \n        hostname = hn;\n    }\n    else {\n        /* We are a proxied request, with no hostname. Unlikely\n         * to get very far - but just in case */\n        hostname = \"_default_\";\n    }\n\n    /*\n     * Copy the scheme, ensuring that it is lower case. If the parsed uri\n     * contains no string or if this is not a proxy request get the http\n     * scheme for this request. As r->parsed_uri.scheme is not set if this\n     * is a reverse proxy request, it is ensured that the cases\n     * \"no proxy request\" and \"reverse proxy request\" are handled in the same\n     * manner (see above why this is needed).\n     */\n    if (r->proxyreq && parsed_uri->scheme) {\n        \n        lcs = apr_pstrdup(test_snippet parsed_uri->scheme);\n        ap_str_tolower(lcs);\n        \n        scheme = lcs;\n    }\n    else {\n        if (conf->base_uri && conf->base_uri->scheme) {\n            scheme = conf->base_uri->scheme;\n        }\n        else {\n            scheme = ap_http_scheme(r);\n        }\n    }\n\n    /*\n     * If this is a proxy request, but not a reverse proxy request (see comment\n     * above why these cases must be handled in the same manner), copy the\n     * URI's port-string (which may be a service name). If the URI contains\n     * no port-string, use apr-util's notion of the default port for that\n     * scheme - if available. Otherwise use the port-number of the current\n     * server.\n     */\n    if (r->proxyreq && (r->proxyreq != PROXYREQ_REVERSE)) {\n        if (parsed_uri->port_str) {\n            port_str = apr_pcalloc(test_snippet strlen(parsed_uri->port_str) + 2);\n            port_str[0] = ':';\n            for (i = 0; parsed_uri->port_str[i]; i++) {\n                port_str[i + 1] = apr_tolower(parsed_uri->port_str[i]);\n            }\n        }\n        else if (apr_uri_port_of_scheme(scheme)) {\n            port_str = apr_psprintf(test_snippet \":%u\", apr_uri_port_of_scheme(scheme));\n        }\n        else {\n            /* No port string given in the AbsoluteUri, and we have no\n             * idea what the default port for the scheme is. Leave it\n             * blank and live with the inefficiency of some extra cached\n             * entities.\n             */\n            port_str = \"\";\n        }\n    }\n    else {\n        if (conf->base_uri && conf->base_uri->port_str) {\n            port_str = conf->base_uri->port_str;\n        }\n        else if (conf->base_uri && conf->base_uri->hostname) {\n            port_str = \"\";\n        }\n        else {\n            \n            port_str = apr_psprintf(test_snippet \":%u\", ap_get_server_port(r));\n        }\n    }\n\n    /*\n     * Check if we need to ignore session identifiers in the URL and do so\n     * if needed.\n     */\n    path = uri;\n    querystring = apr_pstrdup(test_snippet query ? query : parsed_uri->query);\n    if (conf->ignore_session_id->nelts) {\n        int i;\n        char **identifier;\n\n        identifier = (char **) conf->ignore_session_id->elts;\n        for (i = 0; i < conf->ignore_session_id->nelts; i++, identifier++) {\n            int len;\n            const char *param;\n\n            len = strlen(*identifier);\n            /*\n             * Check that we have a parameter separator in the last segment\n             * of the path and that the parameter matches our identifier\n             */\n            if ((param = ap_strrchr_c(path, ';'))\n                    && !strncmp(param + 1, *identifier, len)\n                    && (*(param + len + 1) == '=')\n                    && !ap_strchr_c(param + len + 2, '/')) {\n                path = apr_pstrmemdup(test_snippet path, param - path);\n                continue;\n            }\n            /*\n             * Check if the identifier is in the querystring and cut it out.\n             */\n            if (querystring && *querystring) {\n                /*\n                 * First check if the identifier is at the beginning of the\n                 * querystring and followed by a '='\n                 */\n                if (!strncmp(querystring, *identifier, len)\n                        && (*(querystring + len) == '=')) {\n                    param = querystring;\n                }\n                else {\n                    char *complete;\n\n                    /*\n                     * In order to avoid subkey matching (PR 48401) prepend\n                     * identifier with a '&' and append a '='\n                     */\n                    complete = apr_pstrcat(test_snippet \"&\", *identifier, \"=\", NULL);\n                    param = ap_strstr_c(querystring, complete);\n                    \n                    if (param) {\n                        param++;\n                    }\n                }\n                if (param) {\n                    const char *amp;\n\n                    if (querystring != param) {\n                        querystring = apr_pstrndup(test_snippet querystring,\n                                param - querystring);\n                    }\n                    else {\n                        querystring = \"\";\n                    }\n\n                    if ((amp = ap_strchr_c(param + len + 1, '&'))) {\n                        querystring = apr_pstrcat(test_snippet querystring, amp + 1,\n                                NULL);\n                    }\n                    else {\n                        /*\n                         * If querystring is not \"\", then we have the case\n                         * that the identifier parameter we removed was the\n                         * last one in the original querystring. Hence we have\n                         * a trailing '&' which needs to be removed.\n                         */\n                        if (*querystring) {\n                            querystring[strlen(querystring) - 1] = '\\0';\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    if (conf->ignorequerystring) {\n        *key = apr_pstrcat(test_snippet scheme, \"://\", hostname, port_str, path, \"?\",\n                NULL);\n    }\n    else {\n        *key = apr_pstrcat(test_snippet scheme, \"://\", hostname, port_str, path, \"?\",\n                querystring, NULL);\n    }\n\n    /*\n     * Store the key in the request_config for the cache as r->parsed_uri\n     * might have changed in the time from our first visit here triggered by the\n     * quick handler and our possible second visit triggered by the CACHE_SAVE\n     * filter (e.g. r->parsed_uri got unescaped). In this case we would save the\n     * resource in the cache under a key where it is never found by the quick\n     * handler during following requests.\n     */\n    ap_log_rerror(\n            APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00698) \"cache: Key for entity %s?%s is %s\", uri, parsed_uri->query, *key);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_62560f21126e1c5b5360a523a6586ff79d5d0bc4_0", {
    "ID": "httpd_62560f21126e1c5b5360a523a6586ff79d5d0bc4_0",
    "UID": "3652",
    "code": "static const char test_snippet\n    char *buf,\n    int bufsize,\n    const ap_macro_t * macro,\n    const apr_array_header_t * replacements,\n    apr_array_header_t * used)\n{\n    char *ptr = buf,\n        **atab = (char **) macro->arguments->elts,\n        **rtab = (char **) replacements->elts;\n    int whichone = -1;\n\n    if (used) {\n        ap_assert(used->nalloc >= replacements->nelts);\n    }\n    debug(fprintf(stderr, \"1# %s\", buf));\n\n    while ((ptr = next_substitution(ptr, macro->arguments, &whichone))) {\n        const char *errmsg = substitute(ptr, buf - ptr + bufsize,\n                                        atab[whichone], rtab[whichone],\n                                        atab[whichone][0] == ESCAPE_ARG);\n        if (errmsg) {\n            return errmsg;\n        }\n        ptr += strlen(rtab[whichone]);\n        if (used) {\n            used->elts[whichone] = 1;\n        }\n    }\n    debug(fprintf(stderr, \"2# %s\", buf));\n\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_24bc1f1abdbcc837a00dbe6e3e393fb7951deba8_0", {
    "ID": "httpd_24bc1f1abdbcc837a00dbe6e3e393fb7951deba8_0",
    "UID": "3673",
    "code": "AP_DECLARE(int) ap_find_token(apr_pool_t *p, const char *line, const char test_snippet\n{\n    const unsigned char *start_token;\n    const unsigned char *s;\n\n    if (!line)\n        return 0;\n\n    s = (const unsigned char *)line;\n    for (;;) {\n        /* find start of token, skip all stop characters, note NUL\n         * isn't a token stop, so we don't need to test for it\n         */\n        while (TEST_CHAR(*s, T_HTTP_TOKEN_STOP)) {\n            ++s;\n        }\n        if (!*s) {\n            return 0;\n        }\n        start_token = s;\n        \n        while (*s && !TEST_CHAR(*s, T_HTTP_TOKEN_STOP)) {\n            ++s;\n        }\n        if (!ap_cstr_casecmpn((const char *)start_token, (const char *)tok,\n                         s - start_token)) {\n            return 1;\n        }\n        if (!*s) {\n            return 0;\n        }\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_b5e3103f868b3a8ffc8455cb6420e3f4abd4a726_0", {
    "ID": "httpd_b5e3103f868b3a8ffc8455cb6420e3f4abd4a726_0",
    "UID": "3712",
    "code": "static void error_output_stream(request_rec *r, int test_snippet\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = ap_bucket_error_create(status, NULL, r->pool,\n            r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    ap_pass_brigade(r->output_filters, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_60402b174527bdfce882920bf6f0849d79019170_0", {
    "ID": "httpd_60402b174527bdfce882920bf6f0849d79019170_0",
    "UID": "3720",
    "code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec test_snippet\n{\n    worker_score *ws;\n    apr_off_t bytes;\n\n    if (!sb)\n        return;\n\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_4f9ca65f265bc7e60e36cb07722be8e37fceb33a_0", {
    "ID": "httpd_4f9ca65f265bc7e60e36cb07722be8e37fceb33a_0",
    "UID": "3721",
    "code": "static void copy_request(char *rbuf, apr_size_t rbuflen, request_rec test_snippet\n{\n    char *p;\n\n    if (r->the_request == NULL) {\n        apr_cpystrn(rbuf, \"NULL\", rbuflen);\n        return; \n    }\n\n    if (r->parsed_uri.password == NULL) {\n        p = r->the_request;\n    }\n    else {\n        \n        p = apr_pstrcat(r->pool, r->method, \" \",\n                        apr_uri_unparse(r->pool, &r->parsed_uri,\n                        APR_URI_UNP_OMITPASSWORD),\n                        r->assbackwards ? NULL : \" \", r->protocol, NULL);\n    }\n\n    \n    if (!ap_mod_status_reqtail) {\n        apr_cpystrn(rbuf, p, rbuflen);\n    }\n    else {\n        apr_size_t slen = strlen(p);\n        if (slen < rbuflen) {\n            \n            apr_cpystrn(rbuf, p, rbuflen);\n        }\n        else {\n            apr_cpystrn(rbuf, p+(slen-rbuflen+1), rbuflen);\n        }\n    }\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_6d7f99136cf8fc6f6e450d8053721823ea28968c_0", {
    "ID": "httpd_6d7f99136cf8fc6f6e450d8053721823ea28968c_0",
    "UID": "3725",
    "code": "AP_DECLARE(int) test_snippet\n{\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);\n\n    scoreboard_size  = SIZE_OF_global_score;\n    scoreboard_size += SIZE_OF_process_score * server_limit;\n    scoreboard_size += SIZE_OF_worker_score * server_limit * thread_limit;\n\n    return scoreboard_size;\n}",
    "predicted": "190,Integer Overflow or Wraparound"
  },
  "httpd_99b0ac1b3e485c81300d3f22b3e81a0238c3a1c2_0", {
    "ID": "httpd_99b0ac1b3e485c81300d3f22b3e81a0238c3a1c2_0",
    "UID": "3738",
    "code": "int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e test_snippet\n{\n    int i;\n#if APR_HAS_SHARED_MEMORY\n    apr_status_t rv;\n#endif\n\n    if (ap_scoreboard_image) {\n        ap_scoreboard_image->global->restart_time = apr_time_now();\n        memset(ap_scoreboard_image->parent, 0,\n               SIZE_OF_process_score * server_limit);\n        for (i = 0; i < server_limit; i++) {\n            memset(ap_scoreboard_image->servers[i], 0,\n                   SIZE_OF_worker_score * thread_limit);\n        }\n        ap_init_scoreboard(NULL);\n        return OK;\n    }\n\n    ap_calc_scoreboard_size();\n#if APR_HAS_SHARED_MEMORY\n    if (sb_type == SB_SHARED) {\n        void *sb_shared;\n        rv = open_scoreboard(p);\n        if (rv || !(sb_shared = apr_shm_baseaddr_get(ap_scoreboard_shm))) {\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        memset(sb_shared, 0, scoreboard_size);\n        ap_init_scoreboard(sb_shared);\n    }\n    else\n#endif\n    {\n        \n        void *sb_mem = ap_calloc(1, scoreboard_size);\n        ap_init_scoreboard(sb_mem);\n    }\n\n    scoreboard_type = sb_type;\n    ap_scoreboard_image->global->running_generation = 0;\n    ap_scoreboard_image->global->restart_time = apr_time_now();\n\n    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d14851126a513253dff73889c3f888b3ae6a46ad_0", {
    "ID": "httpd_d14851126a513253dff73889c3f888b3ae6a46ad_0",
    "UID": "3752",
    "code": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t test_snippet\n{\n\n    if ((f->bb) && !APR_BRIGADE_EMPTY(f->bb)) {\n        apr_brigade_cleanup(f->bb);\n    }\n\n    if (f->deferred_pool) {\n        apr_pool_destroy(f->deferred_pool);\n        f->deferred_pool = NULL;\n    }\n\n    remove_any_filter(f, f->r ? &f->r->output_filters : NULL,\n                      f->r ? &f->r->proto_output_filters : NULL,\n                      &f->c->output_filters);\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_d992aa77bed7779865311a7d31b16da1079d6490_0", {
    "ID": "httpd_d992aa77bed7779865311a7d31b16da1079d6490_0",
    "UID": "3753",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetctest_snippetotest_snippetptest_snippetytest_snippet_test_snippetstest_snippetctest_snippetotest_snippetrtest_snippetetest_snippetbtest_snippetotest_snippetatest_snippetrtest_snippetdtest_snippet_test_snippetwtest_snippetotest_snippetrtest_snippetktest_snippetetest_snippetrtest_snippet(test_snippetwtest_snippetotest_snippetrtest_snippetktest_snippetetest_snippetrtest_snippet_test_snippetstest_snippetctest_snippetotest_snippetrtest_snippetetest_snippet test_snippet*test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetctest_snippethtest_snippetitest_snippetltest_snippetdtest_snippet_test_snippetntest_snippetutest_snippetmtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetttest_snippethtest_snippetrtest_snippetetest_snippetatest_snippetdtest_snippet_test_snippetntest_snippetutest_snippetmtest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetwtest_snippetotest_snippetrtest_snippetktest_snippetetest_snippetrtest_snippet_test_snippetstest_snippetctest_snippetotest_snippetrtest_snippetetest_snippet test_snippet*test_snippetwtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetstest_snippetctest_snippetotest_snippetrtest_snippetetest_snippetbtest_snippetotest_snippetatest_snippetrtest_snippetdtest_snippet_test_snippetwtest_snippetotest_snippetrtest_snippetktest_snippetetest_snippetrtest_snippet_test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet_test_snippetitest_snippetntest_snippetdtest_snippetetest_snippetxtest_snippetetest_snippetstest_snippet(test_snippetctest_snippethtest_snippetitest_snippetltest_snippetdtest_snippet_test_snippetntest_snippetutest_snippetmtest_snippet,test_snippet test_snippetttest_snippethtest_snippetrtest_snippetetest_snippetatest_snippetdtest_snippet_test_snippetntest_snippetutest_snippetmtest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetmtest_snippetetest_snippetmtest_snippetctest_snippetptest_snippetytest_snippet(test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet,test_snippet test_snippetwtest_snippetstest_snippet,test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet test_snippet*test_snippetwtest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetFtest_snippetotest_snippetrtest_snippet test_snippetetest_snippetxtest_snippetttest_snippetrtest_snippetatest_snippet test_snippetstest_snippetatest_snippetftest_snippetetest_snippetttest_snippetytest_snippet,test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippet-test_snippetttest_snippetetest_snippetrtest_snippetmtest_snippetitest_snippetntest_snippetatest_snippetttest_snippetetest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippetstest_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippetetest_snippetdtest_snippet,test_snippet test_snippetttest_snippethtest_snippetotest_snippetutest_snippetgtest_snippethtest_snippet test_snippetitest_snippetttest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetstest_snippethtest_snippetotest_snippetutest_snippetltest_snippetdtest_snippet test_snippetbtest_snippetetest_snippet test_snippetttest_snippetrtest_snippetutest_snippetetest_snippet test_snippetttest_snippethtest_snippetotest_snippetstest_snippetetest_snippet test_snippetltest_snippetatest_snippetstest_snippetttest_snippet test_snippetbtest_snippetytest_snippetttest_snippetetest_snippetstest_snippet test_snippetatest_snippetrtest_snippetetest_snippet test_snippetatest_snippetltest_snippetwtest_snippetatest_snippetytest_snippetstest_snippet test_snippetztest_snippetetest_snippetrtest_snippetotest_snippet test_snippetatest_snippetntest_snippetytest_snippetwtest_snippetatest_snippetytest_snippet.test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetctest_snippetltest_snippetitest_snippetetest_snippetntest_snippetttest_snippet[test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetctest_snippetltest_snippetitest_snippetetest_snippetntest_snippetttest_snippet)test_snippet test_snippet-test_snippet test_snippet1test_snippet]test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet[test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet)test_snippet test_snippet-test_snippet test_snippet1test_snippet]test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetvtest_snippethtest_snippetotest_snippetstest_snippetttest_snippet[test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetdtest_snippetetest_snippetstest_snippetttest_snippet-test_snippet>test_snippetvtest_snippethtest_snippetotest_snippetstest_snippetttest_snippet)test_snippet test_snippet-test_snippet test_snippet1test_snippet]test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_b17b4893369f06eb2a058c314425da46fbd97a75_0", {
    "ID": "httpd_b17b4893369f06eb2a058c314425da46fbd97a75_0",
    "UID": "3756",
    "code": "static const char test_snippet\n     set_session_expiry_update(cmd_parms test_snippet parms, void test_snippetdconf, const char test_snippetarg)\n{\n    session_dir_conf test_snippetconf = dconf;\n\n    conf->expiry_update_time = atoi(arg);\n    if (conf->expiry_update_time < 0) {\n        return \"SessionExpiryUpdateInterval must be positive or nul\";\n    }\n    conf->expiry_update_time = apr_time_from_sec(conf->expiry_update_time);\n    conf->expiry_update_set = 1;\n\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_8e92321296ec4aa176c41adafe609528b1808606_0", {
    "ID": "httpd_8e92321296ec4aa176c41adafe609528b1808606_0",
    "UID": "3758",
    "code": "AP_DECLARE(apr_status_t) ap_filter_setaside_brigade(ap_filter_t test_snippet\n        apr_bucket_brigade *bb)\n{\n    int loglevel = ap_get_conn_module_loglevel(f->c, APLOG_MODULE_INDEX);\n\n    if (loglevel >= APLOG_TRACE6) {\n        ap_log_cerror(\n            APLOG_MARK, APLOG_TRACE6, 0, f->c,\n            \"setaside %s brigade to %s brigade in '%s' output filter\",\n            (APR_BRIGADE_EMPTY(bb) ? \"empty\" : \"full\"),\n            (!f->bb || APR_BRIGADE_EMPTY(f->bb) ? \"empty\" : \"full\"), f->frec->name);\n    }\n\n    if (!APR_BRIGADE_EMPTY(bb)) {\n        apr_pool_t *pool;\n        /*\n         * Set aside the brigade bb within f->bb.\n         */\n        if (!f->bb) {\n            ap_filter_t **key;\n\n            pool = f->r ? f->r->pool : f->c->pool;\n\n            key = apr_palloc(pool, sizeof(ap_filter_t **));\n            *key = f;\n            apr_hash_set(f->c->filters, key, sizeof(ap_filter_t **), f);\n\n            f->bb = apr_brigade_create(pool, f->c->bucket_alloc);\n\n            apr_pool_pre_cleanup_register(pool, key, filters_cleanup);\n\n        }\n\n        \n        if (f->r) {\n            apr_bucket *e;\n            for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb); e =\n                    APR_BUCKET_NEXT(e)) {\n                if (APR_BUCKET_IS_TRANSIENT(e)) {\n                    int rv = apr_bucket_setaside(e, f->r->pool);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n                }\n            }\n            pool = f->r->pool;\n            APR_BRIGADE_CONCAT(f->bb, bb);\n        }\n        else {\n            if (!f->deferred_pool) {\n                apr_pool_create(&f->deferred_pool, f->c->pool);\n                apr_pool_tag(f->deferred_pool, \"deferred_pool\");\n            }\n            pool = f->deferred_pool;\n            return ap_save_brigade(f, &f->bb, &bb, pool);\n        }\n\n    }\n    else if (f->deferred_pool) {\n        /*\n         * There are no more requests in the pipeline. We can just clear the\n         * pool.\n         */\n        apr_brigade_cleanup(f->bb);\n        apr_pool_clear(f->deferred_pool);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_e92ad32cbde7940b933b174c821f15a0a6930a29_0", {
    "ID": "httpd_e92ad32cbde7940b933b174c821f15a0a6930a29_0",
    "UID": "3761",
    "code": "AP_DECLARE(apr_status_t) ap_filter_reinstate_brigade(ap_filter_t test_snippet\n                                                     apr_bucket_brigade *bb,\n                                                     apr_bucket **flush_upto)\n{\n    apr_bucket *bucket, *next;\n    apr_size_t bytes_in_brigade, non_file_bytes_in_brigade;\n    int eor_buckets_in_brigade, morphing_bucket_in_brigade;\n    int loglevel = ap_get_conn_module_loglevel(f->c, APLOG_MODULE_INDEX);\n\n    if (loglevel >= APLOG_TRACE6) {\n        ap_log_cerror(\n            APLOG_MARK, APLOG_TRACE6, 0, f->c,\n            \"reinstate %s brigade to %s brigade in '%s' output filter\",\n            (!f->bb || APR_BRIGADE_EMPTY(f->bb) ? \"empty\" : \"full\"),\n            (APR_BRIGADE_EMPTY(bb) ? \"empty\" : \"full\"), f->frec->name);\n    }\n\n    if (f->bb && !APR_BRIGADE_EMPTY(f->bb)) {\n        APR_BRIGADE_PREPEND(bb, f->bb);\n    }\n\n    /*\n     * Determine if and up to which bucket we need to do a blocking write:\n     *\n     *  a) The brigade contains a flush bucket: Do a blocking write\n     *     of everything up that point.\n     *\n     *  b) The request is in CONN_STATE_HANDLER state, and the brigade\n     *     contains at least THRESHOLD_MAX_BUFFER bytes in non-file\n     *     buckets: Do blocking writes until the amount of data in the\n     *     buffer is less than THRESHOLD_MAX_BUFFER.  (The point of this\n     *     rule is to provide flow control, in case a handler is\n     *     streaming out lots of data faster than the data can be\n     *     sent to the client.)\n     *\n     *  c) The request is in CONN_STATE_HANDLER state, and the brigade\n     *     contains at least MAX_REQUESTS_IN_PIPELINE EOR buckets:\n     *     Do blocking writes until less than MAX_REQUESTS_IN_PIPELINE EOR\n     *     buckets are left. (The point of this rule is to prevent too many\n     *     FDs being kept open by pipelined requests, possibly allowing a\n     *     DoS).\n     *\n     *  d) The request is being served by a connection filter and the\n     *     brigade contains a morphing bucket: If there was no other\n     *     reason to do a blocking write yet, try reading the bucket. If its\n     *     contents fit into memory before THRESHOLD_MAX_BUFFER is reached,\n     *     everything is fine. Otherwise we need to do a blocking write the\n     *     up to and including the morphing bucket, because ap_save_brigade()\n     *     would read the whole bucket into memory later on.\n     */\n\n    *flush_upto = NULL;\n\n    bytes_in_brigade = 0;\n    non_file_bytes_in_brigade = 0;\n    eor_buckets_in_brigade = 0;\n    morphing_bucket_in_brigade = 0;\n\n    for (bucket = APR_BRIGADE_FIRST(bb); bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        next = APR_BUCKET_NEXT(bucket);\n\n        if (!APR_BUCKET_IS_METADATA(bucket)) {\n            if (bucket->length == (apr_size_t)-1) {\n                /*\n                 * A setaside of morphing buckets would read everything into\n                 * memory. Instead, we will flush everything up to and\n                 * including this bucket.\n                 */\n                morphing_bucket_in_brigade = 1;\n            }\n            else {\n                bytes_in_brigade += bucket->length;\n                if (!APR_BUCKET_IS_FILE(bucket))\n                    non_file_bytes_in_brigade += bucket->length;\n            }\n        }\n        else if (AP_BUCKET_IS_EOR(bucket)) {\n            eor_buckets_in_brigade++;\n        }\n\n        if (APR_BUCKET_IS_FLUSH(bucket)\n            || non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER\n            || (!f->r && morphing_bucket_in_brigade)\n            || eor_buckets_in_brigade > MAX_REQUESTS_IN_PIPELINE) {\n            \n\n            if (loglevel >= APLOG_TRACE6) {\n                char *reason = APR_BUCKET_IS_FLUSH(bucket) ?\n                               \"FLUSH bucket\" :\n                               (non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER) ?\n                               \"THRESHOLD_MAX_BUFFER\" :\n                               (!f->r && morphing_bucket_in_brigade) ? \"morphing bucket\" :\n                               \"MAX_REQUESTS_IN_PIPELINE\";\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, f->c,\n                              \"will flush because of %s\", reason);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, f->c,\n                              \"seen in brigade%s: bytes: %\" APR_SIZE_T_FMT\n                              \", non-file bytes: %\" APR_SIZE_T_FMT \", eor \"\n                              \"buckets: %d, morphing buckets: %d\",\n                              flush_upto == NULL ? \" so far\"\n                                                 : \" since last flush point\",\n                              bytes_in_brigade,\n                              non_file_bytes_in_brigade,\n                              eor_buckets_in_brigade,\n                              morphing_bucket_in_brigade);\n            }\n            /*\n             * Defer the actual blocking write to avoid doing many writes.\n             */\n            *flush_upto = next;\n\n            bytes_in_brigade = 0;\n            non_file_bytes_in_brigade = 0;\n            eor_buckets_in_brigade = 0;\n            morphing_bucket_in_brigade = 0;\n        }\n    }\n\n    if (loglevel >= APLOG_TRACE8) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, f->c,\n                      \"brigade contains: bytes: %\" APR_SIZE_T_FMT\n                      \", non-file bytes: %\" APR_SIZE_T_FMT\n                      \", eor buckets: %d, morphing buckets: %d\",\n                      bytes_in_brigade, non_file_bytes_in_brigade,\n                      eor_buckets_in_brigade, morphing_bucket_in_brigade);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_6f4f09a44553ed4741fe2110715446cada775df5_0", {
    "ID": "httpd_6f4f09a44553ed4741fe2110715446cada775df5_0",
    "UID": "3764",
    "code": "AP_DECLARE(int) ap_filter_should_yield(ap_filter_t test_snippet\n{\n    /*\n     * Handle the AsyncFilter directive. We limit the filters that are\n     * eligible for asynchronous handling here.\n     */\n    if (f->frec->ftype < f->c->async_filter) {\n        return 0;\n    }\n\n    /*\n     * This function decides whether a filter should yield due to buffered\n     * data in a downstream filter. If a downstream filter buffers we\n     * must back off so we don't overwhelm the server. If this function\n     * returns true, the filter should call ap_filter_setaside_brigade()\n     * to save unprocessed buckets, and then reinstate those buckets on\n     * the next call with ap_filter_reinstate_brigade() and continue\n     * where it left off.\n     *\n     * If this function is forced to return zero, we return back to\n     * synchronous filter behaviour.\n     *\n     * Subrequests present us with a problem - we don't know how much data\n     * they will produce and therefore how much buffering we'll need, and\n     * if a subrequest had to trigger buffering, but next subrequest wouldn't\n     * know when the previous one had finished sending data and buckets\n     * could be sent out of order.\n     *\n     * In the case of subrequests, deny the ability to yield. When the data\n     * reaches the filters from the main request, they will be setaside\n     * there in the right order and the request will be given the\n     * opportunity to yield.\n     */\n    if (f->r && f->r->main) {\n        return 0;\n    }\n\n    /*\n     * This is either a main request or internal redirect, or it is a\n     * connection filter. Yield if there is any buffered data downstream\n     * from us.\n     */\n    while (f) {\n        if (f->bb && !APR_BRIGADE_EMPTY(f->bb)) {\n            return 1;\n        }\n        f = f->next;\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_5c5e2f5378f9d715d763c94b2d7605bb6480af8a_0", {
    "ID": "httpd_5c5e2f5378f9d715d763c94b2d7605bb6480af8a_0",
    "UID": "3770",
    "code": "static timer_event_t * event_get_timer_event(apr_time_t test_snippet\n                                             ap_mpm_callback_fn_t *cbfn,\n                                             void *baton,\n                                             int insertest_snippet \n                                             apr_pollfd_t **remove)\n{\n    timer_event_t *te;\n    \n\n    apr_thread_mutex_lock(g_timer_skiplist_mtx);\n\n    if (!APR_RING_EMPTY(&timer_free_ring, timer_event_test_snippet link)) {\n        te = APR_RING_FIRST(&timer_free_ring);\n        APR_RING_REMOVE(te, link);\n    }\n    else {\n        te = apr_skiplist_alloc(timer_skiplistest_snippet sizeof(timer_event_t));\n        APR_RING_ELEM_INIT(te, link);\n    }\n\n    te->cbfunc = cbfn;\n    te->baton = baton;\n    te->canceled = 0;\n    te->when = t;\n    te->remove = remove;\n\n    if (insert) { \n        \n        apr_skiplist_insert(timer_skiplistest_snippet te);\n    }\n    apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n\n    return te;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_21b356b0849b2ab6ac41036b11e9a0a4a38d6521_0", {
    "ID": "httpd_21b356b0849b2ab6ac41036b11e9a0a4a38d6521_0",
    "UID": "3776",
    "code": "static void process_timeout_queue(struct timeout_queue test_snippet\n                                  apr_time_t timeout_time,\n                                  int (*func)(event_conn_state_t *))\n{\n    int total = 0, count;\n    event_conn_state_t *first, *cs, *last;\n    struct timeout_head_t trash;\n    struct timeout_queue *qp;\n    apr_status_t rv;\n\n    if (!*q->total) {\n        return;\n    }\n\n    APR_RING_INIT(&trash, event_conn_state_t, timeout_list);\n    for (qp = q; qp; qp = qp->next) {\n        count = 0;\n        cs = first = last = APR_RING_FIRST(&qp->head);\n        while (cs != APR_RING_SENTINEL(&qp->head, event_conn_state_t,\n                                       timeout_list)\n               /* Trash the entry if:\n                * - no timeout_time was given (asked for all), or\n                * - it expired (according to the queue timeout), or\n                * - the system clock skewed in the past: no entry should be\n                *   registered above the given timeout_time (~now) + the queue\n                *   timeout, we won't keep any here (eg. for centuries).\n                * Stop otherwise, no following entry will match thanks to the\n                * single timeout per queue (entries are added to the end!).\n                * This allows maintenance in O(1).\n                */\n               && (!timeout_time\n                   || cs->queue_timestamp + qp->timeout < timeout_time\n                   || cs->queue_timestamp > timeout_time + qp->timeout)) {\n            last = cs;\n            rv = apr_pollset_remove(event_pollset, &cs->pfd);\n            if (rv != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rv)) {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, cs->c, APLOGNO(00473)\n                              \"apr_pollset_remove failed\");\n            }\n            cs = APR_RING_NEXT(cs, timeout_list);\n            count++;\n        }\n        if (!count)\n            continue;\n\n        APR_RING_UNSPLICE(first, last, timeout_list);\n        APR_RING_SPLICE_TAIL(&trash, first, last, event_conn_state_t,\n                             timeout_list);\n        qp->count -= count;\n        total += count;\n    }\n    if (!total)\n        return;\n\n    AP_DEBUG_ASSERT(*q->total >= total);\n    *q->total -= total;\n    apr_thread_mutex_unlock(timeout_mutex);\n    first = APR_RING_FIRST(&trash);\n    do {\n        cs = APR_RING_NEXT(first, timeout_list);\n        TO_QUEUE_ELEM_INIT(first);\n        func(first);\n        first = cs;\n    } while (--total);\n    apr_thread_mutex_lock(timeout_mutex);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_c418ad3d6547f58921d0adeac9cfe06c2ab9536f_0", {
    "ID": "httpd_c418ad3d6547f58921d0adeac9cfe06c2ab9536f_0",
    "UID": "3784",
    "code": "AP_CORE_DECLARE(ap_conf_vector_t *) ap_merge_per_dir_configs(apr_pool_t test_snippet\n                                           ap_conf_vector_t *base,\n                                           ap_conf_vector_t *new_conf)\n{\n    void **conf_vector = apr_palloc(p, sizeof(void *) * conf_vector_length);\n    void **base_vector = (void **)base;\n    void **new_vector = (void **)new_conf;\n    int i;\n\n    for (i = 0; i < total_modules; i++) {\n        if (!new_vector[i]) {\n            conf_vector[i] = base_vector[i];\n        }\n        else {\n            const merger_func df = merger_func_cache[i];\n            if (df && base_vector[i]) {\n                conf_vector[i] = (*df)(p, base_vector[i], new_vector[i]);\n            }\n            else\n                conf_vector[i] = new_vector[i];\n        }\n    }\n\n    return (ap_conf_vector_t *)conf_vector;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_aba3c32680abe2c92e24768ba41ba16b17a87ffd_0", {
    "ID": "httpd_aba3c32680abe2c92e24768ba41ba16b17a87ffd_0",
    "UID": "3799",
    "code": "static int event_post_config(apr_pool_t *pconf, apr_pool_t test_snippet\n                             apr_pool_t *ptemp, server_rec *s)\n{\n    struct {\n        struct timeout_queue *tail, *q;\n        apr_hash_t *hash;\n    } wc, ka;\n\n    \n    if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG) {\n        return OK;\n    }\n\n    wc.tail = ka.tail = NULL;\n    wc.hash = apr_hash_make(ptemp);\n    ka.hash = apr_hash_make(ptemp);\n\n    TO_QUEUE_INIT(linger_q, pconf,\n                  apr_time_from_sec(MAX_SECS_TO_LINGER), NULL);\n    TO_QUEUE_INIT(short_linger_q, pconf,\n                  apr_time_from_sec(SECONDS_TO_LINGER), NULL);\n\n    for (; s; s = s->next) {\n        event_srv_cfg *sc = apr_pcalloc(pconf, sizeof *sc);\n\n        ap_set_module_config(s->module_config, &mpm_event_module, sc);\n        if (!wc.tail) {\n            \n            TO_QUEUE_INIT(wc.q, pconf, s->timeout, NULL);\n            apr_hash_set(wc.hash, &s->timeout, sizeof s->timeout, wc.q);\n            wc.tail = write_completion_q = wc.q;\n\n            TO_QUEUE_INIT(ka.q, pconf, s->keep_alive_timeout, NULL);\n            apr_hash_set(ka.hash, &s->keep_alive_timeout,\n                         sizeof s->keep_alive_timeout, ka.q);\n            ka.tail = keepalive_q = ka.q;\n        }\n        else {\n            /* The vhosts use any existing queue with the same timeout,\n             * or their own queue(s) if there isn't */\n            wc.q = apr_hash_get(wc.hash, &s->timeout, sizeof s->timeout);\n            if (!wc.q) {\n                TO_QUEUE_INIT(wc.q, pconf, s->timeout, wc.tail);\n                apr_hash_set(wc.hash, &s->timeout, sizeof s->timeout, wc.q);\n                wc.tail = wc.tail->next = wc.q;\n            }\n\n            ka.q = apr_hash_get(ka.hash, &s->keep_alive_timeout,\n                                sizeof s->keep_alive_timeout);\n            if (!ka.q) {\n                TO_QUEUE_INIT(ka.q, pconf, s->keep_alive_timeout, ka.tail);\n                apr_hash_set(ka.hash, &s->keep_alive_timeout,\n                             sizeof s->keep_alive_timeout, ka.q);\n                ka.tail = ka.tail->next = ka.q;\n            }\n        }\n        sc->wc_q = wc.q;\n        sc->ka_q = ka.q;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b91c2fd975856b18c3206d75de677cd9da4f9069_0", {
    "ID": "httpd_b91c2fd975856b18c3206d75de677cd9da4f9069_0",
    "UID": "3801",
    "code": "AP_DECLARE(void) ap_init_scoreboard(void test_snippet\n{\n    char *more_storage;\n    int i;\n\n    pfn_ap_logio_get_last_bytes = APR_RETRIEVE_OPTIONAL_FN(ap_logio_get_last_bytes);\n    if (!shared_score) {\n        return;\n    }\n    \n    ap_calc_scoreboard_size();\n    ap_scoreboard_image =\n        ap_calloc(1, SIZE_OF_scoreboard + server_limit * sizeof(worker_score *));\n    more_storage = shared_score;\n    ap_scoreboard_image->global = (global_score *)more_storage;\n    more_storage += SIZE_OF_global_score;\n    ap_scoreboard_image->parent = (process_score *)more_storage;\n    more_storage += SIZE_OF_process_score * server_limit;\n    ap_scoreboard_image->servers =\n        (worker_score **)((char*)ap_scoreboard_image + SIZE_OF_scoreboard);\n    for (i = 0; i < server_limit; i++) {\n        ap_scoreboard_image->servers[i] = (worker_score *)more_storage;\n        more_storage += thread_limit * SIZE_OF_worker_score;\n    }\n    ap_assert(more_storage == (char*)shared_score + scoreboard_size);\n    ap_scoreboard_image->global->server_limit = server_limit;\n    ap_scoreboard_image->global->thread_limit = thread_limit;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_506c7e17a3a57cdd0c8eb5b51038a1a2858a8e28_0", {
    "ID": "httpd_506c7e17a3a57cdd0c8eb5b51038a1a2858a8e28_0",
    "UID": "3809",
    "code": "static apr_size_t round_up(apr_size_t val, apr_off_t test_snippet\n{\n    if (round > 1) {\n        return (apr_size_t)(((val + round - 1) / test_snippet * test_snippet;\n    }\n    return val;\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n369,Divide By Zero"
  },
  "httpd_2c5e2b2360067c36a99560bac937980dd81e88a6_0", {
    "ID": "httpd_2c5e2b2360067c36a99560bac937980dd81e88a6_0",
    "UID": "3810",
    "code": "static int process_dir(char *path, apr_pool_t *pool, apr_off_t test_snippet\n{\n    apr_dir_t *dir;\n    apr_pool_t *p;\n    apr_hash_t *h;\n    apr_hash_index_t *i;\n    apr_file_t *fd;\n    apr_status_t status;\n    apr_finfo_t info;\n    apr_size_t len;\n    apr_time_t current, deviation;\n    char *nextpath, *base, *ext;\n    APR_RING_ENTRY(_direntry) anchor;\n    DIRENTRY *d, *t, *n;\n    ENTRY *e;\n    int skip, retries;\n    disk_cache_info_t disk_info;\n\n    APR_RING_INIT(&anchor, _direntry, link);\n    apr_pool_create(&p, pool);\n    h = apr_hash_make(p);\n    fd = NULL;\n    deviation = MAXDEVIATION * APR_USEC_PER_SEC;\n\n    if (apr_dir_open(&dir, path, p) != APR_SUCCESS) {\n        return 1;\n    }\n\n    while (apr_dir_read(&info, 0, dir) == APR_SUCCESS && !interrupted) {\n        if (!strcmp(info.name, \".\") || !strcmp(info.name, \"..\")) {\n            continue;\n        }\n        d = apr_pcalloc(p, sizeof(DIRENTRY));\n        d->basename = apr_pstrcat(p, path, \"/\", info.name, NULL);\n        APR_RING_INSERT_TAIL(&anchor, d, _direntry, link);\n        (test_snippet++;\n    }\n\n    apr_dir_close(dir);\n\n    if (interrupted) {\n        return 1;\n    }\n\n    skip = baselen + 1;\n\n    for (d = APR_RING_FIRST(&anchor);\n         !interrupted && d != APR_RING_SENTINEL(&anchor, _direntry, link);\n         d=n) {\n        n = APR_RING_NEXT(d, link);\n        base = strrchr(d->basename, '/');\n        if (!base++) {\n            base = d->basename;\n        }\n        ext = strchr(base, '.');\n\n        /* there may be temporary files which may be gone before\n         * processing, always skip these if not in realclean mode\n         */\n        if (!ext && !realclean) {\n            if (!strncasecmp(base, AP_TEMPFILE_BASE, AP_TEMPFILE_BASELEN)\n                && strlen(base) == AP_TEMPFILE_NAMELEN) {\n                continue;\n            }\n        }\n\n        /* this may look strange but apr_stat() may return an error which\n         * is system dependent and there may be transient failures,\n         * so just blindly retry for a short while\n         */\n        retries = STAT_ATTEMPTS;\n        status = APR_SUCCESS;\n        do {\n            if (status != APR_SUCCESS) {\n                apr_sleep(STAT_DELAY);\n            }\n            status = apr_stat(&info, d->basename, DIRINFO, p);\n        } while (status != APR_SUCCESS && !interrupted && --retries);\n\n        /* what may happen here is that apache did create a file which\n         * we did detect but then does delete the file before we can\n         * get file information, so if we don't get any file information\n         * we will ignore the file in this case\n         */\n        if (status != APR_SUCCESS) {\n            if (!realclean && !interrupted) {\n                continue;\n            }\n            return 1;\n        }\n\n        if (info.filetype == APR_DIR) {\n            if (process_dir(d->basename, pool, nodes)) {\n                return 1;\n            }\n            continue;\n        }\n\n        if (info.filetype != APR_REG) {\n            continue;\n        }\n\n        if (!ext) {\n            if (!strncasecmp(base, AP_TEMPFILE_BASE, AP_TEMPFILE_BASELEN)\n                && strlen(base) == AP_TEMPFILE_NAMELEN) {\n                d->basename += skip;\n                d->type = TEMP;\n                d->dsize = info.size;\n                apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n            }\n            continue;\n        }\n\n        if (!strcasecmp(ext, CACHE_HEADER_SUFFIX)) {\n            *ext = '\\0';\n            d->basename += skip;\n            \n            if (d->basename[0] == '\\0') {\n                continue;\n            }\n            t = apr_hash_get(h, d->basename, APR_HASH_KEY_STRING);\n            if (t) {\n                d = t;\n            }\n            d->type |= HEADER;\n            d->htime = info.mtime;\n            d->hsize = info.size;\n            apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n            continue;\n        }\n\n        if (!strcasecmp(ext, CACHE_DATA_SUFFIX)) {\n            *ext = '\\0';\n            d->basename += skip;\n            \n            if (d->basename[0] == '\\0') {\n                continue;\n            }\n            t = apr_hash_get(h, d->basename, APR_HASH_KEY_STRING);\n            if (t) {\n                d = t;\n            }\n            d->type |= DATA;\n            d->dtime = info.mtime;\n            d->dsize = info.size;\n            apr_hash_set(h, d->basename, APR_HASH_KEY_STRING, d);\n        }\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    path[baselen] = '\\0';\n\n    for (i = apr_hash_first(p, h); i && !interrupted; i = apr_hash_next(i)) {\n        void *hvalue;\n        apr_uint32_t format;\n\n        apr_hash_this(i, NULL, NULL, &hvalue);\n        d = hvalue;\n\n        switch(d->type) {\n        case HEADERDATA:\n            nextpath = apr_pstrcat(p, path, \"/\", d->basename,\n                                   CACHE_HEADER_SUFFIX, NULL);\n            if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY,\n                              APR_OS_DEFAULT, p) == APR_SUCCESS) {\n                len = sizeof(format);\n                if (apr_file_read_full(fd, &format, len,\n                                       &len) == APR_SUCCESS) {\n                    if (format == DISK_FORMAT_VERSION) {\n                        apr_off_t offset = 0;\n\n                        apr_file_seek(fd, APR_SET, &offset);\n\n                        len = sizeof(disk_cache_info_t);\n\n                        if (apr_file_read_full(fd, &disk_info, len,\n                                               &len) == APR_SUCCESS) {\n                            apr_file_close(fd);\n                            e = apr_palloc(pool, sizeof(ENTRY));\n                            APR_RING_INSERT_TAIL(&root, e, _entry, link);\n                            e->expire = disk_info.expire;\n                            e->response_time = disk_info.response_time;\n                            e->htime = d->htime;\n                            e->dtime = d->dtime;\n                            e->hsize = d->hsize;\n                            e->dsize = d->dsize;\n                            e->basename = apr_pstrdup(pool, d->basename);\n                            if (!disk_info.has_body) {\n                                delete_file(path, apr_pstrcat(p, path, \"/\",\n                                        d->basename, CACHE_DATA_SUFFIX, NULL),\n                                        nodes, p);\n                            }\n                            break;\n                        }\n                        else {\n                            apr_file_close(fd);\n                        }\n                    }\n                    else if (format == VARY_FORMAT_VERSION) {\n                        apr_finfo_t finfo;\n\n                        /* This must be a URL that added Vary headers later,\n                         * so kill the orphaned .data file\n                         */\n                        apr_file_close(fd);\n\n                        if (apr_stat(&finfo, apr_pstrcat(p, nextpath,\n                                CACHE_VDIR_SUFFIX, NULL), APR_FINFO_TYPE, p)\n                                || finfo.filetype != APR_DIR) {\n                            delete_entry(path, d->basename, nodes, p);\n                        }\n                        else {\n                            delete_file(path, apr_pstrcat(p, path, \"/\",\n                                    d->basename, CACHE_DATA_SUFFIX, NULL),\n                                    nodes, p);\n                        }\n                        break;\n                    }\n                    else {\n                        \n                        apr_file_close(fd);\n                        delete_entry(path, d->basename, nodes, p);\n                        break;\n                    }\n                }\n                else {\n                    apr_file_close(fd);\n                }\n\n            }\n            /* we have a somehow unreadable headers file which is associated\n             * with a data file. this may be caused by apache currently\n             * rewriting the headers file. thus we may delete the file set\n             * either in realclean mode or if the headers file modification\n             * timestamp is not within a specified positive or negative offset\n             * to the current time.\n             */\n            current = apr_time_now();\n            if (realclean || d->htime < current - deviation\n                || d->htime > current + deviation) {\n                delete_entry(path, d->basename, nodes, p);\n                unsolicited += d->hsize;\n                unsolicited += d->dsize;\n            }\n            break;\n\n        /* single data and header files may be deleted either in realclean\n         * mode or if their modification timestamp is not within a\n         * specified positive or negative offset to the current time.\n         * this handling is necessary due to possible race conditions\n         * between apache and this process\n         */\n        case HEADER:\n            current = apr_time_now();\n            nextpath = apr_pstrcat(p, path, \"/\", d->basename,\n                                   CACHE_HEADER_SUFFIX, NULL);\n            if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY,\n                              APR_OS_DEFAULT, p) == APR_SUCCESS) {\n                len = sizeof(format);\n                if (apr_file_read_full(fd, &format, len,\n                                       &len) == APR_SUCCESS) {\n                    if (format == VARY_FORMAT_VERSION) {\n                        apr_time_t expires;\n\n                        len = sizeof(expires);\n\n                        if (apr_file_read_full(fd, &expires, len,\n                                               &len) == APR_SUCCESS) {\n                            apr_finfo_t finfo;\n\n                            apr_file_close(fd);\n\n                            if (apr_stat(&finfo, apr_pstrcat(p, nextpath,\n                                    CACHE_VDIR_SUFFIX, NULL), APR_FINFO_TYPE, p)\n                                    || finfo.filetype != APR_DIR) {\n                                delete_entry(path, d->basename, nodes, p);\n                            }\n                            else if (expires < current) {\n                                delete_entry(path, d->basename, nodes, p);\n                            }\n\n                            break;\n                        }\n                    }\n                    else if (format == DISK_FORMAT_VERSION) {\n                        apr_off_t offset = 0;\n\n                        apr_file_seek(fd, APR_SET, &offset);\n\n                        len = sizeof(disk_cache_info_t);\n\n                        if (apr_file_read_full(fd, &disk_info, len,\n                                               &len) == APR_SUCCESS) {\n                            apr_file_close(fd);\n                            e = apr_palloc(pool, sizeof(ENTRY));\n                            APR_RING_INSERT_TAIL(&root, e, _entry, link);\n                            e->expire = disk_info.expire;\n                            e->response_time = disk_info.response_time;\n                            e->htime = d->htime;\n                            e->dtime = d->dtime;\n                            e->hsize = d->hsize;\n                            e->dsize = d->dsize;\n                            e->basename = apr_pstrdup(pool, d->basename);\n                            break;\n                        }\n                        else {\n                            apr_file_close(fd);\n                        }\n                    }\n                    else {\n                        apr_file_close(fd);\n                        delete_entry(path, d->basename, nodes, p);\n                        break;\n                    }\n                }\n                else {\n                    apr_file_close(fd);\n                }\n            }\n\n            if (realclean || d->htime < current - deviation\n                || d->htime > current + deviation) {\n                delete_entry(path, d->basename, nodes, p);\n                unsolicited += d->hsize;\n            }\n            break;\n\n        case DATA:\n            current = apr_time_now();\n            if (realclean || d->dtime < current - deviation\n                || d->dtime > current + deviation) {\n                delete_entry(path, d->basename, nodes, p);\n                unsolicited += d->dsize;\n            }\n            break;\n\n        /* temp files may only be deleted in realclean mode which\n         * is asserted above if a tempfile is in the hash array\n         */\n        case TEMP:\n            delete_file(path, d->basename, nodes, p);\n            unsolicited += d->dsize;\n            break;\n        }\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    apr_pool_destroy(p);\n\n    if (benice) {\n        apr_sleep(NICE_DELAY);\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_3ef3741fae58cc35d9ed362504c8ef5eb6e0e44e_0", {
    "ID": "httpd_3ef3741fae58cc35d9ed362504c8ef5eb6e0e44e_0",
    "UID": "3811",
    "code": "static void purge(char *path, apr_pool_t *pool, apr_off_t test_snippet\n        apr_off_t inodes, apr_off_t nodes, apr_off_t round)\n{\n    ENTRY *e, *n, *oldest;\n\n    struct stats s;\n    s.sum = 0;\n    s.entries = 0;\n    s.dfuture = 0;\n    s.dexpired = 0;\n    s.dfresh = 0;\n    s.max = max;\n    s.nodes = nodes;\n    s.inodes = inodes;\n    s.ntotal = nodes;\n\n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link);\n         e = APR_RING_NEXT(e, link)) {\n        s.sum += round_up((apr_size_t)e->hsize, round);\n        s.sum += round_up((apr_size_t)e->dsize, round);\n        s.entries++;\n    }\n\n    s.total = s.sum;\n    s.etotal = s.entries;\n\n    if ((!s.max || s.sum <= s.max) && (!s.inodes || s.nodes <= s.inodes)) {\n        printstats(path, &s);\n        return;\n    }\n\n    /* process all entries with a timestamp in the future, this may\n     * happen if a wrong system time is corrected\n     */\n\n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link) && !interrupted;) {\n        n = APR_RING_NEXT(e, link);\n        if (e->response_time > now || e->htime > now || e->dtime > now) {\n            delete_entry(path, e->basename, &s.nodes, pool);\n            s.sum -= round_up((apr_size_t)e->hsize, round);\n            s.sum -= round_up((apr_size_t)e->dsize, round);\n            s.entries--;\n            s.dfuture++;\n            APR_RING_REMOVE(e, link);\n            if ((!s.max || s.sum <= s.max) && (!s.inodes || s.nodes <= s.inodes)) {\n                if (!interrupted) {\n                    printstats(path, &s);\n                }\n                return;\n            }\n        }\n        e = n;\n    }\n\n    if (interrupted) {\n        return;\n    }\n\n    \n    for (e = APR_RING_FIRST(&root);\n         e != APR_RING_SENTINEL(&root, _entry, link) && !interrupted;) {\n        n = APR_RING_NEXT(e, link);\n        if (e->expire != APR_DATE_BAD && e->expire < now) {\n            delete_entry(path, e->basename, &s.nodes, pool);\n            s.sum -= round_up((apr_size_t)e->hsize, round);\n            s.sum -= round_up((apr_size_t)e->dsize, round);\n            s.entries--;\n            s.dexpired++;\n            APR_RING_REMOVE(e, link);\n            if ((!s.max || s.sum <= s.max) && (!s.inodes || s.nodes <= s.inodes)) {\n                if (!interrupted) {\n                    printstats(path, &s);\n                }\n                return;\n            }\n        }\n        e = n;\n    }\n\n    if (interrupted) {\n         return;\n    }\n\n    /* process remaining entries oldest to newest, the check for an empty\n     * ring actually isn't necessary except when the compiler does\n     * corrupt 64bit arithmetics which happened to me once, so better safe\n     * than sorry\n     */\n    while (!((!s.max || s.sum <= s.max) && (!s.inodes || s.nodes <= s.inodes))\n            && !interrupted && !APR_RING_EMPTY(&root, _entry, link)) {\n        oldest = APR_RING_FIRST(&root);\n\n        for (e = APR_RING_NEXT(oldest, link);\n             e != APR_RING_SENTINEL(&root, _entry, link);\n             e = APR_RING_NEXT(e, link)) {\n            if (e->dtime < oldest->dtime) {\n                oldest = e;\n            }\n        }\n\n        delete_entry(path, oldest->basename, &s.nodes, pool);\n        s.sum -= round_up((apr_size_t)oldest->hsize, round);\n        s.sum -= round_up((apr_size_t)oldest->dsize, round);\n        s.entries--;\n        s.dfresh++;\n        APR_RING_REMOVE(oldest, link);\n    }\n\n    if (!interrupted) {\n        printstats(path, &s);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e3fb94fab590c789d886a8c1a17753744bddcc14_0", {
    "ID": "httpd_e3fb94fab590c789d886a8c1a17753744bddcc14_0",
    "UID": "3814",
    "code": "AP_DECLARE(apr_size_t) ap_fcgi_encoded_env_len(apr_table_t test_snippet\n                                               apr_size_t maxlen,\n                                               int *starting_elem)\n{\n    const apr_array_header_t *envarr;\n    const apr_table_entry_t *elts;\n    apr_size_t envlen, actualenvlen;\n    int i;\n\n    if (maxlen > AP_FCGI_MAX_CONTENT_LEN) {\n        maxlen = AP_FCGI_MAX_CONTENT_LEN;\n    }\n\n    envarr = apr_table_elts(env);\n    elts = (const apr_table_entry_t *) envarr->elts;\n\n    /* envlen - speculative, may overflow the limit\n     * actualenvlen - len required without overflowing\n     */\n    envlen = actualenvlen = 0;\n    for (i = *starting_elem; i < envarr->nelts; ) {\n        apr_size_t keylen, vallen;\n\n        if (!elts[i].key) {\n            (*starting_elem)++;\n            i++;\n            continue;\n        }\n\n        keylen = strlen(elts[i].key);\n\n        if (keylen >> 7 == 0) {\n            envlen += 1;\n        }\n        else {\n            envlen += 4;\n        }\n\n        envlen += keylen;\n\n        vallen = elts[i].val ? strlen(elts[i].val) : 0;\n\n        if (vallen >> 7 == 0) {\n            envlen += 1;\n        }\n        else {\n            envlen += 4;\n        }\n\n        envlen += vallen;\n\n        if (envlen > maxlen) {\n            break;\n        }\n\n        actualenvlen = envlen;\n        (*starting_elem)++;\n        i++;\n    }\n\n    return actualenvlen;\n}",
    "predicted": "476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound"
  },
  "httpd_2ecb723e9721e457a9221d41dcd660de85268ba4_0", {
    "ID": "httpd_2ecb723e9721e457a9221d41dcd660de85268ba4_0",
    "UID": "3815",
    "code": "AP_DECLARE(apr_status_t) ap_fcgi_encode_env(request_rec test_snippet\n                                            apr_table_t *env,\n                                            void *buffer,\n                                            apr_size_t buflen,\n                                            int *starting_elem)\n{\n    apr_status_t rv = APR_SUCCESS;\n    const apr_array_header_t *envarr;\n    const apr_table_entry_t *elts;\n    char *itr;\n    int i;\n\n    envarr = apr_table_elts(env);\n    elts = (const apr_table_entry_t *) envarr->elts;\n\n    itr = buffer;\n\n    for (i = *starting_elem; i < envarr->nelts; ) {\n        apr_size_t keylen, vallen;\n\n        if (!elts[i].key) {\n            (*starting_elem)++;\n            i++;\n            continue;\n        }\n\n        keylen = strlen(elts[i].key);\n\n        if (keylen >> 7 == 0) {\n            if (buflen < 1) {\n                rv = APR_ENOSPC; \n                break;\n            }\n            itr[0] = keylen & 0xff;\n            itr += 1;\n            buflen -= 1;\n        }\n        else {\n            if (buflen < 4) {\n                rv = APR_ENOSPC; \n                break;\n            }\n            itr[0] = ((keylen >> 24) & 0xff) | 0x80;\n            itr[1] = ((keylen >> 16) & 0xff);\n            itr[2] = ((keylen >> 8) & 0xff);\n            itr[3] = ((keylen) & 0xff);\n            itr += 4;\n            buflen -= 4;\n        }\n\n        vallen = elts[i].val ? strlen(elts[i].val) : 0;\n\n        if (vallen >> 7 == 0) {\n            if (buflen < 1) {\n                rv = APR_ENOSPC; \n                break;\n            }\n            itr[0] = vallen & 0xff;\n            itr += 1;\n            buflen -= 1;\n        }\n        else {\n            if (buflen < 4) {\n                rv = APR_ENOSPC; \n                break;\n            }\n            itr[0] = ((vallen >> 24) & 0xff) | 0x80;\n            itr[1] = ((vallen >> 16) & 0xff);\n            itr[2] = ((vallen >> 8) & 0xff);\n            itr[3] = ((vallen) & 0xff);\n            itr += 4;\n            buflen -= 4;\n        }\n\n        if (buflen < keylen) {\n            rv = APR_ENOSPC; \n            break;\n        }\n        memcpy(itr, elts[i].key, keylen);\n        itr += keylen;\n        buflen -= keylen;\n\n        if (buflen < vallen) {\n            rv = APR_ENOSPC; \n            break;\n        }\n\n        if (elts[i].val) {\n            memcpy(itr, elts[i].val, vallen);\n            itr += vallen;\n        }\n\n        if (buflen == vallen) {\n            (*starting_elem)++;\n            i++;\n            break; \n        }\n\n        buflen -= vallen;\n\n        (*starting_elem)++;\n        i++;\n    }\n\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02492)\n                      \"ap_fcgi_encode_env: out of space \"\n                      \"encoding environment\");\n    }\n\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_8e18373322560e4c7da24d5a10916b44e20ea498_0", {
    "ID": "httpd_8e18373322560e4c7da24d5a10916b44e20ea498_0",
    "UID": "3833",
    "code": "static apr_status_t reqtimeout_filter(ap_filter_t test_snippet\n                                      apr_bucket_brigade *bb,\n                                      ap_input_mode_t mode,\n                                      apr_read_type_e block,\n                                      apr_off_t readbytes)\n{\n    apr_time_t time_left;\n    apr_time_t now = 0;\n    apr_status_t rv;\n    apr_interval_time_t saved_sock_timeout = UNSET;\n    reqtimeout_con_cfg *ccfg = f->ctx;\n\n    if (ccfg->in_keep_alive) {\n        \n        ccfg->in_keep_alive = 0;\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (block == APR_NONBLOCK_READ && mode == AP_MODE_SPECULATIVE) { \n        /*  The source of these above us in the core is check_pipeline(), which\n         *  is between requests but before this filter knows to reset timeouts \n         *  during log_transaction().  If they appear elsewhere, just don't \n         *  check or extend the time since they won't block and we'll see the\n         *  bytes again later\n         */\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (ccfg->new_timeout > 0) {\n        \n        now = apr_time_now();\n        ccfg->timeout_at = now + apr_time_from_sec(ccfg->new_timeout);\n        ccfg->new_timeout = 0;\n        if (ccfg->new_max_timeout > 0) {\n            ccfg->max_timeout_at = now + apr_time_from_sec(ccfg->new_max_timeout);\n            ccfg->new_max_timeout = 0;\n        }\n    }\n    else if (ccfg->timeout_at == 0) {\n        \n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (!ccfg->socket) {\n        ccfg->socket = ap_get_conn_socket(f->c);\n    }\n\n    rv = check_time_left(ccfg, &time_left, now);\n    if (rv != APR_SUCCESS)\n        goto out;\n\n    if (block == APR_NONBLOCK_READ || mode == AP_MODE_INIT\n        || mode == AP_MODE_EATCRLF) {\n        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {\n            extend_timeout(ccfg, bb);\n        }\n        return rv;\n    }\n\n    rv = apr_socket_timeout_get(ccfg->socket, &saved_sock_timeout);\n    AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n\n    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));\n    AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n\n    if (mode == AP_MODE_GETLINE) {\n        /*\n         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()\n         * would loop until a whole line has been read. As this would make it\n         * impossible to enforce a total timeout, we only do non-blocking\n         * reads.\n         */\n        apr_off_t remaining = HUGE_STRING_LEN;\n        do {\n            apr_off_t bblen;\n#if APR_MAJOR_VERSION < 2\n            apr_int32_t nsds;\n            apr_interval_time_t poll_timeout;\n            apr_pollfd_t pollset;\n#endif\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);\n            if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n                break;\n            }\n\n            if (!APR_BRIGADE_EMPTY(bb)) {\n                if (ccfg->min_rate > 0) {\n                    extend_timeout(ccfg, bb);\n                }\n\n                rv = have_lf_or_eos(bb);\n                if (rv != APR_INCOMPLETE) {\n                    break;\n                }\n\n                rv = apr_brigade_length(bb, 1, &bblen);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n                remaining -= bblen;\n                if (remaining <= 0) {\n                    break;\n                }\n\n                \n                if (!ccfg->tmpbb) {\n                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);\n                }\n                rv = brigade_append(ccfg->tmpbb, bb);\n                if (rv != APR_SUCCESS)\n                    break;\n            }\n\n            \n#if APR_MAJOR_VERSION < 2\n            pollset.p = f->c->pool;\n            pollset.desc_type = APR_POLL_SOCKET;\n            pollset.reqevents = APR_POLLIN|APR_POLLHUP;\n            pollset.desc.s = ccfg->socket;\n            apr_socket_timeout_get(ccfg->socket, &poll_timeout);\n            rv = apr_poll(&pollset, 1, &nsds, poll_timeout);\n#else\n            rv = apr_socket_wait(ccfg->socket, APR_WAIT_READ);\n#endif\n            if (rv != APR_SUCCESS)\n                break;\n\n            rv = check_time_left(ccfg, &time_left, 0);\n            if (rv != APR_SUCCESS)\n                break;\n\n            rv = apr_socket_timeout_set(ccfg->socket,\n                                   MIN(time_left, saved_sock_timeout));\n            AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n\n        } while (1);\n\n        if (ccfg->tmpbb)\n            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);\n\n    }\n    else {\n        \n        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {\n            extend_timeout(ccfg, bb);\n        }\n    }\n\n    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);\n\nout:\n    if (APR_STATUS_IS_TIMEUP(rv)) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01382)\n                      \"Request %s read timeout\", ccfg->type);\n        /*\n         * If we allow a normal lingering close, the client may keep this\n         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).\n         * Therefore we tell ap_lingering_close() to shorten this period to\n         * 2s (SECONDS_TO_LINGER).\n         */\n        apr_table_setn(f->c->notes, \"short-lingering-close\", \"1\");\n\n        /*\n         * Also, we must not allow keep-alive requests, as\n         * ap_finalize_protocol() may ignore our error status (if the timeout\n         * happened on a request body that is discarded).\n         */\n        f->c->keepalive = AP_CONN_CLOSE;\n    }\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_e9396a27c3fc966a53bff7daf31d5168a77260bf_0", {
    "ID": "httpd_e9396a27c3fc966a53bff7daf31d5168a77260bf_0",
    "UID": "3834",
    "code": "static const char *ap_expr_eval_word(ap_expr_eval_ctx_t test_snippet\n                                     const ap_expr_t *node)\n{\n    const char *result = \"\";\n    if (inc_rec(ctx))\n        return result;\n    switch (node->node_op) {\n    case op_Digit:\n    case op_String:\n        result = node->node_arg1;\n        break;\n    case op_Var:\n        result = ap_expr_eval_var(ctx, (ap_expr_var_func_t *)node->node_arg1,\n                                  node->node_arg2);\n        break;\n    case op_Concat:\n        if (((ap_expr_t *)node->node_arg2)->node_op != op_Concat) {\n            const char *s1 = ap_expr_eval_word(ctx, node->node_arg1);\n            const char *s2 = ap_expr_eval_word(ctx, node->node_arg2);\n            if (!*s1)\n                result = s2;\n            else if (!*s2)\n                result = s1;\n            else\n                result = apr_pstrcat(ctx->p, s1, s2, NULL);\n        }\n        else {\n            const ap_expr_t *nodep = node;\n            int i = 1;\n            struct iovec *vec;\n            do {\n                nodep = nodep->node_arg2;\n                i++;\n            } while (nodep->node_op == op_Concat);\n            vec = apr_palloc(ctx->p, i * sizeof(struct iovec));\n            nodep = node;\n            i = 0;\n            do {\n                vec[i].iov_base = (void *)ap_expr_eval_word(ctx,\n                                                            nodep->node_arg1);\n                vec[i].iov_len = strlen(vec[i].iov_base);\n                i++;\n                nodep = nodep->node_arg2;\n            } while (nodep->node_op == op_Concat);\n            vec[i].iov_base = (void *)ap_expr_eval_word(ctx, nodep);\n            vec[i].iov_len = strlen(vec[i].iov_base);\n            i++;\n            result = apr_pstrcatv(ctx->p, vec, i, NULL);\n        }\n        break;\n    case op_StringFuncCall: {\n        const ap_expr_t *info = node->node_arg1;\n        const ap_expr_t *args = node->node_arg2;\n        result = ap_expr_eval_string_func(ctx, info, args);\n        break;\n    }\n    case op_RegexBackref: {\n        const unsigned int *np = node->node_arg1;\n        result = ap_expr_eval_re_backref(ctx, *np);\n        break;\n    }\n    default:\n        *ctx->err = \"Internal evaluation error: Unknown word expression node\";\n        break;\n    }\n    if (!result)\n        result = \"\";\n    ctx->reclvl--;\n    return result;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n122,Heap-based Buffer Overflow"
  },
  "httpd_1795cb007a8a44becb32ea3c42e66b9d86fd3491_0", {
    "ID": "httpd_1795cb007a8a44becb32ea3c42e66b9d86fd3491_0",
    "UID": "3836",
    "code": "static void consume_buffer(deflate_ctx *ctx, deflate_filter_config test_snippet\n                           int len, int crc, apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n\n    /*\n     * Do we need to update ctx->crc? Usually this is the case for\n     * inflate action where we need to do a crc on the output, whereas\n     * in the deflate case we need to do a crc on the input\n     */\n    if (crc) {\n        ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n    }\n\n    b = apr_bucket_heap_create((char *)ctx->buffer, len, NULL,\n                               bb->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    ctx->stream.next_out = ctx->buffer;\n    ctx->stream.avail_out = c->bufferSize;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_cdb3dddd444c790a2e7c8dd0897c8e4edbddfc1a_0", {
    "ID": "httpd_cdb3dddd444c790a2e7c8dd0897c8e4edbddfc1a_0",
    "UID": "3837",
    "code": "static int flush_libz_buffer(deflate_ctx *ctx, deflate_filter_config test_snippet\n                             int (*libz_func)(z_streamp, int), int flush,\n                             int crc)\n{\n    int zRC = Z_OK;\n    int done = 0;\n    int deflate_len;\n\n    for (;;) {\n         deflate_len = c->bufferSize - ctx->stream.avail_out;\n         if (deflate_len > 0) {\n             consume_buffer(ctx, c, deflate_len, crc, ctx->bb);\n         }\n\n         if (done)\n             break;\n\n         zRC = libz_func(&ctx->stream, flush);\n\n         /*\n          * We can ignore Z_BUF_ERROR because:\n          * When we call libz_func we can assume that\n          *\n          * - avail_in is zero (due to the surrounding code that calls\n          *   flush_libz_buffer)\n          * - avail_out is non zero due to our actions some lines above\n          *\n          * So the only reason for Z_BUF_ERROR is that the internal libz\n          * buffers are now empty and thus we called libz_func one time\n          * too often. This does not hurt. It simply says that we are done.\n          */\n         if (zRC == Z_BUF_ERROR) {\n             zRC = Z_OK;\n             break;\n         }\n\n         done = (ctx->stream.avail_out != 0 || zRC == Z_STREAM_END);\n\n         if (zRC != Z_OK && zRC != Z_STREAM_END)\n             break;\n    }\n    return zRC;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b94db48c8c1fcee0736f3cf6fc5749db4f0240f0_0", {
    "ID": "httpd_b94db48c8c1fcee0736f3cf6fc5749db4f0240f0_0",
    "UID": "3841",
    "code": "static void putLong(unsigned char *string, unsigned long test_snippet\n{\n    string[0] = (unsigned char)(x & 0xff);\n    string[1] = (unsigned char)((x & 0xff00) >> 8);\n    string[2] = (unsigned char)((x & 0xff0000) >> 16);\n    string[3] = (unsigned char)((x & 0xff000000) >> 24);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_bc31ad4d2f2bb2d7af9377aa0e163bbac76a3baa_0", {
    "ID": "httpd_bc31ad4d2f2bb2d7af9377aa0e163bbac76a3baa_0",
    "UID": "3844",
    "code": "static apr_status_t deflate_out_filter(ap_filter_t test_snippet\n                                       apr_bucket_brigade *bb)\n{\n    apr_bucket *e;\n    request_rec *r = f->r;\n    deflate_ctx *ctx = f->ctx;\n    int zRC;\n    apr_status_t rv;\n    apr_size_t len = 0, blen;\n    const char *data;\n    deflate_filter_config *c;\n\n    \n    if (APR_BRIGADE_EMPTY(bb)) {\n        return APR_SUCCESS;\n    }\n\n    c = ap_get_module_config(r->server->module_config,\n                             &deflate_module);\n\n    /* If we don't have a context, we need to ensure that it is okay to send\n     * the deflated content.  If we have a context, that means we've done\n     * this before and we liked it.\n     * This could be not so nice if we always fail.  But, if we succeed,\n     * we're in better shape.\n     */\n    if (!ctx) {\n        char *token;\n        const char *encoding;\n\n        if (have_ssl_compression(r)) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                          \"Compression enabled at SSL level; not compressing \"\n                          \"at HTTP level.\");\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        \n        e = APR_BRIGADE_LAST(bb);\n        if (APR_BUCKET_IS_EOS(e)) {\n            /*\n             * If we already know the size of the response, we can skip\n             * compression on responses smaller than the compression overhead.\n             * However, if we compress, we must initialize deflate_out before\n             * calling ap_pass_brigade() for the first time.  Otherwise the\n             * headers will be sent to the client without\n             * \"Content-Encoding: gzip\".\n             */\n            e = APR_BRIGADE_FIRST(bb);\n            while (1) {\n                apr_status_t rc;\n                if (APR_BUCKET_IS_EOS(e)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                                  \"Not compressing very small response of %\"\n                                  APR_SIZE_T_FMT \" bytes\", len);\n                    ap_remove_output_filter(f);\n                    return ap_pass_brigade(f->next, bb);\n                }\n                if (APR_BUCKET_IS_METADATA(e)) {\n                    e = APR_BUCKET_NEXT(e);\n                    continue;\n                }\n\n                rc = apr_bucket_read(e, &data, &blen, APR_BLOCK_READ);\n                if (rc != APR_SUCCESS)\n                    return rc;\n                len += blen;\n                \n                if (len > sizeof(gzip_header) + VALIDATION_SIZE + 50)\n                    break;\n\n                e = APR_BUCKET_NEXT(e);\n            }\n        }\n\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n\n        /*\n         * Only work on main request, not subrequests,\n         * that are not a 204 response with no content\n         * and are not tagged with the no-gzip env variable\n         * and not a partial response to a Range request.\n         */\n        if ((r->main != NULL) || (r->status == HTTP_NO_CONTENT) ||\n            apr_table_get(r->subprocess_env, \"no-gzip\") ||\n            apr_table_get(r->headers_out, \"Content-Range\")\n           ) {\n            if (APLOG_R_IS_LEVEL(r, APLOG_TRACE1)) {\n                const char *reason =\n                    (r->main != NULL)                           ? \"subrequest\" :\n                    (r->status == HTTP_NO_CONTENT)              ? \"no content\" :\n                    apr_table_get(r->subprocess_env, \"no-gzip\") ? \"no-gzip\" :\n                    \"content-range\";\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                              \"Not compressing (%s)\", reason);\n            }\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        /* Some browsers might have problems with content types\n         * other than text/html, so set gzip-only-text/html\n         * (with browsermatch) for them\n         */\n        if (r->content_type == NULL\n             || strncmp(r->content_type, \"text/html\", 9)) {\n            const char *env_value = apr_table_get(r->subprocess_env,\n                                                  \"gzip-only-text/html\");\n            if ( env_value && (strcmp(env_value,\"1\") == 0) ) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                              \"Not compressing, (gzip-only-text/html)\");\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, bb);\n            }\n        }\n\n        /* Let's see what our current Content-Encoding is.\n         * If it's already encoded, don't compress again.\n         * (We could, but let's not.)\n         */\n        encoding = apr_table_get(r->headers_out, \"Content-Encoding\");\n        if (encoding) {\n            const char *err_enc;\n\n            err_enc = apr_table_get(r->err_headers_out, \"Content-Encoding\");\n            if (err_enc) {\n                encoding = apr_pstrcat(r->pool, encoding, \",\", err_enc, NULL);\n            }\n        }\n        else {\n            encoding = apr_table_get(r->err_headers_out, \"Content-Encoding\");\n        }\n\n        if (r->content_encoding) {\n            encoding = encoding ? apr_pstrcat(r->pool, encoding, \",\",\n                                              r->content_encoding, NULL)\n                                : r->content_encoding;\n        }\n\n        if (encoding) {\n            const char *tmp = encoding;\n\n            token = ap_get_token(r->pool, &tmp, 0);\n            while (token && *token) {\n                \n                if (strcmp(token, \"identity\") && strcmp(token, \"7bit\") &&\n                    strcmp(token, \"8bit\") && strcmp(token, \"binary\")) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                                  \"Not compressing (content-encoding already \"\n                                  \" set: %s)\", token);\n                    ap_remove_output_filter(f);\n                    return ap_pass_brigade(f->next, bb);\n                }\n\n                \n                if (*tmp) {\n                    ++tmp;\n                }\n                token = (*tmp) ? ap_get_token(r->pool, &tmp, 0) : NULL;\n            }\n        }\n\n        /* Even if we don't accept this request based on it not having\n         * the Accept-Encoding, we need to note that we were looking\n         * for this header and downstream proxies should be aware of that.\n         */\n        apr_table_mergen(r->headers_out, \"Vary\", \"Accept-Encoding\");\n\n        /* force-gzip will just force it out regardless if the browser\n         * can actually do anything with it.\n         */\n        if (!apr_table_get(r->subprocess_env, \"force-gzip\")) {\n            const char *accepts;\n            \n            accepts = apr_table_get(r->headers_in, \"Accept-Encoding\");\n            if (accepts == NULL) {\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, bb);\n            }\n\n            token = ap_get_token(r->pool, &accepts, 0);\n            while (token && token[0] && strcasecmp(token, \"gzip\")) {\n                \n                while (*accepts == ';') {\n                    ++accepts;\n                    ap_get_token(r->pool, &accepts, 1);\n                }\n\n                \n                if (*accepts == ',') {\n                    ++accepts;\n                }\n                token = (*accepts) ? ap_get_token(r->pool, &accepts, 0) : NULL;\n            }\n\n            \n            if (token == NULL || token[0] == '\\0') {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                              \"Not compressing (no Accept-Encoding: gzip)\");\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, bb);\n            }\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                          \"Forcing compression (force-gzip set)\");\n        }\n\n        /* At this point we have decided to filter the content. Let's try to\n         * to initialize zlib (except for 304 responses, where we will only\n         * send out the headers).\n         */\n\n        if (r->status != HTTP_NOT_MODIFIED) {\n            ctx->bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n            ctx->buffer = apr_palloc(r->pool, c->bufferSize);\n            ctx->libz_end_func = deflateEnd;\n\n            zRC = deflateInit2(&ctx->stream, c->compressionlevel, Z_DEFLATED,\n                               c->windowSize, c->memlevel,\n                               Z_DEFAULT_STRATEGY);\n\n            if (zRC != Z_OK) {\n                deflateEnd(&ctx->stream);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01383)\n                              \"unable to init Zlib: \"\n                              \"deflateInit2 returned %d: URL %s\",\n                              zRC, r->uri);\n                /*\n                 * Remove ourselves as it does not make sense to return:\n                 * We are not able to init libz and pass data down the chain\n                 * uncompressed.\n                 */\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, bb);\n            }\n            /*\n             * Register a cleanup function to ensure that we cleanup the internal\n             * libz resources.\n             */\n            apr_pool_cleanup_register(r->pool, ctx, deflate_ctx_cleanup,\n                                      apr_pool_cleanup_null);\n\n            /* Set the filter init flag so subsequent invocations know we are\n             * active.\n             */\n            ctx->filter_init = 1;\n        }\n\n        /*\n         * Zlib initialization worked, so we can now change the important\n         * content metadata before sending the response out.\n         */\n\n        \n        if (!encoding || !strcasecmp(encoding, \"identity\")) {\n            apr_table_setn(r->headers_out, \"Content-Encoding\", \"gzip\");\n        }\n        else {\n            apr_table_mergen(r->headers_out, \"Content-Encoding\", \"gzip\");\n        }\n        \n        if (r->content_encoding) {\n            r->content_encoding = apr_table_get(r->headers_out,\n                                                \"Content-Encoding\");\n        }\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        apr_table_unset(r->headers_out, \"Content-MD5\");\n        if (c->etag_opt != AP_DEFLATE_ETAG_NOCHANGE) {  \n            deflate_check_etag(r, \"gzip\", c->etag_opt);\n        }\n\n        \n        if (r->status == HTTP_NOT_MODIFIED) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        \n        e = apr_bucket_immortal_create(gzip_header, sizeof gzip_header,\n                                       f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n\n        \n        ctx->stream.next_out = ctx->buffer;\n        ctx->stream.avail_out = c->bufferSize;\n    } else if (!ctx->filter_init) {\n        /* Hmm.  We've run through the filter init before as we have a ctx,\n         * but we never initialized.  We probably have a dangling ref.  Bail.\n         */\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb))\n    {\n        apr_bucket *b;\n\n        /*\n         * Optimization: If we are a HEAD request and bytes_sent is not zero\n         * it means that we have passed the content-length filter once and\n         * have more data to sent. This means that the content-length filter\n         * could not determine our content-length for the response to the\n         * HEAD request anyway (the associated GET request would deliver the\n         * body in chunked encoding) and we can stop compressing.\n         */\n        if (r->header_only && r->bytes_sent) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        e = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(e)) {\n            char *buf;\n\n            ctx->stream.avail_in = 0; \n            \n            flush_libz_buffer(ctx, c, deflate, Z_FINISH, NO_UPDATE_CRC);\n\n            buf = apr_palloc(r->pool, VALIDATION_SIZE);\n            putLong((unsigned char *)&buf[0], ctx->crc);\n            putLong((unsigned char *)&buf[4], ctx->stream.total_in);\n\n            b = apr_bucket_pool_create(buf, VALIDATION_SIZE, r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01384)\n                          \"Zlib: Compressed %ld to %ld : URL %s\",\n                          ctx->stream.total_in, ctx->stream.total_out, r->uri);\n\n            \n            if (c->note_input_name) {\n                apr_table_setn(r->notes, c->note_input_name,\n                               (ctx->stream.total_in > 0)\n                                ? apr_off_t_toa(r->pool,\n                                                ctx->stream.total_in)\n                                : \"-\");\n            }\n\n            if (c->note_output_name) {\n                apr_table_setn(r->notes, c->note_output_name,\n                               (ctx->stream.total_in > 0)\n                                ? apr_off_t_toa(r->pool,\n                                                ctx->stream.total_out)\n                                : \"-\");\n            }\n\n            if (c->note_ratio_name) {\n                apr_table_setn(r->notes, c->note_ratio_name,\n                               (ctx->stream.total_in > 0)\n                                ? apr_itoa(r->pool,\n                                           (int)(ctx->stream.total_out\n                                                 * 100\n                                                 / ctx->stream.total_in))\n                                : \"-\");\n            }\n\n            deflateEnd(&ctx->stream);\n            \n            apr_pool_cleanup_kill(r->pool, ctx, deflate_ctx_cleanup);\n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n\n            /* Okay, we've seen the EOS.\n             * Time to pass it along down the chain.\n             */\n            rv = ap_pass_brigade(f->next, ctx->bb);\n            apr_brigade_cleanup(ctx->bb);\n            return rv;\n        }\n\n        if (APR_BUCKET_IS_FLUSH(e)) {\n            \n            zRC = flush_libz_buffer(ctx, c, deflate, Z_SYNC_FLUSH,\n                                    NO_UPDATE_CRC);\n            if (zRC != Z_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01385)\n                              \"Zlib error %d flushing zlib output buffer (%s)\",\n                              zRC, ctx->stream.msg);\n                return APR_EGENERAL;\n            }\n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n            rv = ap_pass_brigade(f->next, ctx->bb);\n            apr_brigade_cleanup(ctx->bb);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            continue;\n        }\n\n        if (APR_BUCKET_IS_METADATA(e)) {\n            /*\n             * Remove meta data bucket from old brigade and insert into the\n             * new.\n             */\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n            continue;\n        }\n\n        \n        apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n        if (!len) {\n            apr_bucket_delete(e);\n            continue;\n        }\n        if (len > APR_INT32_MAX) {\n            apr_bucket_split(e, APR_INT32_MAX);\n            apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n        }\n\n        \n        ctx->crc = crc32(ctx->crc, (const Bytef *)data, len);\n\n        \n        ctx->stream.next_in = (unsigned char *)data; /* We just lost const-ness,\n                                                      * but we'll just have to\n                                                      * trust zlib */\n        ctx->stream.avail_in = (int)len;\n\n        while (ctx->stream.avail_in != 0) {\n            if (ctx->stream.avail_out == 0) {\n                consume_buffer(ctx, c, c->bufferSize, NO_UPDATE_CRC, ctx->bb);\n\n                \n                rv = ap_pass_brigade(f->next, ctx->bb);\n                apr_brigade_cleanup(ctx->bb);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n            }\n\n            zRC = deflate(&(ctx->stream), Z_NO_FLUSH);\n\n            if (zRC != Z_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01386)\n                              \"Zlib error %d deflating data (%s)\", zRC,\n                              ctx->stream.msg);\n                return APR_EGENERAL;\n            }\n        }\n\n        apr_bucket_delete(e);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2be1f630425e8809da35acc47e54cdb68edfe0b2_0", {
    "ID": "httpd_2be1f630425e8809da35acc47e54cdb68edfe0b2_0",
    "UID": "3851",
    "code": "static apr_status_t consume_zlib_flags(deflate_ctx test_snippet\n                                       const char **data, apr_size_t *len)\n{\n    if ((ctx->zlib_flags & EXTRA_FIELD)) {\n        \n        if (ctx->consume_pos == 0) {\n            if (!*len) {\n                return APR_INCOMPLETE;\n            }\n            ctx->consume_len = (unsigned int)**data;\n            ctx->consume_pos++;\n            ++*data;\n            --*len;\n        }\n        if (ctx->consume_pos == 1) {\n            if (!*len) {\n                return APR_INCOMPLETE;\n            }\n            ctx->consume_len += ((unsigned int)**data) << 8;\n            ctx->consume_pos++;\n            ++*data;\n            --*len;\n        }\n        if (*len < ctx->consume_len) {\n            ctx->consume_len -= *len;\n            *len = 0;\n            return APR_INCOMPLETE;\n        }\n        *data += ctx->consume_len;\n        *len -= ctx->consume_len;\n\n        ctx->consume_len = ctx->consume_pos = 0;\n        ctx->zlib_flags &= ~EXTRA_FIELD;\n    }\n\n    if ((ctx->zlib_flags & ORIG_NAME)) {\n        \n        while (*len && **data) {\n            ++*data;\n            --*len;\n        }\n        if (!*len) {\n            return APR_INCOMPLETE;\n        }\n        \n        ++*data;\n        --*len;\n\n        ctx->zlib_flags &= ~ORIG_NAME;\n    }\n\n    if ((ctx->zlib_flags & COMMENT)) {\n        \n        while (*len && **data) {\n            ++*data;\n            --*len;\n        }\n        if (!*len) {\n            return APR_INCOMPLETE;\n        }\n        \n        ++*data;\n        --*len;\n\n        ctx->zlib_flags &= ~COMMENT;\n    }\n\n    if ((ctx->zlib_flags & HEAD_CRC)) {\n        \n        if (ctx->consume_pos == 0) {\n            if (!*len) {\n                return APR_INCOMPLETE;\n            }\n            ctx->consume_pos++;\n            ++*data;\n            --*len;\n        }\n        if (!*len) {\n            return APR_INCOMPLETE;\n        }\n        ++*data;\n        --*len;\n        \n        ctx->consume_pos = 0;\n        ctx->zlib_flags &= ~HEAD_CRC;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_79ffc9251d23900f9776d6b5fafe45ed9e1790a3_0", {
    "ID": "httpd_79ffc9251d23900f9776d6b5fafe45ed9e1790a3_0",
    "UID": "3854",
    "code": "static apr_status_t deflate_in_filter(ap_filter_t test_snippet\n                                      apr_bucket_brigade *bb,\n                                      ap_input_mode_t mode,\n                                      apr_read_type_e block,\n                                      apr_off_t readbytes)\n{\n    apr_bucket *bkt;\n    request_rec *r = f->r;\n    deflate_ctx *ctx = f->ctx;\n    int zRC;\n    apr_status_t rv;\n    deflate_filter_config *c;\n    deflate_dirconf_t *dc;\n    apr_off_t inflate_limit;\n\n    \n    if (mode != AP_MODE_READBYTES) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    c = ap_get_module_config(r->server->module_config, &deflate_module);\n    dc = ap_get_module_config(r->per_dir_config, &deflate_module);\n\n    if (!ctx || ctx->header_len < sizeof(ctx->header)) {\n        apr_size_t len;\n\n        if (!ctx) {\n            \n            if (!ap_is_initial_req(r)) {\n                ap_remove_input_filter(f);\n                return ap_get_brigade(f->next, bb, mode, block, readbytes);\n            }\n\n            \n            if (apr_table_get(r->headers_in, \"Content-Range\") != NULL) {\n                ap_remove_input_filter(f);\n                return ap_get_brigade(f->next, bb, mode, block, readbytes);\n            }\n\n            /* Check whether request body is gzipped.\n             *\n             * If it is, we're transforming the contents, invalidating\n             * some request headers including Content-Encoding.\n             *\n             * If not, we just remove ourself.\n             */\n            if (check_gzip(r, r->headers_in, NULL) == 0) {\n                ap_remove_input_filter(f);\n                return ap_get_brigade(f->next, bb, mode, block, readbytes);\n            }\n\n            f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n            ctx->bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n            ctx->proc_bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n            ctx->buffer = apr_palloc(r->pool, c->bufferSize);\n        }\n\n        do {\n            apr_brigade_cleanup(ctx->bb);\n\n            len = sizeof(ctx->header) - ctx->header_len;\n            rv = ap_get_brigade(f->next, ctx->bb, AP_MODE_READBYTES, block,\n                                len);\n\n            /* ap_get_brigade may return success with an empty brigade for\n             * a non-blocking read which would block (an empty brigade for\n             * a blocking read is an issue which is simply forwarded here).\n             */\n            if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(ctx->bb)) {\n                return rv;\n            }\n\n            \n            bkt = APR_BRIGADE_FIRST(ctx->bb);\n            if (APR_BUCKET_IS_EOS(bkt)) {\n                if (ctx->header_len) {\n                    /* If the header was (partially) read it's an error, this\n                     * is not a gzip Content-Encoding, as claimed.\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02619)\n                                  \"Encountered premature end-of-stream while \"\n                                  \"reading inflate header\");\n                    return APR_EGENERAL;\n                }\n                APR_BUCKET_REMOVE(bkt);\n                APR_BRIGADE_INSERT_TAIL(bb, bkt);\n                ap_remove_input_filter(f);\n                return APR_SUCCESS;\n            }\n\n            rv = apr_brigade_flatten(ctx->bb,\n                                     ctx->header + ctx->header_len, &len);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            if (len && !ctx->header_len) {\n                apr_table_unset(r->headers_in, \"Content-Length\");\n                apr_table_unset(r->headers_in, \"Content-MD5\");\n            }\n            ctx->header_len += len;\n\n        } while (ctx->header_len < sizeof(ctx->header));\n\n        \n        if (ctx->header[0] != deflate_magic[0] ||\n            ctx->header[1] != deflate_magic[1]) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01387)\n                          \"Zlib: Invalid header\");\n            return APR_EGENERAL;\n        }\n\n        ctx->zlib_flags = ctx->header[3];\n        if ((ctx->zlib_flags & RESERVED)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01388)\n                          \"Zlib: Invalid flags %02x\", ctx->zlib_flags);\n            return APR_EGENERAL;\n        }\n\n        zRC = inflateInit2(&ctx->stream, c->windowSize);\n\n        if (zRC != Z_OK) {\n            f->ctx = NULL;\n            inflateEnd(&ctx->stream);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01389)\n                          \"unable to init Zlib: \"\n                          \"inflateInit2 returned %d: URL %s\",\n                          zRC, r->uri);\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        \n        ctx->stream.next_out = ctx->buffer;\n        ctx->stream.avail_out = c->bufferSize;\n\n        apr_brigade_cleanup(ctx->bb);\n    }\n\n    inflate_limit = dc->inflate_limit; \n    if (inflate_limit == 0) { \n        \n        inflate_limit = ap_get_limit_req_body(f->r);\n    }\n\n    if (APR_BRIGADE_EMPTY(ctx->proc_bb)) {\n        rv = ap_get_brigade(f->next, ctx->bb, mode, block, readbytes);\n\n        /* Don't terminate on EAGAIN (or success with an empty brigade in\n         * non-blocking mode), just return focus.\n         */\n        if (block == APR_NONBLOCK_READ\n                && (APR_STATUS_IS_EAGAIN(rv)\n                    || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(ctx->bb)))) {\n            return rv;\n        }\n        if (rv != APR_SUCCESS) {\n            inflateEnd(&ctx->stream);\n            return rv;\n        }\n\n        for (bkt = APR_BRIGADE_FIRST(ctx->bb);\n             bkt != APR_BRIGADE_SENTINEL(ctx->bb);\n             bkt = APR_BUCKET_NEXT(bkt))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bkt)) {\n                if (!ctx->done) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02481)\n                                  \"Encountered premature end-of-stream while inflating\");\n                    return APR_EGENERAL;\n                }\n\n                \n                APR_BUCKET_REMOVE(bkt);\n                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, bkt);\n                break;\n            }\n\n            if (APR_BUCKET_IS_FLUSH(bkt)) {\n                apr_bucket *tmp_b;\n\n                ctx->inflate_total += ctx->stream.avail_out;\n                zRC = inflate(&(ctx->stream), Z_SYNC_FLUSH);\n                ctx->inflate_total -= ctx->stream.avail_out;\n                if (zRC != Z_OK) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01391)\n                                  \"Zlib error %d inflating data (%s)\", zRC,\n                                  ctx->stream.msg);\n                    return APR_EGENERAL;\n                }\n \n                if (inflate_limit && ctx->inflate_total > inflate_limit) { \n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02647)\n                            \"Inflated content length of %\" APR_OFF_T_FMT\n                            \" is larger than the configured limit\"\n                            \" of %\" APR_OFF_T_FMT, \n                            ctx->inflate_total, inflate_limit);\n                    return APR_ENOSPC;\n                }\n\n                if (!check_ratio(r, ctx, dc)) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02805)\n                            \"Inflated content ratio is larger than the \"\n                            \"configured limit %i by %i time(s)\",\n                            dc->ratio_limit, dc->ratio_burst);\n                    return APR_EINVAL;\n                }\n\n                consume_buffer(ctx, c, c->bufferSize - ctx->stream.avail_out,\n                               UPDATE_CRC, ctx->proc_bb);\n\n                /* Flush everything so far in the returning brigade, but continue\n                 * reading should EOS/more follow (don't lose them).\n                 */\n                tmp_b = APR_BUCKET_PREV(bkt);\n                APR_BUCKET_REMOVE(bkt);\n                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, bkt);\n                bkt = tmp_b;\n                continue;\n            }\n\n            \n            if (ctx->done) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02482)\n                              \"Encountered extra data after compressed data\");\n                return APR_EGENERAL;\n            }\n\n            \n            apr_bucket_read(bkt, &data, &len, APR_BLOCK_READ);\n            if (!len) {\n                continue;\n            }\n            if (len > APR_INT32_MAX) {\n                apr_bucket_split(bkt, APR_INT32_MAX);\n                apr_bucket_read(bkt, &data, &len, APR_BLOCK_READ);\n            }\n\n            if (ctx->zlib_flags) {\n                rv = consume_zlib_flags(ctx, &data, &len);\n                if (rv == APR_SUCCESS) {\n                    ctx->zlib_flags = 0;\n                }\n                if (!len) {\n                    continue;\n                }\n            }\n\n            \n            ctx->stream.next_in = (unsigned char *)data;\n            ctx->stream.avail_in = (int)len;\n\n            zRC = Z_OK;\n\n            if (!ctx->validation_buffer) {\n                while (ctx->stream.avail_in != 0) {\n                    if (ctx->stream.avail_out == 0) {\n                        consume_buffer(ctx, c, c->bufferSize, UPDATE_CRC,\n                                       ctx->proc_bb);\n                    }\n\n                    ctx->inflate_total += ctx->stream.avail_out;\n                    zRC = inflate(&ctx->stream, Z_NO_FLUSH);\n                    ctx->inflate_total -= ctx->stream.avail_out;\n                    if (zRC != Z_OK && zRC != Z_STREAM_END) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01392)\n                                      \"Zlib error %d inflating data (%s)\", zRC,\n                                      ctx->stream.msg);\n                        return APR_EGENERAL;\n                    }\n\n                    if (inflate_limit && ctx->inflate_total > inflate_limit) { \n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02648)\n                                \"Inflated content length of %\" APR_OFF_T_FMT\n                                \" is larger than the configured limit\"\n                                \" of %\" APR_OFF_T_FMT, \n                                ctx->inflate_total, inflate_limit);\n                        return APR_ENOSPC;\n                    }\n\n                    if (!check_ratio(r, ctx, dc)) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02649)\n                                \"Inflated content ratio is larger than the \"\n                                \"configured limit %i by %i time(s)\",\n                                dc->ratio_limit, dc->ratio_burst);\n                        return APR_EINVAL;\n                    }\n\n                    if (zRC == Z_STREAM_END) {\n                        ctx->validation_buffer = apr_pcalloc(r->pool,\n                                                             VALIDATION_SIZE);\n                        ctx->validation_buffer_length = 0;\n                        break;\n                    }\n                }\n            }\n\n            if (ctx->validation_buffer) {\n                apr_size_t avail, valid;\n                unsigned char *buf = ctx->validation_buffer;\n\n                avail = ctx->stream.avail_in;\n                valid = (apr_size_t)VALIDATION_SIZE -\n                         ctx->validation_buffer_length;\n\n                /*\n                 * We have inflated all data. Now try to capture the\n                 * validation bytes. We may not have them all available\n                 * right now, but capture what is there.\n                 */\n                if (avail < valid) {\n                    memcpy(buf + ctx->validation_buffer_length,\n                           ctx->stream.next_in, avail);\n                    ctx->validation_buffer_length += avail;\n                    continue;\n                }\n                memcpy(buf + ctx->validation_buffer_length,\n                       ctx->stream.next_in, valid);\n                ctx->validation_buffer_length += valid;\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01393)\n                              \"Zlib: Inflated %ld to %ld : URL %s\",\n                              ctx->stream.total_in, ctx->stream.total_out,\n                              r->uri);\n\n                consume_buffer(ctx, c, c->bufferSize - ctx->stream.avail_out,\n                               UPDATE_CRC, ctx->proc_bb);\n\n                {\n                    unsigned long compCRC, compLen;\n                    compCRC = getLong(buf);\n                    if (ctx->crc != compCRC) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01394)\n                                      \"Zlib: CRC error inflating data\");\n                        return APR_EGENERAL;\n                    }\n                    compLen = getLong(buf + VALIDATION_SIZE / 2);\n                    \n                    if ((ctx->stream.total_out & 0xFFFFFFFF) != compLen) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01395)\n                                      \"Zlib: Length %ld of inflated data does \"\n                                      \"not match expected value %ld\",\n                                      ctx->stream.total_out, compLen);\n                        return APR_EGENERAL;\n                    }\n                }\n\n                inflateEnd(&ctx->stream);\n\n                ctx->done = 1;\n\n                \n                if (avail > valid) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02485)\n                                  \"Encountered extra data after compressed data\");\n                    return APR_EGENERAL;\n                }\n            }\n\n        }\n        apr_brigade_cleanup(ctx->bb);\n    }\n\n    /* If we are about to return nothing for a 'blocking' read and we have\n     * some data in our zlib buffer, flush it out so we can return something.\n     */\n    if (block == APR_BLOCK_READ &&\n            APR_BRIGADE_EMPTY(ctx->proc_bb) &&\n            ctx->stream.avail_out < c->bufferSize) {\n        consume_buffer(ctx, c, c->bufferSize - ctx->stream.avail_out,\n                       UPDATE_CRC, ctx->proc_bb);\n    }\n\n    if (!APR_BRIGADE_EMPTY(ctx->proc_bb)) {\n        if (apr_brigade_partition(ctx->proc_bb, readbytes, &bkt) == APR_INCOMPLETE) {\n            APR_BRIGADE_CONCAT(bb, ctx->proc_bb);\n        }\n        else {\n            APR_BRIGADE_CONCAT(bb, ctx->proc_bb);\n            apr_brigade_split_ex(bb, bkt, ctx->proc_bb);\n        }\n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n            ap_remove_input_filter(f);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d83d3c479057918726b9fc9582a19c1501db6295_0", {
    "ID": "httpd_d83d3c479057918726b9fc9582a19c1501db6295_0",
    "UID": "3864",
    "code": "static void *xcalloc(size_t num, size_t test_snippet\n{\n    void *ret = calloc(num, test_snippet;\n    if (ret == NULL) {\n        fprintf(stderr, \"Could not allocate memory (%\"\n                APR_SIZE_T_FMT\" bytes)\\n\", size*num);\n        exit(1);\n    }\n    return ret;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value"
  },
  "httpd_7c1f6020b3375d1fa7b89aba6e9ab84107d83aa1_0", {
    "ID": "httpd_7c1f6020b3375d1fa7b89aba6e9ab84107d83aa1_0",
    "UID": "3865",
    "code": "static void start_connect(struct connection * test_snippet\n{\n    apr_status_t rv;\n\n    if (!(started < requests))\n    return;\n\n    c->read = 0;\n    c->bread = 0;\n    c->keepalive = 0;\n    c->cbx = 0;\n    c->gotheader = 0;\n    c->rwrite = 0;\n    if (c->ctx)\n        apr_pool_clear(c->ctx);\n    else\n        apr_pool_create(&c->ctx, cntxt);\n\n    if ((rv = apr_socket_create(&c->aprsock, destsa->family,\n                SOCK_STREAM, 0, c->ctx)) != APR_SUCCESS) {\n    apr_err(\"socket\", rv);\n    }\n\n    if (myhost) {\n        if ((rv = apr_socket_bind(c->aprsock, mysa)) != APR_SUCCESS) {\n            apr_err(\"bind\", rv);\n        }\n    }\n\n    c->pollfd.desc_type = APR_POLL_SOCKET;\n    c->pollfd.desc.s = c->aprsock;\n    c->pollfd.reqevents = 0;\n    c->pollfd.client_data = c;\n\n    if ((rv = apr_socket_opt_set(c->aprsock, APR_SO_NONBLOCK, 1))\n         != APR_SUCCESS) {\n        apr_err(\"socket nonblock\", rv);\n    }\n\n    if (windowsize != 0) {\n        rv = apr_socket_opt_set(c->aprsock, APR_SO_SNDBUF,\n                                windowsize);\n        if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n            apr_err(\"socket send buffer\", rv);\n        }\n        rv = apr_socket_opt_set(c->aprsock, APR_SO_RCVBUF,\n                                windowsize);\n        if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n            apr_err(\"socket receive buffer\", rv);\n        }\n    }\n\n    c->start = lasttime = apr_time_now();\n#ifdef USE_SSL\n    if (is_ssl) {\n        BIO *bio;\n        apr_os_sock_t fd;\n\n        if ((c->ssl = SSL_new(ssl_ctx)) == NULL) {\n            BIO_printf(bio_err, \"SSL_new failed.\\n\");\n            ERR_print_errors(bio_err);\n            exit(1);\n        }\n        ssl_rand_seed();\n        apr_os_sock_get(&fd, c->aprsock);\n        bio = BIO_new_socket(fd, BIO_NOCLOSE);\n        SSL_set_bio(c->ssl, bio, bio);\n        SSL_set_connect_state(c->ssl);\n        if (verbosity >= 4) {\n            BIO_set_callback(bio, ssl_print_cb);\n            BIO_set_callback_arg(bio, (void *)bio_err);\n        }\n    } else {\n        c->ssl = NULL;\n    }\n#endif\n    if ((rv = apr_socket_connect(c->aprsock, destsa)) != APR_SUCCESS) {\n        if (APR_STATUS_IS_EINPROGRESS(rv)) {\n            set_conn_state(c, STATE_CONNECTING);\n            c->rwrite = 0;\n            return;\n        }\n        else {\n            set_conn_state(c, STATE_UNCONNECTED);\n            apr_socket_close(c->aprsock);\n            if (good == 0 && destsa->next) {\n                destsa = destsa->next;\n                err_conn = 0;\n            }\n            else if (bad++ > 10) {\n                fprintf(stderr,\n                   \"\\nTest aborted after 10 failures\\n\\n\");\n                apr_err(\"apr_socket_connect()\", rv);\n            }\n            else {\n                err_conn++;\n            }\n\n            start_connect(test_snippet;\n            return;\n        }\n    }\n\n    \n    set_conn_state(c, STATE_CONNECTED);\n#ifdef USE_SSL\n    if (c->ssl) {\n        ssl_proceed_handshake(test_snippet;\n    } else\n#endif\n    {\n        write_request(test_snippet;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_a8e520766b0ed9a2dd7f984b66a4781a81ce74a4_0", {
    "ID": "httpd_a8e520766b0ed9a2dd7f984b66a4781a81ce74a4_0",
    "UID": "3891",
    "code": "static apr_status_t socache_shmcb_init(ap_socache_instance_t test_snippet\n                                       const char *namespace,\n                                       const struct ap_socache_hints *hints,\n                                       server_rec *s, apr_pool_t *p)\n{\n    void *shm_segment;\n    apr_size_t shm_segsize;\n    apr_status_t rv;\n    SHMCBHeader *header;\n    unsigned int num_subcache, num_idx, loop;\n    apr_size_t avg_obj_size, avg_id_len;\n\n    \n    if (ctx->data_file == NULL) {\n        const char *path = apr_pstrcat(p, DEFAULT_SHMCB_PREFIX, namespace,\n                                       DEFAULT_SHMCB_SUFFIX, NULL);\n\n        ctx->data_file = ap_runtime_dir_relative(p, path);\n    }\n\n    \n    rv = apr_shm_create(&ctx->shm, ctx->shm_size, NULL, p);\n    if (APR_STATUS_IS_ENOTIMPL(rv)) {\n        /* If anon shm isn't supported, fail if no named file was\n         * configured successfully; the ap_server_root_relative call\n         * above will return NULL for invalid paths. */\n        if (ctx->data_file == NULL) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00818)\n                         \"Could not use default path '%s' for shmcb socache\",\n                         ctx->data_file);\n            return APR_EINVAL;\n        }\n\n        /* For a name-based segment, remove it first in case of a\n         * previous unclean shutdown. */\n        apr_shm_remove(ctx->data_file, p);\n\n        rv = apr_shm_create(&ctx->shm, ctx->shm_size, ctx->data_file, p);\n    }\n\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00819)\n                     \"Could not allocate shared memory segment for shmcb \"\n                     \"socache\");\n        return rv;\n    }\n\n    shm_segment = apr_shm_baseaddr_get(ctx->shm);\n    shm_segsize = apr_shm_size_get(ctx->shm);\n    if (shm_segsize < (5 * ALIGNED_HEADER_SIZE)) {\n        \n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00820)\n                     \"shared memory segment too small\");\n        return APR_ENOSPC;\n    }\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00821)\n                 \"shmcb_init allocated %\" APR_SIZE_T_FMT\n                 \" bytes of shared memory\",\n                 shm_segsize);\n    \n    shm_segsize -= ALIGNED_HEADER_SIZE;\n    \n    avg_obj_size = hints && hints->avg_obj_size ? hints->avg_obj_size : 150;\n    avg_id_len = hints && hints->avg_id_len ? hints->avg_id_len : 30;\n    num_idx = (shm_segsize) / (avg_obj_size + avg_id_len);\n    num_subcache = 256;\n    while ((num_idx / num_subcache) < (2 * num_subcache))\n        num_subcache /= 2;\n    num_idx /= num_subcache;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00822)\n                 \"for %\" APR_SIZE_T_FMT \" bytes (%\" APR_SIZE_T_FMT\n                 \" including header), recommending %u subcaches, \"\n                 \"%u indexes each\", shm_segsize,\n                 shm_segsize + ALIGNED_HEADER_SIZE,\n                 num_subcache, num_idx);\n    if (num_idx < 5) {\n        \n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00823)\n                     \"shared memory segment too small\");\n        return APR_ENOSPC;\n    }\n    \n    ctx->header = header = shm_segment;\n    header->stat_stores = 0;\n    header->stat_replaced = 0;\n    header->stat_expiries = 0;\n    header->stat_scrolled = 0;\n    header->stat_retrieves_hit = 0;\n    header->stat_retrieves_miss = 0;\n    header->stat_removes_hit = 0;\n    header->stat_removes_miss = 0;\n    header->subcache_num = num_subcache;\n    /* Convert the subcache size (in bytes) to a value that is suitable for\n     * structure alignment on the host platform, by rounding down if necessary. */\n    header->subcache_size = (size_t)(shm_segsize / num_subcache);\n    if (header->subcache_size != APR_ALIGN_DEFAULT(header->subcache_size)) {\n        header->subcache_size = APR_ALIGN_DEFAULT(header->subcache_size) -\n                                APR_ALIGN_DEFAULT(1);\n    }\n    header->subcache_data_offset = ALIGNED_SUBCACHE_SIZE +\n                                   num_idx * ALIGNED_INDEX_SIZE;\n    header->subcache_data_size = header->subcache_size -\n                                 header->subcache_data_offset;\n    header->index_num = num_idx;\n\n    \n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00824)\n                 \"shmcb_init_memory choices follow\");\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00825)\n                 \"subcache_num = %u\", header->subcache_num);\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00826)\n                 \"subcache_size = %u\", header->subcache_size);\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00827)\n                 \"subcache_data_offset = %u\", header->subcache_data_offset);\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00828)\n                 \"subcache_data_size = %u\", header->subcache_data_size);\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00829)\n                 \"index_num = %u\", header->index_num);\n    \n    for (loop = 0; loop < header->subcache_num; loop++) {\n        SHMCBSubcache *subcache = SHMCB_SUBCACHE(header, loop);\n        subcache->idx_pos = subcache->idx_used = 0;\n        subcache->data_pos = subcache->data_used = 0;\n    }\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(00830)\n                 \"Shared memory socache initialised\");\n    \n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_beed7a67ac1d112acba59920d11cffc31b7ad9e6_0", {
    "ID": "httpd_beed7a67ac1d112acba59920d11cffc31b7ad9e6_0",
    "UID": "3898",
    "code": "static void socache_shmcb_status(ap_socache_instance_t test_snippet\n                                 request_rec *r, int flags)\n{\n    server_rec *s = r->server;\n    SHMCBHeader *header = ctx->header;\n    unsigned int loop, total = 0, cache_total = 0, non_empty_subcaches = 0;\n    apr_time_t idx_expiry, min_expiry = 0, max_expiry = 0;\n    apr_time_t now = apr_time_now();\n    double expiry_total = 0;\n    int index_pct, cache_pct;\n\n    AP_DEBUG_ASSERT(header->subcache_num > 0);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00840) \"inside shmcb_status\");\n    /* Perform the iteration inside the mutex to avoid corruption or invalid\n     * pointer arithmetic. The rest of our logic uses read-only header data so\n     * doesn't need the lock. */\n    \n    for (loop = 0; loop < header->subcache_num; loop++) {\n        SHMCBSubcache *subcache = SHMCB_SUBCACHE(header, loop);\n        shmcb_subcache_expire(s, header, subcache, now);\n        total += subcache->idx_used;\n        cache_total += subcache->data_used;\n        if (subcache->idx_used) {\n            SHMCBIndex *idx = SHMCB_INDEX(subcache, subcache->idx_pos);\n            non_empty_subcaches++;\n            idx_expiry = idx->expires;\n            expiry_total += (double)idx_expiry;\n            max_expiry = ((idx_expiry > max_expiry) ? idx_expiry : max_expiry);\n            if (!min_expiry)\n                min_expiry = idx_expiry;\n            else\n                min_expiry = ((idx_expiry < min_expiry) ? idx_expiry : min_expiry);\n        }\n    }\n    index_pct = (100 * total) / (header->index_num *\n                                 header->subcache_num);\n    cache_pct = (100 * cache_total) / (header->subcache_data_size *\n                                       header->subcache_num);\n    \n    ap_rprintf(r, \"cache type: <b>SHMCB</b>, shared memory: <b>%\" APR_SIZE_T_FMT \"</b> \"\n               \"bytes, current entries: <b>%d</b><br>\",\n               ctx->shm_size, total);\n    ap_rprintf(r, \"subcaches: <b>%d</b>, indexes per subcache: <b>%d</b><br>\",\n               header->subcache_num, header->index_num);\n    if (non_empty_subcaches) {\n        apr_time_t average_expiry = (apr_time_t)(expiry_total / (double)non_empty_subcaches);\n        ap_rprintf(r, \"time left on oldest entries' objects: \");\n        if (now < average_expiry)\n            ap_rprintf(r, \"avg: <b>%d</b> seconds, (range: %d...%d)<br>\",\n                       (int)apr_time_sec(average_expiry - now),\n                       (int)apr_time_sec(min_expiry - now),\n                       (int)apr_time_sec(max_expiry - now));\n        else\n            ap_rprintf(r, \"expiry_threshold: <b>Calculation error!</b><br>\");\n    }\n\n    ap_rprintf(r, \"index usage: <b>%d%%</b>, cache usage: <b>%d%%</b><br>\",\n               index_pct, cache_pct);\n    ap_rprintf(r, \"total entries stored since starting: <b>%lu</b><br>\",\n               header->stat_stores);\n    ap_rprintf(r, \"total entries replaced since starting: <b>%lu</b><br>\",\n               header->stat_replaced);\n    ap_rprintf(r, \"total entries expired since starting: <b>%lu</b><br>\",\n               header->stat_expiries);\n    ap_rprintf(r, \"total (pre-expiry) entries scrolled out of the cache: \"\n               \"<b>%lu</b><br>\", header->stat_scrolled);\n    ap_rprintf(r, \"total retrieves since starting: <b>%lu</b> hit, \"\n               \"<b>%lu</b> miss<br>\", header->stat_retrieves_hit,\n               header->stat_retrieves_miss);\n    ap_rprintf(r, \"total removes since starting: <b>%lu</b> hit, \"\n               \"<b>%lu</b> miss<br>\", header->stat_removes_hit,\n               header->stat_removes_miss);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00841) \"leaving shmcb_status\");\n}",
    "predicted": "476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_609fb11956079dd83e02297c491adcd6c14d6353_0", {
    "ID": "httpd_609fb11956079dd83e02297c491adcd6c14d6353_0",
    "UID": "3899",
    "code": "static int cache_save_store(ap_filter_t *f, apr_bucket_brigade test_snippet\n        cache_server_conf *conf, cache_request_rec *cache)\n{\n    int rv = APR_SUCCESS;\n    apr_bucket *e;\n\n    /* pass the brigade in into the cache provider, which is then\n     * expected to move cached buckets to the out brigade, for us\n     * to pass up the filter stack. repeat until in is empty, or\n     * we fail.\n     */\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(in)) {\n\n        rv = cache->provider->store_body(cache->handle, f->r, in, cache->out);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r, APLOGNO(00765)\n                    \"cache: Cache provider's store_body failed!\");\n            ap_remove_output_filter(f);\n\n            \n            cache_remove_lock(conf, cache, f->r, NULL);\n\n            \n            APR_BRIGADE_PREPEND(in, cache->out);\n            return ap_pass_brigade(f->next, in);\n\n        }\n\n        \n        for (e = APR_BRIGADE_FIRST(cache->out);\n             e != APR_BRIGADE_SENTINEL(cache->out);\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_EOS(e)) {\n                rv = cache->provider->commit_entity(cache->handle, f->r);\n                break;\n            }\n        }\n\n        \n        cache_remove_lock(conf, cache, f->r, cache->out);\n\n        if (APR_BRIGADE_EMPTY(cache->out)) {\n            if (APR_BRIGADE_EMPTY(in)) {\n                /* cache provider wants more data before passing the brigade\n                 * upstream, oblige the provider by leaving to fetch more.\n                 */\n                break;\n            }\n            else {\n                /* oops, no data out, but not all data read in either, be\n                 * safe and stand down to prevent a spin.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r, APLOGNO(00766)\n                        \"cache: Cache provider's store_body returned an \"\n                        \"empty brigade, but didn't consume all of the\"\n                        \"input brigade, standing down to prevent a spin\");\n                ap_remove_output_filter(f);\n\n                \n                cache_remove_lock(conf, cache, f->r, NULL);\n\n                return ap_pass_brigade(f->next, in);\n            }\n        }\n\n        rv = ap_pass_brigade(f->next, cache->out);\n    }\n\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_dd2e9e571fc17fd52e50cadb47bf5d8abda8d54a_0", {
    "ID": "httpd_dd2e9e571fc17fd52e50cadb47bf5d8abda8d54a_0",
    "UID": "3900",
    "code": "static void shmcb_subcache_expire(server_rec *s, SHMCBHeader test_snippet\n                                  SHMCBSubcache *subcache, apr_time_t now)\n{\n    unsigned int loop = 0, freed = 0, expired = 0;\n    unsigned int new_idx_pos = subcache->idx_pos;\n    SHMCBIndex *idx = NULL;\n\n    while (loop < subcache->idx_used) {\n        idx = SHMCB_INDEX(subcache, new_idx_pos);\n        if (idx->removed)\n            freed++;\n        else if (idx->expires <= now)\n            expired++;\n        else\n            \n            break;\n        loop++;\n        new_idx_pos = SHMCB_CYCLIC_INCREMENT(new_idx_pos, 1, header->index_num);\n    }\n    if (!loop)\n        \n        return;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00842)\n                 \"expiring %u and reclaiming %u removed socache entries\",\n                 expired, freed);\n    if (loop == subcache->idx_used) {\n        \n        subcache->idx_used = 0;\n        subcache->data_used = 0;\n    } else {\n        \n        unsigned int diff = SHMCB_CYCLIC_SPACE(subcache->data_pos,\n                                               idx->data_pos,\n                                               header->subcache_data_size);\n        \n        subcache->idx_used -= loop;\n        subcache->idx_pos = new_idx_pos;\n        \n        subcache->data_used -= diff;\n        subcache->data_pos = idx->data_pos;\n    }\n    header->stat_expiries += expired;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00843)\n                 \"we now have %u socache entries\", subcache->idx_used);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f87cef9d7fd8a5202db0942af3534ab666a3204a_0", {
    "ID": "httpd_f87cef9d7fd8a5202db0942af3534ab666a3204a_0",
    "UID": "3901",
    "code": "static int shmcb_subcache_store(server_rec *s, SHMCBHeader test_snippet\n                                SHMCBSubcache *subcache,\n                                unsigned char *data, unsigned int data_len,\n                                const unsigned char *id, unsigned int id_len,\n                                apr_time_t expiry)\n{\n    unsigned int data_offset, new_idx, id_offset;\n    SHMCBIndex *idx;\n    unsigned int total_len = id_len + data_len;\n\n    \n    if (total_len > header->subcache_data_size) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00844)\n                     \"inserting socache entry larger (%d) than subcache data area (%d)\",\n                     total_len, header->subcache_data_size);\n        return -1;\n    }\n\n    \n    shmcb_subcache_expire(s, header, subcache, apr_time_now());\n\n    /* Loop until there is enough space to insert\n     * XXX: This should first compress out-of-order expiries and\n     * removed records, and then force-remove oldest-first\n     */\n    if (header->subcache_data_size - subcache->data_used < total_len\n        || subcache->idx_used == header->index_num) {\n        unsigned int loop = 0;\n\n        idx = SHMCB_INDEX(subcache, subcache->idx_pos);\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00845)\n                     \"about to force-expire, subcache: idx_used=%d, \"\n                     \"data_used=%d\", subcache->idx_used, subcache->data_used);\n        do {\n            SHMCBIndex *idx2;\n\n            \n            subcache->idx_pos = SHMCB_CYCLIC_INCREMENT(subcache->idx_pos, 1,\n                                                       header->index_num);\n            subcache->idx_used--;\n            if (!subcache->idx_used) {\n                \n                subcache->data_used = 0;\n                break;\n            }\n            \n            idx2 = SHMCB_INDEX(subcache, subcache->idx_pos);\n            subcache->data_used -= SHMCB_CYCLIC_SPACE(idx->data_pos, idx2->data_pos,\n                                                      header->subcache_data_size);\n            subcache->data_pos = idx2->data_pos;\n            \n            header->stat_scrolled++;\n            \n            idx = idx2;\n            loop++;\n        } while (header->subcache_data_size - subcache->data_used < total_len);\n\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00846)\n                     \"finished force-expire, subcache: idx_used=%d, \"\n                     \"data_used=%d\", subcache->idx_used, subcache->data_used);\n    }\n\n    /* HERE WE ASSUME THAT THE NEW ENTRY SHOULD GO ON THE END! I'M NOT\n     * CHECKING WHETHER IT SHOULD BE GENUINELY \"INSERTED\" SOMEWHERE.\n     *\n     * We aught to fix that.  httpd (never mind third party modules)\n     * does not promise to perform any processing in date order\n     * (c.f. FAQ \"My log entries are not in date order!\")\n     */\n    \n    id_offset = SHMCB_CYCLIC_INCREMENT(subcache->data_pos, subcache->data_used,\n                                       header->subcache_data_size);\n    shmcb_cyclic_ntoc_memcpy(header->subcache_data_size,\n                             SHMCB_DATA(header, subcache), id_offset,\n                             id, id_len);\n    subcache->data_used += id_len;\n    \n    data_offset = SHMCB_CYCLIC_INCREMENT(subcache->data_pos, subcache->data_used,\n                                         header->subcache_data_size);\n    shmcb_cyclic_ntoc_memcpy(header->subcache_data_size,\n                             SHMCB_DATA(header, subcache), data_offset,\n                             data, data_len);\n    subcache->data_used += data_len;\n    \n    new_idx = SHMCB_CYCLIC_INCREMENT(subcache->idx_pos, subcache->idx_used,\n                                     header->index_num);\n    idx = SHMCB_INDEX(subcache, new_idx);\n    idx->expires = expiry;\n    idx->data_pos = id_offset;\n    idx->data_used = total_len;\n    idx->id_len = id_len;\n    idx->removed = 0;\n    subcache->idx_used++;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00847)\n                 \"insert happened at idx=%d, data=(%u:%u)\", new_idx,\n                 id_offset, data_offset);\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00848)\n                 \"finished insert, subcache: idx_pos/idx_used=%d/%d, \"\n                 \"data_pos/data_used=%d/%d\",\n                 subcache->idx_pos, subcache->idx_used,\n                 subcache->data_pos, subcache->data_used);\n    return 0;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_eb28aeef83c2bd3f3ba833039f8ab0eddd28987f_0", {
    "ID": "httpd_eb28aeef83c2bd3f3ba833039f8ab0eddd28987f_0",
    "UID": "3905",
    "code": "static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader test_snippet\n                                   SHMCBSubcache *subcache,\n                                   const unsigned char *id, unsigned int idlen,\n                                   unsigned char *dest, unsigned int *destlen)\n{\n    unsigned int pos;\n    unsigned int loop = 0;\n    apr_time_t now = apr_time_now();\n\n    pos = subcache->idx_pos;\n\n    while (loop < subcache->idx_used) {\n        SHMCBIndex *idx = SHMCB_INDEX(subcache, pos);\n\n        /* Only consider 'idx' if the id matches, and the \"removed\"\n         * flag isn't set, and the record is not expired.\n         * Check the data length too to avoid a buffer overflow\n         * in case of corruption, which should be impossible,\n         * but it's cheap to be safe. */\n        if (!idx->removed\n            && idx->id_len == idlen\n            && (idx->data_used - idx->id_len) <= *destlen\n            && shmcb_cyclic_memcmp(header->subcache_data_size,\n                                   SHMCB_DATA(header, subcache),\n                                   idx->data_pos, id, idx->id_len) == 0) {\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00849)\n                         \"match at idx=%d, data=%d\", pos, idx->data_pos);\n            if (idx->expires > now) {\n                unsigned int data_offset;\n\n                \n                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos,\n                                                     idx->id_len,\n                                                     header->subcache_data_size);\n\n                *destlen = idx->data_used - idx->id_len;\n\n                \n                shmcb_cyclic_cton_memcpy(header->subcache_data_size,\n                                         dest, SHMCB_DATA(header, subcache),\n                                         data_offset, *destlen);\n\n                return 0;\n            }\n            else {\n                \n                idx->removed = 1;\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00850)\n                             \"shmcb_subcache_retrieve discarding expired entry\");\n                return -1;\n            }\n        }\n        \n        loop++;\n        pos = SHMCB_CYCLIC_INCREMENT(pos, 1, header->index_num);\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00851)\n                 \"shmcb_subcache_retrieve found no match\");\n    return -1;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow"
  },
  "httpd_801c058a5acb7c9852b0e1d47df767176072965c_0", {
    "ID": "httpd_801c058a5acb7c9852b0e1d47df767176072965c_0",
    "UID": "3906",
    "code": "static int shmcb_subcache_remove(server_rec *s, SHMCBHeader test_snippet\n                                 SHMCBSubcache *subcache,\n                                 const unsigned char *id,\n                                 unsigned int idlen)\n{\n    unsigned int pos;\n    unsigned int loop = 0;\n\n    pos = subcache->idx_pos;\n    while (loop < subcache->idx_used) {\n        SHMCBIndex *idx = SHMCB_INDEX(subcache, pos);\n\n        /* Only consider 'idx' if the id matches, and the \"removed\"\n         * flag isn't set. */\n        if (!idx->removed && idx->id_len == idlen\n            && shmcb_cyclic_memcmp(header->subcache_data_size,\n                                   SHMCB_DATA(header, subcache),\n                                   idx->data_pos, id, idx->id_len) == 0) {\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00852)\n                         \"possible match at idx=%d, data=%d\", pos, idx->data_pos);\n\n            \n            idx->removed = 1;\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00853)\n                         \"shmcb_subcache_remove removing matching entry\");\n            return 0;\n        }\n        \n        loop++;\n        pos = SHMCB_CYCLIC_INCREMENT(pos, 1, header->index_num);\n    }\n\n    return -1; \n}",
    "predicted": "476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_a49a2f61ef33852f8ed0533a115287e8a3013614_0", {
    "ID": "httpd_a49a2f61ef33852f8ed0533a115287e8a3013614_0",
    "UID": "3907",
    "code": "static void shmcb_cyclic_cton_memcpy(unsigned int buf_size, unsigned char test_snippet\n                                     const unsigned char *data, unsigned int src_offset,\n                                     unsigned int src_len)\n{\n    if (src_offset + src_len < buf_size)\n        \n        memcpy(dest, data + src_offset, src_len);\n    else {\n        \n        memcpy(dest, data + src_offset, buf_size - src_offset);\n        memcpy(dest + buf_size - src_offset, data,\n               src_len + src_offset - buf_size);\n    }\n}",
    "predicted": "415,Double Free\n416,Use After Free\n121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n680,Integer Overflow to Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n124,Buffer Underwrite ('Buffer Underflow')"
  },
  "httpd_b66cca3a1adf3c0ff020fc3f857d29d2ef570dbc_0", {
    "ID": "httpd_b66cca3a1adf3c0ff020fc3f857d29d2ef570dbc_0",
    "UID": "3908",
    "code": "static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t test_snippet\n                                           server_rec *s,\n                                           void *userctx,\n                                           SHMCBHeader *header,\n                                           SHMCBSubcache *subcache,\n                                           ap_socache_iterator_t *iterator,\n                                           unsigned char **buf,\n                                           apr_size_t *buf_len,\n                                           apr_pool_t *pool,\n                                           apr_time_t now)\n{\n    unsigned int pos;\n    unsigned int loop = 0;\n    apr_status_t rv;\n\n    pos = subcache->idx_pos;\n    while (loop < subcache->idx_used) {\n        SHMCBIndex *idx = SHMCB_INDEX(subcache, pos);\n\n        \n        if (!idx->removed) {\n\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00854)\n                         \"iterating idx=%d, data=%d\", pos, idx->data_pos);\n            if (idx->expires > now) {\n                unsigned char *id = *buf;\n                unsigned char *dest;\n                unsigned int data_offset, dest_len;\n                apr_size_t buf_req;\n\n                \n                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos,\n                                                     idx->id_len,\n                                                     header->subcache_data_size);\n\n                dest_len = idx->data_used - idx->id_len;\n\n                buf_req = APR_ALIGN_DEFAULT(idx->id_len + 1)\n                        + APR_ALIGN_DEFAULT(dest_len + 1);\n\n                if (buf_req > *buf_len) {\n                     /* Grow to ~150% of this buffer requirement on resize\n                      * always using APR_ALIGN_DEFAULT sized pages\n                      */\n                     *buf_len = buf_req + APR_ALIGN_DEFAULT(buf_req / 2);\n                     *buf = apr_palloc(pool, *buf_len);\n                     id = *buf;\n                }\n\n                dest = *buf + APR_ALIGN_DEFAULT(idx->id_len + 1);\n\n                \n                shmcb_cyclic_cton_memcpy(header->subcache_data_size, id,\n                                         SHMCB_DATA(header, subcache),\n                                         idx->data_pos, idx->id_len);\n                id[idx->id_len] = '\\0';\n\n                shmcb_cyclic_cton_memcpy(header->subcache_data_size, dest,\n                                         SHMCB_DATA(header, subcache),\n                                         data_offset, dest_len);\n                dest[dest_len] = '\\0';\n\n                rv = iterator(instance, s, userctx, id, idx->id_len,\n                              dest, dest_len, pool);\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(00855)\n                             \"shmcb entry iterated\");\n                if (rv != APR_SUCCESS)\n                    return rv;\n            }\n            else {\n                \n                idx->removed = 1;\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00856)\n                             \"shmcb_subcache_iterate discarding expired entry\");\n            }\n        }\n        \n        loop++;\n        pos = SHMCB_CYCLIC_INCREMENT(pos, 1, header->index_num);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_01fd9e05112ed82e1cb2b58fd6e6421e19518c41_0", {
    "ID": "httpd_01fd9e05112ed82e1cb2b58fd6e6421e19518c41_0",
    "UID": "3911",
    "code": "static void extend_timeout(reqtimeout_con_cfg *ccfg, apr_bucket_brigade test_snippet\n{\n    apr_off_t len;\n    apr_time_t new_timeout_at;\n\n    if (apr_brigade_length(bb, 0, &len) != APR_SUCCESS || len <= 0)\n        return;\n\n    new_timeout_at = ccfg->timeout_at + len * ccfg->cur_stage.rate_factor;\n    if (ccfg->max_timeout_at > 0 && new_timeout_at > ccfg->max_timeout_at) {\n        ccfg->timeout_at = ccfg->max_timeout_at;\n    }\n    else {\n        ccfg->timeout_at = new_timeout_at;\n    }\n}",
    "predicted": "190,Integer Overflow or Wraparound"
  },
  "httpd_f4e939d64a90bebf3eea9b62996308711a4faaab_0", {
    "ID": "httpd_f4e939d64a90bebf3eea9b62996308711a4faaab_0",
    "UID": "3913",
    "code": "static apr_status_t have_lf_or_eos(apr_bucket_brigade test_snippet\n{\n    apr_bucket *b = APR_BRIGADE_LAST(bb);\n\n    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {\n        const char *str;\n        apr_size_t len;\n        apr_status_t rv;\n\n        if (APR_BUCKET_IS_EOS(b))\n            return APR_SUCCESS;\n\n        if (APR_BUCKET_IS_METADATA(b))\n            continue;\n\n        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);\n        if (rv != APR_SUCCESS)\n            return rv;\n\n        if (len == 0)\n            continue;\n\n        if (str[len-1] == APR_ASCII_LF)\n            return APR_SUCCESS;\n    }\n    return APR_INCOMPLETE;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_1ef02b9f796834be663b4212a7aa2beac72fb763_0", {
    "ID": "httpd_1ef02b9f796834be663b4212a7aa2beac72fb763_0",
    "UID": "3914",
    "code": "static apr_status_t brigade_append(apr_bucket_brigade *bbOut, apr_bucket_brigade test_snippet\n{\n    while (!APR_BRIGADE_EMPTY(bbIn)) {\n        apr_bucket *e = APR_BRIGADE_FIRST(bbIn);\n        const char *str;\n        apr_size_t len;\n        apr_status_t rv;\n\n        rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        APR_BUCKET_REMOVE(e);\n        if (APR_BUCKET_IS_METADATA(e) || len > APR_BUCKET_BUFF_SIZE/4) {\n            APR_BRIGADE_INSERT_TAIL(bbOut, e);\n        }\n        else {\n            if (len > 0) {\n                rv = apr_brigade_write(bbOut, NULL, NULL, str, len);\n                if (rv != APR_SUCCESS) {\n                    apr_bucket_destroy(e);\n                    return rv;\n                }\n            }\n            apr_bucket_destroy(e);\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_3a0e41895e139eb85a44d5b8311cc4d1dac75b7e_0", {
    "ID": "httpd_3a0e41895e139eb85a44d5b8311cc4d1dac75b7e_0",
    "UID": "3918",
    "code": "static apr_status_t reqtimeout_eor(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    if (!APR_BRIGADE_EMPTY(bb) && AP_BUCKET_IS_EOR(APR_BRIGADE_LAST(bb))) {\n        reqtimeout_con_cfg *ccfg = f->ctx;\n        ccfg->timeout_at = 0;\n    }\n    return ap_pass_brigade(f->next, bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_bf55477cdbc6a7a0472dda9d08f91615fcbe9fd3_0", {
    "ID": "httpd_bf55477cdbc6a7a0472dda9d08f91615fcbe9fd3_0",
    "UID": "3919",
    "code": "static int stream_reqbody(proxy_http_req_t *req, rb_methods test_snippet\n{\n    request_rec *r = req->r;\n    int seen_eos = 0, rv = OK;\n    apr_size_t hdr_len;\n    char chunk_hdr[20];  \n    proxy_conn_rec *p_conn = req->backend;\n    apr_bucket_alloc_t *bucket_alloc = req->bucket_alloc;\n    apr_bucket_brigade *header_brigade = req->header_brigade;\n    apr_bucket_brigade *input_brigade = req->input_brigade;\n    apr_off_t bytes, bytes_streamed = 0;\n    apr_bucket *e;\n\n    do {\n        if (APR_BRIGADE_EMPTY(input_brigade)\n                && APR_BRIGADE_EMPTY(header_brigade)) {\n            rv = stream_reqbody_read(req, input_brigade, 1);\n            if (rv != OK) {\n                return rv;\n            }\n        }\n\n        if (!APR_BRIGADE_EMPTY(input_brigade)) {\n            \n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                seen_eos = 1;\n\n                \n                e = APR_BRIGADE_LAST(input_brigade);\n                apr_bucket_delete(e);\n            }\n\n            apr_brigade_length(input_brigade, 1, &bytes);\n            bytes_streamed += bytes;\n\n            if (rb_method == RB_STREAM_CHUNKED) {\n                if (bytes) {\n                    /*\n                     * Prepend the size of the chunk\n                     */\n                    hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\n                                           \"%\" APR_UINT64_T_HEX_FMT CRLF,\n                                           (apr_uint64_t)bytes);\n                    ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);\n                    e = apr_bucket_transient_create(chunk_hdr, hdr_len,\n                                                    bucket_alloc);\n                    APR_BRIGADE_INSERT_HEAD(input_brigade, e);\n\n                    /*\n                     * Append the end-of-chunk CRLF\n                     */\n                    e = apr_bucket_immortal_create(CRLF_ASCII, 2, bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n                }\n                if (seen_eos) {\n                    /*\n                     * Append the tailing 0-size chunk\n                     */\n                    e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                                   \n                                                   CRLF_ASCII,\n                                                   5, bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n                }\n            }\n            else if (bytes_streamed > req->cl_val) {\n                /* C-L < bytes streamed?!?\n                 * We will error out after the body is completely\n                 * consumed, but we can't stream more bytes at the\n                 * back end since they would in part be interpreted\n                 * as another request!  If nothing is sent, then\n                 * just send nothing.\n                 *\n                 * Prevents HTTP Response Splitting.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01086)\n                              \"read more bytes of request body than expected \"\n                              \"(got %\" APR_OFF_T_FMT \", expected \"\n                              \"%\" APR_OFF_T_FMT \")\",\n                              bytes_streamed, req->cl_val);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            if (seen_eos && apr_table_get(r->subprocess_env,\n                                          \"proxy-sendextracrlf\")) {\n                e = apr_bucket_immortal_create(CRLF_ASCII, 2, bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n            }\n        }\n\n        /* If we never sent the header brigade, go ahead and take care of\n         * that now by prepending it (once only since header_brigade will be\n         * empty afterward).\n         */\n        APR_BRIGADE_PREPEND(input_brigade, header_brigade);\n\n        \n        rv = ap_proxy_pass_brigade(bucket_alloc, r, p_conn, req->origin,\n                                   input_brigade, seen_eos);\n        if (rv != OK) {\n            return rv;\n        }\n    } while (!seen_eos);\n\n    if (rb_method == RB_STREAM_CL && bytes_streamed != req->cl_val) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01087)\n                      \"client %s given Content-Length did not match\"\n                      \" number of body bytes read\", r->connection->client_ip);\n        return HTTP_BAD_REQUEST;\n    }\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_346444f3da94cf7f0ea1aefec1320084ac21b5d4_0", {
    "ID": "httpd_346444f3da94cf7f0ea1aefec1320084ac21b5d4_0",
    "UID": "3923",
    "code": "static const char *set_reqtimeout_param(reqtimeout_srv_cfg test_snippet\n                                      apr_pool_t *p,\n                                      const char *key,\n                                      const char *val)\n{\n    const char *ret = NULL;\n    char *rate_str = NULL, *initial_str, *max_str = NULL;\n    reqtimeout_stage_t *stage;\n\n    if (!strcasecmp(key, \"handshake\")) {\n        stage = &conf->handshake;\n    }\n    else if (!strcasecmp(key, \"header\")) {\n        stage = &conf->header;\n    }\n    else if (!strcasecmp(key, \"body\")) {\n        stage = &conf->body;\n    }\n    else {\n        return \"Unknown RequestReadTimeout parameter\";\n    }\n\n    memset(stage, 0, sizeof(*stage));\n\n    if ((rate_str = ap_strcasestr(val, \",minrate=\"))) {\n        initial_str = apr_pstrndup(p, val, rate_str - val);\n        rate_str += strlen(\",minrate=\");\n        ret = parse_int(p, rate_str, &stage->min_rate);\n        if (ret)\n            return ret;\n\n        if (stage->min_rate == 0)\n            return \"Minimum data rate must be larger than 0\";\n\n        if ((max_str = strchr(initial_str, '-'))) {\n            *max_str++ = '\\0';\n            ret = parse_int(p, max_str, &stage->max_timeout);\n            if (ret)\n                return ret;\n        }\n\n        ret = parse_int(p, initial_str, &stage->timeout);\n    }\n    else {\n        if (ap_strchr_c(val, '-'))\n            return \"Must set MinRate option if using timeout range\";\n        ret = parse_int(p, val, &stage->timeout);\n    }\n    if (ret)\n        return ret;\n\n    if (stage->max_timeout && stage->timeout >= stage->max_timeout) {\n        return \"Maximum timeout must be larger than initial timeout\";\n    }\n\n    if (stage->min_rate) {\n        stage->rate_factor = apr_time_from_sec(1) / stage->min_rate;\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')"
  },
  "httpd_050c03ac3a5cb89cc5a64d29187086f6c821929e_0", {
    "ID": "httpd_050c03ac3a5cb89cc5a64d29187086f6c821929e_0",
    "UID": "3924",
    "code": "static apr_status_t recall_body(cache_handle_t *h, apr_pool_t test_snippet\n        apr_bucket_brigade *bb)\n{\n    cache_socache_object_t *sobj = (cache_socache_object_t*) h->cache_obj->vobj;\n\n    if (sobj->body) {\n        APR_BRIGADE_CONCAT(bb, sobj->body);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_d11a900c788cd179f3619cdd45c2e62ddfc50321_0", {
    "ID": "httpd_d11a900c788cd179f3619cdd45c2e62ddfc50321_0",
    "UID": "3925",
    "code": "static int ap_proxy_http_request(proxy_http_req_t test_snippet\n{\n    int rv;\n    request_rec *r = req->r;\n    apr_bucket_alloc_t *bucket_alloc = req->bucket_alloc;\n    apr_bucket_brigade *header_brigade = req->header_brigade;\n    apr_bucket_brigade *input_brigade = req->input_brigade;\n\n    \n    switch (req->rb_method) {\n    case RB_STREAM_CL:\n    case RB_STREAM_CHUNKED:\n        if (req->do_100_continue) {\n            rv = ap_proxy_pass_brigade(bucket_alloc, r, req->backend,\n                                       req->origin, header_brigade, 1);\n        }\n        else {\n            rv = stream_reqbody(req, req->rb_method);\n        }\n        break;\n\n    case RB_SPOOL_CL:\n        /* Prefetch has built the header and spooled the whole body;\n         * if we don't expect 100-continue we can flush both all at once,\n         * otherwise flush the header only.\n         */\n        if (!req->do_100_continue) {\n            APR_BRIGADE_CONCAT(header_brigade, input_brigade);\n        }\n        rv = ap_proxy_pass_brigade(bucket_alloc, r, req->backend,\n                                   req->origin, header_brigade, 1);\n        break;\n\n    default:\n        \n        rv = HTTP_INTERNAL_SERVER_ERROR;\n        break;\n    }\n\n    if (rv != OK) {\n        conn_rec *c = r->connection;\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01097)\n                      \"pass request body failed to %pI (%s) from %s (%s)\",\n                      req->backend->addr,\n                      req->backend->hostname ? req->backend->hostname: \"\",\n                      c->client_ip, c->remote_host ? c->remote_host: \"\");\n        return rv;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_a6d133541f2cce2246f82132df452ea2df033af1_0", {
    "ID": "httpd_a6d133541f2cce2246f82132df452ea2df033af1_0",
    "UID": "3927",
    "code": "static apr_status_t hc_watchdog_callback(int state, void test_snippet\n                                         apr_pool_t *pool)\n{\n    apr_status_t rv = APR_SUCCESS;\n    apr_time_t now = apr_time_now();\n    proxy_balancer *balancer;\n    sctx_t *ctx = (sctx_t *)data;\n    server_rec *s = ctx->s;\n    proxy_server_conf *conf;\n    static apr_thread_pool_t *hctp = NULL;\n\n    switch (state) {\n        case AP_WATCHDOG_STATE_STARTING:\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(03258)\n                         \"%s watchdog started.\",\n                         HCHECK_WATHCHDOG_NAME);\n#if HC_USE_THREADS\n            if (tpsize && hctp == NULL) {\n                rv =  apr_thread_pool_create(&hctp, tpsize,\n                                             tpsize, ctx->p);\n                if (rv != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(03312)\n                                 \"apr_thread_pool_create() with %d threads failed\",\n                                 tpsize);\n                    \n                    hctp = NULL;\n                } else {\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(03313)\n                                 \"apr_thread_pool_create() with %d threads succeeded\",\n                                 tpsize);\n                }\n            } else {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(03314)\n                             \"Skipping apr_thread_pool_create()\");\n                hctp = NULL;\n            }\n\n#endif\n            break;\n\n        case AP_WATCHDOG_STATE_RUNNING:\n            \n            if (s) {\n                int i;\n                conf = (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);\n                balancer = (proxy_balancer *)conf->balancers->elts;\n                ctx->s = s;\n                for (i = 0; i < conf->balancers->nelts; i++, balancer++) {\n                    int n;\n                    proxy_worker **workers;\n                    proxy_worker *worker;\n                    \n                    ap_proxy_sync_balancer(balancer, s, conf);\n                    workers = (proxy_worker **)balancer->workers->elts;\n                    for (n = 0; n < balancer->workers->nelts; n++) {\n                        worker = *workers;\n                        if (!PROXY_WORKER_IS(worker, PROXY_WORKER_STOPPED) &&\n                           (worker->s->method != NONE) &&\n                           (now > worker->s->updated + worker->s->interval)) {\n                            baton_t *baton;\n                            apr_pool_t *ptemp;\n                            ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, s,\n                                         \"Checking %s worker: %s  [%d] (%pp)\", balancer->s->name,\n                                         worker->s->name, worker->s->method, worker);\n\n                            if ((rv = hc_init_worker(ctx, worker)) != APR_SUCCESS) {\n                                return rv;\n                            }\n                            \n                            apr_pool_create(&ptemp, ctx->p);\n                            apr_pool_tag(ptemp, \"hc_request\");\n                            baton = apr_palloc(ptemp, sizeof(baton_t));\n                            baton->ctx = ctx;\n                            baton->now = now;\n                            baton->balancer = balancer;\n                            baton->worker = worker;\n                            baton->ptemp = ptemp;\n                            baton->hc = hc_get_hcworker(ctx, worker, ptemp);\n\n                            if (!hctp) {\n                                hc_check(NULL, baton);\n                            }\n#if HC_USE_THREADS\n                            else {\n                                rv = apr_thread_pool_push(hctp, hc_check, (void *)baton,\n                                                          APR_THREAD_TASK_PRIORITY_NORMAL, NULL);\n                            }\n#endif\n                        }\n                        workers++;\n                    }\n                }\n            }\n            break;\n\n        case AP_WATCHDOG_STATE_STOPPING:\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(03261)\n                         \"stopping %s watchdog.\",\n                         HCHECK_WATHCHDOG_NAME);\n#if HC_USE_THREADS\n            if (hctp) {\n                rv =  apr_thread_pool_destroy(hctp);\n                if (rv != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(03315)\n                                 \"apr_thread_pool_destroy() failed\");\n                }\n            }\n#endif\n            hctp = NULL;\n            break;\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_062e1511bbda2ec1321f908d30d6d5c87a79ad15_0", {
    "ID": "httpd_062e1511bbda2ec1321f908d30d6d5c87a79ad15_0",
    "UID": "3929",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t test_snippet\n                                                           apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    int header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));\n    const char *protocol = NULL;\n    apr_bucket *e;\n    apr_bucket_brigade *b2;\n    header_struct h;\n    header_filter_ctx *ctx = f->ctx;\n    const char *ctype;\n    ap_bucket_error *eb = NULL;\n    apr_status_t rv = APR_SUCCESS;\n    int recursive_error = 0;\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));\n    }\n    else if (ctx->headers_sent) {\n        \n        if (header_only) {\n            /* Still next filters may be waiting for EOS, so pass it (alone)\n             * when encountered and be done with this filter.\n             */\n            e = APR_BRIGADE_LAST(b);\n            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {\n                APR_BUCKET_REMOVE(e);\n                apr_brigade_cleanup(b);\n                APR_BRIGADE_INSERT_HEAD(b, e);\n                ap_remove_output_filter(f);\n                rv = ap_pass_brigade(f->next, b);\n            }\n            apr_brigade_cleanup(b);\n            return rv;\n        }\n    }\n\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (AP_BUCKET_IS_ERROR(e) && !eb) {\n            eb = e->data;\n            continue;\n        }\n        /*\n         * If we see an EOC bucket it is a signal that we should get out\n         * of the way doing nothing.\n         */\n        if (AP_BUCKET_IS_EOC(e)) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, b);\n        }\n    }\n\n    if (!ctx->headers_sent && !check_headers(r)) {\n        /* We may come back here from ap_die() below,\n         * so clear anything from this response.\n         */\n        apr_table_clear(r->headers_out);\n        apr_table_clear(r->err_headers_out);\n        apr_brigade_cleanup(b);\n\n        /* Don't recall ap_die() if we come back here (from its own internal\n         * redirect or error response), otherwise we can end up in infinite\n         * recursion; better fall through with 500, minimal headers and an\n         * empty body (EOS only).\n         */\n        if (!check_headers_recursion(r)) {\n            ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n            return AP_FILTER_ERROR;\n        }\n        r->status = HTTP_INTERNAL_SERVER_ERROR;\n        e = ap_bucket_eoc_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        ap_set_content_length(r, 0);\n        recursive_error = 1;\n    }\n    else if (eb) {\n        int status;\n        status = eb->status;\n        apr_brigade_cleanup(b);\n        ap_die(status, r);\n        return AP_FILTER_ERROR;\n    }\n\n    if (r->assbackwards) {\n        r->sent_bodyct = 1;\n        ap_remove_output_filter(f);\n        rv = ap_pass_brigade(f->next, b);\n        goto out;\n    }\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n    }\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_setn(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    \n    basic_http_header_check(r, &protocol);\n    ap_set_keepalive(r);\n\n    if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n        apr_table_unset(r->headers_out, \"Transfer-Encoding\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        r->clength = r->chunked = 0;\n    }\n    else if (r->chunked) {\n        apr_table_mergen(r->headers_out, \"Transfer-Encoding\", \"chunked\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n    }\n\n    ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, \"Content-Type\", ctype);\n    }\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char *token;\n        char **languages = (char **)(r->content_languages->elts);\n        const char *field = apr_table_get(r->headers_out, \"Content-Language\");\n\n        while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n            for (i = 0; i < r->content_languages->nelts; ++i) {\n                if (!ap_cstr_casecmp(token, languages[i]))\n                    break;\n            }\n            if (i == r->content_languages->nelts) {\n                *((char **) apr_array_push(r->content_languages)) = token;\n            }\n        }\n\n        field = apr_array_pstrcat(r->pool, r->content_languages, ',');\n        apr_table_setn(r->headers_out, \"Content-Language\", field);\n    }\n\n    /*\n     * Control cachability for non-cacheable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    b2 = apr_brigade_create(r->pool, c->bucket_alloc);\n    basic_http_header(r, b2, protocol);\n\n    h.pool = r->pool;\n    h.bb = b2;\n\n    if (r->status == HTTP_NOT_MODIFIED) {\n        apr_table_do((int (*)(void *, const char *, const char *)) form_header_field,\n                     (void *) &h, r->headers_out,\n                     \"Connection\",\n                     \"Keep-Alive\",\n                     \"ETag\",\n                     \"Content-Location\",\n                     \"Expires\",\n                     \"Cache-Control\",\n                     \"Vary\",\n                     \"Warning\",\n                     \"WWW-Authenticate\",\n                     \"Proxy-Authenticate\",\n                     \"Set-Cookie\",\n                     \"Set-Cookie2\",\n                     NULL);\n    }\n    else {\n        send_all_header_fields(&h, r);\n    }\n\n    terminate_header(b2);\n\n    if (header_only) {\n        e = APR_BRIGADE_LAST(b);\n        if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(b2, e);\n            ap_remove_output_filter(f);\n        }\n        apr_brigade_cleanup(b);\n    }\n\n    rv = ap_pass_brigade(f->next, b2);\n    apr_brigade_cleanup(b2);\n    ctx->headers_sent = 1;\n\n    if (rv != APR_SUCCESS || header_only) {\n        goto out;\n    }\n\n    r->sent_bodyct = 1;         \n\n    if (r->chunked) {\n        /* We can't add this filter until we have already sent the headers.\n         * If we add it before this point, then the headers will be chunked\n         * as well, and that is just wrong.\n         */\n        ap_add_output_filter(\"CHUNK\", NULL, r, r->connection);\n    }\n\n    /* Don't remove this filter until after we have added the CHUNK filter.\n     * Otherwise, f->next won't be the CHUNK filter and thus the first\n     * brigade won't be chunked properly.\n     */\n    ap_remove_output_filter(f);\n    rv = ap_pass_brigade(f->next, b);\nout:\n    if (recursive_error) {\n        return AP_FILTER_ERROR;\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_1671fe5e6d658d04e3c87136cfde377ee780aab3_0", {
    "ID": "httpd_1671fe5e6d658d04e3c87136cfde377ee780aab3_0",
    "UID": "3939",
    "code": "static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server, int test_snippet\n{\n    apr_socket_t *s = server->sd;\n    int one = 1;\n#if APR_HAVE_IPV6\n#ifdef AP_ENABLE_V4_MAPPED\n    int v6only_setting = 0;\n#else\n    int v6only_setting = 1;\n#endif\n#endif\n    apr_status_t stat;\n\n#ifndef WIN32\n    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00067)\n                      \"make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n#endif\n\n    stat = apr_socket_opt_set(s, APR_SO_KEEPALIVE, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00068)\n                      \"make_sock: for address %pI, apr_socket_opt_set: (SO_KEEPALIVE)\",\n                      server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n\n    /*\n     * To send data over high bandwidth-delay connections at full\n     * speed we must force the TCP window to open wide enough to keep the\n     * pipe full.  The default window size on many systems\n     * is only 4kB.  Cross-country WAN connections of 100ms\n     * at 1Mb/s are not impossible for well connected sites.\n     * If we assume 100ms cross-country latency,\n     * a 4kB buffer limits throughput to 40kB/s.\n     *\n     * To avoid this problem I've added the SendBufferSize directive\n     * to allow the web master to configure send buffer size.\n     *\n     * The trade-off of larger buffers is that more kernel memory\n     * is consumed.  YMMV, know your customers and your network!\n     *\n     * -John Heidemann <johnh@isi.edu> 25-Oct-96\n     *\n     * If no size is specified, use the kernel default.\n     */\n    if (send_buffer_size) {\n        stat = apr_socket_opt_set(s, APR_SO_SNDBUF,  send_buffer_size);\n        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p, APLOGNO(00070)\n                          \"make_sock: failed to set SendBufferSize for \"\n                          \"address %pI, using default\",\n                          server->bind_addr);\n            \n        }\n    }\n    if (receive_buffer_size) {\n        stat = apr_socket_opt_set(s, APR_SO_RCVBUF, receive_buffer_size);\n        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p, APLOGNO(00071)\n                          \"make_sock: failed to set ReceiveBufferSize for \"\n                          \"address %pI, using default\",\n                          server->bind_addr);\n            \n        }\n    }\n\n#if APR_TCP_NODELAY_INHERITED\n    ap_sock_disable_nagle(s);\n#endif\n\n#ifdef SO_REUSEPORT\n    {\n      int thesock;\n      apr_os_sock_get(&thesock, s);\n      if (setsockopt(thesock, SOL_SOCKET, SO_REUSEPORT, (void *)&one, sizeof(int)) < 0) {\n          \n          if (errno == ENOPROTOOPT) {\n              have_so_reuseport = 0;\n          } \n          else {\n              ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(02638)\n                      \"make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEPORT)\",\n                       server->bind_addr);\n              apr_socket_close(s);\n              return errno;\n          }\n      }\n      else {\n          have_so_reuseport = 1;\n      }\n    }\n#endif\n\n    if (test_snippet {\n#if APR_HAVE_IPV6\n        if (server->bind_addr->family == APR_INET6) {\n            stat = apr_socket_opt_set(s, APR_IPV6_V6ONLY, v6only_setting);\n            if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n                ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00069)\n                              \"make_sock: for address %pI, apr_socket_opt_set: \"\n                              \"(IPV6_V6ONLY)\",\n                              server->bind_addr);\n                apr_socket_close(s);\n                return stat;\n            }\n        }\n#endif\n\n        if ((stat = apr_socket_bind(s, server->bind_addr)) != APR_SUCCESS) {\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, stat, p, APLOGNO(00072)\n                          \"make_sock: could not bind to address %pI\",\n                          server->bind_addr);\n            apr_socket_close(s);\n            return stat;\n        }\n\n        if ((stat = apr_socket_listen(s, ap_listenbacklog)) != APR_SUCCESS) {\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, stat, p, APLOGNO(00073)\n                          \"make_sock: unable to listen for connections \"\n                          \"on address %pI\",\n                          server->bind_addr);\n            apr_socket_close(s);\n            return stat;\n        }\n    }\n\n#ifdef WIN32\n    /* I seriously doubt that this would work on Unix; I have doubts that\n     * it entirely solves the problem on Win32.  However, since setting\n     * reuseaddr on the listener -prior- to binding the socket has allowed\n     * us to attach to the same port as an already running instance of\n     * Apache, or even another web server, we cannot identify that this\n     * port was exclusively granted to this instance of Apache.\n     *\n     * So set reuseaddr, but do not attempt to do so until we have the\n     * parent listeners successfully bound.\n     */\n    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);\n    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {\n        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00074)\n                    \"make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)\",\n                     server->bind_addr);\n        apr_socket_close(s);\n        return stat;\n    }\n#endif\n\n    server->sd = s;\n    server->active = enable_default_listener;\n\n    server->accept_func = NULL;\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_4e43dca6c94111c2ceb15c5ca5cc84e79034b17d_0", {
    "ID": "httpd_4e43dca6c94111c2ceb15c5ca5cc84e79034b17d_0",
    "UID": "3940",
    "code": "AP_CORE_DECLARE(apr_status_t) ap_shutdown_conn(conn_rec *c, int test_snippet\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n\n    bb = apr_brigade_create(c->pool, c->bucket_alloc);\n\n    if (test_snippet {\n        \n        b = apr_bucket_flush_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n    }\n\n    \n    b = ap_bucket_eoc_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    rv = ap_pass_brigade(c->output_filters, bb);\n    apr_brigade_destroy(bb);\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_cb5783f36e244a8ff6b90dabcca006275269fbd3_0", {
    "ID": "httpd_cb5783f36e244a8ff6b90dabcca006275269fbd3_0",
    "UID": "3942",
    "code": "apr_status_t cache_remove_lock(cache_server_conf test_snippet\n        cache_request_rec *cache, request_rec *r, apr_bucket_brigade *bb)\n{\n    void *dummy;\n    const char *lockname;\n\n    if (!conf || !conf->lock || !conf->lockpath) {\n        \n        return APR_SUCCESS;\n    }\n    if (bb) {\n        apr_bucket *e;\n        int eos_found = 0;\n        for (e = APR_BRIGADE_FIRST(bb);\n             e != APR_BRIGADE_SENTINEL(bb);\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_EOS(e)) {\n                eos_found = 1;\n                break;\n            }\n        }\n        if (!eos_found) {\n            /* no eos found in brigade, don't delete anything just yet,\n             * we are not done.\n             */\n            return APR_SUCCESS;\n        }\n    }\n    apr_pool_userdata_get(&dummy, CACHE_LOCKFILE_KEY, r->pool);\n    if (dummy) {\n        return apr_file_close((apr_file_t *)dummy);\n    }\n    apr_pool_userdata_get(&dummy, CACHE_LOCKNAME_KEY, r->pool);\n    lockname = (const char *)dummy;\n    if (!lockname) {\n        char dir[5];\n\n        \n        if (!cache->key) {\n            cache_generate_key(r, r->pool, &cache->key);\n        }\n\n        \n        lockname = ap_cache_generate_name(r->pool, 0, 0, cache->key);\n\n        /* lock files represent discrete just-went-stale URLs \"in flight\", so\n         * we support a simple two level directory structure, more is overkill.\n         */\n        dir[0] = '/';\n        dir[1] = lockname[0];\n        dir[2] = '/';\n        dir[3] = lockname[1];\n        dir[4] = 0;\n\n        lockname = apr_pstrcat(r->pool, conf->lockpath, dir, \"/\", lockname, NULL);\n    }\n    return apr_file_remove(lockname, r->pool);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4d7cdfe13f81c3f3a142b8be0b14ff516f13f7bd_0", {
    "ID": "httpd_4d7cdfe13f81c3f3a142b8be0b14ff516f13f7bd_0",
    "UID": "3943",
    "code": "static int cgid_server(void test_snippet\n{\n    int sd, sd2, rc;\n    mode_t omask;\n    apr_pool_t *ptrans;\n    server_rec *main_server = data;\n    apr_hash_t *script_hash = apr_hash_make(pcgi);\n    apr_status_t rv;\n\n    apr_pool_create(&ptrans, pcgi);\n\n    apr_signal(SIGCHLD, SIG_IGN);\n    apr_signal(SIGHUP, daemon_signal_handler);\n\n    \n    ap_close_listeners();\n\n    \n    ap_hook_get_suexec_identity(cgid_suexec_id_doer, NULL, NULL,\n                                APR_HOOK_REALLY_FIRST);\n    apr_hook_sort_all();\n\n    if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01242)\n                     \"Couldn't create unix domain socket\");\n        return errno;\n    }\n\n    omask = umask(0077); \n    rc = bind(sd, (struct sockaddr *)server_addr, server_addr_len);\n    umask(omask); \n    if (rc < 0) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01243)\n                     \"Couldn't bind unix domain socket %s\",\n                     sockname);\n        return errno;\n    }\n\n    \n    rv = apr_file_perms_set(sockname, APR_FPROT_UREAD|APR_FPROT_UWRITE|APR_FPROT_UEXECUTE);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, main_server, APLOGNO(01244)\n                     \"Couldn't set permissions on unix domain socket %s\",\n                     sockname);\n        return rv;\n    }\n\n    if (listen(sd, DEFAULT_CGID_LISTENBACKLOG) < 0) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01245)\n                     \"Couldn't listen on unix domain socket\");\n        return errno;\n    }\n\n    if (!geteuid()) {\n        if (chown(sockname, ap_unixd_config.user_id, -1) < 0) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01246)\n                         \"Couldn't change owner of unix domain socket %s\",\n                         sockname);\n            return errno;\n        }\n    }\n\n    apr_pool_cleanup_register(pcgi, (void *)((long)sd),\n                              close_unix_socket, close_unix_socket);\n\n    \n    if ((rc = ap_run_drop_privileges(pcgi, ap_server_conf)) != 0) {\n        return rc;\n    }\n\n    while (!daemon_should_exit) {\n        int errfileno = STDERR_FILENO;\n        char *argv0 = NULL;\n        char **env = NULL;\n        const char * const *argv;\n        apr_int32_t in_pipe;\n        apr_int32_t out_pipe;\n        apr_int32_t err_pipe;\n        apr_cmdtype_e cmd_type;\n        request_rec *r;\n        apr_procattr_t *procattr = NULL;\n        apr_proc_t *procnew = NULL;\n        apr_file_t *inout;\n        cgid_req_t cgid_req;\n        apr_status_t stat;\n        void *key;\n        apr_socklen_t len;\n        struct sockaddr_un unix_addr;\n\n        apr_pool_clear(ptrans);\n\n        len = sizeof(unix_addr);\n        sd2 = accept(sd, (struct sockaddr *)&unix_addr, &len);\n        if (sd2 < 0) {\n#if defined(ENETDOWN)\n            if (errno == ENETDOWN) {\n                \n                ++daemon_should_exit;\n            }\n#endif\n            if (errno != EINTR) {\n                ap_log_error(APLOG_MARK, APLOG_ERR, errno,\n                             (server_rec *)data, APLOGNO(01247)\n                             \"Error accepting on cgid socket\");\n            }\n            continue;\n        }\n\n        r = apr_pcalloc(ptrans, sizeof(request_rec));\n        procnew = apr_pcalloc(ptrans, sizeof(*procnew));\n        r->pool = ptrans;\n        stat = get_req(sd2, r, &argv0, &env, &cgid_req);\n        if (stat != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, stat,\n                         main_server, APLOGNO(01248)\n                         \"Error reading request on cgid socket\");\n            close(sd2);\n            continue;\n        }\n\n        if (cgid_req.ppid != parent_pid) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, main_server, APLOGNO(01249)\n                         \"CGI request received from wrong server instance; \"\n                         \"see ScriptSock directive\");\n            close(sd2);\n            continue;\n        }\n\n        if (cgid_req.req_type == GETPID_REQ) {\n            pid_t pid;\n            apr_status_t rv;\n\n            pid = (pid_t)((long)apr_hash_get(script_hash, &cgid_req.conn_id, sizeof(cgid_req.conn_id)));\n            rv = sock_write(sd2, &pid, sizeof(pid));\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ERR, rv,\n                             main_server, APLOGNO(01250)\n                             \"Error writing pid %\" APR_PID_T_FMT \" to handler\", pid);\n            }\n            close(sd2);\n            continue;\n        }\n\n        apr_os_file_put(&r->server->error_log, &errfileno, 0, r->pool);\n        apr_os_file_put(&inout, &sd2, 0, r->pool);\n\n        if (cgid_req.req_type == SSI_REQ) {\n            in_pipe  = APR_NO_PIPE;\n            out_pipe = APR_FULL_BLOCK;\n            err_pipe = APR_NO_PIPE;\n            cmd_type = APR_SHELLCMD;\n        }\n        else {\n            in_pipe  = APR_CHILD_BLOCK;\n            out_pipe = APR_CHILD_BLOCK;\n            err_pipe = APR_CHILD_BLOCK;\n            cmd_type = APR_PROGRAM;\n        }\n\n        if (((rc = apr_procattr_create(&procattr, ptrans)) != APR_SUCCESS) ||\n            ((cgid_req.req_type == CGI_REQ) &&\n             (((rc = apr_procattr_io_set(procattr,\n                                        in_pipe,\n                                        out_pipe,\n                                        err_pipe)) != APR_SUCCESS) ||\n              /* XXX apr_procattr_child_*_set() is creating an unnecessary\n               * pipe between this process and the child being created...\n               * It is cleaned up with the temporary pool for this request.\n               */\n              ((rc = apr_procattr_child_err_set(procattr, r->server->error_log, NULL)) != APR_SUCCESS) ||\n              ((rc = apr_procattr_child_in_set(procattr, inout, NULL)) != APR_SUCCESS))) ||\n            ((rc = apr_procattr_child_out_set(procattr, inout, NULL)) != APR_SUCCESS) ||\n            ((rc = apr_procattr_dir_set(procattr,\n                                  ap_make_dirstr_parent(r->pool, r->filename))) != APR_SUCCESS) ||\n            ((rc = apr_procattr_cmdtype_set(procattr, cmd_type)) != APR_SUCCESS) ||\n#ifdef AP_CGID_USE_RLIMIT\n#ifdef RLIMIT_CPU\n        (  (cgid_req.limits.limit_cpu_set) && ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_CPU,\n                                      &cgid_req.limits.limit_cpu)) != APR_SUCCESS)) ||\n#endif\n#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)\n        ( (cgid_req.limits.limit_mem_set) && ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_MEM,\n                                      &cgid_req.limits.limit_mem)) != APR_SUCCESS)) ||\n#endif\n#ifdef RLIMIT_NPROC\n        ( (cgid_req.limits.limit_nproc_set) && ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_NPROC,\n                                      &cgid_req.limits.limit_nproc)) != APR_SUCCESS)) ||\n#endif\n#endif\n\n            ((rc = apr_procattr_child_errfn_set(procattr, cgid_child_errfn)) != APR_SUCCESS)) {\n            /* Something bad happened, tell the world.\n             * ap_log_rerror() won't work because the header table used by\n             * ap_log_rerror() hasn't been replicated in the phony r\n             */\n            ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server, APLOGNO(01251)\n                         \"couldn't set child process attributes: %s\", r->filename);\n\n            procnew->pid = 0; \n            close(sd2);\n        }\n        else {\n            apr_pool_userdata_set(r, ERRFN_USERDATA_KEY, apr_pool_cleanup_null, ptrans);\n\n            argv = (const char * const *)create_argv(r->pool, NULL, NULL, NULL, argv0, r->args);\n\n           /* We want to close sd2 for the new CGI process too.\n            * If it is left open it'll make ap_pass_brigade() block\n            * waiting for EOF if CGI forked something running long.\n            * close(sd2) here should be okay, as CGI channel\n            * is already dup()ed by apr_procattr_child_{in,out}_set()\n            * above.\n            */\n            close(sd2);\n\n            if (memcmp(&empty_ugid, &cgid_req.ugid, sizeof(empty_ugid))) {\n                /* We have a valid identity, and can be sure that\n                 * cgid_suexec_id_doer will return a valid ugid\n                 */\n                rc = ap_os_create_privileged_process(r, procnew, argv0, argv,\n                                                     (const char * const *)env,\n                                                     procattr, ptrans);\n            } else {\n                rc = apr_proc_create(procnew, argv0, argv,\n                                     (const char * const *)env,\n                                     procattr, ptrans);\n            }\n\n            if (rc != APR_SUCCESS) {\n                /* Bad things happened. Everyone should have cleaned up.\n                 * ap_log_rerror() won't work because the header table used by\n                 * ap_log_rerror() hasn't been replicated in the phony r\n                 */\n                ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server, APLOGNO(01252)\n                             \"couldn't create child process: %d: %s\", rc,\n                             apr_filepath_name_get(r->filename));\n\n                procnew->pid = 0; \n            }\n        }\n\n        /* If the script process was created, remember the pid for\n         * later cleanup.  If the script process wasn't created, clear\n         * out any prior pid with the same key.\n         *\n         * We don't want to leak storage for the key, so only allocate\n         * a key if the key doesn't exist yet in the hash; there are\n         * only a limited number of possible keys (one for each\n         * possible thread in the server), so we can allocate a copy\n         * of the key the first time a thread has a cgid request.\n         * Note that apr_hash_set() only uses the storage passed in\n         * for the key if it is adding the key to the hash for the\n         * first time; new key storage isn't needed for replacing the\n         * existing value of a key.\n         */\n\n        if (apr_hash_get(script_hash, &cgid_req.conn_id, sizeof(cgid_req.conn_id))) {\n            key = &cgid_req.conn_id;\n        }\n        else {\n            key = apr_pmemdup(pcgi, &cgid_req.conn_id, sizeof(cgid_req.conn_id));\n        }\n        apr_hash_set(script_hash, key, sizeof(cgid_req.conn_id),\n                     (void *)((long)procnew->pid));\n    }\n    return -1; \n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4a536afd9e419df8d744699d4d4e68820e525c39_0", {
    "ID": "httpd_4a536afd9e419df8d744699d4d4e68820e525c39_0",
    "UID": "3945",
    "code": "static apr_status_t dummy_connection(ap_pod_t test_snippet\n{\n    const char *data;\n    apr_status_t rv;\n    apr_socket_t *sock;\n    apr_pool_t *p;\n    apr_size_t len;\n    ap_listen_rec *lp;\n    int i;\n\n    \n    rv = apr_pool_create(&p, pod->p);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    /* If possible, find a listener which is configured for\n     * plain-HTTP, not SSL; using an SSL port would either be\n     * expensive to do correctly (performing a complete SSL handshake)\n     * or cause log spam by doing incorrectly (simply sending EOF). */\n    for (i = 0; i < num_buckets; i++) {\n        lp = mpm_listen[i];\n        while (lp && lp->protocol && strcasecmp(lp->protocol, \"http\") != 0) {\n            lp = lp->next;\n        }\n        if (!lp) {\n            lp = mpm_listen[i];\n        }\n\n        rv = apr_socket_create(&sock, lp->bind_addr->family, SOCK_STREAM, 0, p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00054)\n                         \"get socket to connect to listener\");\n            apr_pool_destroy(p);\n            return rv;\n        }\n\n        /* on some platforms (e.g., FreeBSD), the kernel won't accept many\n         * queued connections before it starts blocking local connects...\n         * we need to keep from blocking too long and instead return an error,\n         * because the MPM won't want to hold up a graceful restart for a\n         * long time\n         */\n        rv = apr_socket_timeout_set(sock, apr_time_from_sec(3));\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00055)\n                         \"set timeout on socket to connect to listener\");\n            apr_socket_close(sock);\n            apr_pool_destroy(p);\n            return rv;\n        }\n\n        rv = apr_socket_connect(sock, lp->bind_addr);\n        if (rv != APR_SUCCESS) {\n            int log_level = APLOG_WARNING;\n\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                /* probably some server processes bailed out already and there\n                 * is nobody around to call accept and clear out the kernel\n                 * connection queue; usually this is not worth logging\n                 */\n                log_level = APLOG_DEBUG;\n            }\n\n            ap_log_error(APLOG_MARK, log_level, rv, ap_server_conf, APLOGNO(00056)\n                         \"connect to listener on %pI\", lp->bind_addr);\n            apr_pool_destroy(p);\n            return rv;\n        }\n\n        if (lp->protocol && strcasecmp(lp->protocol, \"https\") == 0) {\n            /* Send a TLS 1.0 close_notify alert.  This is perhaps the\n             * \"least wrong\" way to open and cleanly terminate an SSL\n             * connection.  It should \"work\" without noisy error logs if\n             * the server actually expects SSLv3/TLSv1.  With\n             * SSLv23_server_method() OpenSSL's SSL_accept() fails\n             * ungracefully on receipt of this message, since it requires\n             * an 11-byte ClientHello message and this is too short. */\n            static const unsigned char tls10_close_notify[7] = {\n                '\\x15',         \n                '\\x03', '\\x01', \n                '\\x00', '\\x02', \n                '\\x01',         \n                '\\x00'          \n            };\n            data = (const char *)tls10_close_notify;\n            len = sizeof(tls10_close_notify);\n        }\n        else  {\n            /* Create an HTTP request string.  We include a User-Agent so\n             * that adminstrators can track down the cause of the\n             * odd-looking requests in their logs.  A complete request is\n             * used since kernel-level filtering may require that much\n             * data before returning from accept(). */\n            data = apr_pstrcat(p, \"OPTIONS * HTTP/1.0\\r\\nUser-Agent: \",\n                               ap_get_server_description(),\n                               \" (internal dummy connection)\\r\\n\\r\\n\", NULL);\n            len = strlen(data);\n        }\n\n        apr_socket_send(sock, data, &len);\n        apr_socket_close(sock);\n    }\n    apr_pool_destroy(p);\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_f60bfc54592740742c5d0d53f0997d7eef12d382_0", {
    "ID": "httpd_f60bfc54592740742c5d0d53f0997d7eef12d382_0",
    "UID": "3950",
    "code": "AP_DECLARE_NONSTD(void) test_snippet\n{\n    ap_listen_rec *lr;\n    int i;\n    for (i = 0; i < num_buckets; i++) {\n        for (lr = mpm_listen[i]; lr; lr = lr->next) {\n            apr_socket_close(lr->sd);\n            lr->active = 0;\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_1b27f85f59b0a30bde220b441a0b694cedcf90ed_0", {
    "ID": "httpd_1b27f85f59b0a30bde220b441a0b694cedcf90ed_0",
    "UID": "3951",
    "code": "static int proxy_handler(request_rec test_snippet\n{\n    char *uri, *scheme, *p;\n    const char *p2;\n    void *sconf = r->server->module_config;\n    proxy_server_conf *conf = (proxy_server_conf *)\n        ap_get_module_config(sconf, &proxy_module);\n    apr_array_header_t *proxies = conf->proxies;\n    struct proxy_remote *ents = (struct proxy_remote *) proxies->elts;\n    int i, rc, access_status;\n    int direct_connect = 0;\n    const char *str;\n    apr_int64_t maxfwd;\n    proxy_balancer *balancer = NULL;\n    proxy_worker *worker = NULL;\n    int attempts = 0, max_attempts = 0;\n    struct dirconn_entry *list = (struct dirconn_entry *)conf->dirconn->elts;\n    int saved_status;\n\n    \n    if (!r->filename) {\n        return DECLINED;\n    }\n\n    if (!r->proxyreq) {\n        \n        if (r->handler &&\n            strncmp(r->handler, \"proxy:\", 6) == 0 &&\n            strncmp(r->filename, \"proxy:\", 6) != 0) {\n            r->proxyreq = PROXYREQ_REVERSE;\n            r->filename = apr_pstrcat(r->pool, r->handler, r->filename, NULL);\n        }\n        else {\n            return DECLINED;\n        }\n    } else if (strncmp(r->filename, \"proxy:\", 6) != 0) {\n        return DECLINED;\n    }\n\n    \n    if ((str = apr_table_get(r->headers_in, \"Max-Forwards\"))) {\n        char *end;\n        maxfwd = apr_strtoi64(str, &end, 10);\n        if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n            return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                    apr_psprintf(r->pool,\n                            \"Max-Forwards value '%s' could not be parsed\", str));\n        }\n        else if (maxfwd == 0) {\n            switch (r->method_number) {\n            case M_TRACE: {\n                int access_status;\n                r->proxyreq = PROXYREQ_NONE;\n                if ((access_status = ap_send_http_trace(r)))\n                    ap_die(access_status, r);\n                else\n                    ap_finalize_request_protocol(r);\n                return OK;\n            }\n            case M_OPTIONS: {\n                int access_status;\n                r->proxyreq = PROXYREQ_NONE;\n                if ((access_status = ap_send_http_options(r)))\n                    ap_die(access_status, r);\n                else\n                    ap_finalize_request_protocol(r);\n                return OK;\n            }\n            default: {\n                return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                                     \"Max-Forwards has reached zero - proxy loop?\");\n            }\n            }\n        }\n        maxfwd = (maxfwd > 0) ? maxfwd - 1 : 0;\n    }\n    else {\n        \n        maxfwd = conf->maxfwd;\n    }\n    if (maxfwd >= 0) {\n        apr_table_setn(r->headers_in, \"Max-Forwards\",\n                       apr_psprintf(r->pool, \"%\" APR_INT64_T_FMT, maxfwd));\n    }\n\n    if (r->method_number == M_TRACE) {\n        core_server_config *coreconf = (core_server_config *)\n                                       ap_get_core_module_config(sconf);\n\n        if (coreconf->trace_enable == AP_TRACE_DISABLE)\n        {\n            /* Allow \"error-notes\" string to be printed by ap_send_error_response()\n             * Note; this goes nowhere, canned error response need an overhaul.\n             */\n            apr_table_setn(r->notes, \"error-notes\",\n                           \"TRACE forbidden by server configuration\");\n            apr_table_setn(r->notes, \"verbose-error-to\", \"*\");\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01139)\n                          \"TRACE forbidden by server configuration\");\n            return HTTP_METHOD_NOT_ALLOWED;\n        }\n\n        /* Can't test ap_should_client_block, we aren't ready to send\n         * the client a 100 Continue response till the connection has\n         * been established\n         */\n        if (coreconf->trace_enable != AP_TRACE_EXTENDED\n            && (r->read_length || r->read_chunked || r->remaining))\n        {\n            /* Allow \"error-notes\" string to be printed by ap_send_error_response()\n             * Note; this goes nowhere, canned error response need an overhaul.\n             */\n            apr_table_setn(r->notes, \"error-notes\",\n                           \"TRACE with request body is not allowed\");\n            apr_table_setn(r->notes, \"verbose-error-to\", \"*\");\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01140)\n                          \"TRACE with request body is not allowed\");\n            return HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n    }\n\n    uri = r->filename + 6;\n    p = strchr(uri, ':');\n    if (p == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01141)\n                      \"proxy_handler no URL in %s\", r->filename);\n        return HTTP_BAD_REQUEST;\n    }\n\n    \n    if (conf->domain != NULL) {\n        rc = proxy_needsdomain(r, uri, conf->domain);\n        if (ap_is_HTTP_REDIRECT(rc))\n            return HTTP_MOVED_PERMANENTLY;\n    }\n\n    scheme = apr_pstrndup(r->pool, uri, p - uri);\n    \n    \n    for (direct_connect = i = 0; i < conf->dirconn->nelts &&\n                                        !direct_connect; i++) {\n        direct_connect = list[i].matcher(&list[i], r);\n    }\n#if DEBUGGING\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                (direct_connect) ? \"NoProxy for %s\" : \"UseProxy for %s\",\n                r->uri);\n#endif\n\n    do {\n        char *url = uri;\n        \n        access_status = ap_proxy_pre_request(&worker, &balancer, r, conf, &url);\n        if (access_status != OK) {\n            /*\n             * Only return if access_status is not HTTP_SERVICE_UNAVAILABLE\n             * This gives other modules the chance to hook into the\n             * request_status hook and decide what to do in this situation.\n             */\n            if (access_status != HTTP_SERVICE_UNAVAILABLE)\n                return access_status;\n            /*\n             * Ensure that balancer is NULL if worker is NULL to prevent\n             * potential problems in the post_request hook.\n             */\n            if (!worker)\n                balancer = NULL;\n            goto cleanup;\n        }\n\n        \n        if (balancer) {\n            ap_proxy_initialize_worker(worker, r->server, conf->pool);\n        }\n\n        if (balancer && balancer->s->max_attempts_set && !max_attempts)\n            max_attempts = balancer->s->max_attempts;\n        \n        if (!direct_connect) {\n            for (i = 0; i < proxies->nelts; i++) {\n                p2 = ap_strchr_c(ents[i].scheme, ':');  \n                if (strcmp(ents[i].scheme, \"*\") == 0 ||\n                    (ents[i].use_regex &&\n                     ap_regexec(ents[i].regexp, url, 0, NULL, 0) == 0) ||\n                    (p2 == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||\n                    (p2 != NULL &&\n                    strncasecmp(url, ents[i].scheme,\n                                strlen(ents[i].scheme)) == 0)) {\n\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01142)\n                                  \"Trying to run scheme_handler against proxy\");\n                    access_status = proxy_run_scheme_handler(r, worker,\n                                                             conf, url,\n                                                             ents[i].hostname,\n                                                             ents[i].port);\n\n                    \n                    if (access_status != DECLINED) {\n                        const char *cl_a;\n                        char *end;\n                        apr_off_t cl;\n\n                        /*\n                         * An fatal error or success, so no point in\n                         * retrying with a direct connection.\n                         */\n                        if (access_status != HTTP_BAD_GATEWAY) {\n                            goto cleanup;\n                        }\n                        cl_a = apr_table_get(r->headers_in, \"Content-Length\");\n                        if (cl_a) {\n                            apr_strtoff(&cl, cl_a, &end, 10);\n                            /*\n                             * The request body is of length > 0. We cannot\n                             * retry with a direct connection since we already\n                             * sent (parts of) the request body to the proxy\n                             * and do not have any longer.\n                             */\n                            if (cl > 0) {\n                                goto cleanup;\n                            }\n                        }\n                        /*\n                         * Transfer-Encoding was set as input header, so we had\n                         * a request body. We cannot retry with a direct\n                         * connection for the same reason as above.\n                         */\n                        if (apr_table_get(r->headers_in, \"Transfer-Encoding\")) {\n                            goto cleanup;\n                        }\n                    }\n                }\n            }\n        }\n\n        \n        /* N.B. what if we're behind a firewall, where we must use a proxy or\n        * give up??\n        */\n\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01143)\n                      \"Running scheme %s handler (attempt %d)\",\n                      scheme, attempts);\n        AP_PROXY_RUN(r, worker, conf, url, attempts);\n        access_status = proxy_run_scheme_handler(r, worker, conf,\n                                                 url, NULL, 0);\n        if (access_status == OK)\n            break;\n        else if (access_status == HTTP_INTERNAL_SERVER_ERROR) {\n            /* Unrecoverable server error.\n             * We can not failover to another worker.\n             * Mark the worker as unusable if member of load balancer\n             */\n            if (balancer) {\n                worker->s->status |= PROXY_WORKER_IN_ERROR;\n                worker->s->error_time = apr_time_now();\n            }\n            break;\n        }\n        else if (access_status == HTTP_SERVICE_UNAVAILABLE) {\n            /* Recoverable server error.\n             * We can failover to another worker\n             * Mark the worker as unusable if member of load balancer\n             */\n            if (balancer) {\n                worker->s->status |= PROXY_WORKER_IN_ERROR;\n                worker->s->error_time = apr_time_now();\n            }\n        }\n        else {\n            /* Unrecoverable error.\n             * Return the origin status code to the client.\n             */\n            break;\n        }\n        /* Try again if the worker is unusable and the service is\n         * unavailable.\n         */\n    } while (!PROXY_WORKER_IS_USABLE(worker) &&\n             max_attempts > attempts++);\n\n    if (DECLINED == access_status) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01144)\n                      \"No protocol handler was valid for the URL %s. \"\n                      \"If you are using a DSO version of mod_proxy, make sure \"\n                      \"the proxy submodules are included in the configuration \"\n                      \"using LoadModule.\", r->uri);\n        access_status = HTTP_INTERNAL_SERVER_ERROR;\n        goto cleanup;\n    }\ncleanup:\n    /*\n     * Save current r->status and set it to the value of access_status which\n     * might be different (e.g. r->status could be HTTP_OK if e.g. we override\n     * the error page on the proxy or if the error was not generated by the\n     * backend itself but by the proxy e.g. a bad gateway) in order to give\n     * ap_proxy_post_request a chance to act correctly on the status code.\n     */\n    saved_status = r->status;\n    r->status = access_status;\n    ap_proxy_post_request(worker, balancer, r, conf);\n    /*\n     * Only restore r->status if it has not been changed by\n     * ap_proxy_post_request as we assume that this change was intentional.\n     */\n    if (r->status == access_status) {\n        r->status = saved_status;\n    }\n\n    proxy_run_request_status(&access_status, r);\n    AP_PROXY_RUN_FINISHED(r, attempts, access_status);\n\n    return access_status;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n"
  },
  "httpd_676682c562feeb96074133d6098d4906eee1b7ad_0", {
    "ID": "httpd_676682c562feeb96074133d6098d4906eee1b7ad_0",
    "UID": "3957",
    "code": "static const char *add_global_log(cmd_parms *cmd, void *dummy, const char test_snippet\n                                  const char *fmt, const char *envclause) {\n    multi_log_state *mls = ap_get_module_config(cmd->server->module_config,\n                                                &log_config_module);\n    config_log_state *clsarray;\n    config_log_state *cls;\n    const char *ret;\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err) {\n        return err;\n    }\n\n    \n    ret = add_custom_log(cmd, dummy, fn, fmt, envclause);\n\n    \n    if (ret == NULL) {\n        clsarray = (config_log_state*)mls->config_logs->elts;\n        cls = &clsarray[mls->config_logs->nelts-1];\n        cls->inherit = 1;\n    }\n\n    return ret;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_854c3b2262467d47ca0811979980e504874a5d43_0", {
    "ID": "httpd_854c3b2262467d47ca0811979980e504874a5d43_0",
    "UID": "3960",
    "code": "static apr_status_t inflate_out_filter(ap_filter_t test_snippet\n                                      apr_bucket_brigade *bb)\n{\n    apr_bucket *e;\n    request_rec *r = f->r;\n    deflate_ctx *ctx = f->ctx;\n    int zRC;\n    apr_status_t rv;\n    deflate_filter_config *c;\n\n    \n    if (APR_BRIGADE_EMPTY(bb)) {\n        return APR_SUCCESS;\n    }\n\n    c = ap_get_module_config(r->server->module_config, &deflate_module);\n\n    if (!ctx) {\n\n        /*\n         * Only work on main request, not subrequests,\n         * that are not a 204 response with no content\n         * and not a partial response to a Range request,\n         * and only when Content-Encoding ends in gzip.\n         */\n        if (!ap_is_initial_req(r) || (r->status == HTTP_NO_CONTENT) ||\n            (apr_table_get(r->headers_out, \"Content-Range\") != NULL) ||\n            (check_gzip(r, r->headers_out, r->err_headers_out) == 0)\n           ) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        /*\n         * At this point we have decided to filter the content, so change\n         * important content metadata before sending any response out.\n         * Content-Encoding was already reset by the check_gzip() call.\n         */\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        apr_table_unset(r->headers_out, \"Content-MD5\");\n        if (c->etag_opt != AP_DEFLATE_ETAG_NOCHANGE) {\n            deflate_check_etag(r, \"gunzip\", c->etag_opt);\n        }\n\n        \n        if (r->status == HTTP_NOT_MODIFIED) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n        ctx->buffer = apr_palloc(r->pool, c->bufferSize);\n        ctx->libz_end_func = inflateEnd;\n        ctx->validation_buffer = NULL;\n        ctx->validation_buffer_length = 0;\n\n        zRC = inflateInit2(&ctx->stream, c->windowSize);\n\n        if (zRC != Z_OK) {\n            f->ctx = NULL;\n            inflateEnd(&ctx->stream);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01397)\n                          \"unable to init Zlib: \"\n                          \"inflateInit2 returned %d: URL %s\",\n                          zRC, r->uri);\n            /*\n             * Remove ourselves as it does not make sense to return:\n             * We are not able to init libz and pass data down the chain\n             * compressed.\n             */\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        /*\n         * Register a cleanup function to ensure that we cleanup the internal\n         * libz resources.\n         */\n        apr_pool_cleanup_register(r->pool, ctx, deflate_ctx_cleanup,\n                                  apr_pool_cleanup_null);\n\n        \n        ctx->stream.next_out = ctx->buffer;\n        ctx->stream.avail_out = c->bufferSize;\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb))\n    {\n        const char *data;\n        apr_bucket *b;\n        apr_size_t len;\n\n        e = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(e)) {\n            /*\n             * We are really done now. Ensure that we never return here, even\n             * if a second EOS bucket falls down the chain. Thus remove\n             * ourselves.\n             */\n            ap_remove_output_filter(f);\n            \n            ctx->stream.avail_in = 0;\n            /*\n             * Flush the remaining data from the zlib buffers. It is correct\n             * to use Z_SYNC_FLUSH in this case and not Z_FINISH as in the\n             * deflate case. In the inflate case Z_FINISH requires to have a\n             * large enough output buffer to put ALL data in otherwise it\n             * fails, whereas in the deflate case you can empty a filled output\n             * buffer and call it again until no more output can be created.\n             */\n            flush_libz_buffer(ctx, c, f->c->bucket_alloc, inflate, Z_SYNC_FLUSH,\n                              UPDATE_CRC);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01398)\n                          \"Zlib: Inflated %ld to %ld : URL %s\",\n                          ctx->stream.total_in, ctx->stream.total_out, r->uri);\n\n            if (ctx->validation_buffer_length == VALIDATION_SIZE) {\n                unsigned long compCRC, compLen;\n                compCRC = getLong(ctx->validation_buffer);\n                if (ctx->crc != compCRC) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01399)\n                                  \"Zlib: Checksum of inflated stream invalid\");\n                    return APR_EGENERAL;\n                }\n                ctx->validation_buffer += VALIDATION_SIZE / 2;\n                compLen = getLong(ctx->validation_buffer);\n                \n                if ((ctx->stream.total_out & 0xFFFFFFFF) != compLen) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01400)\n                                  \"Zlib: Length of inflated stream invalid\");\n                    return APR_EGENERAL;\n                }\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01401)\n                              \"Zlib: Validation bytes not present\");\n                return APR_EGENERAL;\n            }\n\n            inflateEnd(&ctx->stream);\n            \n            apr_pool_cleanup_kill(r->pool, ctx, deflate_ctx_cleanup);\n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n\n            /*\n             * Okay, we've seen the EOS.\n             * Time to pass it along down the chain.\n             */\n            return ap_pass_brigade(f->next, ctx->bb);\n        }\n\n        if (APR_BUCKET_IS_FLUSH(e)) {\n            apr_status_t rv;\n\n            \n            zRC = flush_libz_buffer(ctx, c, f->c->bucket_alloc, inflate,\n                                    Z_SYNC_FLUSH, UPDATE_CRC);\n            if (zRC == Z_STREAM_END) {\n                if (ctx->validation_buffer == NULL) {\n                    ctx->validation_buffer = apr_pcalloc(f->r->pool,\n                                                         VALIDATION_SIZE);\n                }\n            }\n            else if (zRC != Z_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01402)\n                              \"Zlib error %d flushing inflate buffer (%s)\",\n                              zRC, ctx->stream.msg);\n                return APR_EGENERAL;\n            }\n\n            \n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n            rv = ap_pass_brigade(f->next, ctx->bb);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            continue;\n        }\n\n        if (APR_BUCKET_IS_METADATA(e)) {\n            /*\n             * Remove meta data bucket from old brigade and insert into the\n             * new.\n             */\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);\n            continue;\n        }\n\n        \n        apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n        if (!len) {\n            apr_bucket_delete(e);\n            continue;\n        }\n        if (len > INT_MAX) {\n            apr_bucket_split(e, INT_MAX);\n            apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n        }\n\n        \n        if (ctx->header_len < sizeof(ctx->header)) {\n            apr_size_t rem;\n\n            rem = sizeof(ctx->header) - ctx->header_len;\n            if (len < rem) {\n                memcpy(ctx->header + ctx->header_len, data, len);\n                ctx->header_len += len;\n                apr_bucket_delete(e);\n                continue;\n            }\n            memcpy(ctx->header + ctx->header_len, data, rem);\n            ctx->header_len += rem;\n            {\n                int zlib_method;\n                zlib_method = ctx->header[2];\n                if (zlib_method != Z_DEFLATED) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01404)\n                                  \"inflate: data not deflated!\");\n                    ap_remove_output_filter(f);\n                    return ap_pass_brigade(f->next, bb);\n                }\n                if (ctx->header[0] != deflate_magic[0] ||\n                    ctx->header[1] != deflate_magic[1]) {\n                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01405)\n                                      \"inflate: bad header\");\n                    return APR_EGENERAL ;\n                }\n                ctx->zlib_flags = ctx->header[3];\n                if ((ctx->zlib_flags & RESERVED)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02620)\n                                  \"inflate: bad flags %02x\",\n                                  ctx->zlib_flags);\n                    return APR_EGENERAL;\n                }\n            }\n            if (len == rem) {\n                apr_bucket_delete(e);\n                continue;\n            }\n            data += rem;\n            len -= rem;\n        }\n\n        if (ctx->zlib_flags) {\n            rv = consume_zlib_flags(ctx, &data, &len);\n            if (rv == APR_SUCCESS) {\n                ctx->zlib_flags = 0;\n            }\n            if (!len) {\n                apr_bucket_delete(e);\n                continue;\n            }\n        }\n\n        \n        ctx->stream.next_in = (unsigned char *)data;\n        ctx->stream.avail_in = len;\n\n        if (ctx->validation_buffer) {\n            if (ctx->validation_buffer_length < VALIDATION_SIZE) {\n                apr_size_t copy_size;\n\n                copy_size = VALIDATION_SIZE - ctx->validation_buffer_length;\n                if (copy_size > ctx->stream.avail_in)\n                    copy_size = ctx->stream.avail_in;\n                memcpy(ctx->validation_buffer + ctx->validation_buffer_length,\n                       ctx->stream.next_in, copy_size);\n                \n                ctx->stream.avail_in -= copy_size;\n                ctx->validation_buffer_length += copy_size;\n            }\n            if (ctx->stream.avail_in) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01407)\n                              \"Zlib: %d bytes of garbage at the end of \"\n                              \"compressed stream.\", ctx->stream.avail_in);\n                /*\n                 * There is nothing worth consuming for zlib left, because it is\n                 * either garbage data or the data has been copied to the\n                 * validation buffer (processing validation data is no business\n                 * for zlib). So set ctx->stream.avail_in to zero to indicate\n                 * this to the following while loop.\n                 */\n                ctx->stream.avail_in = 0;\n            }\n        }\n\n        while (ctx->stream.avail_in != 0) {\n            if (ctx->stream.avail_out == 0) {\n\n                ctx->stream.next_out = ctx->buffer;\n                len = c->bufferSize - ctx->stream.avail_out;\n\n                ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n                b = apr_bucket_heap_create((char *)ctx->buffer, len,\n                                           NULL, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n                ctx->stream.avail_out = c->bufferSize;\n                \n                rv = ap_pass_brigade(f->next, ctx->bb);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n            }\n\n            zRC = inflate(&ctx->stream, Z_NO_FLUSH);\n\n            if (zRC == Z_STREAM_END) {\n                /*\n                 * We have inflated all data. Now try to capture the\n                 * validation bytes. We may not have them all available\n                 * right now, but capture what is there.\n                 */\n                ctx->validation_buffer = apr_pcalloc(f->r->pool,\n                                                     VALIDATION_SIZE);\n                if (ctx->stream.avail_in > VALIDATION_SIZE) {\n                    ctx->validation_buffer_length = VALIDATION_SIZE;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01408)\n                                  \"Zlib: %d bytes of garbage at the end of \"\n                                  \"compressed stream.\",\n                                  ctx->stream.avail_in - VALIDATION_SIZE);\n                } else if (ctx->stream.avail_in > 0) {\n                           ctx->validation_buffer_length = ctx->stream.avail_in;\n                }\n                if (ctx->validation_buffer_length)\n                    memcpy(ctx->validation_buffer, ctx->stream.next_in,\n                           ctx->validation_buffer_length);\n                break;\n            }\n\n            if (zRC != Z_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01409)\n                              \"Zlib error %d inflating data (%s)\", zRC,\n                              ctx->stream.msg);\n                return APR_EGENERAL;\n            }\n        }\n\n        apr_bucket_delete(e);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_bda40a752786749022069c16b3da3bc9557b2e18_0", {
    "ID": "httpd_bda40a752786749022069c16b3da3bc9557b2e18_0",
    "UID": "3969",
    "code": "static void perform_idle_server_maintenance(int test_snippet\n{\n    int i, j;\n    int idle_thread_count;\n    worker_score *ws;\n    process_score *ps;\n    int free_length;\n    int totally_free_length = 0;\n    int free_slots[MAX_SPAWN_RATE];\n    int last_non_dead;\n    int total_non_dead;\n    int active_thread_count = 0;\n\n    \n    free_length = 0;\n\n    idle_thread_count = 0;\n    last_non_dead = -1;\n    total_non_dead = 0;\n\n    for (i = 0; i < ap_daemons_limit; ++i) {\n        /* Initialization to satisfy the compiler. It doesn't know\n         * that threads_per_child is always > 0 */\n        int status = SERVER_DEAD;\n        int any_dying_threads = 0;\n        int any_dead_threads = 0;\n        int all_dead_threads = 1;\n        int child_threads_active = 0;\n\n        if (i >= retained->max_daemons_limit\n            && totally_free_length == retained->idle_spawn_rate[child_bucket])\n            /* short cut if all active processes have been examined and\n             * enough empty scoreboard slots have been found\n             */\n\n            break;\n        ps = &ap_scoreboard_image->parent[i];\n        for (j = 0; j < threads_per_child; j++) {\n            ws = &ap_scoreboard_image->servers[i][j];\n            status = ws->status;\n\n            \n            any_dying_threads = any_dying_threads ||\n                (status == SERVER_GRACEFUL);\n            any_dead_threads = any_dead_threads || (status == SERVER_DEAD);\n            all_dead_threads = all_dead_threads &&\n                (status == SERVER_DEAD || status == SERVER_GRACEFUL);\n\n            /* We consider a starting server as idle because we started it\n             * at least a cycle ago, and if it still hasn't finished starting\n             * then we're just going to swamp things worse by forking more.\n             * So we hopefully won't need to fork more if we count it.\n             * This depends on the ordering of SERVER_READY and SERVER_STARTING.\n             */\n            if (ps->pid != 0) { /* XXX just set all_dead_threads in outer\n                                   for loop if no pid?  not much else matters */\n                if (status <= SERVER_READY && !ps->quiescing && !ps->not_accepting\n                    && ps->generation == retained->my_generation &&\n                    bucket[i] == test_snippet\n                {\n                    ++idle_thread_count;\n                }\n                if (status >= SERVER_READY && status < SERVER_GRACEFUL) {\n                    ++child_threads_active;\n                }\n            }\n        }\n        active_thread_count += child_threads_active;\n        if (any_dead_threads\n            && totally_free_length < retained->idle_spawn_rate[child_bucket]\n            && free_length < MAX_SPAWN_RATE/num_buckets\n            && (!ps->pid      \n                  || ps->quiescing)) {  \n            if (all_dead_threads) {\n                /* great! we prefer these, because the new process can\n                 * start more threads sooner.  So prioritize this slot\n                 * by putting it ahead of any slots with active threads.\n                 *\n                 * first, make room by moving a slot that's potentially still\n                 * in use to the end of the array\n                 */\n                free_slots[free_length] = free_slots[totally_free_length];\n                free_slots[totally_free_length++] = i;\n            }\n            else {\n                /* slot is still in use - back of the bus\n                 */\n                free_slots[free_length] = i;\n            }\n            ++free_length;\n        }\n        else if (child_threads_active == threads_per_child) {\n            had_healthy_child = 1;\n        }\n        \n        if (!any_dying_threads) {\n            last_non_dead = i;\n            ++total_non_dead;\n        }\n    }\n\n    if (retained->sick_child_detected) {\n        if (had_healthy_child) {\n            /* Assume this is a transient error, even though it may not be.  Leave\n             * the server up in case it is able to serve some requests or the\n             * problem will be resolved.\n             */\n            retained->sick_child_detected = 0;\n        }\n        else {\n            /* looks like a basket case, as no child ever fully initialized; give up.\n             */\n            shutdown_pending = 1;\n            child_fatal = 1;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, 0,\n                         ap_server_conf, APLOGNO(02324)\n                         \"A resource shortage or other unrecoverable failure \"\n                         \"was encountered before any child process initialized \"\n                         \"successfully... httpd is exiting!\");\n            \n            return;\n        }\n    }\n\n    retained->max_daemons_limit = last_non_dead + 1;\n\n    if (idle_thread_count > max_spare_threads/num_buckets) {\n        \n        ap_mpm_podx_signal(pod[child_bucket], AP_MPM_PODX_GRACEFUL);\n        retained->idle_spawn_rate[child_bucket] = 1;\n    }\n    else if (idle_thread_count < min_spare_threads/num_buckets) {\n        \n        if (free_length == 0) { \n\n            if (active_thread_count >= ap_daemons_limit * threads_per_child) {\n                if (!retained->maxclients_reported) {\n                    \n                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00484)\n                                 \"server reached MaxRequestWorkers setting, \"\n                                 \"consider raising the MaxRequestWorkers \"\n                                 \"setting\");\n                    retained->maxclients_reported = 1;\n                }\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00485)\n                             \"scoreboard is full, not at MaxRequestWorkers\");\n            }\n            retained->idle_spawn_rate[child_bucket] = 1;\n        }\n        else {\n            if (free_length > retained->idle_spawn_rate[child_bucket]) {\n                free_length = retained->idle_spawn_rate[child_bucket];\n            }\n            if (retained->idle_spawn_rate[child_bucket] >= 8) {\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00486)\n                             \"server seems busy, (you may need \"\n                             \"to increase StartServers, ThreadsPerChild \"\n                             \"or Min/MaxSpareThreads), \"\n                             \"spawning %d children, there are around %d idle \"\n                             \"threads, and %d total children\", free_length,\n                             idle_thread_count, total_non_dead);\n            }\n            for (i = 0; i < free_length; ++i) {\n                bucket[free_slots[i]] = child_bucket;\n                make_child(ap_server_conf, free_slots[i]);\n            }\n            /* the next time around we want to spawn twice as many if this\n             * wasn't good enough, but not if we've just done a graceful\n             */\n            if (retained->hold_off_on_exponential_spawning) {\n                --retained->hold_off_on_exponential_spawning;\n            }\n            else if (retained->idle_spawn_rate[child_bucket] < MAX_SPAWN_RATE/num_buckets) {\n                retained->idle_spawn_rate[child_bucket] *= 2;\n            }\n        }\n    }\n    else {\n        retained->idle_spawn_rate[child_bucket] = 1;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_a312802412b84eb298f7a1f038a0d437d3ced292_0", {
    "ID": "httpd_a312802412b84eb298f7a1f038a0d437d3ced292_0",
    "UID": "3970",
    "code": "static int make_child(server_rec * s, int test_snippet\n{\n    int pid;\n\n    if (slot + 1 > retained->max_daemons_limit) {\n        retained->max_daemons_limit = slot + 1;\n    }\n\n    child_listen = mpm_listen[bucket[slot]];\n    child_pod = pod[bucket[slot]];\n\n    if (one_process) {\n        set_signals();\n        event_note_child_started(slot, getpid());\n        child_main(test_snippet;\n        \n    }\n\n    if ((pid = fork()) == -1) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, APLOGNO(00481)\n                     \"fork: Unable to fork new process\");\n\n        /* fork didn't succeed.  There's no need to touch the scoreboard;\n         * if we were trying to replace a failed child process, then\n         * server_main_loop() marked its workers SERVER_DEAD, and if\n         * we were trying to replace a child process that exited normally,\n         * its worker_thread()s left SERVER_DEAD or SERVER_GRACEFUL behind.\n         */\n\n        /* In case system resources are maxxed out, we don't want\n           Apache running away with the CPU trying to fork over and\n           over and over again. */\n        apr_sleep(apr_time_from_sec(10));\n\n        return -1;\n    }\n\n    if (!pid) {\n#ifdef HAVE_BINDPROCESSOR\n        /* By default, AIX binds to a single processor.  This bit unbinds\n         * children which will then bind to another CPU.\n         */\n        int status = bindprocessor(BINDPROCESS, (int) getpid(),\n                                   PROCESSOR_CLASS_ANY);\n        if (status != OK)\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, errno,\n                         ap_server_conf, APLOGNO(00482)\n                         \"processor unbind failed\");\n#endif\n        RAISE_SIGSTOP(MAKE_CHILD);\n\n        apr_signal(SIGTERM, just_die);\n        child_main(test_snippet;\n        \n    }\n    \n    if (ap_scoreboard_image->parent[slot].pid != 0) {\n        /* This new child process is squatting on the scoreboard\n         * entry owned by an exiting child process, which cannot\n         * exit until all active requests complete.\n         */\n        event_note_child_lost_slot(slot, pid);\n    }\n    ap_scoreboard_image->parent[slot].quiescing = 0;\n    ap_scoreboard_image->parent[slot].not_accepting = 0;\n    event_note_child_started(slot, pid);\n    return 0;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_a966449cac5552ada825b389917cbb9231065fd2_0", {
    "ID": "httpd_a966449cac5552ada825b389917cbb9231065fd2_0",
    "UID": "3976",
    "code": "static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * test_snippet\n{\n    int remaining_children_to_start;\n\n    int i;\n\n    ap_log_pid(pconf, ap_pid_fname);\n\n    if (!retained->is_graceful) {\n        if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {\n            mpm_state = AP_MPMQ_STOPPING;\n            return DONE;\n        }\n        /* fix the generation number in the global score; we just got a new,\n         * cleared scoreboard\n         */\n        ap_scoreboard_image->global->running_generation = retained->my_generation;\n    }\n\n    bucket = apr_palloc(_pconf, sizeof(int) *  ap_daemons_limit);\n\n    restart_pending = shutdown_pending = 0;\n    set_signals();\n    \n    if (max_spare_threads < min_spare_threads + threads_per_child * num_buckettest_snippet\n        max_spare_threads = min_spare_threads + threads_per_child * num_buckets;\n\n    /* If we're doing a graceful_restart then we're going to see a lot\n     * of children exiting immediately when we get into the main loop\n     * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty\n     * rapidly... and for each one that exits we may start a new one, until\n     * there are at least min_spare_threads idle threads, counting across\n     * all children.  But we may be permitted to start more children than\n     * that, so we'll just keep track of how many we're\n     * supposed to start up without the 1 second penalty between each fork.\n     */\n    remaining_children_to_start = ap_daemons_to_start;\n    if (remaining_children_to_start > ap_daemons_limit) {\n        remaining_children_to_start = ap_daemons_limit;\n    }\n    if (!retained->is_graceful) {\n        startup_children(remaining_children_to_start);\n        remaining_children_to_start = 0;\n    }\n    else {\n        /* give the system some time to recover before kicking into\n         * exponential mode */\n        retained->hold_off_on_exponential_spawning = 10;\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00489)\n                 \"%s configured -- resuming normal operations\",\n                 ap_get_server_description());\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00490)\n                 \"Server built: %s\", ap_get_server_built());\n    ap_log_command_line(plog, test_snippet;\n    ap_log_common(test_snippet;\n\n    mpm_state = AP_MPMQ_RUNNING;\n\n    server_main_loop(remaining_children_to_start);\n    mpm_state = AP_MPMQ_STOPPING;\n\n    if (shutdown_pending && !retained->is_graceful) {\n        /* Time to shut down:\n         * Kill child processes, tell them to call child_exit, etc...\n         */\n        for (i = 0; i < num_buckets; i++) {\n            ap_mpm_podx_killpg(pod[i], ap_daemons_limit, AP_MPM_PODX_RESTART);\n        }\n        ap_reclaim_child_processes(1, \n                                   event_note_child_killed);\n\n        if (!child_fatal) {\n            \n            ap_remove_pid(pconf, ap_pid_fname);\n            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,\n                         ap_server_conf, APLOGNO(00491) \"caught SIGTERM, shutting down\");\n        }\n        return DONE;\n    } else if (shutdown_pending) {\n        /* Time to gracefully shut down:\n         * Kill child processes, tell them to call child_exit, etc...\n         */\n        int active_children;\n        int index;\n        apr_time_t cutoff = 0;\n\n        \n        ap_close_listeners();\n        for (i = 0; i < num_buckets; i++) {\n            ap_mpm_podx_killpg(pod[i], ap_daemons_limit, AP_MPM_PODX_GRACEFUL);\n        }\n        ap_relieve_child_processes(event_note_child_killed);\n\n        if (!child_fatal) {\n            \n            ap_remove_pid(pconf, ap_pid_fname);\n            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00492)\n                         \"caught \" AP_SIG_GRACEFUL_STOP_STRING\n                         \", shutting down gracefully\");\n        }\n\n        if (ap_graceful_shutdown_timeout) {\n            cutoff = apr_time_now() +\n                     apr_time_from_sec(ap_graceful_shutdown_timeout);\n        }\n\n        \n        shutdown_pending = 0;\n        do {\n            \n            apr_sleep(apr_time_from_sec(1));\n\n            \n            ap_relieve_child_processes(event_note_child_killed);\n\n            active_children = 0;\n            for (index = 0; index < ap_daemons_limit; ++index) {\n                if (ap_mpm_safe_kill(MPM_CHILD_PID(index), 0) == APR_SUCCESS) {\n                    active_children = 1;\n                    \n                    break;\n                }\n            }\n        } while (!shutdown_pending && active_children &&\n                 (!ap_graceful_shutdown_timeout || apr_time_now() < cutoff));\n\n        /* We might be here because we received SIGTERM, either\n         * way, try and make sure that all of our processes are\n         * really dead.\n         */\n        for (i = 0; i < num_buckets; i++) {\n            ap_mpm_podx_killpg(pod[i], ap_daemons_limit, AP_MPM_PODX_RESTART);\n        }\n        ap_reclaim_child_processes(1, event_note_child_killed);\n\n        return DONE;\n    }\n\n    \n    apr_signal(SIGHUP, SIG_IGN);\n\n    if (one_procestest_snippet {\n        \n        return DONE;\n    }\n\n    \n    /* XXX: we really need to make sure this new generation number isn't in\n     * use by any of the children.\n     */\n    ++retained->my_generation;\n    ap_scoreboard_image->global->running_generation = retained->my_generation;\n\n    if (retained->is_graceful) {\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00493)\n                     AP_SIG_GRACEFUL_STRING\n                     \" received.  Doing graceful restart\");\n        \n        for (i = 0; i < num_buckets; i++) {\n            ap_mpm_podx_killpg(pod[i], ap_daemons_limit, AP_MPM_PODX_GRACEFUL);\n        }\n\n        /* This is mostly for debugging... so that we know what is still\n         * gracefully dealing with existing request.\n         */\n\n    }\n    else {\n        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM\n         * and a SIGHUP, we may as well use the same signal, because some user\n         * pthreads are stealing signals from us left and right.\n         */\n        for (i = 0; i < num_buckets; i++) {\n            ap_mpm_podx_killpg(pod[i], ap_daemons_limit, AP_MPM_PODX_RESTART);\n        }\n\n        ap_reclaim_child_processes(1,  \n                                   event_note_child_killed);\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00494)\n                     \"SIGHUP received.  Attempting to restart\");\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_51bc1f800406d42553c3655afdebe633e56d5e38_0", {
    "ID": "httpd_51bc1f800406d42553c3655afdebe633e56d5e38_0",
    "UID": "3978",
    "code": "AP_DECLARE(apr_status_t) ap_mpm_podx_open(apr_pool_t *p, ap_pod_t test_snippet\n{\n    apr_status_t rv;\n\n    *pod = apr_palloc(p, sizeof(test_snippet);\n    rv = apr_file_pipe_create(&((*pod)->pod_in), &((*pod)->pod_out), p);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    /*\n     apr_file_pipe_timeout_set((*pod)->pod_in, 0);\n     */\n    (*pod)->p = p;\n\n    \n    apr_file_inherit_unset((*pod)->pod_in);\n    apr_file_inherit_unset((*pod)->pod_out);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_aaa0765e08bca640d3f2f989511f29562c251b3b_0", {
    "ID": "httpd_aaa0765e08bca640d3f2f989511f29562c251b3b_0",
    "UID": "3979",
    "code": "AP_DECLARE(apr_status_t) ap_duplicate_listeners(server_rec *s, apr_pool_t test_snippet\n                                                  int num_buckets) {\n    int i;\n    apr_status_t stat;\n    int use_nonblock = 0;\n    ap_listen_rec *lr;\n\n    mpm_listen = apr_palloc(p, sizeof(ap_listen_rec*) * num_buckets);\n    for (i = 0; i < num_buckets; i++) {\n        ap_listen_rec *last = NULL;\n        lr = ap_listeners;\n        while (lr) {\n            ap_listen_rec *duplr;\n            char *hostname;\n            apr_port_t port;\n            apr_sockaddr_t *sa;\n            duplr  = apr_palloc(p, sizeof(ap_listen_rec));\n            duplr->slave = NULL;\n            duplr->protocol = apr_pstrdup(p, lr->protocol);\n            hostname = apr_pstrdup(p, lr->bind_addr->hostname);\n            port = lr->bind_addr->port;\n            apr_sockaddr_info_get(&sa, hostname, APR_UNSPEC, port, 0, p);\n            duplr->bind_addr = sa;\n            duplr->next = NULL;\n            if ((stat = apr_socket_create(&duplr->sd, duplr->bind_addr->family,\n                                          SOCK_STREAM, 0, p)) != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_CRIT, 0, p, APLOGNO(02640)\n                              \"ap_duplicate_socket: for address %pI, \"\n                              \"cannot duplicate a new socket!\",\n                              duplr->bind_addr);\n                return stat;\n            }\n            make_sock(p, duplr, 1);\n#if AP_NONBLOCK_WHEN_MULTI_LISTEN\n            use_nonblock = (ap_listeners && ap_listeners->next);\n            if ((stat = apr_socket_opt_set(duplr->sd, APR_SO_NONBLOCK, use_nonblock))\n                != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(02641)\n                              \"unable to control socket non-blocking status\");\n                return stat;\n            }\n#endif\n            ap_apply_accept_filter(p, duplr, s);\n\n            if (last == NULL) {\n                mpm_listen[i] = last = duplr;\n            }\n            else {\n                last->next = duplr;\n                last = duplr;\n            }\n            lr = lr->next;\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_a7d4c6669194d57609c433b0ca9aa0422366464e_0", {
    "ID": "httpd_a7d4c6669194d57609c433b0ca9aa0422366464e_0",
    "UID": "3980",
    "code": "static int event_open_logs(apr_pool_t * p, apr_pool_t * test_snippet\n                           apr_pool_t * ptemp, server_rec * s)\n{\n    int startup = 0;\n    int level_flags = 0;\n    apr_status_t rv;\n    int i;\n    int num_of_cores = 0;\n\n    pconf = p;\n\n    \n    if (retained->module_loads == 1) {\n        startup = 1;\n        level_flags |= APLOG_STARTUP;\n    }\n\n    enable_default_listener = 0;\n\n    if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT | level_flags, 0,\n                     (startup ? NULL : s),\n                     \"no listening sockets available, shutting down\");\n        return DONE;\n    }\n\n    enable_default_listener = 1;\n    if (have_so_reuseport) {\n#ifdef _SC_NPROCESSORS_ONLN\n        num_of_cores = sysconf(_SC_NPROCESSORS_ONLN);\n#else\n        num_of_cores = 1;\n#endif\n        if (num_of_cores > 8) {\n            num_buckets = num_of_cores/8;\n        }\n        else {\n            num_buckets = 1;\n        }\n    }\n    else {\n        num_buckets = 1;\n    }\n\n    ap_duplicate_listeners(ap_server_conf, pconf, num_buckets);\n\n    pod = apr_palloc(pconf, sizeof(ap_pod_t *) * num_buckets);\n\n    if (!one_process) {\n        for (i = 0; i < num_buckets; i++) {\n            if ((rv = ap_mpm_podx_open(pconf, &pod[i]))) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,\n                             (startup ? NULL : s),\n                             \"could not open pipe-of-death\");\n                return DONE;\n            }\n        }\n    }\n    \n    srand((unsigned int)apr_time_now());\n    return OK;\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
  },
  "httpd_4f605ec7c7cb48c42631773829773f8fe65d21ed_0", {
    "ID": "httpd_4f605ec7c7cb48c42631773829773f8fe65d21ed_0",
    "UID": "3989",
    "code": "static apr_status_t proxy_send_dir_filter(ap_filter_t test_snippet\n                                          apr_bucket_brigade *in)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_pool_t *p = r->pool;\n    apr_bucket_brigade *out = apr_brigade_create(p, c->bucket_alloc);\n    apr_status_t rv;\n\n    register int n;\n    char *dir, *path, *reldir, *site, *str, *type;\n\n    const char *pwd = apr_table_get(r->notes, \"Directory-PWD\");\n    const char *readme = apr_table_get(r->notes, \"Directory-README\");\n\n    proxy_dir_ctx_t *ctx = f->ctx;\n\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(p, sizeof(*ctx));\n        ctx->in = apr_brigade_create(p, c->bucket_alloc);\n        ctx->buffer[0] = 0;\n        ctx->state = HEADER;\n    }\n\n    \n    APR_BRIGADE_CONCAT(ctx->in, in);\n\n    if (HEADER == ctx->state) {\n\n        \n        const char *basedir = \"\";  \n        char *wildcard = NULL;\n        const char *escpath;\n\n        /*\n         * In the reverse proxy case we need to construct our site string\n         * via ap_construct_url. For non anonymous sites apr_uri_unparse would\n         * only supply us with 'username@' which leads to the construction of\n         * an invalid base href later on. Losing the username part of the URL\n         * is no problem in the reverse proxy case as the browser sents the\n         * credentials anyway once entered.\n         */\n        if (r->proxyreq == PROXYREQ_REVERSE) {\n            site = ap_construct_url(p, \"\", r);\n        }\n        else {\n            \n            site = apr_uri_unparse(p, &f->r->parsed_uri,\n                                   APR_URI_UNP_OMITPASSWORD |\n                                   APR_URI_UNP_OMITPATHINFO);\n        }\n\n        \n        path = apr_uri_unparse(p, &f->r->parsed_uri, APR_URI_UNP_OMITSITEPART | APR_URI_UNP_OMITQUERY);\n\n        \n        if (strncasecmp(path, \"/%2f\", 4) == 0) {\n            basedir = \"/%2f\";\n        }\n\n        \n        if ((type = strstr(path, \";type=\")) != NULL)\n            *type++ = '\\0';\n\n        (void)decodeenc(path);\n\n        while (path[1] == '/') \n            ++path;\n\n        reldir = strrchr(path, '/');\n        if (reldir != NULL && ftp_check_globbingchars(reldir)) {\n            wildcard = &reldir[1];\n            reldir[0] = '\\0'; \n        }\n\n        \n        \n        path = dir = apr_pstrcat(p, path, \"/\", NULL);\n        for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)\n            path[n - 1] = '\\0';\n\n        \n        str = (basedir[0] != '\\0') ? \"<a href=\\\"/%2f/\\\">%2f</a>/\" : \"\";\n\n        \n        escpath = ap_escape_html(p, path);\n        str = apr_psprintf(p, DOCTYPE_HTML_3_2\n                \"<html>\\n <head>\\n  <title>%s%s%s</title>\\n\"\n                \"<base href=\\\"%s%s%s\\\">\\n\"\n                \" </head>\\n\"\n                \" <body>\\n  <h2>Directory of \"\n                \"<a href=\\\"/\\\">%s</a>/%s\",\n                ap_escape_html(p, site), basedir, escpath,\n                ap_escape_uri(p, site), basedir, escpath,\n                ap_escape_uri(p, site), str);\n\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str),\n                                                          p, c->bucket_alloc));\n\n        for (dir = path+1; (dir = strchr(dir, '/')) != NULL; )\n        {\n            *dir = '\\0';\n            if ((reldir = strrchr(path+1, '/'))==NULL) {\n                reldir = path+1;\n            }\n            else\n                ++reldir;\n            \n            str = apr_psprintf(p, \"<a href=\\\"%s%s/\\\">%s</a>/\", basedir,\n                        ap_escape_uri(p, path),\n                        ap_escape_html(p, reldir));\n            *dir = '/';\n            while (*dir == '/')\n              ++dir;\n            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str,\n                                                           strlen(str), p,\n                                                           c->bucket_alloc));\n        }\n        if (wildcard != NULL) {\n            wildcard = ap_escape_html(p, wildcard);\n            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(wildcard,\n                                                           strlen(wildcard), p,\n                                                           c->bucket_alloc));\n        }\n\n        \n        \n        if (pwd == NULL || strncmp(pwd, path, strlen(pwd)) == 0) {\n            str = apr_psprintf(p, \"</h2>\\n\\n  <hr />\\n\\n<pre>\");\n        }\n        else {\n            str = apr_psprintf(p, \"</h2>\\n\\n(%s)\\n\\n  <hr />\\n\\n<pre>\",\n                               ap_escape_html(p, pwd));\n        }\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str),\n                                                           p, c->bucket_alloc));\n\n        \n        if (readme) {\n            str = apr_psprintf(p, \"%s\\n</pre>\\n\\n<hr />\\n\\n<pre>\\n\",\n                               ap_escape_html(p, readme));\n\n            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str,\n                                                           strlen(str), p,\n                                                           c->bucket_alloc));\n        }\n\n        \n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_flush_create(c->bucket_alloc));\n        if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {\n            return rv;\n        }\n        apr_brigade_cleanup(out);\n\n        ctx->state = BODY;\n    }\n\n    \n    while (BODY == ctx->state) {\n        char *filename;\n        int found = 0;\n        int eos = 0;\n        ap_regmatch_t re_result[LS_REG_MATCH];\n\n        \n        \n        while (!found && !APR_BRIGADE_EMPTY(ctx->in)) {\n            char *pos, *response;\n            apr_size_t len, max;\n            apr_bucket *e;\n\n            e = APR_BRIGADE_FIRST(ctx->in);\n            if (APR_BUCKET_IS_EOS(e)) {\n                eos = 1;\n                break;\n            }\n            if (APR_SUCCESS != (rv = apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ))) {\n                return rv;\n            }\n            pos = memchr(response, APR_ASCII_LF, len);\n            if (pos != NULL) {\n                if ((response + len) != (pos + 1)) {\n                    len = pos - response + 1;\n                    apr_bucket_split(e, pos - response + 1);\n                }\n                found = 1;\n            }\n            max = sizeof(ctx->buffer) - strlen(ctx->buffer) - 1;\n            if (len > max) {\n                len = max;\n            }\n\n            \n            apr_cpystrn(ctx->buffer+strlen(ctx->buffer), response, len+1);\n\n            APR_BUCKET_REMOVE(e);\n            apr_bucket_destroy(e);\n        }\n\n        \n        if (eos) {\n            ctx->state = FOOTER;\n            break;\n        }\n\n        \n        if (!found) {\n            return APR_SUCCESS;\n        }\n\n        {\n            apr_size_t n = strlen(ctx->buffer);\n            if (ctx->buffer[n-1] == CRLF[1])  \n                ctx->buffer[--n] = '\\0';\n            if (ctx->buffer[n-1] == CRLF[0])  \n                ctx->buffer[--n] = '\\0';\n        }\n\n        \n        if (ctx->buffer[0] == 'l' && (filename = strstr(ctx->buffer, \" -> \")) != NULL) {\n            char *link_ptr = filename;\n\n            do {\n                filename--;\n            } while (filename[0] != ' ' && filename > ctx->buffer);\n            if (filename > ctx->buffer)\n                *(filename++) = '\\0';\n            *(link_ptr++) = '\\0';\n            str = apr_psprintf(p, \"%s <a href=\\\"%s\\\">%s %s</a>\\n\",\n                               ap_escape_html(p, ctx->buffer),\n                               ap_escape_uri(p, filename),\n                               ap_escape_html(p, filename),\n                               ap_escape_html(p, link_ptr));\n        }\n\n        \n        else if (ctx->buffer[0] == 'd' || ctx->buffer[0] == '-' || ctx->buffer[0] == 'l' || apr_isdigit(ctx->buffer[0])) {\n            int searchidx = 0;\n            char *searchptr = NULL;\n            int firstfile = 1;\n            if (apr_isdigit(ctx->buffer[0])) {  \n                searchptr = strchr(ctx->buffer, '<');\n                if (searchptr != NULL)\n                    *searchptr = '[';\n                searchptr = strchr(ctx->buffer, '>');\n                if (searchptr != NULL)\n                    *searchptr = ']';\n            }\n\n            filename = strrchr(ctx->buffer, ' ');\n            if (filename == NULL) {\n                \n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01034)\n                              \"proxy_ftp: could not parse line %s\",\n                              ctx->buffer);\n                \n                ctx->buffer[0] = 0;\n                continue;  \n            }\n            *(filename++) = '\\0';\n\n            \n            if (!strcmp(filename, \".\") || !strcmp(filename, \"..\") || firstfile) {\n                firstfile = 0;\n                searchidx = filename - ctx->buffer;\n            }\n            else if (searchidx != 0 && ctx->buffer[searchidx] != 0) {\n                *(--filename) = ' ';\n                ctx->buffer[searchidx - 1] = '\\0';\n                filename = &ctx->buffer[searchidx];\n            }\n\n            \n            if (!strcmp(filename, \".\") || !strcmp(filename, \"..\") || ctx->buffer[0] == 'd') {\n                str = apr_psprintf(p, \"%s <a href=\\\"%s/\\\">%s</a>\\n\",\n                                   ap_escape_html(p, ctx->buffer),\n                                   ap_escape_uri(p, filename),\n                                   ap_escape_html(p, filename));\n            }\n            else {\n                str = apr_psprintf(p, \"%s <a href=\\\"%s\\\">%s</a>\\n\",\n                                   ap_escape_html(p, ctx->buffer),\n                                   ap_escape_uri(p, filename),\n                                   ap_escape_html(p, filename));\n            }\n        }\n        \n        else if (0 == ap_regexec(ls_regex, ctx->buffer, LS_REG_MATCH, re_result, 0)) {\n            /*\n             * We don't need to check for rm_eo == rm_so == -1 here since ls_regex\n             * is such that $2 cannot be unset if we have a match.\n             */\n            filename = apr_pstrndup(p, &ctx->buffer[re_result[2].rm_so], re_result[2].rm_eo - re_result[2].rm_so);\n\n            str = apr_pstrcat(p, ap_escape_html(p, apr_pstrndup(p, ctx->buffer, re_result[2].rm_so)),\n                              \"<a href=\\\"\", ap_escape_uri(p, filename), \"\\\">\",\n                              ap_escape_html(p, filename), \"</a>\\n\", NULL);\n        }\n        else {\n            strcat(ctx->buffer, \"\\n\"); \n            str = ap_escape_html(p, ctx->buffer);\n        }\n\n        \n        ctx->buffer[0] = 0;\n\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str), p,\n                                                            c->bucket_alloc));\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_flush_create(c->bucket_alloc));\n        if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {\n            return rv;\n        }\n        apr_brigade_cleanup(out);\n\n    }\n\n    if (FOOTER == ctx->state) {\n        str = apr_psprintf(p, \"</pre>\\n\\n  <hr />\\n\\n  %s\\n\\n </body>\\n</html>\\n\", ap_psignature(\"\", r));\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str), p,\n                                                            c->bucket_alloc));\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_flush_create(c->bucket_alloc));\n        APR_BRIGADE_INSERT_TAIL(out, apr_bucket_eos_create(c->bucket_alloc));\n        if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {\n            return rv;\n        }\n        apr_brigade_destroy(out);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_d75a391138a1d3fbcbd8c1696bcc34663b6eb302_0", {
    "ID": "httpd_d75a391138a1d3fbcbd8c1696bcc34663b6eb302_0",
    "UID": "4002",
    "code": "DAV_DECLARE(const char *) dav_lock_get_activelock(request_rec test_snippet\n                                                  dav_lock *lock,\n                                                  dav_buffer *pbuf)\n{\n    dav_lock *lock_scan;\n    const dav_hooks_locks *hooks = DAV_GET_HOOKS_LOCKS(r);\n    int count = 0;\n    dav_buffer work_buf = { 0 };\n    apr_pool_t *p = r->pool;\n\n    \n    if (lock == NULL || hooks == NULL) {\n        /*\n        ** Since resourcediscovery is defined with (activelock)*,\n        ** <D:activelock/> shouldn't be necessary for an empty lock.\n        */\n        return \"\";\n    }\n\n    /*\n    ** Note: it could be interesting to sum the lengths of the owners\n    **       and locktokens during this loop. However, the buffer\n    **       mechanism provides some rough padding so that we don't\n    **       really need to have an exact size. Further, constructing\n    **       locktoken strings could be relatively expensive.\n    */\n    for (lock_scan = lock; lock_scan != NULL; lock_scan = lock_scan->next)\n        count++;\n\n    \n    if (pbuf == NULL)\n        pbuf = &work_buf;\n\n    \n    pbuf->cur_len = 0;\n\n    \n    dav_check_bufsize(p, pbuf, count * 300);\n\n    for (; lock != NULL; lock = lock->next) {\n        char tmp[100];\n\n#if DAV_DEBUG\n        if (lock->rectype == DAV_LOCKREC_INDIRECT_PARTIAL) {\n            \n            dav_buffer_append(p, pbuf,\n                              \"DESIGN ERROR: attempted to product an \"\n                              \"activelock element from a partial, indirect \"\n                              \"lock record. Creating an XML parsing error \"\n                              \"to ease detection of this situation: <\");\n        }\n#endif\n\n        dav_buffer_append(p, pbuf, \"<D:activelock>\" DEBUG_CR \"<D:locktype>\");\n        switch (lock->type) {\n        case DAV_LOCKTYPE_WRITE:\n            dav_buffer_append(p, pbuf, \"<D:write/>\");\n            break;\n        default:\n            \n            break;\n        }\n        dav_buffer_append(p, pbuf, \"</D:locktype>\" DEBUG_CR \"<D:lockscope>\");\n        switch (lock->scope) {\n        case DAV_LOCKSCOPE_EXCLUSIVE:\n            dav_buffer_append(p, pbuf, \"<D:exclusive/>\");\n            break;\n        case DAV_LOCKSCOPE_SHARED:\n            dav_buffer_append(p, pbuf, \"<D:shared/>\");\n            break;\n        default:\n            \n            break;\n        }\n        dav_buffer_append(p, pbuf, \"</D:lockscope>\" DEBUG_CR);\n        apr_snprintf(tmp, sizeof(tmp), \"<D:depth>%s</D:depth>\" DEBUG_CR,\n                     lock->depth == DAV_INFINITY ? \"infinity\" : \"0\");\n        dav_buffer_append(p, pbuf, tmp);\n\n        if (lock->owner) {\n            /*\n            ** This contains a complete, self-contained <DAV:owner> element,\n            ** with namespace declarations and xml:lang handling. Just drop\n            ** it in.\n            */\n            dav_buffer_append(p, pbuf, lock->owner);\n        }\n\n        dav_buffer_append(p, pbuf, \"<D:timeout>\");\n        if (lock->timeout == DAV_TIMEOUT_INFINITE) {\n            dav_buffer_append(p, pbuf, \"Infinite\");\n        }\n        else {\n            time_t now = time(NULL);\n            \n            /*\n            ** Check if the timeout is not, for any reason, already elapsed.\n            ** (e.g., because of a large collection, or disk under heavy load...)\n             */\n            if (now >= lock->timeout) {\n                dav_buffer_append(p, pbuf, \"Second-0\");\n            }\n            else {\n                apr_snprintf(tmp, sizeof(tmp), \"Second-%lu\", (long unsigned int)(lock->timeout - now));\n                dav_buffer_append(p, pbuf, tmp);\n            }\n        }\n\n        dav_buffer_append(p, pbuf,\n                          \"</D:timeout>\" DEBUG_CR\n                          \"<D:locktoken>\" DEBUG_CR\n                          \"<D:href>\");\n        dav_buffer_append(p, pbuf,\n                          (*hooks->format_locktoken)(p, lock->locktoken));\n        dav_buffer_append(p, pbuf,\n                          \"</D:href>\" DEBUG_CR\n                          \"</D:locktoken>\" DEBUG_CR\n                          \"</D:activelock>\" DEBUG_CR);\n    }\n\n    return pbuf->buf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d296b46ccb6cfc13c772bfa166b9d526ff937b2b_0", {
    "ID": "httpd_d296b46ccb6cfc13c772bfa166b9d526ff937b2b_0",
    "UID": "4006",
    "code": "static void ap_logio_add_bytes_out(conn_rec *c, apr_off_t test_snippet\n{\n    logio_config_t *cf = ap_get_module_config(c->conn_config, &logio_module);\n    cf->bytes_out += bytes;\n\n    if (!cf->first_byte_seen) {\n         \n        cf->first_byte_seen = 1; \n\n        if (cf->r) { \n            logio_dirconf_t *conf = (logio_dirconf_t*) \n                ap_get_module_config(cf->r->per_dir_config, &logio_module);\n            if (conf && conf->track_ttfb) { \n                cf->ttfb = apr_time_now() - cf->r->request_time;\n            }\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_dd90be07ece426b4e254656a7f257c98c9ee136c_0", {
    "ID": "httpd_dd90be07ece426b4e254656a7f257c98c9ee136c_0",
    "UID": "4009",
    "code": "static authz_status host_check_authorization(request_rec test_snippet\n                                             const char *require_line,\n                                             const void *parsed_require_line)\n{\n    const char *t;\n    char *w, *hash_ptr;\n    const char *remotehost = NULL;\n    int remotehost_is_ip;\n\n    remotehost = ap_get_remote_host(r->connection,\n                                    r->per_dir_config,\n                                    REMOTE_DOUBLE_REV,\n                                    &remotehost_is_ip);\n\n    if ((remotehost == NULL) || remotehost_is_ip) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01753)\n                      \"access check of '%s' to %s failed, reason: unable to get the \"\n                      \"remote host name\", require_line, r->uri);\n    }\n    else {\n        const char *err = NULL;\n        const ap_expr_info_t *expr = parsed_require_line;\n        const char *require;\n\n        require = ap_expr_str_exec(r, expr, &err);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02593)\n                          \"authz_host authorize: require host: Can't \"\n                          \"evaluate require expression: %s\", err);\n            return AUTHZ_DENIED;\n        }\n\n        /* The 'host' provider will allow the configuration to specify a list of\n            host names to check rather than a single name.  This is different\n            from the previous host based syntax. */\n        t = require;\n        while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n            /* '#' is not valid hostname character and admin could specify\n             * 'Require host localhost# Add example.com later'. We should not\n             * grant access to 'example.com' in that case. */\n            if ((hash_ptr = ap_strchr(w, '#'))) {\n                if (hash_ptr == w) {\n                    break;\n                }\n                *hash_ptr = '\\0';\n            }\n            if (in_domain(w, remotehost)) {\n                return AUTHZ_GRANTED;\n            }\n            if (hash_ptr) {\n                break;\n            }\n        }\n    }\n\n    \n    return AUTHZ_DENIED;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_58b0b1207dcca8b9717fabcf7ed2df72a14b6e08_0", {
    "ID": "httpd_58b0b1207dcca8b9717fabcf7ed2df72a14b6e08_0",
    "UID": "4012",
    "code": "static int status_handler(request_rec test_snippet\n{\n    const char *loc;\n    apr_time_t nowtime;\n    apr_uint32_t up_time;\n    ap_loadavg_t t;\n    int j, i, res, written;\n    int ready;\n    int busy;\n    unsigned long count;\n    unsigned long lres, my_lres, conn_lres;\n    apr_off_t bytes, my_bytes, conn_bytes;\n    apr_off_t bcount, kbcount;\n    long req_time;\n    int short_report;\n    int no_table_report;\n    worker_score *ws_record = apr_palloc(r->pool, sizeof *ws_record);\n    process_score *ps_record;\n    char *stat_buffer;\n    pid_t *pid_buffer, worker_pid;\n    int *thread_idle_buffer = NULL;\n    int *thread_busy_buffer = NULL;\n    clock_t tu, ts, tcu, tcs;\n    ap_generation_t mpm_generation, worker_generation;\n#ifdef HAVE_TIMES\n    float tick;\n    int times_per_thread;\n#endif\n\n    if (strcmp(r->handler, STATUS_MAGIC_TYPE) && strcmp(r->handler,\n            \"server-status\")) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_TIMES\n    times_per_thread = getpid() != child_pid;\n#endif\n\n    ap_mpm_query(AP_MPMQ_GENERATION, &mpm_generation);\n\n#ifdef HAVE_TIMES\n#ifdef _SC_CLK_TCK\n    tick = sysconf(_SC_CLK_TCK);\n#else\n    tick = HZ;\n#endif\n#endif\n\n    ready = 0;\n    busy = 0;\n    count = 0;\n    bcount = 0;\n    kbcount = 0;\n    short_report = 0;\n    no_table_report = 0;\n\n    pid_buffer = apr_palloc(r->pool, server_limit * sizeof(pid_t));\n    stat_buffer = apr_palloc(r->pool, server_limit * thread_limit * sizeof(char));\n    if (is_async) {\n        thread_idle_buffer = apr_palloc(r->pool, server_limit * sizeof(int));\n        thread_busy_buffer = apr_palloc(r->pool, server_limit * sizeof(int));\n    }\n\n    nowtime = apr_time_now();\n    tu = ts = tcu = tcs = 0;\n\n    if (!ap_exists_scoreboard_image()) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01237)\n                      \"Server status unavailable in inetd mode\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->allowed = (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET)\n        return DECLINED;\n\n    ap_set_content_type(r, \"text/html; charset=ISO-8859-1\");\n\n    /*\n     * Simple table-driven form data set parser that lets you alter the header\n     */\n\n    if (r->args) {\n        i = 0;\n        while (status_options[i].id != STAT_OPT_END) {\n            if ((loc = ap_strstr_c(r->args,\n                                   status_options[i].form_data_str)) != NULL) {\n                switch (status_options[i].id) {\n                case STAT_OPT_REFRESH: {\n                    apr_size_t len = strlen(status_options[i].form_data_str);\n                    long t = 0;\n\n                    if (*(loc + len ) == '=') {\n                        t = atol(loc + len + 1);\n                    }\n                    apr_table_setn(r->headers_out,\n                                   status_options[i].hdr_out_str,\n                                   apr_ltoa(r->pool, t < 1 ? 10 : t));\n                    break;\n                }\n                case STAT_OPT_NOTABLE:\n                    no_table_report = 1;\n                    break;\n                case STAT_OPT_AUTO:\n                    ap_set_content_type(r, \"text/plain; charset=ISO-8859-1\");\n                    short_report = 1;\n                    break;\n                }\n            }\n\n            i++;\n        }\n    }\n\n    for (i = 0; i < server_limit; ++i) {\n#ifdef HAVE_TIMES\n        clock_t proc_tu = 0, proc_ts = 0, proc_tcu = 0, proc_tcs = 0;\n        clock_t tmp_tu, tmp_ts, tmp_tcu, tmp_tcs;\n#endif\n\n        ps_record = ap_get_scoreboard_process(i);\n        if (is_async) {\n            thread_idle_buffer[i] = 0;\n            thread_busy_buffer[i] = 0;\n        }\n        for (j = 0; j < thread_limit; ++j) {\n            int indx = (i * thread_limit) + j;\n\n            ap_copy_scoreboard_worker(ws_record, i, j);\n            res = ws_record->status;\n\n            if ((i >= max_servers || j >= threads_per_child)\n                && (res == SERVER_DEAD))\n                stat_buffer[indx] = status_flags[SERVER_DISABLED];\n            else\n                stat_buffer[indx] = status_flags[res];\n\n            if (!ps_record->quiescing\n                && ps_record->pid) {\n                if (res == SERVER_READY) {\n                    if (ps_record->generation == mpm_generation)\n                        ready++;\n                    if (is_async)\n                        thread_idle_buffer[i]++;\n                }\n                else if (res != SERVER_DEAD &&\n                         res != SERVER_STARTING &&\n                         res != SERVER_IDLE_KILL) {\n                    busy++;\n                    if (is_async) {\n                        if (res == SERVER_GRACEFUL)\n                            thread_idle_buffer[i]++;\n                        else\n                            thread_busy_buffer[i]++;\n                    }\n                }\n            }\n\n            /* XXX what about the counters for quiescing/seg faulted\n             * processes?  should they be counted or not?  GLA\n             */\n            if (ap_extended_status) {\n                lres = ws_record->access_count;\n                bytes = ws_record->bytes_served;\n\n                if (lres != 0 || (res != SERVER_READY && res != SERVER_DEAD)) {\n#ifdef HAVE_TIMES\n                    tmp_tu = ws_record->times.tms_utime;\n                    tmp_ts = ws_record->times.tms_stime;\n                    tmp_tcu = ws_record->times.tms_cutime;\n                    tmp_tcs = ws_record->times.tms_cstime;\n\n                    if (times_per_thread) {\n                        proc_tu += tmp_tu;\n                        proc_ts += tmp_ts;\n                        proc_tcu += tmp_tcu;\n                        proc_tcs += tmp_tcs;\n                    }\n                    else {\n                        if (tmp_tu > proc_tu ||\n                            tmp_ts > proc_ts ||\n                            tmp_tcu > proc_tcu ||\n                            tmp_tcs > proc_tcs) {\n                            proc_tu = tmp_tu;\n                            proc_ts = tmp_ts;\n                            proc_tcu = tmp_tcu;\n                            proc_tcs = tmp_tcs;\n                        }\n                    }\n#endif \n\n                    count += lres;\n                    bcount += bytes;\n\n                    if (bcount >= KBYTE) {\n                        kbcount += (bcount >> 10);\n                        bcount = bcount & 0x3ff;\n                    }\n                }\n            }\n        }\n#ifdef HAVE_TIMES\n        tu += proc_tu;\n        ts += proc_ts;\n        tcu += proc_tcu;\n        tcs += proc_tcs;\n#endif\n        pid_buffer[i] = ps_record->pid;\n    }\n\n    \n    up_time = (apr_uint32_t) apr_time_sec(nowtime -\n                               ap_scoreboard_image->global->restart_time);\n    ap_get_loadavg(&t);\n\n    if (!short_report) {\n        ap_rputs(DOCTYPE_HTML_3_2\n                 \"<html><head>\\n\"\n                 \"<title>Apache Status</title>\\n\"\n                 \"</head><body>\\n\"\n                 \"<h1>Apache Server Status for \", r);\n        ap_rvputs(r, ap_escape_html(r->pool, ap_get_server_name(r)),\n                  \" (via \", r->connection->local_ip,\n                  \")</h1>\\n\\n\", NULL);\n        ap_rvputs(r, \"<dl><dt>Server Version: \",\n                  ap_get_server_description(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Server MPM: \",\n                  ap_show_mpm(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Server Built: \",\n                  ap_get_server_built(), \"\\n</dt></dl><hr /><dl>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Current Time: \",\n                  ap_ht_time(r->pool, nowtime, DEFAULT_TIME_FORMAT, 0),\n                             \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Restart Time: \",\n                  ap_ht_time(r->pool,\n                             ap_scoreboard_image->global->restart_time,\n                             DEFAULT_TIME_FORMAT, 0),\n                  \"</dt>\\n\", NULL);\n        ap_rprintf(r, \"<dt>Parent Server Config. Generation: %d</dt>\\n\",\n                   ap_state_query(AP_SQ_CONFIG_GEN));\n        ap_rprintf(r, \"<dt>Parent Server MPM Generation: %d</dt>\\n\",\n                   (int)mpm_generation);\n        ap_rputs(\"<dt>Server uptime: \", r);\n        show_time(r, up_time);\n        ap_rputs(\"</dt>\\n\", r);\n        ap_rprintf(r, \"<dt>Server load: %.2f %.2f %.2f</dt>\\n\",\n                   t.loadavg, t.loadavg5, t.loadavg15);\n    }\n    else {\n        ap_rvputs(r, ap_get_server_name(r), \"\\n\", NULL);\n        ap_rvputs(r, \"ServerVersion: \",\n                  ap_get_server_description(), \"\\n\", NULL);\n        ap_rvputs(r, \"ServerMPM: \",\n                  ap_show_mpm(), \"\\n\", NULL);\n        ap_rvputs(r, \"Server Built: \",\n                  ap_get_server_built(), \"\\n\", NULL);\n        ap_rvputs(r, \"CurrentTime: \",\n                  ap_ht_time(r->pool, nowtime, DEFAULT_TIME_FORMAT, 0),\n                             \"\\n\", NULL);\n        ap_rvputs(r, \"RestartTime: \",\n                  ap_ht_time(r->pool,\n                             ap_scoreboard_image->global->restart_time,\n                             DEFAULT_TIME_FORMAT, 0),\n                  \"\\n\", NULL);\n        ap_rprintf(r, \"ParentServerConfigGeneration: %d\\n\",\n                   ap_state_query(AP_SQ_CONFIG_GEN));\n        ap_rprintf(r, \"ParentServerMPMGeneration: %d\\n\",\n                   (int)mpm_generation);\n        ap_rprintf(r, \"ServerUptimeSeconds: %u\\n\",\n                   up_time);\n        ap_rputs(\"ServerUptime:\", r);\n        show_time(r, up_time);\n        ap_rputs(\"\\n\", r);\n        ap_rprintf(r, \"Load1: %.2f\\nLoad5: %.2f\\nLoad15: %.2f\\n\",\n                   t.loadavg, t.loadavg5, t.loadavg15);\n    }\n\n    if (ap_extended_status) {\n        if (short_report) {\n            ap_rprintf(r, \"Total Accesses: %lu\\nTotal kBytes: %\"\n                       APR_OFF_T_FMT \"\\n\",\n                       count, kbcount);\n\n#ifdef HAVE_TIMES\n            \n            ap_rprintf(r, \"CPUUser: %g\\nCPUSystem: %g\\nCPUChildrenUser: %g\\nCPUChildrenSystem: %g\\n\",\n                       tu / tick, ts / tick, tcu / tick, tcs / tick);\n\n            if (ts || tu || tcu || tcs)\n                ap_rprintf(r, \"CPULoad: %g\\n\",\n                           (tu + ts + tcu + tcs) / tick / up_time * 100.);\n#endif\n\n            ap_rprintf(r, \"Uptime: %ld\\n\", (long) (up_time));\n            if (up_time > 0) {\n                ap_rprintf(r, \"ReqPerSec: %g\\n\",\n                           (float) count / (float) up_time);\n\n                ap_rprintf(r, \"BytesPerSec: %g\\n\",\n                           KBYTE * (float) kbcount / (float) up_time);\n            }\n            if (count > 0)\n                ap_rprintf(r, \"BytesPerReq: %g\\n\",\n                           KBYTE * (float) kbcount / (float) count);\n        }\n        else { \n            ap_rprintf(r, \"<dt>Total accesses: %lu - Total Traffic: \", count);\n            format_kbyte_out(r, kbcount);\n            ap_rputs(\"</dt>\\n\", r);\n\n#ifdef HAVE_TIMES\n            \n            ap_rprintf(r, \"<dt>CPU Usage: u%g s%g cu%g cs%g\",\n                       tu / tick, ts / tick, tcu / tick, tcs / tick);\n\n            if (ts || tu || tcu || tcs)\n                ap_rprintf(r, \" - %.3g%% CPU load</dt>\\n\",\n                           (tu + ts + tcu + tcs) / tick / up_time * 100.);\n#endif\n\n            if (up_time > 0) {\n                ap_rprintf(r, \"<dt>%.3g requests/sec - \",\n                           (float) count / (float) up_time);\n\n                format_byte_out(r, (unsigned long)(KBYTE * (float) kbcount\n                                                   / (float) up_time));\n                ap_rputs(\"/second - \", r);\n            }\n\n            if (count > 0) {\n                format_byte_out(r, (unsigned long)(KBYTE * (float) kbcount\n                                                   / (float) count));\n                ap_rputs(\"/request\", r);\n            }\n\n            ap_rputs(\"</dt>\\n\", r);\n        } \n    } \n\n    if (!short_report)\n        ap_rprintf(r, \"<dt>%d requests currently being processed, \"\n                      \"%d idle workers</dt>\\n\", busy, ready);\n    else\n        ap_rprintf(r, \"BusyWorkers: %d\\nIdleWorkers: %d\\n\", busy, ready);\n\n    if (!short_report)\n        ap_rputs(\"</dl>\", r);\n\n    if (is_async) {\n        int write_completion = 0, lingering_close = 0, keep_alive = 0,\n            connections = 0;\n        /*\n         * These differ from 'busy' and 'ready' in how gracefully finishing\n         * threads are counted. XXX: How to make this clear in the html?\n         */\n        int busy_workers = 0, idle_workers = 0;\n        if (!short_report)\n            ap_rputs(\"\\n\\n<table rules=\\\"all\\\" cellpadding=\\\"1%\\\">\\n\"\n                     \"<tr><th rowspan=\\\"2\\\">PID</th>\"\n                         \"<th colspan=\\\"2\\\">Connections</th>\\n\"\n                         \"<th colspan=\\\"2\\\">Threads</th>\"\n                         \"<th colspan=\\\"4\\\">Async connections</th></tr>\\n\"\n                     \"<tr><th>total</th><th>accepting</th>\"\n                         \"<th>busy</th><th>idle</th><th>writing</th>\"\n                         \"<th>keep-alive</th><th>closing</th></tr>\\n\", r);\n        for (i = 0; i < server_limit; ++i) {\n            ps_record = ap_get_scoreboard_process(i);\n            if (ps_record->pid) {\n                connections      += ps_record->connections;\n                write_completion += ps_record->write_completion;\n                keep_alive       += ps_record->keep_alive;\n                lingering_close  += ps_record->lingering_close;\n                busy_workers     += thread_busy_buffer[i];\n                idle_workers     += thread_idle_buffer[i];\n                if (!short_report)\n                    ap_rprintf(r, \"<tr><td>%\" APR_PID_T_FMT \"</td><td>%u</td>\"\n                                      \"<td>%s</td><td>%u</td><td>%u</td>\"\n                                      \"<td>%u</td><td>%u</td><td>%u</td>\"\n                                      \"</tr>\\n\",\n                               ps_record->pid, ps_record->connections,\n                               ps_record->not_accepting ? \"no\" : \"yes\",\n                               thread_busy_buffer[i], thread_idle_buffer[i],\n                               ps_record->write_completion,\n                               ps_record->keep_alive,\n                               ps_record->lingering_close);\n            }\n        }\n        if (!short_report) {\n            ap_rprintf(r, \"<tr><td>Sum</td><td>%d</td><td>&nbsp;</td><td>%d</td>\"\n                          \"<td>%d</td><td>%d</td><td>%d</td><td>%d</td>\"\n                          \"</tr>\\n</table>\\n\",\n                          connections, busy_workers, idle_workers,\n                          write_completion, keep_alive, lingering_close);\n\n        }\n        else {\n            ap_rprintf(r, \"ConnsTotal: %d\\n\"\n                          \"ConnsAsyncWriting: %d\\n\"\n                          \"ConnsAsyncKeepAlive: %d\\n\"\n                          \"ConnsAsyncClosing: %d\\n\",\n                       connections, write_completion, keep_alive,\n                       lingering_close);\n        }\n    }\n\n    \n    if (!short_report)\n        ap_rputs(\"<pre>\", r);\n    else\n        ap_rputs(\"Scoreboard: \", r);\n\n    written = 0;\n    for (i = 0; i < server_limit; ++i) {\n        for (j = 0; j < thread_limit; ++j) {\n            int indx = (i * thread_limit) + j;\n            if (stat_buffer[indx] != status_flags[SERVER_DISABLED]) {\n                ap_rputc(stat_buffer[indx], r);\n                if ((written % STATUS_MAXLINE == (STATUS_MAXLINE - 1))\n                    && !short_report)\n                    ap_rputs(\"\\n\", r);\n                written++;\n            }\n        }\n    }\n\n\n    if (short_report)\n        ap_rputs(\"\\n\", r);\n    else {\n        ap_rputs(\"</pre>\\n\"\n                 \"<p>Scoreboard Key:<br />\\n\"\n                 \"\\\"<b><code>_</code></b>\\\" Waiting for Connection, \\n\"\n                 \"\\\"<b><code>S</code></b>\\\" Starting up, \\n\"\n                 \"\\\"<b><code>R</code></b>\\\" Reading Request,<br />\\n\"\n                 \"\\\"<b><code>W</code></b>\\\" Sending Reply, \\n\"\n                 \"\\\"<b><code>K</code></b>\\\" Keepalive (read), \\n\"\n                 \"\\\"<b><code>D</code></b>\\\" DNS Lookup,<br />\\n\"\n                 \"\\\"<b><code>C</code></b>\\\" Closing connection, \\n\"\n                 \"\\\"<b><code>L</code></b>\\\" Logging, \\n\"\n                 \"\\\"<b><code>G</code></b>\\\" Gracefully finishing,<br /> \\n\"\n                 \"\\\"<b><code>I</code></b>\\\" Idle cleanup of worker, \\n\"\n                 \"\\\"<b><code>.</code></b>\\\" Open slot with no current process<br />\\n\"\n                 \"<p />\\n\", r);\n        if (!ap_extended_status) {\n            int j;\n            int k = 0;\n            ap_rputs(\"PID Key: <br />\\n\"\n                     \"<pre>\\n\", r);\n            for (i = 0; i < server_limit; ++i) {\n                for (j = 0; j < thread_limit; ++j) {\n                    int indx = (i * thread_limit) + j;\n\n                    if (stat_buffer[indx] != '.') {\n                        ap_rprintf(r, \"   %\" APR_PID_T_FMT\n                                   \" in state: %c \", pid_buffer[i],\n                                   stat_buffer[indx]);\n\n                        if (++k >= 3) {\n                            ap_rputs(\"\\n\", r);\n                            k = 0;\n                        } else\n                            ap_rputs(\",\", r);\n                    }\n                }\n            }\n\n            ap_rputs(\"\\n\"\n                     \"</pre>\\n\", r);\n        }\n    }\n\n    if (ap_extended_status && !short_report) {\n        if (no_table_report)\n            ap_rputs(\"<hr /><h2>Server Details</h2>\\n\\n\", r);\n        else\n            ap_rputs(\"\\n\\n<table border=\\\"0\\\"><tr>\"\n                     \"<th>Srv</th><th>PID</th><th>Acc</th>\"\n                     \"<th>M</th>\"\n#ifdef HAVE_TIMES\n                     \"<th>CPU\\n</th>\"\n#endif\n                     \"<th>SS</th><th>Req</th>\"\n                     \"<th>Conn</th><th>Child</th><th>Slot</th>\"\n                     \"<th>Client</th><th>VHost</th>\"\n                     \"<th>Request</th></tr>\\n\\n\", r);\n\n        for (i = 0; i < server_limit; ++i) {\n            for (j = 0; j < thread_limit; ++j) {\n                ap_copy_scoreboard_worker(ws_record, i, j);\n\n                if (ws_record->access_count == 0 &&\n                    (ws_record->status == SERVER_READY ||\n                     ws_record->status == SERVER_DEAD)) {\n                    continue;\n                }\n\n                ps_record = ap_get_scoreboard_process(i);\n\n                if (ws_record->start_time == 0L)\n                    req_time = 0L;\n                else\n                    req_time = (long)\n                        ((ws_record->stop_time -\n                          ws_record->start_time) / 1000);\n                if (req_time < 0L)\n                    req_time = 0L;\n\n                lres = ws_record->access_count;\n                my_lres = ws_record->my_access_count;\n                conn_lres = ws_record->conn_count;\n                bytes = ws_record->bytes_served;\n                my_bytes = ws_record->my_bytes_served;\n                conn_bytes = ws_record->conn_bytes;\n                if (ws_record->pid) { \n                    worker_pid = ws_record->pid;\n                    worker_generation = ws_record->generation;\n                }\n                else {\n                    worker_pid = ps_record->pid;\n                    worker_generation = ps_record->generation;\n                }\n\n                if (no_table_report) {\n                    if (ws_record->status == SERVER_DEAD)\n                        ap_rprintf(r,\n                                   \"<b>Server %d-%d</b> (-): %d|%lu|%lu [\",\n                                   i, (int)worker_generation,\n                                   (int)conn_lres, my_lres, lres);\n                    else\n                        ap_rprintf(r,\n                                   \"<b>Server %d-%d</b> (%\"\n                                   APR_PID_T_FMT \"): %d|%lu|%lu [\",\n                                   i, (int) worker_generation,\n                                   worker_pid,\n                                   (int)conn_lres, my_lres, lres);\n\n                    switch (ws_record->status) {\n                    case SERVER_READY:\n                        ap_rputs(\"Ready\", r);\n                        break;\n                    case SERVER_STARTING:\n                        ap_rputs(\"Starting\", r);\n                        break;\n                    case SERVER_BUSY_READ:\n                        ap_rputs(\"<b>Read</b>\", r);\n                        break;\n                    case SERVER_BUSY_WRITE:\n                        ap_rputs(\"<b>Write</b>\", r);\n                        break;\n                    case SERVER_BUSY_KEEPALIVE:\n                        ap_rputs(\"<b>Keepalive</b>\", r);\n                        break;\n                    case SERVER_BUSY_LOG:\n                        ap_rputs(\"<b>Logging</b>\", r);\n                        break;\n                    case SERVER_BUSY_DNS:\n                        ap_rputs(\"<b>DNS lookup</b>\", r);\n                        break;\n                    case SERVER_CLOSING:\n                        ap_rputs(\"<b>Closing</b>\", r);\n                        break;\n                    case SERVER_DEAD:\n                        ap_rputs(\"Dead\", r);\n                        break;\n                    case SERVER_GRACEFUL:\n                        ap_rputs(\"Graceful\", r);\n                        break;\n                    case SERVER_IDLE_KILL:\n                        ap_rputs(\"Dying\", r);\n                        break;\n                    default:\n                        ap_rputs(\"?STATE?\", r);\n                        break;\n                    }\n\n                    ap_rprintf(r, \"] \"\n#ifdef HAVE_TIMES\n                               \"u%g s%g cu%g cs%g\"\n#endif\n                               \"\\n %ld %ld (\",\n#ifdef HAVE_TIMES\n                               ws_record->times.tms_utime / tick,\n                               ws_record->times.tms_stime / tick,\n                               ws_record->times.tms_cutime / tick,\n                               ws_record->times.tms_cstime / tick,\n#endif\n                               (long)apr_time_sec(nowtime -\n                                                  ws_record->last_used),\n                               (long) req_time);\n\n                    format_byte_out(r, conn_bytes);\n                    ap_rputs(\"|\", r);\n                    format_byte_out(r, my_bytes);\n                    ap_rputs(\"|\", r);\n                    format_byte_out(r, bytes);\n                    ap_rputs(\")\\n\", r);\n                    ap_rprintf(r,\n                               \" <i>%s {%s}</i> <b>[%s]</b><br />\\n\\n\",\n                               ap_escape_html(r->pool,\n                                              ws_record->client),\n                               ap_escape_html(r->pool,\n                                              ap_escape_logitem(r->pool,\n                                                                ws_record->request)),\n                               ap_escape_html(r->pool,\n                                              ws_record->vhost));\n                }\n                else { \n                    if (ws_record->status == SERVER_DEAD)\n                        ap_rprintf(r,\n                                   \"<tr><td><b>%d-%d</b></td><td>-</td><td>%d/%lu/%lu\",\n                                   i, (int)worker_generation,\n                                   (int)conn_lres, my_lres, lres);\n                    else\n                        ap_rprintf(r,\n                                   \"<tr><td><b>%d-%d</b></td><td>%\"\n                                   APR_PID_T_FMT\n                                   \"</td><td>%d/%lu/%lu\",\n                                   i, (int)worker_generation,\n                                   worker_pid,\n                                   (int)conn_lres,\n                                   my_lres, lres);\n\n                    switch (ws_record->status) {\n                    case SERVER_READY:\n                        ap_rputs(\"</td><td>_\", r);\n                        break;\n                    case SERVER_STARTING:\n                        ap_rputs(\"</td><td><b>S</b>\", r);\n                        break;\n                    case SERVER_BUSY_READ:\n                        ap_rputs(\"</td><td><b>R</b>\", r);\n                        break;\n                    case SERVER_BUSY_WRITE:\n                        ap_rputs(\"</td><td><b>W</b>\", r);\n                        break;\n                    case SERVER_BUSY_KEEPALIVE:\n                        ap_rputs(\"</td><td><b>K</b>\", r);\n                        break;\n                    case SERVER_BUSY_LOG:\n                        ap_rputs(\"</td><td><b>L</b>\", r);\n                        break;\n                    case SERVER_BUSY_DNS:\n                        ap_rputs(\"</td><td><b>D</b>\", r);\n                        break;\n                    case SERVER_CLOSING:\n                        ap_rputs(\"</td><td><b>C</b>\", r);\n                        break;\n                    case SERVER_DEAD:\n                        ap_rputs(\"</td><td>.\", r);\n                        break;\n                    case SERVER_GRACEFUL:\n                        ap_rputs(\"</td><td>G\", r);\n                        break;\n                    case SERVER_IDLE_KILL:\n                        ap_rputs(\"</td><td>I\", r);\n                        break;\n                    default:\n                        ap_rputs(\"</td><td>?\", r);\n                        break;\n                    }\n\n                    ap_rprintf(r,\n                               \"\\n</td>\"\n#ifdef HAVE_TIMES\n                               \"<td>%.2f</td>\"\n#endif\n                               \"<td>%ld</td><td>%ld\",\n#ifdef HAVE_TIMES\n                               (ws_record->times.tms_utime +\n                                ws_record->times.tms_stime +\n                                ws_record->times.tms_cutime +\n                                ws_record->times.tms_cstime) / tick,\n#endif\n                               (long)apr_time_sec(nowtime -\n                                                  ws_record->last_used),\n                               (long)req_time);\n\n                    ap_rprintf(r, \"</td><td>%-1.1f</td><td>%-2.2f</td><td>%-2.2f\\n\",\n                               (float)conn_bytes / KBYTE, (float) my_bytes / MBYTE,\n                               (float)bytes / MBYTE);\n\n                    ap_rprintf(r, \"</td><td>%s</td><td nowrap>%s</td>\"\n                                  \"<td nowrap>%s</td></tr>\\n\\n\",\n                               ap_escape_html(r->pool,\n                                              ws_record->client),\n                               ap_escape_html(r->pool,\n                                              ws_record->vhost),\n                               ap_escape_html(r->pool,\n                                              ap_escape_logitem(r->pool,\n                                                      ws_record->request)));\n                } \n            } \n        } \n\n        if (!no_table_report) {\n            ap_rputs(\"</table>\\n \\\n<hr /> \\\n<table>\\n \\\n<tr><th>Srv</th><td>Child Server number - generation</td></tr>\\n \\\n<tr><th>PID</th><td>OS process ID</td></tr>\\n \\\n<tr><th>Acc</th><td>Number of accesses this connection / this child / this slot</td></tr>\\n \\\n<tr><th>M</th><td>Mode of operation</td></tr>\\n\"\n\n#ifdef HAVE_TIMES\n\"<tr><th>CPU</th><td>CPU usage, number of seconds</td></tr>\\n\"\n#endif\n\n\"<tr><th>SS</th><td>Seconds since beginning of most recent request</td></tr>\\n \\\n<tr><th>Req</th><td>Milliseconds required to process most recent request</td></tr>\\n \\\n<tr><th>Conn</th><td>Kilobytes transferred this connection</td></tr>\\n \\\n<tr><th>Child</th><td>Megabytes transferred this child</td></tr>\\n \\\n<tr><th>Slot</th><td>Total megabytes transferred this slot</td></tr>\\n \\\n</table>\\n\", r);\n        }\n    } \n    else {\n\n        if (!short_report) {\n            ap_rputs(\"<hr />To obtain a full report with current status \"\n                     \"information you need to use the \"\n                     \"<code>ExtendedStatus On</code> directive.\\n\", r);\n        }\n    }\n\n    {\n        \n        int flags =\n            (short_report ? AP_STATUS_SHORT : 0) |\n            (no_table_report ? AP_STATUS_NOTABLE : 0) |\n            (ap_extended_status ? AP_STATUS_EXTENDED : 0);\n\n        ap_run_status_hook(r, flags);\n    }\n\n    if (!short_report) {\n        ap_rputs(ap_psignature(\"<hr />\\n\",r), r);\n        ap_rputs(\"</body></html>\\n\", r);\n    }\n\n    return 0;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_9d4861f02cb1b8901c84edbd8a01a4179c639b92_0", {
    "ID": "httpd_9d4861f02cb1b8901c84edbd8a01a4179c639b92_0",
    "UID": "4017",
    "code": "static apr_status_t socache_dbm_store(ap_socache_instance_t test_snippet\n                                      server_rec *s, const unsigned char *id,\n                                      unsigned int idlen, apr_time_t expiry,\n                                      unsigned char *ucaData,\n                                      unsigned int nData, apr_pool_t *pool)\n{\n    apr_dbm_t *dbm;\n    apr_datum_t dbmkey;\n    apr_datum_t dbmval;\n    apr_status_t rv;\n\n    \n#ifdef PAIRMAX\n    if ((idlen + nData) >= PAIRMAX) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00805)\n                 \"data size too large for DBM socache: %d >= %d\",\n                 (idlen + nData), PAIRMAX);\n        return APR_ENOSPC;\n    }\n#else\n    if ((idlen + nData) >= 950 ) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00806)\n                 \"data size too large for DBM socache: %d >= %d\",\n                 (idlen + nData), 950);\n        return APR_ENOSPC;\n    }\n#endif\n\n    \n    dbmkey.dptr  = (char *)id;\n    dbmkey.dsize = idlen;\n\n    \n    dbmval.dsize = sizeof(apr_time_t) + nData;\n    dbmval.dptr  = (char *)ap_malloc(dbmval.dsize);\n    memcpy((char *)dbmval.dptr, &expiry, sizeof(apr_time_t));\n    memcpy((char *)dbmval.dptr+sizeof(apr_time_t), ucaData, nData);\n\n    \n    apr_pool_clear(ctx->pool);\n\n    if ((rv = apr_dbm_open(&dbm, ctx->data_file,\n                           APR_DBM_RWCREATE, DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00807)\n                     \"Cannot open socache DBM file `%s' for writing \"\n                     \"(store)\",\n                     ctx->data_file);\n        free(dbmval.dptr);\n        return rv;\n    }\n    if ((rv = apr_dbm_store(dbm, dbmkey, dbmval)) != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00808)\n                     \"Cannot store socache object to DBM file `%s'\",\n                     ctx->data_file);\n        apr_dbm_close(dbm);\n        free(dbmval.dptr);\n        return rv;\n    }\n    apr_dbm_close(dbm);\n\n    \n    free(dbmval.dptr);\n\n    \n    socache_dbm_expire(ctx, s);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2207e9f5f6f2c1e038855919f5a9ec5f81b22355_0", {
    "ID": "httpd_2207e9f5f6f2c1e038855919f5a9ec5f81b22355_0",
    "UID": "4030",
    "code": "static void socache_shmcb_status(ap_socache_instance_t test_snippet\n                                 request_rec *r, int flags)\n{\n    server_rec *s = r->server;\n    SHMCBHeader *header = ctx->header;\n    unsigned int loop, total = 0, cache_total = 0, non_empty_subcaches = 0;\n    apr_time_t idx_expiry, min_expiry = 0, max_expiry = 0;\n    apr_time_t now = apr_time_now();\n    double expiry_total = 0;\n    int index_pct, cache_pct;\n\n    AP_DEBUG_ASSERT(header->subcache_num > 0);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00840) \"inside shmcb_status\");\n    /* Perform the iteration inside the mutex to avoid corruption or invalid\n     * pointer arithmetic. The rest of our logic uses read-only header data so\n     * doesn't need the lock. */\n    \n    for (loop = 0; loop < header->subcache_num; loop++) {\n        SHMCBSubcache *subcache = SHMCB_SUBCACHE(header, loop);\n        shmcb_subcache_expire(s, header, subcache, now);\n        total += subcache->idx_used;\n        cache_total += subcache->data_used;\n        if (subcache->idx_used) {\n            SHMCBIndex *idx = SHMCB_INDEX(subcache, subcache->idx_pos);\n            non_empty_subcaches++;\n            idx_expiry = idx->expires;\n            expiry_total += (double)idx_expiry;\n            max_expiry = ((idx_expiry > max_expiry) ? idx_expiry : max_expiry);\n            if (!min_expiry)\n                min_expiry = idx_expiry;\n            else\n                min_expiry = ((idx_expiry < min_expiry) ? idx_expiry : min_expiry);\n        }\n    }\n    index_pct = (100 * total) / (header->index_num *\n                                 header->subcache_num);\n    cache_pct = (100 * cache_total) / (header->subcache_data_size *\n                                       header->subcache_num);\n    \n    if (!(flags & AP_STATUS_SHORT)) {\n        ap_rprintf(r, \"cache type: <b>SHMCB</b>, shared memory: <b>%\" APR_SIZE_T_FMT \"</b> \"\n                   \"bytes, current entries: <b>%d</b><br>\",\n                   ctx->shm_size, total);\n        ap_rprintf(r, \"subcaches: <b>%d</b>, indexes per subcache: <b>%d</b><br>\",\n                   header->subcache_num, header->index_num);\n        if (non_empty_subcaches) {\n            apr_time_t average_expiry = (apr_time_t)(expiry_total / (double)non_empty_subcaches);\n            ap_rprintf(r, \"time left on oldest entries' objects: \");\n            if (now < average_expiry)\n                ap_rprintf(r, \"avg: <b>%d</b> seconds, (range: %d...%d)<br>\",\n                           (int)apr_time_sec(average_expiry - now),\n                           (int)apr_time_sec(min_expiry - now),\n                           (int)apr_time_sec(max_expiry - now));\n            else\n                ap_rprintf(r, \"expiry_threshold: <b>Calculation error!</b><br>\");\n        }\n\n        ap_rprintf(r, \"index usage: <b>%d%%</b>, cache usage: <b>%d%%</b><br>\",\n                   index_pct, cache_pct);\n        ap_rprintf(r, \"total entries stored since starting: <b>%lu</b><br>\",\n                   header->stat_stores);\n        ap_rprintf(r, \"total entries replaced since starting: <b>%lu</b><br>\",\n                   header->stat_replaced);\n        ap_rprintf(r, \"total entries expired since starting: <b>%lu</b><br>\",\n                   header->stat_expiries);\n        ap_rprintf(r, \"total (pre-expiry) entries scrolled out of the cache: \"\n                   \"<b>%lu</b><br>\", header->stat_scrolled);\n        ap_rprintf(r, \"total retrieves since starting: <b>%lu</b> hit, \"\n                   \"<b>%lu</b> miss<br>\", header->stat_retrieves_hit,\n                   header->stat_retrieves_miss);\n        ap_rprintf(r, \"total removes since starting: <b>%lu</b> hit, \"\n                   \"<b>%lu</b> miss<br>\", header->stat_removes_hit,\n                   header->stat_removes_miss);\n    }\n    else {\n        ap_rputs(\"CacheType: SHMCB\\n\", r);\n        ap_rprintf(r, \"CacheSharedMemory: %\" APR_SIZE_T_FMT \"\\n\",\n                   ctx->shm_size);\n        ap_rprintf(r, \"CacheCurrentEntries: %d\\n\", total);\n        ap_rprintf(r, \"CacheSubcaches: %d\\n\", header->subcache_num);\n        ap_rprintf(r, \"CacheIndexesPerSubcaches: %d\\n\", header->index_num);\n        if (non_empty_subcaches) {\n            apr_time_t average_expiry = (apr_time_t)(expiry_total / (double)non_empty_subcaches);\n            if (now < average_expiry) {\n                ap_rprintf(r, \"CacheTimeLeftOldestAvg: %d\\n\", (int)apr_time_sec(average_expiry - now));\n                ap_rprintf(r, \"CacheTimeLeftOldestMin: %d\\n\", (int)apr_time_sec(min_expiry - now));\n                ap_rprintf(r, \"CacheTimeLeftOldestMax: %d\\n\", (int)apr_time_sec(max_expiry - now));\n            }\n        }\n\n        ap_rprintf(r, \"CacheIndexUsage: %d%%\\n\", index_pct);\n        ap_rprintf(r, \"CacheUsage: %d%%\\n\", cache_pct);\n        ap_rprintf(r, \"CacheStoreCount: %lu\\n\", header->stat_stores);\n        ap_rprintf(r, \"CacheReplaceCount: %lu\\n\", header->stat_replaced);\n        ap_rprintf(r, \"CacheExpireCount: %lu\\n\", header->stat_expiries);\n        ap_rprintf(r, \"CacheDiscardCount: %lu\\n\", header->stat_scrolled);\n        ap_rprintf(r, \"CacheRetrieveHitCount: %lu\\n\", header->stat_retrieves_hit);\n        ap_rprintf(r, \"CacheRetrieveMissCount: %lu\\n\", header->stat_retrieves_miss);\n        ap_rprintf(r, \"CacheRemoveHitCount: %lu\\n\", header->stat_removes_hit);\n        ap_rprintf(r, \"CacheRemoveMissCount: %lu\\n\", header->stat_removes_miss);\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00841) \"leaving shmcb_status\");\n}",
    "predicted": "This code does not appear to have any security vulnerabilities. It's a status function for a shared memory cache (SHMCB), and it doesn't seem to have any buffer overflows, integer overflows, or other common security issues. It doesn't take any user input, so there's no risk of injection attacks. It doesn't open any files or network connections, so there's no risk of path traversal or other file-related attacks. It doesn't use any cryptographic functions, so there's no risk of weak cryptography. It doesn't have any error conditions that it fails to check. It doesn't have any race conditions, as it doesn't use any multithreading or asynchronous operations. It doesn't have any resource leaks, as it doesn't allocate any resources that it fails to free. It doesn't have any uninitialized variables, as all variables are initialized before they're used. It doesn't have any null pointer dereferences, as it doesn't dereference any pointers that could be null. It doesn't have any use-after-free or double-free issues, as it doesn't free any memory. It doesn't have any insecure temporary files, as it doesn't create any files. It doesn't have any hard-coded passwords or cryptographic keys. It doesn't have any suspicious comments that might indicate a known issue that was ignored. It doesn't have any operations on a resource after expiration or release. It doesn't have any reliance on undefined behavior. It doesn't have any missing references to active file descriptors or handles. It doesn't have any assignments to variables without use. It doesn't have any unchecked return values. It doesn't have any improper neutralization of special elements used in an OS command or an LDAP query. It doesn't have any external control of system or configuration setting. It doesn't have any improper handling of Unicode encoding. It doesn't have any signed to unsigned conversion errors. It doesn't have any numeric truncation errors. It doesn't have any least privilege violations. It doesn't have any improper checks for dropped privileges. It doesn't have any use of cryptographically weak pseudo-random number generators. It doesn't have any signal handler race conditions. It doesn't have any race conditions within a thread. It doesn't have any divisions by zero. It doesn't have any detection of error conditions without action. It doesn't have any unchecked error conditions. It doesn't have any declarations of throws for generic exceptions. It doesn't have any uncontrolled resource consumption. It doesn't have any improper resource shutdown or release. It doesn't have any addition of data structure sentinels. It doesn't have any use of sizeof() on a pointer type. It doesn't have any signal handler use of a non-reentrant function. It doesn't have any use of incorrect operators. It doesn't have any logic/time bombs. It doesn't have any cleartext storage of sensitive information in an environment variable. It doesn't have any sensitive data storage in improperly locked memory. It doesn't have any unchecked input for loop condition. It doesn't have any reachable assertions. It doesn't have any improper initialization. It doesn't have any multiple operations on resource in single-operation context. It doesn't have any free of pointer not at start of buffer. It doesn't have any mismatched memory management routines. It doesn't have any missing release of file descriptor or handle after effective lifetime. It doesn't have any memory allocation with excessive size value. It doesn't have any unchecked return value to NULL pointer dereference. So, the response is null."
  },
  "httpd_4d6ca777cc044094b508e3aea2cba372a90076c2_0", {
    "ID": "httpd_4d6ca777cc044094b508e3aea2cba372a90076c2_0",
    "UID": "4042",
    "code": "static void ap_proxy_read_headers(request_rec *r, request_rec test_snippet\n                                  char *buffer, int size,\n                                  conn_rec *c, int *pread_len)\n{\n    int len;\n    char *value, *end;\n    char field[MAX_STRING_LEN];\n    int saw_headers = 0;\n    void *sconf = r->server->module_config;\n    proxy_server_conf *psc;\n    proxy_dir_conf *dconf;\n\n    dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n    psc = (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);\n\n    r->headers_out = apr_table_make(r->pool, 20);\n    r->trailers_out = apr_table_make(r->pool, 5);\n    *pread_len = 0;\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), or we timeout.\n     */\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"Headers received from backend:\");\n    while ((len = ap_getline(buffer, size, rr, 1)) > 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"%s\", buffer);\n\n        if (!(value = strchr(buffer, ':'))) {     \n\n            /* We may encounter invalid headers, usually from buggy\n             * MS IIS servers, so we need to determine just how to handle\n             * them. We can either ignore them, assume that they mark the\n             * start-of-body (eg: a missing CRLF) or (the default) mark\n             * the headers as totally bogus and return a 500. The sole\n             * exception is an extra \"HTTP/1.0 200, OK\" line sprinkled\n             * in between the usual MIME headers, which is a favorite\n             * IIS bug.\n             */\n             \n\n            if (!apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n                if (psc->badopt == bad_error) {\n                    \n                    r->headers_out = NULL;\n                    return;\n                }\n                else if (psc->badopt == bad_body) {\n                    /* if we've already started loading headers_out, then\n                     * return what we've accumulated so far, in the hopes\n                     * that they are useful; also note that we likely pre-read\n                     * the first line of the response.\n                     */\n                    if (saw_headers) {\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01098)\n                                      \"Starting body due to bogus non-header \"\n                                      \"in headers returned by %s (%s)\",\n                                      r->uri, r->method);\n                        *pread_len = len;\n                        return;\n                    } else {\n                         ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01099)\n                                       \"No HTTP headers returned by %s (%s)\",\n                                       r->uri, r->method);\n                        return;\n                    }\n                }\n            }\n            \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01100)\n                          \"Ignoring bogus HTTP header returned by %s (%s)\",\n                          r->uri, r->method);\n            continue;\n        }\n\n        *value = '\\0';\n        ++value;\n        /* XXX: RFC2068 defines only SP and HT as whitespace, this test is\n         * wrong... and so are many others probably.\n         */\n        while (apr_isspace(*value))\n            ++value;            \n\n        \n        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n            *end = '\\0';\n\n        /* make sure we add so as not to destroy duplicated headers\n         * Modify headers requiring canonicalisation and/or affected\n         * by ProxyPassReverse and family with process_proxy_header\n         */\n        process_proxy_header(r, dconf, buffer, value);\n        saw_headers = 1;\n\n        \n        if (len >= size - 1) {\n            while ((len = ap_getline(field, MAX_STRING_LEN, rr, 1))\n                    >= MAX_STRING_LEN - 1) {\n                \n            }\n            if (len == 0) \n                break;\n        }\n    }\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n20,Improper Input Validation\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_1218c2ad04910fdcf8ce576c1789dab3a8b34e8b_0", {
    "ID": "httpd_1218c2ad04910fdcf8ce576c1789dab3a8b34e8b_0",
    "UID": "4043",
    "code": "static int connect_to_daemon(int *sdptr, request_rec test_snippet\n                             cgid_server_conf *conf)\n{\n    int sd;\n    int connect_tries;\n    int connect_errno;\n    apr_interval_time_t sliding_timer;\n\n    connect_tries = 0;\n    sliding_timer = 100000; \n    while (1) {\n        connect_errno = 0;\n        ++connect_tries;\n        if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n            return log_scripterror(r, conf, HTTP_INTERNAL_SERVER_ERROR, errno,\n                                   APLOGNO(01255) \"unable to create socket to cgi daemon\");\n        }\n        if (connect(sd, (struct sockaddr *)server_addr, server_addr_len) < 0) {\n            \n            connect_errno = errno;\n            /* ECONNREFUSED means the listen queue is full; ENOENT means that\n             * the cgid server either hasn't started up yet, or we're pointing\n             * at the wrong socket file */\n            if ((errno == ECONNREFUSED || errno == ENOENT) && \n                 connect_tries < DEFAULT_CONNECT_ATTEMPTS) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, errno, r, APLOGNO(01256)\n                              \"connect #%d to cgi daemon failed, sleeping before retry\",\n                              connect_tries);\n                close(sd);\n                apr_sleep(sliding_timer);\n                if (sliding_timer < apr_time_from_sec(2)) {\n                    sliding_timer *= 2;\n                }\n            }\n            else {\n                close(sd);\n                return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno, APLOGNO(01257)\n                                       \"unable to connect to cgi daemon after multiple tries\");\n            }\n        }\n        else {\n            apr_pool_cleanup_register(r->pool, (void *)((long)sd),\n                                      close_unix_socket, apr_pool_cleanup_null);\n            break; \n        }\n\n        /* If we didn't find the socket but the server was not recently restarted,\n         * chances are there's something wrong with the cgid daemon\n         */\n        if (connect_errno == ENOENT &&\n            apr_time_sec(apr_time_now() - ap_scoreboard_image->global->restart_time) > \n                DEFAULT_CONNECT_STARTUP_DELAY) {\n            return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, connect_errno, \n                                   apr_pstrcat(r->pool, APLOGNO(02833) \"ScriptSock \", sockname, \" does not exist\", NULL));\n        }\n\n        \n        if (connect_errno != ENOENT && kill(daemon_pid, 0) != 0) {\n            return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, connect_errno, APLOGNO(01258)\n                                   \"cgid daemon is gone; is Apache terminating?\");\n        }\n    }\n    *sdptr = sd;\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_a67513ea69f6f6dabd1e1cfd070b2abe2c90c596_0", {
    "ID": "httpd_a67513ea69f6f6dabd1e1cfd070b2abe2c90c596_0",
    "UID": "4045",
    "code": "static apr_array_header_t *merge_balancers(apr_pool_t test_snippet\n                                           apr_array_header_t *base,\n                                           apr_array_header_t *overrides)\n{\n    proxy_balancer *b1;\n    proxy_balancer *b2;\n    proxy_balancer tmp;\n    int x, y, found;\n    apr_array_header_t *tocopy = apr_array_make(p, 1, sizeof(proxy_balancer));\n\n    /* Check if the balancer is defined in both override and base configs:\n     * a) If it is, Create copy of base balancer and change the configuration\n     *    which can be changed by ProxyPass.\n     * b) Otherwise, copy the balancer to tocopy array and merge it later.\n     */\n    b1 = (proxy_balancer *) base->elts;\n    for (y = 0; y < base->nelts; y++) {\n        b2 = (proxy_balancer *) overrides->elts;\n        for (x = 0, found = 0; x < overrides->nelts; x++) {\n            if (b1->hash.def == b2->hash.def && b1->hash.fnv == b2->hash.fnv) {\n                tmp = *b2;\n                *b2 = *b1;\n                b2->s = tmp.s;\n\n                /* For shared memory entries, b2->s belongs to override\n                 * balancer, so if some entry is not set there, we have to\n                 * update it according to the base balancer. */\n                if (*b2->s->sticky == 0 && *b1->s->sticky) {\n                    PROXY_STRNCPY(b2->s->sticky_path, b1->s->sticky_path);\n                    PROXY_STRNCPY(b2->s->sticky, b1->s->sticky);\n                }\n                if (!b2->s->sticky_separator_set\n                    && b1->s->sticky_separator_set) {\n                    b2->s->sticky_separator_set = b1->s->sticky_separator_set;\n                    b2->s->sticky_separator = b1->s->sticky_separator;\n                }\n                if (!b2->s->timeout && b1->s->timeout) {\n                    b2->s->timeout = b1->s->timeout;\n                }\n                if (!b2->s->max_attempts_set && b1->s->max_attempts_set) {\n                    b2->s->max_attempts_set = b1->s->max_attempts_set;\n                    b2->s->max_attempts = b1->s->max_attempts;\n                }\n                if (!b2->s->nonce_set && b1->s->nonce_set) {\n                    b2->s->nonce_set = b1->s->nonce_set;\n                    PROXY_STRNCPY(b2->s->nonce, b1->s->nonce);\n                }\n                if (!b2->s->sticky_force_set && b1->s->sticky_force_set) {\n                    b2->s->sticky_force_set = b1->s->sticky_force_set;\n                    b2->s->sticky_force = b1->s->sticky_force;\n                }\n                if (!b2->s->scolonsep_set && b1->s->scolonsep_set) {\n                    b2->s->scolonsep_set = b1->s->scolonsep_set;\n                    b2->s->scolonsep = b1->s->scolonsep;\n                }\n                if (!b2->s->forcerecovery_set && b1->s->forcerecovery_set) {\n                    b2->s->forcerecovery_set = b1->s->forcerecovery_set;\n                    b2->s->forcerecovery = b1->s->forcerecovery;\n                }\n\n                /* For non-shared memory entries, b2 is copy of b1, so we have\n                 * to use tmp copy of b1 to detect changes done in override. */\n                if (tmp.lbmethod_set) {\n                    b2->lbmethod_set = tmp.lbmethod_set;\n                    b2->lbmethod = tmp.lbmethod;\n                }\n                if (tmp.growth_set) {\n                    b2->growth_set = tmp.growth_set;\n                    b2->growth = tmp.growth;\n                }\n                if (tmp.failontimeout_set) {\n                    b2->failontimeout_set = tmp.failontimeout_set;\n                    b2->failontimeout = tmp.failontimeout;\n                }\n                if (!apr_is_empty_array(tmp.errstatuses)) {\n                    apr_array_cat(tmp.errstatuses, b2->errstatuses);\n                    b2->errstatuses = tmp.errstatuses;\n                }\n\n                found = 1;\n                break;\n            }\n            b2++;\n        }\n        if (!found) {\n            *(proxy_balancer *)apr_array_push(tocopy) = *b1;\n        }\n        b1++;\n    }\n\n    return apr_array_append(p, tocopy, overrides);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8513668706e59a1e80acd2789ce961fc3f7bf006_0", {
    "ID": "httpd_8513668706e59a1e80acd2789ce961fc3f7bf006_0",
    "UID": "4055",
    "code": "static int proxy_status_hook(request_rec *r, int test_snippet\n{\n    int i, n;\n    void *sconf = r->server->module_config;\n    proxy_server_conf *conf = (proxy_server_conf *)\n        ap_get_module_config(sconf, &proxy_module);\n    proxy_balancer *balancer = NULL;\n    proxy_worker **worker = NULL;\n\n    if (conf->balancers->nelts == 0 ||\n        conf->proxy_status == status_off)\n        return OK;\n\n    balancer = (proxy_balancer *)conf->balancers->elts;\n    for (i = 0; i < conf->balancers->nelts; i++) {\n        if (!(flags & AP_STATUS_SHORT)) {\n            ap_rputs(\"<hr />\\n<h1>Proxy LoadBalancer Status for \", r);\n            ap_rvputs(r, balancer->s->name, \"</h1>\\n\\n\", NULL);\n            ap_rputs(\"\\n\\n<table border=\\\"0\\\"><tr>\"\n                     \"<th>SSes</th><th>Timeout</th><th>Method</th>\"\n                     \"</tr>\\n<tr>\", r);\n            if (*balancer->s->sticky) {\n                if (strcmp(balancer->s->sticky, balancer->s->sticky_path)) {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, \" | \",\n                              balancer->s->sticky_path, NULL);\n                }\n                else {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, NULL);\n                }\n            }\n            else {\n                ap_rputs(\"<td> - \", r);\n            }\n            ap_rprintf(r, \"</td><td>%\" APR_TIME_T_FMT \"</td>\",\n                       apr_time_sec(balancer->s->timeout));\n            ap_rprintf(r, \"<td>%s</td>\\n\",\n                       balancer->lbmethod->name);\n            ap_rputs(\"</table>\\n\", r);\n            ap_rputs(\"\\n\\n<table border=\\\"0\\\"><tr>\"\n                     \"<th>Sch</th><th>Host</th><th>Stat</th>\"\n                     \"<th>Route</th><th>Redir</th>\"\n                     \"<th>F</th><th>Set</th><th>Acc</th><th>Wr</th><th>Rd</th>\"\n                     \"</tr>\\n\", r);\n        }\n        else {\n            ap_rprintf(r, \"ProxyBalancer[%d]Name: %s\\n\", i, balancer->s->name);\n        }\n\n        worker = (proxy_worker **)balancer->workers->elts;\n        for (n = 0; n < balancer->workers->nelts; n++) {\n            char fbuf[50];\n            if (!(flags & AP_STATUS_SHORT)) {\n                ap_rvputs(r, \"<tr>\\n<td>\", (*worker)->s->scheme, \"</td>\", NULL);\n                ap_rvputs(r, \"<td>\", (*worker)->s->hostname, \"</td><td>\", NULL);\n                ap_rvputs(r, ap_proxy_parse_wstatus(r->pool, *worker), NULL);\n                ap_rvputs(r, \"</td><td>\", (*worker)->s->route, NULL);\n                ap_rvputs(r, \"</td><td>\", (*worker)->s->redirect, NULL);\n                ap_rprintf(r, \"</td><td>%d</td>\", (*worker)->s->lbfactor);\n                ap_rprintf(r, \"<td>%d</td>\", (*worker)->s->lbset);\n                ap_rprintf(r, \"<td>%\" APR_SIZE_T_FMT \"</td><td>\",\n                           (*worker)->s->elected);\n                ap_rputs(apr_strfsize((*worker)->s->transferred, fbuf), r);\n                ap_rputs(\"</td><td>\", r);\n                ap_rputs(apr_strfsize((*worker)->s->read, fbuf), r);\n                ap_rputs(\"</td>\\n\", r);\n\n                \n                ap_rputs(\"</tr>\\n\", r);\n            }\n            else {\n                ap_rprintf(r, \"ProxyBalancer[%d]Worker[%d]Name: %s\\n\",\n                           i, n, (*worker)->s->name);\n                ap_rprintf(r, \"ProxyBalancer[%d]Worker[%d]Status: %s\\n\",\n                           i, n, ap_proxy_parse_wstatus(r->pool, *worker));\n                ap_rprintf(r, \"ProxyBalancer[%d]Worker[%d]Elected: %\"\n                              APR_SIZE_T_FMT \"\\n\",\n                           i, n, (*worker)->s->elected);\n                ap_rprintf(r, \"ProxyBalancer[%d]Worker[%d]Sent: %s\\n\",\n                           i, n, apr_strfsize((*worker)->s->transferred, fbuf));\n                ap_rprintf(r, \"ProxyBalancer[%d]Worker[%d]Rcvd: %s\\n\",\n                           i, n, apr_strfsize((*worker)->s->read, fbuf));\n                \n            }\n\n            ++worker;\n        }\n        if (!(flags & AP_STATUS_SHORT)) {\n            ap_rputs(\"</table>\\n\", r);\n        }\n        ++balancer;\n    }\n    if (!(flags & AP_STATUS_SHORT)) {\n        ap_rputs(\"<hr /><table>\\n\"\n                 \"<tr><th>SSes</th><td>Sticky session name</td></tr>\\n\"\n                 \"<tr><th>Timeout</th><td>Balancer Timeout</td></tr>\\n\"\n                 \"<tr><th>Sch</th><td>Connection scheme</td></tr>\\n\"\n                 \"<tr><th>Host</th><td>Backend Hostname</td></tr>\\n\"\n                 \"<tr><th>Stat</th><td>Worker status</td></tr>\\n\"\n                 \"<tr><th>Route</th><td>Session Route</td></tr>\\n\"\n                 \"<tr><th>Redir</th><td>Session Route Redirection</td></tr>\\n\"\n                 \"<tr><th>F</th><td>Load Balancer Factor</td></tr>\\n\"\n                 \"<tr><th>Acc</th><td>Number of uses</td></tr>\\n\"\n                 \"<tr><th>Wr</th><td>Number of bytes transferred</td></tr>\\n\"\n                 \"<tr><th>Rd</th><td>Number of bytes read</td></tr>\\n\"\n                 \"</table>\", r);\n    }\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_cb81780fa9eec0080f87d022aa9ad40c0b240ac8_0", {
    "ID": "httpd_cb81780fa9eec0080f87d022aa9ad40c0b240ac8_0",
    "UID": "4064",
    "code": "static test_snippet\nrate_limit_filter(ap_filter_t *f, apr_bucket_brigade *input_bb)\n{\n    test_snippet rv = APR_SUCCESS;\n    rl_ctx_t *ctx = f->ctx;\n    apr_bucket *fb;\n    int do_sleep = 0;\n    apr_bucket_alloc_t *ba = f->r->connection->bucket_alloc;\n    apr_bucket_brigade *bb = input_bb;\n\n    if (f->c->aborted) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01454) \"rl: conn aborted\");\n        apr_brigade_cleanup(bb);\n        return APR_ECONNABORTED;\n    }\n\n    if (ctx == NULL) {\n\n        const char *rl = NULL;\n        int ratelimit;\n\n        \n        if (f->r->main != NULL) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        rl = apr_table_get(f->r->subprocess_env, \"rate-limit\");\n\n        if (rl == NULL) {\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n        \n        \n        ratelimit = atoi(rl) * 1024;\n        if (ratelimit <= 0) {\n            \n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        \n        ctx = apr_palloc(f->r->pool, sizeof(rl_ctx_t));\n        f->ctx = ctx;\n        ctx->state = RATE_LIMIT;\n        ctx->speed = ratelimit;\n\n        \n        \n        ctx->chunk_size = (ctx->speed / (1000 / RATE_INTERVAL_MS));\n        ctx->tmpbb = apr_brigade_create(f->r->pool, ba);\n        ctx->holdingbb = apr_brigade_create(f->r->pool, ba);\n    }\n\n    while (ctx->state != RATE_ERROR &&\n           (!APR_BRIGADE_EMPTY(bb) || !APR_BRIGADE_EMPTY(ctx->holdingbb))) {\n        apr_bucket *e;\n\n        if (!APR_BRIGADE_EMPTY(ctx->holdingbb)) {\n            APR_BRIGADE_CONCAT(bb, ctx->holdingbb);\n            apr_brigade_cleanup(ctx->holdingbb);\n        }\n\n        while (ctx->state == RATE_FULLSPEED && !APR_BRIGADE_EMPTY(bb)) {\n            \n            for (e = APR_BRIGADE_FIRST(bb);\n                 e != APR_BRIGADE_SENTINEL(bb); e = APR_BUCKET_NEXT(e)) {\n                if (AP_RL_BUCKET_IS_END(e)) {\n                    apr_bucket *f;\n                    f = APR_RING_LAST(&bb->list);\n                    APR_RING_UNSPLICE(e, f, link);\n                    APR_RING_SPLICE_TAIL(&ctx->holdingbb->list, e, f,\n                                         apr_bucket, link);\n                    ctx->state = RATE_LIMIT;\n                    break;\n                }\n            }\n\n            if (f->c->aborted) {\n                apr_brigade_cleanup(bb);\n                ctx->state = RATE_ERROR;\n                break;\n            }\n\n            fb = apr_bucket_flush_create(ba);\n            APR_BRIGADE_INSERT_TAIL(bb, fb);\n            rv = ap_pass_brigade(f->next, bb);\n\n            if (rv != APR_SUCCESS) {\n                ctx->state = RATE_ERROR;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01455)\n                              \"rl: full speed brigade pass failed.\");\n            }\n        }\n\n        while (ctx->state == RATE_LIMIT && !APR_BRIGADE_EMPTY(bb)) {\n            for (e = APR_BRIGADE_FIRST(bb);\n                 e != APR_BRIGADE_SENTINEL(bb); e = APR_BUCKET_NEXT(e)) {\n                if (AP_RL_BUCKET_IS_START(e)) {\n                    apr_bucket *f;\n                    f = APR_RING_LAST(&bb->list);\n                    APR_RING_UNSPLICE(e, f, link);\n                    APR_RING_SPLICE_TAIL(&ctx->holdingbb->list, e, f,\n                                         apr_bucket, link);\n                    ctx->state = RATE_FULLSPEED;\n                    break;\n                }\n            }\n\n            while (!APR_BRIGADE_EMPTY(bb)) {\n                apr_bucket *stop_point;\n                apr_off_t len = 0;\n\n                if (f->c->aborted) {\n                    apr_brigade_cleanup(bb);\n                    ctx->state = RATE_ERROR;\n                    break;\n                }\n\n                if (do_sleep) {\n                    apr_sleep(RATE_INTERVAL_MS * 1000);\n                }\n                else {\n                    do_sleep = 1;\n                }\n\n                apr_brigade_length(bb, 1, &len);\n\n                rv = apr_brigade_partition(bb, ctx->chunk_size, &stop_point);\n                if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {\n                    ctx->state = RATE_ERROR;\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01456)\n                                  \"rl: partition failed.\");\n                    break;\n                }\n\n                if (stop_point != APR_BRIGADE_SENTINEL(bb)) {\n                    apr_bucket *f;\n                    apr_bucket *e = APR_BUCKET_PREV(stop_point);\n                    f = APR_RING_FIRST(&bb->list);\n                    APR_RING_UNSPLICE(f, e, link);\n                    APR_RING_SPLICE_HEAD(&ctx->tmpbb->list, f, e, apr_bucket,\n                                         link);\n                }\n                else {\n                    APR_BRIGADE_CONCAT(ctx->tmpbb, bb);\n                }\n\n                fb = apr_bucket_flush_create(ba);\n\n                APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, fb);\n\n#if 0\n                brigade_dump(f->r, ctx->tmpbb);\n                brigade_dump(f->r, bb);\n#endif\n\n                rv = ap_pass_brigade(f->next, ctx->tmpbb);\n                apr_brigade_cleanup(ctx->tmpbb);\n\n                if (rv != APR_SUCCESS) {\n                    ctx->state = RATE_ERROR;\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01457)\n                                  \"rl: brigade pass failed.\");\n                    break;\n                }\n            }\n        }\n    }\n\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_c7cbecefd534cc24076e629b343938d56d3f9f50_0", {
    "ID": "httpd_c7cbecefd534cc24076e629b343938d56d3f9f50_0",
    "UID": "4065",
    "code": "static apr_array_header_t *get_arguments(apr_pool_t * pool, const char test_snippet\n{\n    apr_array_header_t *args = apr_array_make(pool, 1, sizeof(char *));\n\n    trim(line);\n    while (test_snippet {\n        char *arg = ap_getword_conf(pool, &line);\n        char **new = apr_array_push(args);\n        *new = arg;\n        trim(line);\n    }\n\n    return args;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_718f9cc87d7628ff298dc806a88f315789df0813_0", {
    "ID": "httpd_718f9cc87d7628ff298dc806a88f315789df0813_0",
    "UID": "4068",
    "code": "static int cfg_trim_line(char test_snippet\n{\n    char *start, *end;\n    /*\n     * Leading and trailing white space is eliminated completely\n     */\n    start = buf;\n    while (apr_isspace(*start))\n        ++start;\n    \n    end = &start[strlen(start)];\n    while (--end >= start && apr_isspace(*end))\n        *end = '\\0';\n    \n    if (start != buf)\n        memmove(buf, start, end - start + 2);\n#ifdef DEBUG_CFG_LINES\n    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL, APLOGNO(00555) \"Read config: '%s'\", buf);\n#endif\n    return end - start + 1;\n}",
    "predicted": "476,NULL Pointer Dereference\n457,Use of Uninitialized Variable"
  },
  "httpd_074307950be4686803127af10377a3acc45d2ed0_0", {
    "ID": "httpd_074307950be4686803127af10377a3acc45d2ed0_0",
    "UID": "4078",
    "code": "static int number_of_escapes(const char delim, const char test_snippet\n{\n    int nesc = 0;\n    const char *s = str;\n    while (*s) {\n        if (*s == ESCAPE || *s == delim)\n            nesc++;\n        s++;\n    }\n    debug(fprintf(stderr, \"escapes: %d ---%s---\\n\", nesc, str));\n    return nesc;\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference"
  },
  "httpd_e9bb00a3ec75dbb1deb41dd980dc482350673e0a_0", {
    "ID": "httpd_e9bb00a3ec75dbb1deb41dd980dc482350673e0a_0",
    "UID": "4088",
    "code": "static const char *process_content(apr_pool_t * test_snippet\n                                   const ap_macro_t * macro,\n                                   const apr_array_header_t * replacements,\n                                   apr_array_header_t * used,\n                                   apr_array_header_t ** result)\n{\n    apr_array_header_t *contents = macro->contents;\n    char line[MAX_STRING_LEN];\n    int i;\n\n    if (result) {\n        *result = apr_array_make(test_snippet 1, sizeof(char *));\n    }\n\n    \n    for (i = 0; i < contents->nelts; i++) {\n        const char *errmsg;\n        \n        strncpy(line, ((char **) contents->elts)[i], MAX_STRING_LEN - 1);\n        errmsg = substitute_macro_args(line, MAX_STRING_LEN,\n                                       macro, replacements, used);\n        if (errmsg) {\n            return apr_psprintf(test_snippet\n                               \"while processing line %d of macro '%s' (%s) %s\",\n                                i + 1, macro->name, macro->location, errmsg);\n        }\n        \n        if (result) {\n            char **new = apr_array_push(*result);\n            *new = apr_pstrdup(test_snippet line);\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5ac0fd6e739a57231fc28e932906693e600c1079_0", {
    "ID": "httpd_5ac0fd6e739a57231fc28e932906693e600c1079_0",
    "UID": "4093",
    "code": "static apr_status_t array_getch(char *ch, void test_snippet\n{\n    array_contents_t *ml = (array_contents_t *) param;\n    char **tab = (char **) ml->contents->elts;\n\n    while (ml->char_index >= ml->length) {\n        if (ml->index >= ml->contents->nelts) {\n            \n            if (ml->next && ml->next->getch && next_one(ml)) {\n                apr_status_t rc = ml->next->getch(ch, ml->next->param);\n                if (*ch==LF)\n                    ml->next->line_number++;\n                return rc;\n            }\n            return APR_EOF;\n        }\n        ml->index++;\n        ml->char_index = 0;\n        ml->length = ml->index >= ml->contents->nelts ?\n            0 : strlen(tab[ml->index]);\n    }\n\n    *ch = tab[ml->index][ml->char_index++];\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free\n416,Use After Free\n401,Missing Release of Memory after Effective Lifetime\n122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_4300160bb38dbb7a3b0582da3668693c01a16ace_0", {
    "ID": "httpd_4300160bb38dbb7a3b0582da3668693c01a16ace_0",
    "UID": "4094",
    "code": "static apr_status_t array_getstr(void *buf, size_t bufsize, void test_snippet\n{\n    array_contents_t *ml = (array_contents_t *) param;\n    char *buffer = (char *) buf;\n    char next = '\\0';\n    size_t i = 0;\n    apr_status_t rc = APR_SUCCESS;\n\n    \n    while (i < bufsize - 1 && next != LF &&\n           ((rc = array_getch(&next, param)) == APR_SUCCESS)) {\n        buffer[i++] = next;\n    }\n\n    if (rc == APR_EOF) {\n        \n        if (next_one(ml)) {\n            ap_assert(ml->next->getstr);\n            /* keep next line count in sync! the caller will update\n               the current line_number, we need to forward to the next */\n            ml->next->line_number++;\n            return ml->next->getstr(buf, bufsize, ml->next->param);\n        }\n        \n        return APR_EOF;\n    }\n\n    buffer[i] = '\\0';\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e06ab8c0f15d57b51d9f71698e0f567dda05e891_0", {
    "ID": "httpd_e06ab8c0f15d57b51d9f71698e0f567dda05e891_0",
    "UID": "4095",
    "code": "apr_status_t ajp_msg_end(ajp_msg_t test_snippet\n{\n    apr_size_t len = msg->len - AJP_HEADER_LEN;\n\n    if (msg->server_side) {\n        msg->buf[0] = 0x41;\n        msg->buf[1] = 0x42;\n    }\n    else {\n        msg->buf[0] = 0x12;\n        msg->buf[1] = 0x34;\n    }\n\n    msg->buf[2] = (apr_byte_t)((len >> 8) & 0xFF);\n    msg->buf[3] = (apr_byte_t)(len & 0xFF);\n\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free\n416,Use After Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_dc684a5dabb601d602e66ed58645e69374785dd8_0", {
    "ID": "httpd_dc684a5dabb601d602e66ed58645e69374785dd8_0",
    "UID": "4096",
    "code": "static const char *macro_section(cmd_parms * test_snippet\n                                 void *dummy, const char *arg)\n{\n    apr_pool_t *pool;\n    char *endp, *name, *where;\n    const char *errmsg;\n    ap_macro_t *macro;\n\n    debug(fprintf(stderr, \"macro_section: arg='%s'\\n\", arg));\n\n    \n    if (ap_macros == NULL)\n        ap_macros = apr_hash_make(cmd->temp_pool);\n    ap_assert(ap_macros != NULL);\n\n    pool = apr_hash_pool_get(ap_macros);\n\n    endp = (char *) ap_strrchr_c(arg, '>');\n\n    if (endp == NULL) {\n        return BEGIN_MACRO \"> directive missing closing '>'\";\n    }\n\n    if (endp == arg) {\n        return BEGIN_MACRO \" macro definition: empty name\";\n    }\n\n    warn_if_non_blank(\"non blank chars found after \" BEGIN_MACRO \" closing '>'\",\n                      endp+1, cmd->config_file);\n\n    \n    *endp = '\\0';\n\n    \n    name = ap_getword_conf(pool, &arg);\n    if (empty_string_p(name)) {\n        return BEGIN_MACRO \" macro definition: name not found\";\n    }\n\n    ap_str_tolower(name);\n    macro = apr_hash_get(ap_macros, name, APR_HASH_KEY_STRING);\n\n    if (macro != NULL) {\n        \n        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_WARNING, 0, NULL,\n                     \"macro '%s' multiply defined: \"\n                     \"%s, redefined on line %d of \\\"%s\\\"\",\n                     macro->name, macro->location,\n                     cmd->config_file->line_number, cmd->config_file->name);\n    }\n    else {\n        \n        macro = (ap_macro_t *) apr_palloc(pool, sizeof(ap_macro_t));\n        macro->name = name;\n    }\n\n    debug(fprintf(stderr, \"macro_section: name=%s\\n\", name));\n\n    \n    macro->location = apr_psprintf(pool,\n                                   \"defined on line %d of \\\"%s\\\"\",\n                                   cmd->config_file->line_number,\n                                   cmd->config_file->name);\n    debug(fprintf(stderr, \"macro_section: location=%s\\n\", macro->location));\n\n    where =\n        apr_psprintf(pool, \"macro '%s' (%s)\", macro->name, macro->location);\n\n    if (looks_like_an_argument(name)) {\n        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_WARNING, 0, NULL,\n                     \"%s better prefix a macro name with any of '%s'\",\n                     where, ARG_PREFIX);\n    }\n\n    \n    macro->arguments = get_arguments(pool, arg);\n\n    errmsg = check_macro_arguments(cmd->temp_pool, macro);\n\n    if (errmsg) {\n        return errmsg;\n    }\n\n    errmsg = get_lines_till_end_token(pool, cmd->config_file,\n                                      END_MACRO, BEGIN_MACRO,\n                                      where, &macro->contents);\n\n    if (errmsg) {\n        return apr_psprintf(cmd->temp_pool,\n                            \"%s\" APR_EOL_STR \"\\tcontents error: %s\",\n                            where, errmsg);\n    }\n\n    errmsg = check_macro_contents(cmd->temp_pool, macro);\n\n    if (errmsg) {\n        return apr_psprintf(cmd->temp_pool,\n                            \"%s\" APR_EOL_STR \"\\tcontents checking error: %s\",\n                            where, errmsg);\n    }\n\n    \n    apr_hash_set(ap_macros, name, APR_HASH_KEY_STRING, macro);\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_a051b5152b352afc0b0b6ce456105b5b82380689_0", {
    "ID": "httpd_a051b5152b352afc0b0b6ce456105b5b82380689_0",
    "UID": "4099",
    "code": "static const char *use_macro(cmd_parms * cmd, void *dummy, const char test_snippet\n{\n    char *name, *recursion, *where;\n    const char *errmsg;\n    ap_macro_t *macro;\n    apr_array_header_t *replacements;\n    apr_array_header_t *contents;\n\n    debug(fprintf(stderr, \"use_macro -%s-\\n\", arg));\n\n    \n    if (ap_macros == NULL) {\n        return \"no macro defined before \" USE_MACRO;\n    }\n\n    \n    name = ap_getword_conf(cmd->temp_pool, &arg);\n    ap_str_tolower(name);\n\n    if (empty_string_p(name)) {\n        return \"no macro name specified with \" USE_MACRO;\n    }\n\n    \n    macro = apr_hash_get(ap_macros, name, APR_HASH_KEY_STRING);\n\n    if (!macro) {\n        return apr_psprintf(cmd->temp_pool, \"macro '%s' undefined\", name);\n    }\n\n    /* recursion is detected here by looking at the config file name,\n     * which may already contains \"macro 'foo'\". Ok, it looks like a hack,\n     * but otherwise it is uneasy to keep this data available somewhere...\n     * the name has just the needed visibility and liveness.\n     */\n    recursion =\n        apr_pstrcat(cmd->temp_pool, \"macro '\", macro->name, \"'\", NULL);\n\n    if (ap_strstr((char *) cmd->config_file->name, recursion)) {\n        return apr_psprintf(cmd->temp_pool,\n                            \"recursive use of macro '%s' is invalid\",\n                            macro->name);\n    }\n\n    \n    replacements = get_arguments(cmd->temp_pool, arg);\n\n    if (macro->arguments->nelts != replacements->nelts) {\n        return apr_psprintf(cmd->temp_pool,\n                            \"macro '%s' (%s) used \"\n                            \"with %d arguments instead of %d\",\n                            macro->name, macro->location,\n                            replacements->nelts, macro->arguments->nelts);\n    }\n\n    where = apr_psprintf(cmd->temp_pool,\n                         \"macro '%s' (%s) used on line %d of \\\"%s\\\"\",\n                         macro->name, macro->location,\n                         cmd->config_file->line_number,\n                         cmd->config_file->name);\n\n    check_macro_use_arguments(where, replacements);\n\n    errmsg = process_content(cmd->temp_pool, macro, replacements,\n                             NULL, &contents);\n\n    if (errmsg) {\n        return apr_psprintf(cmd->temp_pool,\n                            \"%s error while substituting: %s\",\n                            where, errmsg);\n    }\n\n    /* the current \"config file\" is replaced by a string array...\n       at the end of processing the array, the initial config file\n       will be returned there (see next_one) so as to go on. */\n    cmd->config_file = make_array_config(cmd->temp_pool, contents, where,\n                                         cmd->config_file, &cmd->config_file);\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_be1564a747b28a4e65a05ff0d921a4480abf2996_0", {
    "ID": "httpd_be1564a747b28a4e65a05ff0d921a4480abf2996_0",
    "UID": "4116",
    "code": "static apr_status_t send_environment(proxy_conn_rec *conn, request_rec test_snippet\n                                     apr_pool_t *temp_pool,\n                                     apr_uint16_t request_id)\n{\n    const apr_array_header_t *envarr;\n    const apr_table_entry_t *elts;\n    struct iovec vec[2];\n    ap_fcgi_header header;\n    unsigned char farray[AP_FCGI_HEADER_LEN];\n    char *body;\n    apr_status_t rv;\n    apr_size_t avail_len, len, required_len;\n    int next_elem, starting_elem;\n\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    \n\n    /* XXX mod_cgi/mod_cgid use ap_create_environment here, which fills in\n     *     the TZ value specially.  We could use that, but it would mean\n     *     parsing the key/value pairs back OUT of the allocated env array,\n     *     not to mention allocating a totally useless array in the first\n     *     place, which would suck. */\n\n    envarr = apr_table_elts(r->subprocess_env);\n    elts = (const apr_table_entry_t *) envarr->elts;\n\n#ifdef FCGI_DUMP_ENV_VARS\n    {\n        int i;\n        \n        for (i = 0; i < envarr->nelts; ++i) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01062)\n                          \"sending env var '%s' value '%s'\",\n                          elts[i].key, elts[i].val);\n        }\n    }\n#endif\n\n    \n    next_elem = 0; \n\n    avail_len = 16 * 1024; /* our limit per record, which could have been up\n                            * to AP_FCGI_MAX_CONTENT_LEN\n                            */\n\n    while (next_elem < envarr->nelts) {\n        starting_elem = next_elem;\n        required_len = ap_fcgi_encoded_env_len(r->subprocess_env,\n                                               avail_len,\n                                               &next_elem);\n\n        if (!required_len) {\n            if (next_elem < envarr->nelts) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                              APLOGNO(02536) \"couldn't encode envvar '%s' in %\"\n                              APR_SIZE_T_FMT \" bytes\",\n                              elts[next_elem].key, avail_len);\n                \n                ++next_elem;\n                continue;\n            }\n            \n            break;\n        }\n\n        body = apr_palloc(temp_pool, required_len);\n        rv = ap_fcgi_encode_env(r, r->subprocess_env, body, required_len,\n                                &starting_elem);\n        \n        ap_assert(rv == APR_SUCCESS);\n        \n        ap_assert(starting_elem == next_elem);\n\n        ap_fcgi_fill_in_header(&header, AP_FCGI_PARAMS, request_id,\n                               (apr_uint16_t)required_len, 0);\n        ap_fcgi_header_to_array(&header, farray);\n\n        vec[0].iov_base = (void *)farray;\n        vec[0].iov_len = sizeof(farray);\n        vec[1].iov_base = body;\n        vec[1].iov_len = required_len;\n\n        rv = send_data(conn, vec, 2, &len, 1);\n        apr_pool_clear(temp_pool);\n\n        if (rv) {\n            return rv;\n        }\n    }\n\n    \n    ap_fcgi_fill_in_header(&header, AP_FCGI_PARAMS, request_id, 0, 0);\n    ap_fcgi_header_to_array(&header, farray);\n\n    vec[0].iov_base = (void *)farray;\n    vec[0].iov_len = sizeof(farray);\n\n    return send_data(conn, vec, 1, &len, 1);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_f88a5f260ca8fdcc657433fd8c79b7810bc3c461_0", {
    "ID": "httpd_f88a5f260ca8fdcc657433fd8c79b7810bc3c461_0",
    "UID": "4117",
    "code": "static apr_status_t send_data(proxy_conn_rec test_snippet\n                              struct iovec *vec,\n                              int nvec,\n                              apr_size_t *len,\n                              int blocking)\n{\n    apr_status_t rv = APR_SUCCESS, arv;\n    apr_size_t written = 0, to_write = 0;\n    int i, offset;\n    apr_interval_time_t old_timeout;\n    apr_socket_t *s = conn->sock;\n\n    if (!blocking) {\n        arv = apr_socket_timeout_get(s, &old_timeout);\n        if (arv != APR_SUCCESS) {\n            return arv;\n        }\n        arv = apr_socket_timeout_set(s, 0);\n        if (arv != APR_SUCCESS) {\n            return arv;\n        }\n    }\n\n    for (i = 0; i < nvec; i++) {\n        to_write += vec[i].iov_len;\n    }\n\n    offset = 0;\n    while (to_write) {\n        apr_size_t n = 0;\n        rv = apr_socket_sendv(s, vec + offset, nvec - offset, &n);\n        if ((rv != APR_SUCCESS) && !APR_STATUS_IS_EAGAIN(rv)) {\n            break;\n        }\n        if (n > 0) {\n            written += n;\n            if (written >= to_write)\n                break;                 \n            for (i = offset; i < nvec; ) {\n                if (n >= vec[i].iov_len) {\n                    offset++;\n                    n -= vec[i++].iov_len;\n                } else {\n                    vec[i].iov_len -= n;\n                    vec[i].iov_base = (char *) vec[i].iov_base + n;\n                    break;\n                }\n            }\n        }\n    }\n\n    conn->worker->s->transferred += written;\n    *len = written;\n\n    if (!blocking) {\n        arv = apr_socket_timeout_set(s, old_timeout);\n        if ((arv != APR_SUCCESS) && (rv == APR_SUCCESS)) {\n            return arv;\n        }\n    }\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_7219f1ea69d58c5703abd7b4f3d2162651c0d332_0", {
    "ID": "httpd_7219f1ea69d58c5703abd7b4f3d2162651c0d332_0",
    "UID": "4124",
    "code": "static char* process_tags(header_entry *hdr, request_rec test_snippet\n{\n    int i;\n    const char *s;\n    char *str = NULL;\n\n    format_tag *tag = (format_tag*) hdr->ta->elts;\n\n    for (i = 0; i < hdr->ta->nelts; i++) {\n        s = tag[i].func(r, tag[i].arg);\n        if (str == NULL)\n            str = apr_pstrdup(r->pool, s);\n        else\n            str = apr_pstrcat(r->pool, str, s, NULL);\n    }\n    return str ? str : \"\";\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e7ddc81af314525f74eb605a30131b2d4e7c9621_0", {
    "ID": "httpd_e7ddc81af314525f74eb605a30131b2d4e7c9621_0",
    "UID": "4131",
    "code": "static int do_errorlog_default(const ap_errorlog_info *info, char test_snippet\n                               int buflen, int *errstr_start, int *errstr_end,\n                               const char *errstr_fmt, va_list args)\n{\n    int len = 0;\n    int field_start = 0;\n    int item_len;\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n    char scratch[MAX_STRING_LEN];\n#endif\n\n    if (!info->using_provider && !info->startup) {\n        buf[len++] = '[';\n        len += log_ctime(info, \"u\", buf + len, buflen - len);\n        buf[len++] = ']';\n        buf[len++] = ' ';\n    }\n\n    if (!info->startup) {\n        buf[len++] = '[';\n        len += log_module_name(info, NULL, buf + len, buflen - len);\n        buf[len++] = ':';\n        len += log_loglevel(info, NULL, buf + len, buflen - len);\n        len += cpystrn(buf + len, \"] [pid \", buflen - len);\n\n        len += log_pid(info, NULL, buf + len, buflen - len);\n#if APR_HAS_THREADS\n        field_start = len;\n        len += cpystrn(buf + len, \":tid \", buflen - len);\n        item_len = log_tid(info, NULL, buf + len, buflen - len);\n        if (!item_len)\n            len = field_start;\n        else\n            len += item_len;\n#endif\n        buf[len++] = ']';\n        buf[len++] = ' ';\n    }\n\n    if (info->level >= APLOG_DEBUG) {\n        item_len = log_file_line(info, NULL, buf + len, buflen - len);\n        if (item_len) {\n            len += item_len;\n            len += cpystrn(buf + len, \": \", buflen - len);\n        }\n    }\n\n    if (info->status) {\n        item_len = log_apr_status(info, NULL, buf + len, buflen - len);\n        if (item_len) {\n            len += item_len;\n            len += cpystrn(buf + len, \": \", buflen - len);\n        }\n    }\n\n    /*\n     * useragent_ip/client_ip can be client or backend server. If we have\n     * a scoreboard handle, it is likely a client.\n     */\n    if (info->r) {\n        len += apr_snprintf(buf + len, buflen - len,\n                            info->r->connection->sbh ? \"[client %s:%d] \" : \"[remote %s:%d] \",\n                            info->r->useragent_ip,\n                            info->r->useragent_addr ? info->r->useragent_addr->port : 0);\n    }\n    else if (info->c) {\n        len += apr_snprintf(buf + len, buflen - len,\n                            info->c->sbh ? \"[client %s:%d] \" : \"[remote %s:%d] \",\n                            info->c->client_ip,\n                            info->c->client_addr ? info->c->client_addr->port : 0);\n    }\n\n    \n    *errstr_start = len;\n#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED\n    if (apr_vsnprintf(scratch, MAX_STRING_LEN, errstr_fmt, args)) {\n        len += ap_escape_errorlog_item(buf + len, scratch,\n                                       buflen - len);\n\n    }\n#else\n    len += apr_vsnprintf(buf + len, buflen - len, errstr_fmt, args);\n#endif\n    *errstr_end = len;\n\n    field_start = len;\n    len += cpystrn(buf + len, \", referer: \", buflen - len);\n    item_len = log_header(info, \"Referer\", buf + len, buflen - len);\n    if (item_len)\n        len += item_len;\n    else\n        len = field_start;\n\n    return len;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_c81b713b362eef5e64a52831d84d326e20807a6f_0", {
    "ID": "httpd_c81b713b362eef5e64a52831d84d326e20807a6f_0",
    "UID": "4135",
    "code": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade test_snippet\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n        int folded = 0;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else {\n                r->status = HTTP_BAD_REQUEST;\n            }\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC) {\n                const char *field_escaped;\n                if (field) {\n                    \n                    field[len - 1] = '\\0';\n                    field_escaped = ap_escape_html(r->pool, field);\n                }\n                else {\n                    field_escaped = field = \"\";\n                }\n\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_psprintf(r->pool,\n                                           \"Size of a request header field \"\n                                           \"exceeds server limit.<br />\\n\"\n                                           \"<pre>\\n%.*s\\n</pre>\\n\", \n                                           field_name_len(field_escaped),\n                                           field_escaped));\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                              \"Request header exceeds LimitRequestFieldSize%s\"\n                              \"%.*s\",\n                              *field ? \": \" : \"\",\n                              field_name_len(field), field);\n            }\n            return;\n        }\n\n        if (last_field != NULL) {\n            if ((len > 0) && ((*field == '\\t') || *field == ' ')) {\n                /* This line is a continuation of the preceding line(s),\n                 * so append it to the line that we've set aside.\n                 * Note: this uses a power-of-two allocator to avoid\n                 * doing O(n) allocs and using O(n^2) space for\n                 * continuations that span many many lines.\n                 */\n                apr_size_t fold_len = last_len + len + 1; \n\n                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                    r->status = HTTP_BAD_REQUEST;\n                    /* report what we have accumulated so far before the\n                     * overflow (last_field) as the field with the problem\n                     */\n                    apr_table_setn(r->notes, \"error-notes\",\n                                   apr_psprintf(r->pool,\n                                               \"Size of a request header field \"\n                                               \"after folding \"\n                                               \"exceeds server limit.<br />\\n\"\n                                               \"<pre>\\n%.*s\\n</pre>\\n\", \n                                               field_name_len(last_field), \n                                               ap_escape_html(r->pool, last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)\n                                  \"Request header exceeds LimitRequestFieldSize \"\n                                  \"after folding: %.*s\",\n                                  field_name_len(last_field), last_field);\n                    return;\n                }\n\n                if (fold_len > alloc_len) {\n                    char *fold_buf;\n                    alloc_len += alloc_len;\n                    if (fold_len > alloc_len) {\n                        alloc_len = fold_len;\n                    }\n                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                    memcpy(fold_buf, last_field, last_len);\n                    last_field = fold_buf;\n                }\n                memcpy(last_field + last_len, field, len +1); \n                last_len += len;\n                folded = 1;\n            }\n            else  {\n\n                if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                                   \"The number of request header fields \"\n                                   \"exceeds this server's limit.\");\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)\n                                  \"Number of request headers exceeds \"\n                                  \"LimitRequestFields\");\n                    return;\n                }\n\n                if (!(value = strchr(last_field, ':'))) { \n                    r->status = HTTP_BAD_REQUEST;      \n                    apr_table_setn(r->notes, \"error-notes\",\n                                   apr_psprintf(r->pool,\n                                               \"Request header field is \"\n                                               \"missing ':' separator.<br />\\n\"\n                                               \"<pre>\\n%.*s</pre>\\n\", \n                                               (int)LOG_NAME_MAX_LEN,\n                                               ap_escape_html(r->pool,\n                                                              last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564)\n                                  \"Request header field is missing ':' \"\n                                  \"separator: %.*s\", (int)LOG_NAME_MAX_LEN,\n                                  last_field);\n                    return;\n                }\n\n                tmp_field = value - 1; \n\n                *value++ = '\\0'; \n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;            \n                }\n\n                \n                while (tmp_field > last_field\n                       && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n\n                \n                tmp_field = last_field + last_len - 1;\n                while (tmp_field > value\n                       && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n\n                if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) {\n                    int err = 0;\n\n                    if (*last_field == '\\0') {\n                        err = HTTP_BAD_REQUEST;\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02425)\n                                      \"Empty request header field name not allowed\");\n                    }\n                    else if (ap_has_cntrl(last_field)) {\n                        err = HTTP_BAD_REQUEST;\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426)\n                                      \"[HTTP strict] Request header field name contains \"\n                                      \"control character: %.*s\",\n                                      (int)LOG_NAME_MAX_LEN, last_field);\n                    }\n                    else if (ap_has_cntrl(value)) {\n                        err = HTTP_BAD_REQUEST;\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427)\n                                      \"Request header field '%.*s' contains\"\n                                      \"control character\", (int)LOG_NAME_MAX_LEN,\n                                      last_field);\n                    }\n                    if (err && !(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY)) {\n                        r->status = err;\n                        return;\n                    }\n                }\n                apr_table_addn(r->headers_in, last_field, value);\n\n                /* reset the alloc_len so that we'll allocate a new\n                 * buffer if we have to do any more folding: we can't\n                 * use the previous buffer because its contents are\n                 * now part of r->headers_in\n                 */\n                alloc_len = 0;\n\n            } \n        }\n\n        \n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this line so that we can parse it on\n         * the next loop iteration.  (In the folded case, last_field\n         * has been updated already.)\n         */\n        if (!folded) {\n            last_field = field;\n            last_len = len;\n        }\n    }\n\n    /* Combine multiple message-header fields with the same\n     * field-name, following RFC 2616, 4.2.\n     */\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n\n    \n    apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL);\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n606,Unchecked Input for Loop Condition\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_347f8f923f5e5f3713346800fea7deb81a391366_0", {
    "ID": "httpd_347f8f923f5e5f3713346800fea7deb81a391366_0",
    "UID": "4151",
    "code": "AP_DECLARE(const char *) ap_parse_log_level(const char *str, int test_snippet\n{\n    char *err = \"Log level keyword must be one of emerg/alert/crit/error/warn/\"\n                \"notice/info/debug/trace1/.../trace8\";\n    int i = 0;\n\n    if (str == NULL)\n        return err;\n\n    while (priorities[i].t_name != NULL) {\n        if (!strcasecmp(str, priorities[i].t_name)) {\n            *val = priorities[i].t_val;\n            return NULL;\n        }\n        i++;\n    }\n    return err;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_58007628fb0158f83694330b0298c132031ac53d_0", {
    "ID": "httpd_58007628fb0158f83694330b0298c132031ac53d_0",
    "UID": "4178",
    "code": "static int proxy_http_handler(request_rec *r, proxy_worker test_snippet\n                              proxy_server_conf *conf,\n                              char *url, const char *proxyname,\n                              apr_port_t proxyport)\n{\n    int status;\n    char server_portstr[32];\n    char *scheme;\n    const char *proxy_function;\n    const char *u;\n    apr_bucket_brigade *header_brigade;\n    apr_bucket_brigade *input_brigade;\n    proxy_conn_rec *backend = NULL;\n    int is_ssl = 0;\n    conn_rec *c = r->connection;\n    int retry = 0;\n    char *old_cl_val = NULL, *old_te_val = NULL;\n    enum rb_methods rb_method = RB_INIT;\n    char *locurl = url;\n    int flushall = 0;\n    int toclose = 0;\n    /*\n     * Use a shorter-lived pool to reduce memory usage\n     * and avoid a memory leak\n     */\n    apr_pool_t *p = r->pool;\n    apr_uri_t *uri;\n\n    \n    u = strchr(url, ':');\n    if (u == NULL || u[1] != '/' || u[2] != '/' || u[3] == '\\0')\n        return DECLINED;\n    if ((u - url) > 14)\n        return HTTP_BAD_REQUEST;\n    scheme = apr_pstrmemdup(p, url, u - url);\n    \n    ap_str_tolower(scheme);\n    \n    if (strcmp(scheme, \"https\") == 0) {\n        if (!ap_proxy_ssl_enable(NULL)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01112)\n                          \"HTTPS: declining URL %s (mod_ssl not configured?)\",\n                          url);\n            return DECLINED;\n        }\n        is_ssl = 1;\n        proxy_function = \"HTTPS\";\n    }\n    else if (!(strcmp(scheme, \"http\") == 0 || (strcmp(scheme, \"ftp\") == 0 && proxyname))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01113) \"HTTP: declining URL %s\",\n                      url);\n        return DECLINED; \n    }\n    else {\n        if (*scheme == 'h')\n            proxy_function = \"HTTP\";\n        else\n            proxy_function = \"FTP\";\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"HTTP: serving URL %s\", url);\n\n\n    \n    if ((status = ap_proxy_acquire_connection(proxy_function, &backend,\n                                              worker, r->server)) != OK)\n        goto cleanup;\n\n\n    backend->is_ssl = is_ssl;\n\n    if (is_ssl) {\n        ap_proxy_ssl_connection_cleanup(backend, r);\n    }\n\n    /*\n     * In the case that we are handling a reverse proxy connection and this\n     * is not a request that is coming over an already kept alive connection\n     * with the client, do NOT reuse the connection to the backend, because\n     * we cannot forward a failure to the client in this case as the client\n     * does NOT expect this in this situation.\n     * Yes, this creates a performance penalty.\n     */\n    if ((r->proxyreq == PROXYREQ_REVERSE) && (!c->keepalives)\n        && (apr_table_get(r->subprocess_env, \"proxy-initial-not-pooled\"))) {\n        backend->close = 1;\n    }\n\n    if (apr_table_get(r->subprocess_env, \"proxy-flushall\")) {\n        flushall = 1;\n    }\n\n    \n    uri = apr_palloc(p, sizeof(*uri));\n    if ((status = ap_proxy_determine_connection(p, r, conf, worker, backend,\n                                            uri, &locurl, proxyname,\n                                            proxyport, server_portstr,\n                                            sizeof(server_portstr))) != OK)\n        goto cleanup;\n\n    /* Prefetch (nonlocking) the request body so to increase the chance to get\n     * the whole (or enough) body and determine Content-Length vs chunked or\n     * spooled. By doing this before connecting or reusing the backend, we want\n     * to minimize the delay between this connection is considered alive and\n     * the first bytes sent (should the client's link be slow or some input\n     * filter retain the data). This is a best effort to prevent the backend\n     * from closing (from under us) what it thinks is an idle connection, hence\n     * to reduce to the minimum the unavoidable local is_socket_connected() vs\n     * remote keepalive race condition.\n     */\n    input_brigade = apr_brigade_create(p, c->bucket_alloc);\n    header_brigade = apr_brigade_create(p, c->bucket_alloc);\n    if ((status = ap_proxy_http_prefetch(p, r, backend, worker, conf, uri,\n                                         locurl, server_portstr,\n                                         header_brigade, input_brigade,\n                                         &old_cl_val, &old_te_val, &rb_method,\n                                         flushall)) != OK)\n        goto cleanup;\n\n    /* We need to reset backend->close now, since ap_proxy_http_prefetch() set\n     * it to disable the reuse of the connection *after* this request (no keep-\n     * alive), not to close any reusable connection before this request. However\n     * assure what is expected later by using a local flag and do the right thing\n     * when ap_proxy_connect_backend() below provides the connection to close.\n     */\n    toclose = backend->close;\n    backend->close = 0;\n\n    while (retry < 2) {\n        conn_rec *backconn;\n\n        if (retry) {\n            char *newurl = url;\n\n            \n            if ((status = ap_proxy_determine_connection(p, r, conf, worker,\n                            backend, uri, &newurl, proxyname, proxyport,\n                            server_portstr, sizeof(server_portstr))) != OK)\n                break;\n\n            /* The code assumes locurl is not changed during the loop, or\n             * ap_proxy_http_prefetch() would have to be called every time,\n             * and header_brigade be changed accordingly...\n             */\n            AP_DEBUG_ASSERT(strcmp(newurl, locurl) == 0);\n        }\n\n        \n        if (ap_proxy_connect_backend(proxy_function, backend, worker, r->server)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01114)\n                          \"HTTP: failed to make connection to backend: %s\",\n                          backend->hostname);\n            status = HTTP_SERVICE_UNAVAILABLE;\n            break;\n        }\n\n        \n        backconn = backend->connection;\n        if (!backconn) {\n            if ((status = ap_proxy_connection_create_ex(proxy_function,\n                                                        backend, r)) != OK)\n                break;\n            backconn = backend->connection;\n\n            /*\n             * On SSL connections set a note on the connection what CN is\n             * requested, such that mod_ssl can check if it is requested to do\n             * so.\n             */\n            if (backend->ssl_hostname) {\n                apr_table_setn(backend->connection->notes,\n                               \"proxy-request-hostname\",\n                               backend->ssl_hostname);\n            }\n        }\n\n        \n        if (toclose) {\n            backend->close = 1;\n            backconn->keepalive = AP_CONN_CLOSE;\n        }\n\n        /* Step Four: Send the Request\n         * On the off-chance that we forced a 100-Continue as a\n         * kinda HTTP ping test, allow for retries\n         */\n        if ((status = ap_proxy_http_request(p, r, backend,\n                                            header_brigade, input_brigade,\n                                            old_cl_val, old_te_val, rb_method,\n                                            flushall)) != OK) {\n            proxy_run_detach_backend(r, backend);\n            if ((status == HTTP_SERVICE_UNAVAILABLE) &&\n                    worker->s->ping_timeout_set) {\n                backend->close = 1;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO(01115)\n                              \"HTTP: 100-Continue failed to %pI (%s)\",\n                              worker->cp->addr, worker->s->hostname);\n                retry++;\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        \n        status = ap_proxy_http_process_response(p, r, &backend, worker,\n                                                conf, server_portstr);\n\n        break;\n    }\n\n    \ncleanup:\n    if (backend) {\n        if (status != OK)\n            backend->close = 1;\n        ap_proxy_http_cleanup(proxy_function, r, backend);\n    }\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a1b4a1dd233d62e4c27b4a21acc74ff12c280a0e_0", {
    "ID": "httpd_a1b4a1dd233d62e4c27b4a21acc74ff12c280a0e_0",
    "UID": "4190",
    "code": "AP_DECLARE(int) ap_casecmpstrn(const char *s1, const char *s2, apr_size_t test_snippet\n{\n    const unsigned char *ps1 = (const unsigned char *) s1;\n    const unsigned char *ps2 = (const unsigned char *) s2;\n    while (n--) {\n        if (ucharmap[*ps1] != ucharmap[*ps2]) {\n            return (ucharmap[*ps1] - ucharmap[*ps2]);\n        }\n        if (*ps1++ == '\\0') {\n            break;\n        }\n        ps2++;\n    }\n    return (0);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_1eafb7deb99512431d13d1862323cf6eb471bc7c_0", {
    "ID": "httpd_1eafb7deb99512431d13d1862323cf6eb471bc7c_0",
    "UID": "4202",
    "code": "static int session_included(request_rec * r, session_dir_conf * test_snippet\n{\n\n    const char **includes = (const char **) conf->includes->elts;\n    const char **excludes = (const char **) conf->excludes->elts;\n    int included = 1;                \n    int i;\n\n    if (conf->includes->nelts) {\n        included = 0;\n        for (i = 0; !included && i < conf->includes->nelts; i++) {\n            const char *include = includes[i];\n            if (strncmp(r->uri, include, strlen(include)) == 0) {\n                included = 1;\n            }\n        }\n    }\n\n    if (conf->excludes->nelts) {\n        for (i = 0; included && i < conf->excludes->nelts; i++) {\n            const char *exclude = excludes[i];\n            if (strncmp(r->uri, exclude, strlen(exclude)) == 0) {\n                included = 0;\n            }\n        }\n    }\n\n    return included;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_390bca7429f1593a66479ea0a653913c0b11d124_0", {
    "ID": "httpd_390bca7429f1593a66479ea0a653913c0b11d124_0",
    "UID": "4209",
    "code": "static const char test_snippet\n    set_proxy_exclude(cmd_parms test_snippetparms, void test_snippetdummy, const char test_snippetarg)\n{\n    server_rec test_snippets = parms->server;\n    proxy_server_conf test_snippetconf =\n    ap_get_module_config(s->module_config, &proxy_module);\n    struct noproxy_entry test_snippetnew;\n    struct noproxy_entry test_snippetlist = (struct noproxy_entry test_snippet) conf->noproxies->elts;\n    struct apr_sockaddr_t test_snippetaddr;\n    int found = 0;\n    int i;\n\n    /test_snippet Don't duplicate entries test_snippet/\n    for (i = 0; i < conf->noproxies->nelts; i++) {\n        if (strcasecmp(arg, list[i].name) == 0) { /test_snippet ignore case for host names test_snippet/\n            found = 1;\n            break;\n        }\n    }\n\n    if (!found) {\n        new = apr_array_push(conf->noproxies);\n        new->name = arg;\n        if (APR_SUCCESS == apr_sockaddr_info_get(&addr, new->name, APR_UNSPEC, 0, 0, parms->pool)) {\n            new->addr = addr;\n        }\n        else {\n            new->addr = NULL;\n        }\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_387a882a69f3c2f7e7700968d6877296790f4410_0", {
    "ID": "httpd_387a882a69f3c2f7e7700968d6877296790f4410_0",
    "UID": "4210",
    "code": "static const char test_snippet\n    set_proxy_dirconn(cmd_parms test_snippetparms, void test_snippetdummy, const char test_snippetarg)\n{\n    server_rec test_snippets = parms->server;\n    proxy_server_conf test_snippetconf =\n    ap_get_module_config(s->module_config, &proxy_module);\n    struct dirconn_entry test_snippetNew;\n    struct dirconn_entry test_snippetlist = (struct dirconn_entry test_snippet) conf->dirconn->elts;\n    int found = 0;\n    int i;\n\n    /test_snippet Don't duplicate entries test_snippet/\n    for (i = 0; i < conf->dirconn->nelts; i++) {\n        if (strcasecmp(arg, list[i].name) == 0) {\n            found = 1;\n            break;\n        }\n    }\n\n    if (!found) {\n        New = apr_array_push(conf->dirconn);\n        New->name = apr_pstrdup(parms->pool, arg);\n        New->hostaddr = NULL;\n\n        if (ap_proxy_is_ipaddr(New, parms->pool)) {\n#if DEBUGGING\n            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n                         \"Parsed addr %s\", inet_ntoa(New->addr));\n            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n                         \"Parsed mask %s\", inet_ntoa(New->mask));\n#endif\n        }\n        else if (ap_proxy_is_domainname(New, parms->pool)) {\n            ap_str_tolower(New->name);\n#if DEBUGGING\n            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n                         \"Parsed domain %s\", New->name);\n#endif\n        }\n        else if (ap_proxy_is_hostname(New, parms->pool)) {\n            ap_str_tolower(New->name);\n#if DEBUGGING\n            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,\n                         \"Parsed host %s\", New->name);\n#endif\n        }\n        else {\n            ap_proxy_is_word(New, parms->pool);\n#if DEBUGGING\n            fprintf(stderr, \"Parsed word %s\\n\", New->name);\n#endif\n        }\n    }\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d67523bf0dfc754aec9016871ade92c3d225f604_0", {
    "ID": "httpd_d67523bf0dfc754aec9016871ade92c3d225f604_0",
    "UID": "4211",
    "code": "PROXY_DECLARE(int) ap_proxy_pre_request(proxy_worker test_snippet\n                                        proxy_balancer **balancer,\n                                        request_rec *r,\n                                        proxy_server_conf *conf, char **url)\n{\n    int access_status;\n\n    access_status = proxy_run_pre_request(worker, balancer, r, conf, url);\n    if (access_status == DECLINED && *balancer == NULL) {\n        *worker = ap_proxy_get_worker(r->pool, NULL, conf, *url);\n        if (*worker) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                          \"%s: found worker %s for %s\",\n                          (*worker)->s->scheme, (*worker)->s->name, *url);\n\n            *balancer = NULL;\n            access_status = OK;\n        }\n        else if (r->proxyreq == PROXYREQ_PROXY) {\n            if (conf->forward) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                              \"*: found forward proxy worker for %s\", *url);\n                *balancer = NULL;\n                *worker = conf->forward;\n                access_status = OK;\n                /*\n                 * The forward worker does not keep connections alive, so\n                 * ensure that mod_proxy_http does the correct thing\n                 * regarding the Connection header in the request.\n                 */\n                apr_table_setn(r->subprocess_env, \"proxy-nokeepalive\", \"1\");\n            }\n        }\n        else if (r->proxyreq == PROXYREQ_REVERSE) {\n            if (conf->reverse) {\n                char *ptr;\n                char *ptr2;\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                              \"*: found reverse proxy worker for %s\", *url);\n                *balancer = NULL;\n                *worker = conf->reverse;\n                access_status = OK;\n                /*\n                 * The reverse worker does not keep connections alive, so\n                 * ensure that mod_proxy_http does the correct thing\n                 * regarding the Connection header in the request.\n                 */\n                apr_table_setn(r->subprocess_env, \"proxy-nokeepalive\", \"1\");\n                /*\n                 * In the case of the generic reverse proxy, we need to see if we\n                 * were passed a UDS url (eg: from mod_proxy) and adjust uds_path\n                 * as required.\n                 *\n                 * NOTE: Here we use a quick note lookup, but we could also\n                 * check to see if r->filename starts with 'proxy:'\n                 */\n                if (apr_table_get(r->notes, \"rewrite-proxy\") &&\n                    (ptr2 = ap_strcasestr(r->filename, \"unix:\")) &&\n                    (ptr = ap_strchr(ptr2, '|'))) {\n                    apr_uri_t urisock;\n                    apr_status_t rv;\n                    *ptr = '\\0';\n                    rv = apr_uri_parse(r->pool, ptr2, &urisock);\n                    if (rv == APR_SUCCESS) {\n                        char *rurl = ptr+1;\n                        char *sockpath = ap_runtime_dir_relative(r->pool, urisock.path);\n                        apr_table_setn(r->notes, \"uds_path\", sockpath);\n                        *url = apr_pstrdup(r->pool, rurl); \n                        \n                        memmove(r->filename+6, rurl, strlen(rurl)+1);\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                                      \"*: rewrite of url due to UDS(%s): %s (%s)\",\n                                      sockpath, *url, r->filename);\n                    }\n                    else {\n                        *ptr = '|';\n                    }\n                }\n            }\n        }\n    }\n    else if (access_status == DECLINED && *balancer != NULL) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00934)\n                      \"all workers are busy.  Unable to serve %s\", *url);\n        access_status = HTTP_SERVICE_UNAVAILABLE;\n    }\n    return access_status;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_ed61a48d1a8ee62db236efcdcd9258715bf12e83_0", {
    "ID": "httpd_ed61a48d1a8ee62db236efcdcd9258715bf12e83_0",
    "UID": "4212",
    "code": "test_snippet\nap_proxy_determine_connection(apr_pool_t *p, request_rec *r,\n                              proxy_server_conf *conf,\n                              proxy_worker *worker,\n                              proxy_conn_rec *conn,\n                              apr_uri_t *uri,\n                              char **url,\n                              const char *proxyname,\n                              apr_port_t proxyport,\n                              char *server_portstr,\n                              int server_portstr_size)\n{\n    int server_port;\n    apr_status_t err = APR_SUCCESS;\n    apr_status_t uerr = APR_SUCCESS;\n    const char *uds_path;\n\n    /*\n     * Break up the URL to determine the host to connect to\n     */\n\n    \n    if (APR_SUCCESS != apr_uri_parse(p, *url, uri)) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p,\"URI cannot be parsed: \", *url,\n                                         NULL));\n    }\n    if (!uri->port) {\n        uri->port = ap_proxy_port_of_scheme(uri->scheme);\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00944)\n                 \"connecting %s to %s:%d\", *url, uri->hostname, uri->port);\n\n    /*\n     * allocate these out of the specified connection pool\n     * The scheme handler decides if this is permanent or\n     * short living pool.\n     */\n    \n    if (!proxyname) {\n        *url = apr_pstrcat(p, uri->path, uri->query ? \"?\" : \"\",\n                           uri->query ? uri->query : \"\",\n                           uri->fragment ? \"#\" : \"\",\n                           uri->fragment ? uri->fragment : \"\", NULL);\n    }\n    /*\n     * Figure out if our passed in proxy_conn_rec has a usable\n     * address cached.\n     *\n     * TODO: Handle this much better... \n     *\n     * XXX: If generic workers are ever address-reusable, we need \n     *      to check host and port on the conn and be careful about\n     *      spilling the cached addr from the worker.\n     */\n    uds_path = (*worker->s->uds_path ? worker->s->uds_path : apr_table_get(r->notes, \"uds_path\"));\n    if (uds_path) {\n        if (conn->uds_path == NULL) {\n            \n            conn->uds_path = apr_pstrdup(conn->pool, uds_path);\n        }\n        if (conn->uds_path) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02545)\n                         \"%s: has determined UDS as %s\",\n                         uri->scheme, conn->uds_path);\n        }\n        else {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02546)\n                         \"%s: cannot determine UDS (%s)\",\n                         uri->scheme, uds_path);\n\n        }\n        /*\n         * In UDS cases, some structs are NULL. Protect from de-refs\n         * and provide info for logging at the same time.\n         */\n        if (!conn->addr) {\n            apr_sockaddr_t *sa;\n            apr_sockaddr_info_get(&sa, NULL, APR_UNSPEC, 0, 0, conn->pool);\n            conn->addr = sa;\n        }\n        conn->hostname = \"httpd-UDS\";\n        conn->port = 0;\n    }\n    else {\n        int will_reuse = worker->s->is_address_reusable && !worker->s->disablereuse;\n        if (!conn->hostname || !will_reuse) {\n            if (proxyname) {\n                conn->hostname = apr_pstrdup(conn->pool, proxyname);\n                conn->port = proxyport;\n                /*\n                 * If we have a forward proxy and the protocol is HTTPS,\n                 * then we need to prepend a HTTP CONNECT request before\n                 * sending our actual HTTPS requests.\n                 * Save our real backend data for using it later during HTTP CONNECT.\n                 */\n                if (conn->is_ssl) {\n                    const char *proxy_auth;\n\n                    forward_info *forward = apr_pcalloc(conn->pool, sizeof(forward_info));\n                    conn->forward = forward;\n                    forward->use_http_connect = 1;\n                    forward->target_host = apr_pstrdup(conn->pool, uri->hostname);\n                    forward->target_port = uri->port;\n                    /* Do we want to pass Proxy-Authorization along?\n                     * If we haven't used it, then YES\n                     * If we have used it then MAYBE: RFC2616 says we MAY propagate it.\n                     * So let's make it configurable by env.\n                     * The logic here is the same used in mod_proxy_http.\n                     */\n                    proxy_auth = apr_table_get(r->headers_in, \"Proxy-Authorization\");\n                    if (proxy_auth != NULL &&\n                        proxy_auth[0] != '\\0' &&\n                        r->user == NULL && \n                        apr_table_get(r->subprocess_env, \"Proxy-Chain-Auth\")) {\n                        forward->proxy_auth = apr_pstrdup(conn->pool, proxy_auth);\n                    }\n                }\n            }\n            else {\n                conn->hostname = apr_pstrdup(conn->pool, uri->hostname);\n                conn->port = uri->port;\n            }\n            if (!will_reuse) {\n                /*\n                 * Only do a lookup if we should not reuse the backend address.\n                 * Otherwise we will look it up once for the worker.\n                 */\n                err = apr_sockaddr_info_get(&(conn->addr),\n                                            conn->hostname, APR_UNSPEC,\n                                            conn->port, 0,\n                                            conn->pool);\n            }\n            socket_cleanup(conn);\n        }\n        if (will_reuse) {\n            /*\n             * Looking up the backend address for the worker only makes sense if\n             * we can reuse the address.\n             */\n            if (!worker->cp->addr) {\n                if ((err = PROXY_THREAD_LOCK(worker)) != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, err, r, APLOGNO(00945) \"lock\");\n                    return HTTP_INTERNAL_SERVER_ERROR;\n                }\n\n                /*\n                 * Worker can have the single constant backend adress.\n                 * The single DNS lookup is used once per worker.\n                 * If dynamic change is needed then set the addr to NULL\n                 * inside dynamic config to force the lookup.\n                 */\n                err = apr_sockaddr_info_get(&(worker->cp->addr),\n                                            conn->hostname, APR_UNSPEC,\n                                            conn->port, 0,\n                                            worker->cp->pool);\n                conn->addr = worker->cp->addr;\n                if ((uerr = PROXY_THREAD_UNLOCK(worker)) != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, uerr, r, APLOGNO(00946) \"unlock\");\n                }\n            }\n            else {\n                conn->addr = worker->cp->addr;\n            }\n        }\n    }\n    \n    if (conn->close) {\n        socket_cleanup(conn);\n        conn->close = 0;\n    }\n\n    if (err != APR_SUCCESS) {\n        return ap_proxyerror(r, HTTP_GATEWAY_TIME_OUT,\n                             apr_pstrcat(p, \"DNS lookup failure for: \",\n                                         conn->hostname, NULL));\n    }\n\n    \n    {\n        server_port = ap_get_server_port(r);\n        if (ap_is_default_port(server_port, r)) {\n            strcpy(server_portstr,\"\");\n        }\n        else {\n            apr_snprintf(server_portstr, server_portstr_size, \":%d\",\n                         server_port);\n        }\n    }\n    \n    if (OK != ap_proxy_checkproxyblock(r, conf, uri->hostname, \n                                       proxyname ? NULL : conn->addr)) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00947)\n                 \"connected %s to %s:%d\", *url, conn->hostname, conn->port);\n    return OK;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_8231871b5d06b71109672c66b25a609743dd2b55_0", {
    "ID": "httpd_8231871b5d06b71109672c66b25a609743dd2b55_0",
    "UID": "4221",
    "code": "static int uwsgi_send_headers(request_rec *r, proxy_conn_rec * test_snippet\n{\n    char *buf, *ptr;\n\n    const apr_array_header_t *env_table;\n    const apr_table_entry_t *env;\n\n    int j;\n\n    apr_size_t headerlen = 4;\n    apr_uint16_t pktsize, keylen, vallen;\n    const char *script_name;\n    const char *path_info;\n    const char *auth;\n\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    /*\n       this is not a security problem (in Linux) as uWSGI destroy the env memory area readable in /proc\n       and generally if you host untrusted apps in your server and allows them to read others uid /proc/<pid>\n       files you have higher problems...\n     */\n    auth = apr_table_get(r->headers_in, \"Authorization\");\n    if (auth) {\n        apr_table_setn(r->subprocess_env, \"HTTP_AUTHORIZATION\", auth);\n    }\n\n    script_name = apr_table_get(r->subprocess_env, \"SCRIPT_NAME\");\n    path_info = apr_table_get(r->subprocess_env, \"PATH_INFO\");\n\n    if (script_name && path_info) {\n        if (strcmp(path_info, \"/\")) {\n            apr_table_set(r->subprocess_env, \"SCRIPT_NAME\",\n                          apr_pstrndup(r->pool, script_name,\n                                       strlen(script_name) -\n                                       strlen(path_info)));\n        }\n        else {\n            if (!strcmp(script_name, \"/\")) {\n                apr_table_setn(r->subprocess_env, \"SCRIPT_NAME\", \"\");\n            }\n        }\n    }\n\n    env_table = apr_table_elts(r->subprocess_env);\n    env = (apr_table_entry_t *) env_table->elts;\n\n    for (j = 0; j < env_table->nelts; ++j) {\n        headerlen += 2 + strlen(env[j].key) + 2 + strlen(env[j].val);\n    }\n\n    ptr = buf = apr_palloc(r->pool, headerlen);\n\n    ptr += 4;\n\n    for (j = 0; j < env_table->nelts; ++j) {\n        keylen = strlen(env[j].key);\n        *ptr++ = (apr_byte_t) (keylen & 0xff);\n        *ptr++ = (apr_byte_t) ((keylen >> 8) & 0xff);\n        memcpy(ptr, env[j].key, keylen);\n        ptr += keylen;\n\n        vallen = strlen(env[j].val);\n        *ptr++ = (apr_byte_t) (vallen & 0xff);\n        *ptr++ = (apr_byte_t) ((vallen >> 8) & 0xff);\n        memcpy(ptr, env[j].val, vallen);\n        ptr += vallen;\n    }\n\n    pktsize = headerlen - 4;\n\n    buf[0] = 0;\n    buf[1] = (apr_byte_t) (pktsize & 0xff);\n    buf[2] = (apr_byte_t) ((pktsize >> 8) & 0xff);\n    buf[3] = 0;\n\n    return uwsgi_send(conn, buf, headerlen, r);\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_14685b1e367249072319a821e19be842894d7670_0", {
    "ID": "httpd_14685b1e367249072319a821e19be842894d7670_0",
    "UID": "4230",
    "code": "static authz_status user_check_authorization(request_rec test_snippet\n                                             const char *require_args,\n                                             const void *parsed_require_args)\n{\n    const char *err = NULL;\n    const ap_expr_info_t *expr = parsed_require_args;\n    const char *require;\n\n    const char *t, *w;\n\n    if (!r->user) {\n        return AUTHZ_DENIED_NO_USER;\n    }\n\n    require = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02594)\n                      \"authz_user authorize: require user: Can't \"\n                      \"evaluate require expression: %s\", err);\n        return AUTHZ_DENIED;\n    }\n\n    t = require;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        if (!strcmp(r->user, w)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01663)\n                  \"access to %s failed, reason: user '%s' does not meet \"\n                  \"'require'ments for user to be allowed access\",\n                  r->uri, r->user);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_64e4774b1c11c97f446d0d19004adf2f41cd92c6_0", {
    "ID": "httpd_64e4774b1c11c97f446d0d19004adf2f41cd92c6_0",
    "UID": "4232",
    "code": "apr_status_t ap_queue_info_set_idle(fd_queue_info_t * test_snippet\n                                    apr_pool_t * pool_to_recycle)\n{\n    apr_status_t rv;\n    apr_int32_t prev_idlers;\n\n    ap_push_pool(test_snippet pool_to_recycle);\n\n    \n    prev_idlers = apr_atomic_inc32(&(queue_info->idlers)) - zero_pt;\n\n    \n    if (prev_idlers < 0) {\n        rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n        if (rv != APR_SUCCESS) {\n            AP_DEBUG_ASSERT(0);\n            return rv;\n        }\n        rv = apr_thread_cond_signal(queue_info->wait_for_idler);\n        if (rv != APR_SUCCESS) {\n            apr_thread_mutex_unlock(queue_info->idlers_mutex);\n            return rv;\n        }\n        rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_f7667ac09d48cf53dd59e045cf0ee65fe83bd6cd_0", {
    "ID": "httpd_f7667ac09d48cf53dd59e045cf0ee65fe83bd6cd_0",
    "UID": "4235",
    "code": "static authz_status dbmgroup_check_authorization(request_rec test_snippet\n                                                 const char *require_args,\n                                                 const void *parsed_require_args)\n{\n    authz_dbm_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                      &authz_dbm_module);\n    char *user = r->user;\n\n    const char *err = NULL;\n    const ap_expr_info_t *expr = parsed_require_args;\n    const char *require;\n\n    const char *t;\n    char *w;\n    const char *orig_groups = NULL;\n    const char *realm = ap_auth_name(r);\n    const char *groups;\n    char *v;\n\n    if (!user) {\n        return AUTHZ_DENIED_NO_USER;\n    }\n\n    if (!conf->grpfile) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01798)\n                        \"No group file was specified in the configuration\");\n        return AUTHZ_DENIED;\n    }\n\n    \n    if (!orig_groups) {\n        apr_status_t status;\n\n        status = get_dbm_grp(r, apr_pstrcat(r->pool, user, \":\", realm, NULL),\n                             user, conf->grpfile, conf->dbmtype, &groups);\n\n        if (status != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01799)\n                          \"could not open dbm (type %s) group access \"\n                          \"file: %s\", conf->dbmtype, conf->grpfile);\n            return AUTHZ_GENERAL_ERROR;\n        }\n\n        if (groups == NULL) {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01800)\n                          \"Authorization of user %s to access %s failed, reason: \"\n                          \"user doesn't appear in DBM group file (%s).\",\n                          r->user, r->uri, conf->grpfile);\n            return AUTHZ_DENIED;\n        }\n\n        orig_groups = groups;\n    }\n\n    require = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02591)\n                      \"authz_dbm authorize: require dbm-group: Can't \"\n                      \"evaluate require expression: %s\", err);\n        return AUTHZ_DENIED;\n    }\n\n    t = require;\n    while ((w = ap_getword_white(r->pool, &t)) && w[0]) {\n        groups = orig_groups;\n        while (groups[0]) {\n            v = ap_getword(r->pool, &groups, ',');\n            if (!strcmp(v, w)) {\n                return AUTHZ_GRANTED;\n            }\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01801)\n                  \"Authorization of user %s to access %s failed, reason: \"\n                  \"user is not part of the 'require'ed group(s).\",\n                  r->user, r->uri);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n"
  },
  "httpd_19c42015f90749715a566652e22137095cbaad0d_0", {
    "ID": "httpd_19c42015f90749715a566652e22137095cbaad0d_0",
    "UID": "4237",
    "code": "apr_status_t ap_queue_info_try_get_idler(fd_queue_info_t * test_snippet\n{\n    apr_int32_t new_idlers;\n    new_idlers = apr_atomic_add32(&(queue_info->idlers), -1) - zero_pt;\n    if (--new_idlers <= 0) {\n        apr_atomic_inc32(&(queue_info->idlers));    \n        return APR_EAGAIN;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_385008efef8a3a72c48d3ab579f89742a98b0ac4_0", {
    "ID": "httpd_385008efef8a3a72c48d3ab579f89742a98b0ac4_0",
    "UID": "4242",
    "code": "static authz_status group_check_authorization(request_rec test_snippet\n                                              const char *require_args,\n                                              const void *parsed_require_args)\n{\n    authz_groupfile_config_rec *conf = ap_get_module_config(r->per_dir_config,\n            &authz_groupfile_module);\n    char *user = r->user;\n\n    const char *err = NULL;\n    const ap_expr_info_t *expr = parsed_require_args;\n    const char *require;\n\n    const char *t, *w;\n    apr_table_t *grpstatus = NULL;\n    apr_status_t status;\n\n    if (!user) {\n        return AUTHZ_DENIED_NO_USER;\n    }\n\n    /* If there is no group file - then we are not\n     * configured. So decline.\n     */\n    if (!(conf->groupfile)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01664)\n                        \"No group file was specified in the configuration\");\n        return AUTHZ_DENIED;\n    }\n\n    status = groups_for_user(r->pool, user, conf->groupfile,\n                                &grpstatus);\n\n    if (status != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01665)\n                        \"Could not open group file: %s\",\n                        conf->groupfile);\n        return AUTHZ_DENIED;\n    }\n\n    if (apr_is_empty_table(grpstatus)) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01666)\n                      \"Authorization of user %s to access %s failed, reason: \"\n                      \"user doesn't appear in group file (%s).\",\n                      r->user, r->uri, conf->groupfile);\n        return AUTHZ_DENIED;\n    }\n\n    require = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02592)\n                      \"authz_groupfile authorize: require group: Can't \"\n                      \"evaluate require expression: %s\", err);\n        return AUTHZ_DENIED;\n    }\n\n    t = require;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n        if (apr_table_get(grpstatus, w)) {\n            return AUTHZ_GRANTED;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01667)\n                    \"Authorization of user %s to access %s failed, reason: \"\n                    \"user is not part of the 'require'ed group(s).\",\n                    r->user, r->uri);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition"
  },
  "httpd_0795339ecc62becafabe6e86cac84fc305a465b7_0", {
    "ID": "httpd_0795339ecc62becafabe6e86cac84fc305a465b7_0",
    "UID": "4243",
    "code": "apr_status_t ap_queue_info_wait_for_idler(fd_queue_info_t * test_snippet\n                                          int *had_to_block)\n{\n    apr_status_t rv;\n    apr_int32_t prev_idlers;\n\n    \n    \n    prev_idlers = apr_atomic_add32(&(queue_info->idlers), -1) - zero_pt;\n\n    \n    if (prev_idlers <= 0) {\n        rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n        if (rv != APR_SUCCESS) {\n            AP_DEBUG_ASSERT(0);\n            \n            apr_atomic_inc32(&(queue_info->idlers));    \n            return rv;\n        }\n        /* Re-check the idle worker count to guard against a\n         * race condition.  Now that we're in the mutex-protected\n         * region, one of two things may have happened:\n         *   - If the idle worker count is still negative, the\n         *     workers are all still busy, so it's safe to\n         *     block on a condition variable.\n         *   - If the idle worker count is non-negative, then a\n         *     worker has become idle since the first check\n         *     of queue_info->idlers above.  It's possible\n         *     that the worker has also signaled the condition\n         *     variable--and if so, the listener missed it\n         *     because it wasn't yet blocked on the condition\n         *     variable.  But if the idle worker count is\n         *     now non-negative, it's safe for this function to\n         *     return immediately.\n         *\n         *     A \"negative value\" (relative to zero_pt) in\n         *     queue_info->idlers tells how many\n         *     threads are waiting on an idle worker.\n         */\n        if (queue_info->idlers < zero_pt) {\n            *had_to_block = 1;\n            rv = apr_thread_cond_wait(queue_info->wait_for_idler,\n                                      queue_info->idlers_mutex);\n            if (rv != APR_SUCCESS) {\n                apr_status_t rv2;\n                AP_DEBUG_ASSERT(0);\n                rv2 = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n                if (rv2 != APR_SUCCESS) {\n                    return rv2;\n                }\n                return rv;\n            }\n        }\n        rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n    }\n\n    if (queue_info->terminated) {\n        return APR_EOF;\n    }\n    else {\n        return APR_SUCCESS;\n    }\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_da0b726fb5aea610668af45ba3ee7ca1f639786b_0", {
    "ID": "httpd_da0b726fb5aea610668af45ba3ee7ca1f639786b_0",
    "UID": "4247",
    "code": "static const char *proxylist_read(cmd_parms *cmd, void test_snippet\n                                  const char *filename)\n{\n    char lbuf[MAX_STRING_LEN];\n    char *arg;\n    const char *args;\n    const char *errmsg;\n    ap_configfile_t *cfp;\n    apr_status_t rv;\n\n    filename = ap_server_root_relative(cmd->temp_pool, filename);\n    rv = ap_pcfg_openfile(&cfp, cmd->temp_pool, filename);\n    if (rv != APR_SUCCESS) {\n        return apr_psprintf(cmd->pool, \"%s: Could not open file %s: %pm\",\n                            cmd->cmd->name, filename, &rv);\n    }\n\n    while (!(ap_cfg_getline(lbuf, MAX_STRING_LEN, cfp))) {\n        args = lbuf;\n        while (*(arg = ap_getword_conf(cmd->temp_pool, &args)) != '\\0') {\n            if (*arg == '#') {\n                break;\n            }\n            errmsg = proxies_set(cmd, cfg, arg);\n            if (errmsg) {\n                ap_cfg_closefile(cfp);\n                errmsg = apr_psprintf(cmd->pool, \"%s at line %d of %s\",\n                                      errmsg, cfp->line_number, filename);\n                return errmsg;\n            }\n        }\n    }\n\n    ap_cfg_closefile(cfp);\n    return NULL;\n}",
    "predicted": "23,Relative Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_55e28a3adf31be13e339510362c83b6cf645ba3d_0", {
    "ID": "httpd_55e28a3adf31be13e339510362c83b6cf645ba3d_0",
    "UID": "4248",
    "code": "static authz_status dbmfilegroup_check_authorization(request_rec test_snippet\n                                                     const char *require_args,\n                                                     const void *parsed_require_args)\n{\n    authz_dbm_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                      &authz_dbm_module);\n    char *user = r->user;\n    const char *realm = ap_auth_name(r);\n    const char *filegroup = NULL;\n    apr_status_t status;\n    const char *groups;\n    char *v;\n\n    if (!user) {\n        return AUTHZ_DENIED_NO_USER;\n    }\n\n    if (!conf->grpfile) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01802)\n                        \"No group file was specified in the configuration\");\n        return AUTHZ_DENIED;\n    }\n\n    \n    status = get_dbm_grp(r, apr_pstrcat(r->pool, user, \":\", realm, NULL),\n                         user, conf->grpfile, conf->dbmtype, &groups);\n\n    if (status != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01803)\n                      \"could not open dbm (type %s) group access \"\n                      \"file: %s\", conf->dbmtype, conf->grpfile);\n        return AUTHZ_DENIED;\n    }\n\n    if (groups == NULL) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01804)\n                      \"Authorization of user %s to access %s failed, reason: \"\n                      \"user doesn't appear in DBM group file (%s).\",\n                      r->user, r->uri, conf->grpfile);\n        return AUTHZ_DENIED;\n    }\n\n    filegroup = authz_owner_get_file_group(r);\n\n    if (filegroup) {\n        while (groups[0]) {\n            v = ap_getword(r->pool, &groups, ',');\n            if (!strcmp(v, filegroup)) {\n                return AUTHZ_GRANTED;\n            }\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01805)\n                  \"Authorization of user %s to access %s failed, reason: \"\n                  \"user is not part of the 'require'ed group(s).\",\n                  r->user, r->uri);\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value"
  },
  "httpd_582508dcd04ae0d9dc8f1cf83dd2dd39a25e7173_0", {
    "ID": "httpd_582508dcd04ae0d9dc8f1cf83dd2dd39a25e7173_0",
    "UID": "4249",
    "code": "apr_uint32_t ap_queue_info_get_idlers(fd_queue_info_t * test_snippet\n{\n    apr_int32_t val;\n    val = (apr_int32_t)apr_atomic_read32(&queue_info->idlers) - zero_pt;\n    if (val < 0)\n        return 0;\n    return val;\n}",
    "predicted": "195,Signed to Unsigned Conversion Error"
  },
  "httpd_6f1a445973d99b9a9330f8ccaf359becf6e12dc8_0", {
    "ID": "httpd_6f1a445973d99b9a9330f8ccaf359becf6e12dc8_0",
    "UID": "4250",
    "code": "static authz_status dbdgroup_check_authorization(request_rec test_snippet\n                                                 const char *require_args,\n                                                 const void *parsed_require_args)\n{\n    int i, rv;\n    const char *w;\n    apr_array_header_t *groups = NULL;\n\n    const char *err = NULL;\n    const ap_expr_info_t *expr = parsed_require_args;\n    const char *require;\n\n    const char *t;\n    authz_dbd_cfg *cfg = ap_get_module_config(r->per_dir_config,\n                                              &authz_dbd_module);\n\n    if (!r->user) {\n        return AUTHZ_DENIED_NO_USER;\n    }\n\n    if (groups == NULL) {\n        groups = apr_array_make(r->pool, 4, sizeof(const char*));\n        rv = authz_dbd_group_query(r, cfg, groups);\n        if (rv != OK) {\n            return AUTHZ_GENERAL_ERROR;\n        }\n    }\n\n    require = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02590)\n                      \"authz_dbd authorize: require dbd-group: Can't \"\n                      \"evaluate require expression: %s\", err);\n        return AUTHZ_DENIED;\n    }\n\n    t = require;\n    while (t[0]) {\n        w = ap_getword_white(r->pool, &t);\n        for (i=0; i < groups->nelts; ++i) {\n            if (!strcmp(w, ((const char**)groups->elts)[i])) {\n                return AUTHZ_GRANTED;\n            }\n        }\n    }\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_87bccd92b68eb4fe4c6b73b229fcb302ed41a010_0", {
    "ID": "httpd_87bccd92b68eb4fe4c6b73b229fcb302ed41a010_0",
    "UID": "4251",
    "code": "AP_DECLARE(void) ap_str_toupper(char test_snippet\n{\n    while (test_snippet {\n        *str = apr_toupper(test_snippet;\n        ++str;\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_2cf54efbd3b8dc887852e4164cfedce06908367e_0", {
    "ID": "httpd_2cf54efbd3b8dc887852e4164cfedce06908367e_0",
    "UID": "4252",
    "code": "AP_DECLARE(int) ap_regname(const ap_regex_t test_snippet\n                           apr_array_header_t *names, const char *prefix,\n                           int upper)\n{\n    int namecount;\n    int nameentrysize;\n    int i;\n    char *nametable;\n\n    pcre_fullinfo((const pcre *)preg->re_pcre, NULL,\n                       PCRE_INFO_NAMECOUNT, &namecount);\n    pcre_fullinfo((const pcre *)preg->re_pcre, NULL,\n                       PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);\n    pcre_fullinfo((const pcre *)preg->re_pcre, NULL,\n                       PCRE_INFO_NAMETABLE, &nametable);\n\n    for (i = 0; i < namecount; i++) {\n        const char *offset = nametable + i * nameentrysize;\n        int capture = ((offset[0] << 8) + offset[1]);\n        while (names->nelts <= capture) {\n            apr_array_push(names);\n        }\n        if (upper || prefix) {\n            char *name = ((char **) names->elts)[capture] =\n                    prefix ? apr_pstrcat(names->pool, prefix, offset + 2,\n                            NULL) :\n                            apr_pstrdup(names->pool, offset + 2);\n            if (upper) {\n                ap_str_toupper(name);\n            }\n        }\n        else {\n            ((const char **)names->elts)[capture] = offset + 2;\n        }\n    }\n\n    return namecount;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_0abfcd35ee79b9e2ea7a3ff5423db68764d25c89_0", {
    "ID": "httpd_0abfcd35ee79b9e2ea7a3ff5423db68764d25c89_0",
    "UID": "4256",
    "code": "static char *parse_format_string(cmd_parms *cmd, header_entry *hdr, const char test_snippet\n{\n    apr_pool_t *p = cmd->pool;\n    char *res;\n\n    \n    if (hdr->action == hdr_unset || hdr->action == hdr_echo) {\n        return NULL;\n    }\n    \n    else if (hdr->action == hdr_edit || hdr->action == hdr_edit_r ) {\n        s = hdr->subs;\n    }\n\n    if (!strncmp(s, \"expr=\", 5)) { \n        const char *err;\n        hdr->expr_out = ap_expr_parse_cmd(cmd, s+5, \n                                          AP_EXPR_FLAG_STRING_RESULT,\n                                          &err, NULL);\n        if (err) {\n            return apr_pstrcat(cmd->pool,\n                    \"Can't parse value expression : \", err, NULL);\n        }\n        return NULL;\n    }\n\n    hdr->ta = apr_array_make(p, 10, sizeof(format_tag));\n\n    while (test_snippet {\n        if ((res = parse_format_tag(p, (format_tag *) apr_array_push(hdr->ta), &s))) {\n            return res;\n        }\n    }\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9eaf9af4f65c193178a2b96c6835bebbbaf57c8e_0", {
    "ID": "httpd_9eaf9af4f65c193178a2b96c6835bebbbaf57c8e_0",
    "UID": "4259",
    "code": "apr_status_t ap_queue_pop_something(fd_queue_t * queue, apr_socket_t ** test_snippet\n                                    event_conn_state_t ** ecs, apr_pool_t ** p,\n                                    timer_event_t ** te_out)\n{\n    fd_queue_elem_t *elem;\n    apr_status_t rv;\n\n    if ((rv = apr_thread_mutex_lock(queue->one_big_mutex)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    \n    if (ap_queue_empty(queue)) {\n        if (!queue->terminated) {\n            apr_thread_cond_wait(queue->not_empty, queue->one_big_mutex);\n        }\n        \n        if (ap_queue_empty(queue)) {\n            rv = apr_thread_mutex_unlock(queue->one_big_mutex);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n            if (queue->terminated) {\n                return APR_EOF; \n            }\n            else {\n                return APR_EINTR;\n            }\n        }\n    }\n\n    *te_out = NULL;\n\n    if (!APR_RING_EMPTY(&queue->timers, timer_event_t, link)) {\n        *te_out = APR_RING_FIRST(&queue->timers);\n        APR_RING_REMOVE(*te_out, link);\n    }\n    else {\n        elem = &queue->data[queue->out];\n        queue->out++;\n        if (queue->out >= queue->bounds)\n            queue->out -= queue->bounds;\n        queue->nelts--;\n        *sd = elem->sd;\n        *ecs = elem->ecs;\n        *p = elem->p;\n#ifdef AP_DEBUG\n        elem->sd = NULL;\n        elem->p = NULL;\n#endif \n    }\n\n    rv = apr_thread_mutex_unlock(queue->one_big_mutex);\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_23b55465a231dd9915943e3445fb36ab1dea0e11_0", {
    "ID": "httpd_23b55465a231dd9915943e3445fb36ab1dea0e11_0",
    "UID": "4275",
    "code": "static char* process_tags(header_entry *hdr, request_rec test_snippet\n{\n    int i;\n    const char *s;\n    char *str = NULL;\n    format_tag *tag = NULL;\n\n    if (hdr->expr_out) { \n        const char *err;\n        const char *val;\n        val = ap_expr_str_exec(r, hdr->expr_out, &err);\n        if (err) { \n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02557)\n                          \"Can't evaluate value expression: %s\", err);\n            return \"\";\n        }\n        return apr_pstrdup(r->pool, val);\n    }\n\n    tag = (format_tag*) hdr->ta->elts;\n\n    for (i = 0; i < hdr->ta->nelts; i++) {\n        s = tag[i].func(r, tag[i].arg);\n        if (str == NULL)\n            str = apr_pstrdup(r->pool, s);\n        else\n            str = apr_pstrcat(r->pool, str, s, NULL);\n    }\n    return str ? str : \"\";\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a3c39fc078be3228f8ebcb6726eabb691add7755_0", {
    "ID": "httpd_a3c39fc078be3228f8ebcb6726eabb691add7755_0",
    "UID": "4277",
    "code": "static int proxy_walk(request_rec test_snippet\n{\n    proxy_server_conf *sconf = ap_get_module_config(r->server->module_config,\n                                                    &proxy_module);\n    ap_conf_vector_t *per_dir_defaults = r->server->lookup_defaults;\n    ap_conf_vector_t **sec_proxy = (ap_conf_vector_t **) sconf->sec_proxy->elts;\n    ap_conf_vector_t *entry_config;\n    proxy_dir_conf *entry_proxy;\n    int num_sec = sconf->sec_proxy->nelts;\n    /* XXX: shouldn't we use URI here?  Canonicalize it first?\n     * Pass over \"proxy:\" prefix\n     */\n    const char *proxyname = r->filename + 6;\n    int j;\n    apr_pool_t *rxpool = NULL;\n\n    for (j = 0; j < num_sec; ++j)\n    {\n        int nmatch = 0;\n        int i;\n        ap_regmatch_t *pmatch = NULL;\n\n        entry_config = sec_proxy[j];\n        entry_proxy = ap_get_module_config(entry_config, &proxy_module);\n\n        if (entry_proxy->r) {\n\n            if (entry_proxy->refs && entry_proxy->refs->nelts) {\n                if (!rxpool) {\n                    apr_pool_create(&rxpool, r->pool);\n                }\n                nmatch = entry_proxy->refs->nelts;\n                pmatch = apr_palloc(rxpool, nmatch*sizeof(ap_regmatch_t));\n            }\n\n            if (ap_regexec(entry_proxy->r, proxyname, nmatch, pmatch, 0)) {\n                continue;\n            }\n\n            for (i = 0; i < nmatch; i++) {\n                if (pmatch[i].rm_so >= 0 && pmatch[i].rm_eo >= 0 &&\n                        ((const char **)entry_proxy->refs->elts)[i]) {\n                    apr_table_setn(r->subprocess_env,\n                            ((const char **)entry_proxy->refs->elts)[i],\n                            apr_pstrndup(r->pool,\n                                    proxyname + pmatch[i].rm_so,\n                                    pmatch[i].rm_eo - pmatch[i].rm_so));\n                }\n            }\n        }\n\n        else if (\n            /* XXX: What about case insensitive matching ???\n             * Compare regex, fnmatch or string as appropriate\n             * If the entry doesn't relate, then continue\n             */\n            entry_proxy->p_is_fnmatch ? apr_fnmatch(entry_proxy->p,\n                    proxyname, 0) :\n                    strncmp(proxyname, entry_proxy->p,\n                            strlen(entry_proxy->p))) {\n            continue;\n        }\n        per_dir_defaults = ap_merge_per_dir_configs(r->pool, per_dir_defaults,\n                                                             entry_config);\n    }\n\n    r->per_dir_config = per_dir_defaults;\n\n    if (rxpool) {\n        apr_pool_destroy(rxpool);\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n"
  },
  "httpd_59bf92234275997c1889faaac917b73397fa9a6b_0", {
    "ID": "httpd_59bf92234275997c1889faaac917b73397fa9a6b_0",
    "UID": "4285",
    "code": "static int do_headers_fixup(request_rec *r, apr_table_t test_snippet\n                             apr_array_header_t *fixup, int early)\n{\n    echo_do v;\n    int i;\n    const char *val;\n\n    for (i = 0; i < fixup->nelts; ++i) {\n        header_entry *hdr = &((header_entry *) (fixup->elts))[i];\n        const char *envar = hdr->condition_var;\n\n        \n        if (!early && (envar == condition_early)) {\n            continue;\n        }\n        \n        else if (early && (envar != condition_early)) {\n            continue;\n        }\n        \n        else if (hdr->expr != NULL) {\n            const char *err = NULL;\n            int eval = ap_expr_exec(r, hdr->expr, &err);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01501)\n                              \"Failed to evaluate expression (%s) - ignoring\",\n                              err);\n            }\n            else if (!eval) {\n                continue;\n            }\n        }\n        \n        else if (envar && !early) {\n            if (*envar != '!') {\n                if (apr_table_get(r->subprocess_env, envar) == NULL)\n                    continue;\n            }\n            else {\n                if (apr_table_get(r->subprocess_env, &envar[1]) != NULL)\n                    continue;\n            }\n        }\n\n        switch (hdr->action) {\n        case hdr_add:\n            apr_table_addn(headers, hdr->header, process_tags(hdr, r));\n            break;\n        case hdr_append:\n            apr_table_mergen(headers, hdr->header, process_tags(hdr, r));\n            break;\n        case hdr_merge:\n            val = apr_table_get(headers, hdr->header);\n            if (val == NULL) {\n                apr_table_addn(headers, hdr->header, process_tags(hdr, r));\n            } else {\n                char *new_val = process_tags(hdr, r);\n                apr_size_t new_val_len = strlen(new_val);\n                int tok_found = 0;\n\n                \n                while (*val) {\n                    const char *tok_start;\n\n                    while (apr_isspace(*val))\n                        ++val;\n\n                    tok_start = val;\n\n                    while (*val && *val != ',') {\n                        if (*val++ == '\"')\n                            while (*val)\n                                if (*val++ == '\"')\n                                    break;\n                    }\n\n                    if (new_val_len == (apr_size_t)(val - tok_start)\n                        && !strncmp(tok_start, new_val, new_val_len)) {\n                        tok_found = 1;\n                        break;\n                    }\n\n                    if (*val)\n                        ++val;\n                }\n\n                if (!tok_found) {\n                    apr_table_mergen(headers, hdr->header, new_val);\n                }\n            }\n            break;\n        case hdr_set:\n            if (!strcasecmp(hdr->header, \"Content-Type\")) {\n                 ap_set_content_type(r, process_tags(hdr, r));\n            }\n            apr_table_setn(headers, hdr->header, process_tags(hdr, r));\n            break;\n        case hdr_setifempty:\n            if (NULL == apr_table_get(headers, hdr->header)) {\n                if (!strcasecmp(hdr->header, \"Content-Type\")) {\n                    ap_set_content_type(r, process_tags(hdr, r));\n                }\n                apr_table_setn(headers, hdr->header, process_tags(hdr, r));\n            }\n            break;\n        case hdr_unset:\n            apr_table_unset(headers, hdr->header);\n            break;\n        case hdr_echo:\n            v.r = r;\n            v.hdr = hdr;\n            apr_table_do((int (*) (void *, const char *, const char *))\n                         echo_header, (void *) &v, r->headers_in, NULL);\n            break;\n        case hdr_edit:\n        case hdr_edit_r:\n            if (!strcasecmp(hdr->header, \"Content-Type\") && r->content_type) {\n                const char *repl = process_regexp(hdr, r->content_type, r);\n                if (repl == NULL)\n                    return 0;\n                ap_set_content_type(r, repl);\n            }\n            if (apr_table_get(headers, hdr->header)) {\n                edit_do ed;\n\n                ed.r = r;\n                ed.hdr = hdr;\n                ed.t = apr_table_make(r->pool, 5);\n                if (!apr_table_do(edit_header, (void *) &ed, headers,\n                                  hdr->header, NULL))\n                    return 0;\n                apr_table_unset(headers, hdr->header);\n                apr_table_do(add_them_all, (void *) headers, ed.t, NULL);\n            }\n            break;\n        case hdr_note:\n            apr_table_setn(r->notes, process_tags(hdr, r), apr_table_get(headers, hdr->header));\n            break;\n \n        }\n    }\n    return 1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_913095bd77cb60057c83c1232b97f9b678ba207a_0", {
    "ID": "httpd_913095bd77cb60057c83c1232b97f9b678ba207a_0",
    "UID": "4289",
    "code": "static void process_socket(apr_thread_t *thd, apr_pool_t * p, apr_socket_t * test_snippet\n                          event_conn_state_t * cs, int my_child_num,\n                          int my_thread_num)\n{\n    conn_rec *c;\n    long conn_id = ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);\n    int rc;\n    ap_sb_handle_t *sbh;\n\n    \n    ap_create_sb_handle(&sbh, p, my_child_num, my_thread_num);\n\n    if (cs == NULL) {           \n        listener_poll_type *pt = apr_pcalloc(p, sizeof(*pt));\n        cs = apr_pcalloc(p, sizeof(event_conn_state_t));\n        cs->bucket_alloc = apr_bucket_alloc_create(p);\n        c = ap_run_create_connection(p, ap_server_conf, test_snippet\n                                     conn_id, sbh, cs->bucket_alloc);\n        if (!c) {\n            apr_bucket_alloc_destroy(cs->bucket_alloc);\n            apr_pool_clear(p);\n            ap_push_pool(worker_queue_info, p);\n            return;\n        }\n        apr_atomic_inc32(&connection_count);\n        apr_pool_cleanup_register(c->pool, cs, decrement_connection_count,\n                                  apr_pool_cleanup_null);\n        ap_set_module_config(c->conn_config, &mpm_event_module, cs);\n        c->current_thread = thd;\n        cs->c = c;\n        c->cs = &(cs->pub);\n        cs->p = p;\n        cs->pfd.desc_type = APR_POLL_SOCKET;\n        cs->pfd.reqevents = APR_POLLIN;\n        cs->pfd.desc.s = sock;\n        pt->type = PT_CSD;\n        pt->baton = cs;\n        cs->pfd.client_data = pt;\n        apr_pool_pre_cleanup_register(p, cs, ptrans_pre_cleanup);\n        TO_QUEUE_ELEM_INIT(cs);\n\n        ap_update_vhost_given_ip(c);\n\n        rc = ap_run_pre_connection(c, sock);\n        if (rc != OK && rc != DONE) {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(00469)\n                          \"process_socket: connection aborted\");\n            c->aborted = 1;\n        }\n\n        /**\n         * XXX If the platform does not have a usable way of bundling\n         * accept() with a socket readability check, like Win32,\n         * and there are measurable delays before the\n         * socket is readable due to the first data packet arriving,\n         * it might be better to create the cs on the listener thread\n         * with the state set to CONN_STATE_CHECK_REQUEST_LINE_READABLE\n         *\n         * FreeBSD users will want to enable the HTTP accept filter\n         * module in their kernel for the highest performance\n         * When the accept filter is active, sockets are kept in the\n         * kernel until a HTTP request is received.\n         */\n        cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n\n        cs->pub.sense = CONN_SENSE_DEFAULT;\n    }\n    else {\n        c = cs->c;\n        c->sbh = sbh;\n        notify_resume(cs);\n        c->current_thread = thd;\n    }\n\n    if (c->clogging_input_filters && !c->aborted) {\n        /* Since we have an input filter which 'clogs' the input stream,\n         * like mod_ssl used to, lets just do the normal read from input\n         * filters, like the Worker MPM does. Filters that need to write\n         * where they would otherwise read, or read where they would\n         * otherwise write, should set the sense appropriately.\n         */\n        apr_atomic_inc32(&clogged_count);\n        ap_run_process_connection(c);\n        if (cs->pub.state != CONN_STATE_SUSPENDED) {\n            cs->pub.state = CONN_STATE_LINGER;\n        }\n        apr_atomic_dec32(&clogged_count);\n    }\n\nread_request:\n    if (cs->pub.state == CONN_STATE_READ_REQUEST_LINE) {\n        if (!c->aborted) {\n            ap_run_process_connection(c);\n\n            /* state will be updated upon return\n             * fall thru to either wait for readability/timeout or\n             * do lingering close\n             */\n        }\n        else {\n            cs->pub.state = CONN_STATE_LINGER;\n        }\n    }\n\n    if (cs->pub.state == CONN_STATE_WRITE_COMPLETION) {\n        ap_filter_t *output_filter = c->output_filters;\n        apr_status_t rv;\n        ap_update_child_status_from_conn(sbh, SERVER_BUSY_WRITE, c);\n        while (output_filter->next != NULL) {\n            output_filter = output_filter->next;\n        }\n        rv = output_filter->frec->filter_func.out_func(output_filter, NULL);\n        if (rv != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00470)\n                          \"network write failure in core output filter\");\n            cs->pub.state = CONN_STATE_LINGER;\n        }\n        else if (c->data_in_output_filters) {\n            /* Still in WRITE_COMPLETION_STATE:\n             * Set a write timeout for this connection, and let the\n             * event thread poll for writeability.\n             */\n            cs->expiration_time = ap_server_conf->timeout + apr_time_now();\n            c->sbh = NULL;\n            notify_suspend(cs);\n            apr_thread_mutex_lock(timeout_mutex);\n            TO_QUEUE_APPEND(write_completion_q, cs);\n            cs->pfd.reqevents = (\n                    cs->pub.sense == CONN_SENSE_WANT_READ ? APR_POLLIN :\n                            APR_POLLOUT) | APR_POLLHUP | APR_POLLERR;\n            cs->pub.sense = CONN_SENSE_DEFAULT;\n            rc = apr_pollset_add(event_pollset, &cs->pfd);\n            apr_thread_mutex_unlock(timeout_mutex);\n            return;\n        }\n        else if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted ||\n            listener_may_exit) {\n            cs->pub.state = CONN_STATE_LINGER;\n        }\n        else if (c->data_in_input_filters) {\n            cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n            goto read_request;\n        }\n        else {\n            cs->pub.state = CONN_STATE_CHECK_REQUEST_LINE_READABLE;\n        }\n    }\n\n    if (cs->pub.state == CONN_STATE_LINGER) {\n        if (!start_lingering_close_blocking(cs)) {\n            c->sbh = NULL;\n            notify_suspend(cs);\n            return;\n        }\n    }\n    else if (cs->pub.state == CONN_STATE_CHECK_REQUEST_LINE_READABLE) {\n        /* It greatly simplifies the logic to use a single timeout value here\n         * because the new element can just be added to the end of the list and\n         * it will stay sorted in expiration time sequence.  If brand new\n         * sockets are sent to the event thread for a readability check, this\n         * will be a slight behavior change - they use the non-keepalive\n         * timeout today.  With a normal client, the socket will be readable in\n         * a few milliseconds anyway.\n         */\n        cs->expiration_time = ap_server_conf->keep_alive_timeout +\n                              apr_time_now();\n        c->sbh = NULL;\n        notify_suspend(cs);\n        apr_thread_mutex_lock(timeout_mutex);\n        TO_QUEUE_APPEND(keepalive_q, cs);\n\n        \n        cs->pfd.reqevents = APR_POLLIN;\n        rc = apr_pollset_add(event_pollset, &cs->pfd);\n        apr_thread_mutex_unlock(timeout_mutex);\n\n        if (rc != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf,\n                         \"process_socket: apr_pollset_add failure\");\n            AP_DEBUG_ASSERT(rc == APR_SUCCESS);\n        }\n        return;\n    }\n    else if (cs->pub.state == CONN_STATE_SUSPENDED) {\n        apr_atomic_inc32(&suspended_count);\n    }\n    /*\n     * Prevent this connection from writing to our connection state after it\n     * is no longer associated with this thread. This would happen if the EOR\n     * bucket is destroyed from the listener thread due to a connection abort\n     * or timeout.\n     */\n    c->sbh = NULL;\n    notify_suspend(cs);\n    return;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d793677d04bc75944d7bb97c377ffcd42e8e66a0_0", {
    "ID": "httpd_d793677d04bc75944d7bb97c377ffcd42e8e66a0_0",
    "UID": "4294",
    "code": "AP_DECLARE(int) ap_location_walk(request_rec test_snippet\n{\n    ap_conf_vector_t *now_merged = NULL;\n    core_server_config *sconf =\n        ap_get_core_module_config(r->server->module_config);\n    ap_conf_vector_t **sec_ent = (ap_conf_vector_t **)sconf->sec_url->elts;\n    int num_sec = sconf->sec_url->nelts;\n    walk_cache_t *cache;\n    const char *entry_uri;\n    int cached;\n\n    /* No tricks here, there are no <Locations > to parse in this vhost.\n     * We won't destroy the cache, just in case _this_ redirect is later\n     * redirected again to a vhost with <Location > blocks to optimize.\n     */\n    if (!num_sec) {\n        return OK;\n    }\n\n    cache = prep_walk_cache(AP_NOTE_LOCATION_WALK, r);\n    cached = (cache->cached != NULL);\n\n    /* Location and LocationMatch differ on their behaviour w.r.t. multiple\n     * slashes.  Location matches multiple slashes with a single slash,\n     * LocationMatch doesn't.  An exception, for backwards brokenness is\n     * absoluteURIs... in which case neither match multiple slashes.\n     */\n    if (r->uri[0] != '/') {\n        entry_uri = r->uri;\n    }\n    else {\n        char *uri = apr_pstrdup(r->pool, r->uri);\n        ap_no2slash(uri);\n        entry_uri = uri;\n    }\n\n    /* If we have an cache->cached location that matches r->uri,\n     * and the vhost's list of locations hasn't changed, we can skip\n     * rewalking the location_walk entries.\n     */\n    if (cached\n        && (cache->dir_conf_tested == sec_ent)\n        && (strcmp(entry_uri, cache->cached) == 0)) {\n        /* Well this looks really familiar!  If our end-result (per_dir_result)\n         * didn't change, we have absolutely nothing to do :)\n         * Otherwise (as is the case with most dir_merged/file_merged requests)\n         * we must merge our dir_conf_merged onto this new r->per_dir_config.\n         */\n        if (r->per_dir_config == cache->per_dir_result) {\n            return OK;\n        }\n\n        if (cache->walked->nelts) {\n            now_merged = ((walk_walked_t*)cache->walked->elts)\n                                            [cache->walked->nelts - 1].merged;\n        }\n    }\n    else {\n        /* We start now_merged from NULL since we want to build\n         * a locations list that can be merged to any vhost.\n         */\n        int len, sec_idx;\n        int matches = cache->walked->nelts;\n        int cached_matches = matches;\n        walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;\n        apr_pool_t *rxpool = NULL;\n\n        cached &= auth_internal_per_conf;\n        cache->cached = entry_uri;\n\n        /* Go through the location entries, and check for matches.\n         * We apply the directive sections in given order, we should\n         * really try them with the most general first.\n         */\n        for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {\n\n            core_dir_config *entry_core;\n            entry_core = ap_get_core_module_config(sec_ent[sec_idx]);\n\n            \n            len = strlen(entry_core->d);\n\n            /* Test the regex, fnmatch or string as appropriate.\n             * If it's a strcmp, and the <Location > pattern was\n             * not slash terminated, then this uri must be slash\n             * terminated (or at the end of the string) to match.\n             */\n            if (entry_core->r) {\n\n                int nmatch = 0;\n                int i;\n                ap_regmatch_t *pmatch = NULL;\n\n                if (entry_core->refs && entry_core->refs->nelts) {\n                    if (!rxpool) {\n                        apr_pool_create(&rxpool, r->pool);\n                    }\n                    nmatch = entry_core->refs->nelts;\n                    pmatch = apr_palloc(rxpool, nmatch*sizeof(ap_regmatch_t));\n                }\n\n                if (ap_regexec(entry_core->r, r->uri, nmatch, pmatch, 0)) {\n                    continue;\n                }\n\n                for (i = 0; i < nmatch; i++) {\n                    if (pmatch[i].rm_so >= 0 && pmatch[i].rm_eo >= 0 && \n                        ((const char **)entry_core->refs->elts)[i]) {\n                        apr_table_setn(r->subprocess_env,\n                                       ((const char **)entry_core->refs->elts)[i],\n                                       apr_pstrndup(r->pool,\n                                       r->uri + pmatch[i].rm_so,\n                                       pmatch[i].rm_eo - pmatch[i].rm_so));\n                    }\n                }\n\n            }\n            else {\n\n                if ((entry_core->d_is_fnmatch\n                   ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)\n                   : (strncmp(entry_core->d, cache->cached, len)\n                      || (len > 0\n                          && entry_core->d[len - 1] != '/'\n                          && cache->cached[len] != '/'\n                          && cache->cached[len] != '\\0')))) {\n                    continue;\n                }\n\n            }\n\n            /* If we merged this same section last time, reuse it\n             */\n            if (matches) {\n                if (last_walk->matched == sec_ent[sec_idx]) {\n                    now_merged = last_walk->merged;\n                    ++last_walk;\n                    --matches;\n                    continue;\n                }\n\n                /* We fell out of sync.  This is our own copy of walked,\n                 * so truncate the remaining matches and reset remaining.\n                 */\n                cache->walked->nelts -= matches;\n                matches = 0;\n                cached = 0;\n            }\n\n            if (now_merged) {\n                now_merged = ap_merge_per_dir_configs(r->pool,\n                                                      now_merged,\n                                                      sec_ent[sec_idx]);\n            }\n            else {\n                now_merged = sec_ent[sec_idx];\n            }\n\n            last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n            last_walk->matched = sec_ent[sec_idx];\n            last_walk->merged = now_merged;\n        }\n\n        if (rxpool) {\n            apr_pool_destroy(rxpool);\n        }\n\n        /* Whoops - everything matched in sequence, but either the original\n         * walk found some additional matches (which we need to truncate), or\n         * this walk found some additional matches.\n         */\n        if (matches) {\n            cache->walked->nelts -= matches;\n            cached = 0;\n        }\n        else if (cache->walked->nelts > cached_matches) {\n            cached = 0;\n        }\n    }\n\n    if (cached\n        && r->per_dir_config == cache->dir_conf_merged) {\n        r->per_dir_config = cache->per_dir_result;\n        return OK;\n    }\n\n    cache->dir_conf_tested = sec_ent;\n    cache->dir_conf_merged = r->per_dir_config;\n\n    /* Merge our cache->dir_conf_merged construct with the r->per_dir_configs,\n     * and note the end result to (potentially) skip this step next time.\n     */\n    if (now_merged) {\n        r->per_dir_config = ap_merge_per_dir_configs(r->pool,\n                                                     r->per_dir_config,\n                                                     now_merged);\n    }\n    cache->per_dir_result = r->per_dir_config;\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n476,NULL Pointer Dereference"
  },
  "httpd_81abdc6a5f7517b2fc5b54a2c49b079700ef3ed4_0", {
    "ID": "httpd_81abdc6a5f7517b2fc5b54a2c49b079700ef3ed4_0",
    "UID": "4320",
    "code": "static int apply_rewrite_list(request_rec *r, apr_array_header_t test_snippet\n                              char *perdir)\n{\n    rewriterule_entry *entries;\n    rewriterule_entry *p;\n    int i;\n    int changed;\n    int rc;\n    int s;\n    rewrite_ctx *ctx;\n    int round = 1;\n\n    ctx = apr_palloc(r->pool, sizeof(*ctx));\n    ctx->perdir = perdir;\n    ctx->r = r;\n\n    /*\n     *  Iterate over all existing rules\n     */\n    entries = (rewriterule_entry *)rewriterules->elts;\n    changed = 0;\n    loop:\n    for (i = 0; i < rewriterules->nelts; i++) {\n        p = &entries[i];\n\n        /*\n         *  Ignore this rule on subrequests if we are explicitly\n         *  asked to do so or this is a proxy-throughput or a\n         *  forced redirect rule.\n         */\n        if (r->main != NULL &&\n            (p->flags & RULEFLAG_IGNOREONSUBREQ ||\n             p->flags & RULEFLAG_FORCEREDIRECT    )) {\n            continue;\n        }\n\n        /*\n         *  Apply the current rule.\n         */\n        ctx->vary = NULL;\n        rc = apply_rewrite_rule(p, ctx);\n\n        if (rc) {\n            /* Regardless of what we do next, we've found a match. Check to see\n             * if any of the request header fields were involved, and add them\n             * to the Vary field of the response.\n             */\n            if (ctx->vary) {\n                apr_table_merge(r->headers_out, \"Vary\", ctx->vary);\n            }\n\n            /*\n             * The rule sets the response code (implies match-only)\n             */\n            if (p->flags & RULEFLAG_STATUS) {\n                return ACTION_STATUS;\n            }\n\n            /*\n             * Indicate a change if this was not a match-only rule.\n             */\n            if (rc != 2) {\n                changed = ((p->flags & RULEFLAG_NOESCAPE)\n                           ? ACTION_NOESCAPE : ACTION_NORMAL);\n            }\n\n            /*\n             *  Pass-Through Feature (`RewriteRule .. .. [PT]'):\n             *  Because the Apache 1.x API is very limited we\n             *  need this hack to pass the rewritten URL to other\n             *  modules like mod_alias, mod_userdir, etc.\n             */\n            if (p->flags & RULEFLAG_PASSTHROUGH) {\n                rewritelog((r, 2, perdir, \"forcing '%s' to get passed through \"\n                           \"to next API URI-to-filename handler\", r->filename));\n                r->filename = apr_pstrcat(r->pool, \"passthrough:\",\n                                         r->filename, NULL);\n                changed = ACTION_NORMAL;\n                break;\n            }\n\n            if (p->flags & RULEFLAG_END) {\n                rewritelog((r, 8, perdir, \"Rule has END flag, no further rewriting for this request\"));\n                apr_pool_userdata_set(\"1\", really_last_key, apr_pool_cleanup_null, r->pool);\n                break;\n            }\n            /*\n             *  Stop processing also on proxy pass-through and\n             *  last-rule and new-round flags.\n             */\n            if (p->flags & (RULEFLAG_PROXY | RULEFLAG_LASTRULE)) {\n                break;\n            }\n\n            /*\n             *  On \"new-round\" flag we just start from the top of\n             *  the rewriting ruleset again.\n             */\n            if (p->flags & RULEFLAG_NEWROUND) {\n                if (++round >= p->maxrounds) { \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02596)\n                                  \"RewriteRule '%s' and URI '%s' exceeded \"\n                                  \"maximum number of rounds (%d) via the [N] flag\", \n                                  p->pattern, r->uri, p->maxrounds);\n\n                    r->status = HTTP_INTERNAL_SERVER_ERROR;\n                    return ACTION_STATUS; \n                }\n                goto loop;\n            }\n\n            /*\n             *  If we are forced to skip N next rules, do it now.\n             */\n            if (p->skip > 0) {\n                s = p->skip;\n                while (   i < rewriterules->nelts\n                       && s > 0) {\n                    i++;\n                    s--;\n                }\n            }\n        }\n        else {\n            /*\n             *  If current rule is chained with next rule(s),\n             *  skip all this next rule(s)\n             */\n            while (   i < rewriterules->nelts\n                   && p->flags & RULEFLAG_CHAIN) {\n                i++;\n                p = &entries[i];\n            }\n        }\n    }\n    return changed;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n606,Unchecked Input for Loop Condition"
  },
  "httpd_ecd29a3f639d43afe09d36d1d8aa394b46056fca_0", {
    "ID": "httpd_ecd29a3f639d43afe09d36d1d8aa394b46056fca_0",
    "UID": "4322",
    "code": "static const char *user_parse_config(cmd_parms *cmd, const char test_snippet\n                                     const void **parsed_require_line)\n{\n    const char *expr_err = NULL;\n    ap_expr_info_t *expr = apr_pcalloc(cmd->pool, sizeof(*expr));\n\n    expr = ap_expr_parse_cmd(cmd, require_line, AP_EXPR_FLAG_STRING_RESULT,\n            &expr_err, NULL);\n\n    if (expr_err)\n        return apr_pstrcat(cmd->temp_pool,\n                           \"Cannot parse expression in require line: \",\n                           expr_err, NULL);\n\n    *parsed_require_line = expr;\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_0d96feccab54ff4f0217720c145f539487e9da38_0", {
    "ID": "httpd_0d96feccab54ff4f0217720c145f539487e9da38_0",
    "UID": "4328",
    "code": "static int proxy_trans(request_rec test_snippet\n{\n    int i;\n    struct proxy_alias *ent;\n    proxy_dir_conf *dconf;\n    proxy_server_conf *conf;\n\n    if (r->proxyreq) {\n        /* someone has already set up the proxy, it was possibly ourselves\n         * in proxy_detect\n         */\n        return OK;\n    }\n\n    if ((r->unparsed_uri[0] == '*' && r->unparsed_uri[1] == '\\0')\n        || !r->uri || r->uri[0] != '/') {\n        return DECLINED;\n    }\n\n    /* XXX: since r->uri has been manipulated already we're not really\n     * compliant with RFC1945 at this point.  But this probably isn't\n     * an issue because this is a hybrid proxy/origin server.\n     */\n\n    dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n    conf = (proxy_server_conf *) ap_get_module_config(r->server->module_config,\n                                                      &proxy_module);\n    \n    if (dconf->alias) {\n        int rv = ap_proxy_trans_match(r, dconf->alias, dconf);\n        if (OK == rv) { \n            \n            if (conf->aliases->nelts) {\n                ent = (struct proxy_alias *) conf->aliases->elts;\n                for (i = 0; i < conf->aliases->nelts; i++) {\n                    int rv = ap_proxy_trans_match(r, &ent[i], dconf);\n                    if (DECLINED == rv) { \n                        return DECLINED;\n                    }\n                }\n            }\n            return OK; \n        }\n        if (DONE != rv) {\n            return rv;\n        }\n    }\n\n    \n    if (conf->aliases->nelts) {\n        ent = (struct proxy_alias *) conf->aliases->elts;\n        for (i = 0; i < conf->aliases->nelts; i++) {\n            int rv = ap_proxy_trans_match(r, &ent[i], dconf);\n            if (DONE != rv) {\n                return rv;\n            }\n        }\n    }\n    return DECLINED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_ec1992639cef5145558d6b0893be2f37c29bdf12_0", {
    "ID": "httpd_ec1992639cef5145558d6b0893be2f37c29bdf12_0",
    "UID": "4331",
    "code": "AP_DECLARE(int) ap_process_request_internal(request_rec test_snippet\n{\n    int file_req = (r->main && r->filename);\n    int access_status;\n    core_dir_config *d;\n\n    \n    if (!r->proxyreq && r->parsed_uri.path) {\n        d = ap_get_core_module_config(r->per_dir_config);\n        if (d->allow_encoded_slashes) {\n            access_status = ap_unescape_url_keep2f(r->parsed_uri.path, d->decode_encoded_slashes);\n        }\n        else {\n            access_status = ap_unescape_url(r->parsed_uri.path);\n        }\n        if (access_status) {\n            if (access_status == HTTP_NOT_FOUND) {\n                if (! d->allow_encoded_slashes) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00026)\n                                  \"found %%2f (encoded '/') in URI \"\n                                  \"(decoded='%s'), returning 404\",\n                                  r->parsed_uri.path);\n                }\n            }\n            return access_status;\n        }\n    }\n\n    ap_getparents(r->uri);     \n\n    /* All file subrequests are a huge pain... they cannot bubble through the\n     * next several steps.  Only file subrequests are allowed an empty uri,\n     * otherwise let translate_name kill the request.\n     */\n    if (!file_req) {\n        if ((access_status = ap_location_walk(r))) {\n            return access_status;\n        }\n        if ((access_status = ap_if_walk(r))) {\n            return access_status;\n        }\n\n        \n        if (!r->connection->log) {\n            d = ap_get_core_module_config(r->per_dir_config);\n            if (d->log)\n                r->log = d->log;\n        }\n\n        if ((access_status = ap_run_translate_name(r))) {\n            return decl_die(access_status, \"translate\", r);\n        }\n    }\n\n    /* Reset to the server default config prior to running map_to_storage\n     */\n    r->per_dir_config = r->server->lookup_defaults;\n\n    if ((access_status = ap_run_map_to_storage(r))) {\n        \n        return access_status;\n    }\n\n    /* Rerun the location walk, which overrides any map_to_storage config.\n     */\n    if ((access_status = ap_location_walk(r))) {\n        return access_status;\n    }\n    if ((access_status = ap_if_walk(r))) {\n        return access_status;\n    }\n\n    \n    if (!r->connection->log) {\n        d = ap_get_core_module_config(r->per_dir_config);\n        if (d->log)\n            r->log = d->log;\n    }\n\n    if ((access_status = ap_run_post_perdir_config(r))) {\n        return access_status;\n    }\n\n    \n    if (r->main == NULL) {\n        if ((access_status = ap_run_header_parser(r))) {\n            return access_status;\n        }\n    }\n\n    /* Skip authn/authz if the parent or prior request passed the authn/authz,\n     * and that configuration didn't change (this requires optimized _walk()\n     * functions in map_to_storage that use the same merge results given\n     * identical input.)  If the config changes, we must re-auth.\n     */\n    if (r->prev && (r->prev->per_dir_config == r->per_dir_config)) {\n        r->user = r->prev->user;\n        r->ap_auth_type = r->prev->ap_auth_type;\n    }\n    else if (r->main && (r->main->per_dir_config == r->per_dir_config)) {\n        r->user = r->main->user;\n        r->ap_auth_type = r->main->ap_auth_type;\n    }\n    else {\n        switch (ap_satisfies(r)) {\n        case SATISFY_ALL:\n        case SATISFY_NOSPEC:\n            if ((access_status = ap_run_access_checker(r)) != OK) {\n                return decl_die(access_status,\n                                \"check access (with Satisfy All)\", r);\n            }\n\n            access_status = ap_run_access_checker_ex(r);\n            if (access_status == OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                              \"request authorized without authentication by \"\n                              \"access_checker_ex hook: %s\", r->uri);\n            }\n            else if (access_status != DECLINED) {\n                return decl_die(access_status, \"check access\", r);\n            }\n            else {\n                if ((access_status = ap_run_check_user_id(r)) != OK) {\n                    return decl_die(access_status, \"check user\", r);\n                }\n                if (r->user == NULL) {\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00027)\n                                  \"No authentication done but request not \"\n                                  \"allowed without authentication for %s. \"\n                                  \"Authentication not configured?\",\n                                  r->uri);\n                    access_status = HTTP_INTERNAL_SERVER_ERROR;\n                    return decl_die(access_status, \"check user\", r);\n                }\n                if ((access_status = ap_run_auth_checker(r)) != OK) {\n                    return decl_die(access_status, \"check authorization\", r);\n                }\n            }\n            break;\n        case SATISFY_ANY:\n            if ((access_status = ap_run_access_checker(r)) == OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                              \"request authorized without authentication by \"\n                              \"access_checker hook and 'Satisfy any': %s\",\n                              r->uri);\n                break;\n            }\n\n            access_status = ap_run_access_checker_ex(r);\n            if (access_status == OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                              \"request authorized without authentication by \"\n                              \"access_checker_ex hook: %s\", r->uri);\n            }\n            else if (access_status != DECLINED) {\n                return decl_die(access_status, \"check access\", r);\n            }\n            else {\n                if ((access_status = ap_run_check_user_id(r)) != OK) {\n                    return decl_die(access_status, \"check user\", r);\n                }\n                if (r->user == NULL) {\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00028)\n                                  \"No authentication done but request not \"\n                                  \"allowed without authentication for %s. \"\n                                  \"Authentication not configured?\",\n                                  r->uri);\n                    access_status = HTTP_INTERNAL_SERVER_ERROR;\n                    return decl_die(access_status, \"check user\", r);\n                }\n                if ((access_status = ap_run_auth_checker(r)) != OK) {\n                    return decl_die(access_status, \"check authorization\", r);\n                }\n            }\n            break;\n        }\n    }\n    /* XXX Must make certain the ap_run_type_checker short circuits mime\n     * in mod-proxy for r->proxyreq && r->parsed_uri.scheme\n     *                              && !strcmp(r->parsed_uri.scheme, \"http\")\n     */\n    if ((access_status = ap_run_type_checker(r)) != OK) {\n        return decl_die(access_status, \"find types\", r);\n    }\n\n    if ((access_status = ap_run_fixups(r)) != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r, \"fixups hook gave %d: %s\",\n                      access_status, r->uri);\n        return access_status;\n    }\n\n    return OK;\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_e3dc5b3853413feb22c4ba0c14d8f48569461ede_0", {
    "ID": "httpd_e3dc5b3853413feb22c4ba0c14d8f48569461ede_0",
    "UID": "4336",
    "code": "AP_DECLARE(void) ap_set_module_loglevel(apr_pool_t *pool, struct ap_logconf test_snippet\n                                        int index, int level)\n{\n    if (!l->module_levels) {\n        l->module_levels = apr_palloc(pool, conf_vector_length);\n        if (l->level == APLOG_UNSET) {\n                ap_reset_module_loglevels(l, APLOG_UNSET);\n        }\n        else {\n                ap_reset_module_loglevels(l, APLOG_NO_MODULE);\n        }\n    }\n\n    l->module_levels[index] = level;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference"
  },
  "httpd_20d4bda083542e4a6804aed6306eb8e6801483d4_0", {
    "ID": "httpd_20d4bda083542e4a6804aed6306eb8e6801483d4_0",
    "UID": "4337",
    "code": "static const char *update_loglevel(cmd_parms *cmd, struct ap_logconf test_snippet\n                                   const char *arg)\n{\n    const char *level_str, *err;\n    module *module;\n    int level;\n\n    level_str = ap_strrchr_c(arg, ':');\n\n    if (level_str == NULL) {\n        err = ap_parse_log_level(arg, &log->level);\n        if (err != NULL)\n            return err;\n        ap_reset_module_loglevels(log, APLOG_NO_MODULE);\n        ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                     \"Setting %s for all modules to %s\", cmd->cmd->name, arg);\n        return NULL;\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, level_str - arg);\n    level_str++;\n    if (!*level_str) {\n        return apr_psprintf(cmd->temp_pool, \"Module specifier '%s' must be \"\n                            \"followed by a log level keyword\", arg);\n    }\n\n    err = ap_parse_log_level(level_str, &level);\n    if (err != NULL)\n        return apr_psprintf(cmd->temp_pool, \"%s:%s: %s\", arg, level_str, err);\n\n    if ((module = find_module(cmd->server, arg)) == NULL) {\n        char *name = apr_psprintf(cmd->temp_pool, \"%s_module\", arg);\n        ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, cmd->server,\n                     \"Cannot find module '%s', trying '%s'\", arg, name);\n        module = find_module(cmd->server, name);\n    }\n\n    if (module == NULL) {\n        return apr_psprintf(cmd->temp_pool, \"Cannot find module %s\", arg);\n    }\n\n    ap_set_module_loglevel(cmd->pool, log, module->module_index, level);\n    ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                 \"Setting %s for module %s to %s\", cmd->cmd->name,\n                 module->name, level_str);\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2d06a33def60d7db5c83005235d81db5ab64c3bd_0", {
    "ID": "httpd_2d06a33def60d7db5c83005235d81db5ab64c3bd_0",
    "UID": "4338",
    "code": "static const char *set_loglevel_override(cmd_parms *cmd, void *d_, int test_snippet\n                                         char *const argv[])\n{\n    core_server_config *sconf;\n    conn_log_config *entry;\n    int ret, i;\n    const char *addr, *mask, *err;\n\n    if (argc < 2)\n        return \"LogLevelOverride requires at least two arguments\";\n\n    entry = apr_pcalloc(cmd->pool, sizeof(conn_log_config));\n    sconf = ap_get_core_module_config(cmd->server->module_config);\n    if (!sconf->conn_log_level)\n        sconf->conn_log_level = apr_array_make(cmd->pool, 4, sizeof(entry));\n    APR_ARRAY_PUSH(sconf->conn_log_level, conn_log_config *) = entry;\n\n    addr = argv[0];\n    mask = ap_strchr_c(addr, '/');\n    if (mask) {\n        addr = apr_pstrmemdup(cmd->temp_pool, addr, mask - addr);\n        mask++;\n    }\n    ret = apr_ipsubnet_create(&entry->subnet, addr, mask, cmd->pool);\n    if (ret != APR_SUCCESS)\n        return \"parsing of subnet/netmask failed\";\n\n    for (i = 1; i < argc; i++) {\n        if ((err = update_loglevel(cmd, &entry->log, argv[i])) != NULL)\n            return err;\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_15935f971e37c5f27149bf92303dd055a55392d9_0", {
    "ID": "httpd_15935f971e37c5f27149bf92303dd055a55392d9_0",
    "UID": "4345",
    "code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char test_snippet\n                                     apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n\n    while (i < len) {\n        char c = buffer[i];\n\n        ap_xlate_proto_from_ascii(&c, 1);\n\n        \n        if (ctx->state == BODY_CHUNK_END\n                || ctx->state == BODY_CHUNK_END_LF) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            else if (c == CR && ctx->state == BODY_CHUNK_END) {\n                ctx->state = BODY_CHUNK_END_LF;\n            }\n            else {\n                /*\n                 * LF expected.\n                 */\n                return APR_EINVAL;\n            }\n            i++;\n            continue;\n        }\n\n        \n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                /*\n                 * Detect invalid character at beginning. This also works for\n                 * empty chunk size lines.\n                 */\n                return APR_EINVAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(apr_off_t) * 8;\n            ctx->chunk_used = 0;\n        }\n\n        if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_LF) {\n            /*\n             * LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (c == CR) {\n            ctx->state = BODY_CHUNK_LF;\n        }\n        else if (c == ';') {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (ctx->state == BODY_CHUNK_EXT) {\n            /*\n             * Control chars (but tabs) are invalid.\n             */\n            if (c != '\\t' && apr_iscntrl(c)) {\n                return APR_EINVAL;\n            }\n        }\n        else if (c == ' ' || c == '\\t') {\n            ctx->state = BODY_CHUNK_CR;\n        }\n        else if (ctx->state == BODY_CHUNK_CR) {\n            /*\n             * ';', CR or LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (ctx->state == BODY_CHUNK_PART) {\n            int xvalue;\n\n            \n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits < 0) {\n                \n                return APR_ENOSPC;\n            }\n\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                \n                return APR_EINVAL;\n            }\n\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            if (ctx->remaining < 0) {\n                \n                return APR_ENOSPC;\n            }\n        }\n        else {\n            \n            return APR_EGENERAL;\n        }\n\n        i++;\n    }\n\n    \n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_5d289bf89be86c1727a5f4d75cfba66e504d57d4_0", {
    "ID": "httpd_5d289bf89be86c1727a5f4d75cfba66e504d57d4_0",
    "UID": "4350",
    "code": "static const char *add_redirect_internal(cmd_parms test_snippet\n                                         alias_dir_conf *dirconf,\n                                         const char *arg1, const char *arg2,\n                                         const char *arg3, int use_regex)\n{\n    alias_entry *new;\n    server_rec *s = cmd->server;\n    alias_server_conf *serverconf = ap_get_module_config(s->module_config,\n                                                         &alias_module);\n    int status = (int) (long) cmd->info;\n    int grokarg1 = 1;\n    ap_regex_t *regex = NULL;\n    const char *fake = arg2;\n    const char *url = arg3;\n\n    /*\n     * Logic flow:\n     *   Go ahead and try to grok the 1st arg, in case it is a\n     *   Redirect status. Now if we have 3 args, we expect that\n     *   we were able to understand that 1st argument (it's something\n     *   we expected, so if not, then we bail\n     */\n    if (!strcasecmp(arg1, \"permanent\"))\n        status = HTTP_MOVED_PERMANENTLY;\n    else if (!strcasecmp(arg1, \"temp\"))\n        status = HTTP_MOVED_TEMPORARILY;\n    else if (!strcasecmp(arg1, \"seeother\"))\n        status = HTTP_SEE_OTHER;\n    else if (!strcasecmp(arg1, \"gone\")) {\n        status = HTTP_GONE;\n        grokarg1 = -1;\n    }\n    else if (apr_isdigit(*arg1)) {\n        status = atoi(arg1);\n        if (!ap_is_HTTP_REDIRECT(status)) {\n            grokarg1 = -1;\n        }\n    }\n    else {\n        grokarg1 = 0;\n    }\n\n    if (arg3 && !grokarg1)\n        return \"Redirect: invalid first argument (of three)\";\n\n    /*\n     * if we have the 2nd arg and we understand the 1st one as a redirect\n     * status (3xx, but not things like 404 /robots.txt), or if we have the\n     * 1st arg but don't understand it, we use the expression syntax assuming\n     * a path from the location.\n     *\n     * if we understand the first arg but have no second arg, we are dealing\n     * with a status like \"GONE\" or a non-redirect status (e.g. 404, 503).\n     */\n    if (!cmd->path) {\n        \n        ;\n    }\n    else if ((grokarg1 > 0 && arg2 && !arg3) || (!grokarg1 && !arg2)) {\n        const char *expr_err = NULL;\n\n        url = grokarg1 ? arg2 : arg1;\n        dirconf->redirect =\n                ap_expr_parse_cmd(cmd, url, AP_EXPR_FLAG_STRING_RESULT,\n                        &expr_err, NULL);\n        if (expr_err) {\n            return apr_pstrcat(cmd->temp_pool,\n                    \"Cannot parse redirect expression '\", url, \"': \", expr_err,\n                    NULL);\n        }\n\n        dirconf->redirect_status = status;\n        dirconf->redirect_set = 1;\n\n        return NULL;\n\n    }\n    else if (grokarg1 < 0 && !arg2) {\n\n        dirconf->redirect_status = status;\n        dirconf->redirect_set = 1;\n\n        return NULL;\n\n    }\n\n    /*\n     * if we don't have the 3rd arg and we didn't understand the 1st\n     * one, then assume URL-path URL. This also handles case, eg, GONE\n     * we even though we don't have a 3rd arg, we did understand the 1st\n     * one, so we don't want to re-arrange\n     */\n    if (!arg3 && !grokarg1) {\n        fake = arg1;\n        url = arg2;\n    }\n\n    if (use_regex) {\n        regex = ap_pregcomp(cmd->pool, fake, AP_REG_EXTENDED);\n        if (regex == NULL)\n            return \"Regular expression could not be compiled.\";\n    }\n\n    if (ap_is_HTTP_REDIRECT(status)) {\n        if (!url)\n            return \"URL to redirect to is missing\";\n        /* PR#35314: we can allow path components here;\n         * they get correctly resolved to full URLs.\n         */\n        if (!use_regex && !ap_is_url(url) && (url[0] != '/'))\n            return \"Redirect to non-URL\";\n    }\n    else {\n        if (url)\n            return \"Redirect URL not valid for this status\";\n    }\n\n    if (cmd->path)\n        new = apr_array_push(dirconf->redirects);\n    else\n        new = apr_array_push(serverconf->redirects);\n\n    new->fake = fake;\n    new->real = url;\n    new->regexp = regex;\n    new->redir_status = status;\n    return NULL;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_020e63803c31cb39738691c415146baddf018e13_0", {
    "ID": "httpd_020e63803c31cb39738691c415146baddf018e13_0",
    "UID": "4372",
    "code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms test_snippet\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        \n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_cc8dbb3af7b631db061d0d29fab82c2b88014569_0", {
    "ID": "httpd_cc8dbb3af7b631db061d0d29fab82c2b88014569_0",
    "UID": "4392",
    "code": "PROXY_DECLARE(int) ap_proxy_tunnel_run(proxy_tunnel_rec test_snippet\n{\n    int rc = OK;\n    request_rec *r = tunnel->r;\n    apr_pollset_t *pollset = tunnel->pollset;\n    apr_interval_time_t timeout = tunnel->timeout >= 0 ? tunnel->timeout : -1;\n    struct proxy_tunnel_conn *client = tunnel->client, *origin = tunnel->origin;\n    apr_size_t read_buf_size = ap_get_read_buf_size(r);\n    const char *scheme = tunnel->scheme;\n    apr_status_t rv;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(10212)\n                  \"proxy: %s: tunnel running (timeout %\" APR_TIME_T_FMT \".\"\n                                                     \"%\" APR_TIME_T_FMT \")\",\n                  scheme, timeout > 0 ? apr_time_sec(timeout) : timeout,\n                          timeout > 0 ? timeout % APR_USEC_PER_SEC : 0);\n\n    client->pfd->reqevents = 0;\n    origin->pfd->reqevents = 0;\n    add_pollset(pollset, client->pfd, APR_POLLIN);\n    add_pollset(pollset, origin->pfd, APR_POLLIN);\n\n    /* Loop until both directions of the connection are closed,\n     * or a failure occurs.\n     */\n    do {\n        struct proxy_tunnel_conn *in, *out;\n        const apr_pollfd_t *results;\n        apr_int32_t nresults, i;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                      \"proxy: %s: polling client=%hx, origin=%hx\",\n                      scheme, client->pfd->reqevents, origin->pfd->reqevents);\n        do {\n            rv = apr_pollset_poll(pollset, timeout, &nresults, &results);\n        } while (APR_STATUS_IS_EINTR(rv));\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(10213)\n                              \"proxy: %s: polling timeout\", scheme);\n                rc = HTTP_GATEWAY_TIME_OUT;\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10214)\n                              \"proxy: %s: polling failed\", scheme);\n                rc = HTTP_INTERNAL_SERVER_ERROR;\n            }\n            goto cleanup;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, APLOGNO(10215)\n                      \"proxy: %s: woken up, %i result(s)\", scheme, nresults);\n\n        for (i = 0; i < nresults; i++) {\n            const apr_pollfd_t *cur = &results[i];\n            int revents = cur->rtnevents;\n\n            \n            if (cur->desc.s != client->pfd->desc.s\n                    && cur->desc.s != origin->pfd->desc.s) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10222)\n                              \"proxy: %s: unknown socket in pollset\", scheme);\n                rc = HTTP_INTERNAL_SERVER_ERROR;\n                goto cleanup;\n            }\n\n            in = cur->client_data;\n            if (revents & APR_POLLOUT) {\n                in = in->other;\n            }\n            else if (!(revents & (APR_POLLIN | APR_POLLHUP))) {\n                \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10220)\n                              \"proxy: %s: polling events error (%x)\",\n                              scheme, revents);\n                rc = HTTP_INTERNAL_SERVER_ERROR;\n                goto cleanup;\n            }\n            out = in->other;\n\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                          \"proxy: %s: #%i: %s/%hx => %s/%hx: %x\",\n                          scheme, i, in->name, in->pfd->reqevents,\n                          out->name, out->pfd->reqevents, revents);\n\n            if (in->readable && (in->drain || !(revents & APR_POLLOUT))) {\n                int sent = 0;\n\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                              \"proxy: %s: %s is %s\", scheme, in->name,\n                              (revents & APR_POLLOUT) ? \"draining\"\n                                                      : \"readable\");\n\n                rv = ap_proxy_transfer_between_connections(r,\n                                               in->c, out->c,\n                                               in->bb, out->bb,\n                                               in->name, &sent,\n                                               read_buf_size,\n                                               AP_PROXY_TRANSFER_SHOULD_YIELD);\n                if (sent && out == client) {\n                    tunnel->replied = 1;\n                }\n                if (rv != APR_SUCCESS) {\n                    if (APR_STATUS_IS_INCOMPLETE(rv)) {\n                        /* Pause POLLIN while waiting for POLLOUT on the other\n                         * side, hence avoid filling the output filters even\n                         * more and hence blocking there.\n                         */\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                                      \"proxy: %s: %s wait writable\",\n                                      scheme, out->name);\n                        revents &= ~APR_POLLOUT;\n                        in->drain = 1;\n                    }\n                    else if (APR_STATUS_IS_EOF(rv)) {\n                        /* Stop POLLIN and wait for POLLOUT (flush) on the\n                         * other side to shut it down.\n                         */\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                                      \"proxy: %s: %s read shutdown\",\n                                      scheme, in->name);\n                        in->readable = in->drain = 0;\n                    }\n                    else {\n                        \n                        rc = HTTP_INTERNAL_SERVER_ERROR;\n                        goto cleanup;\n                    }\n                    del_pollset(pollset, in->pfd, APR_POLLIN);\n                    sent = 1;\n                }\n                else {\n                    in->drain = 0;\n                }\n\n                if (sent) {\n                    add_pollset(pollset, out->pfd, APR_POLLOUT);\n                }\n            }\n\n            if (revents & APR_POLLOUT) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                              \"proxy: %s: %s is writable\",\n                              scheme, out->name);\n\n                rv = ap_filter_output_pending(out->c);\n                if (rv == DECLINED) {\n                    /* No more pending data. If the 'in' side is not readable\n                     * anymore it's time to shutdown for write (this direction\n                     * is over). Otherwise draining (if any) is done, back to\n                     * normal business.\n                     */\n                    if (!in->readable) {\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n                                      \"proxy: %s: %s write shutdown\",\n                                      scheme, out->name);\n                        del_pollset(pollset, out->pfd, APR_POLLOUT);\n                        apr_socket_shutdown(out->pfd->desc.s, 1);\n                    }\n                    else {\n                        add_pollset(pollset, in->pfd, APR_POLLIN);\n                        if (!in->drain) {\n                            del_pollset(pollset, out->pfd, APR_POLLOUT);\n                        }\n                    }\n                }\n                else if (rv != OK) {\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10221)\n                                  \"proxy: %s: %s flushing failed (%i)\",\n                                  scheme, out->name, rv);\n                    rc = HTTP_INTERNAL_SERVER_ERROR;\n                    goto cleanup;\n                }\n            }\n        }\n    } while (client->pfd->reqevents || origin->pfd->reqevents);\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(10223)\n                  \"proxy: %s: tunnel finished\", scheme);\n\ncleanup:\n    del_pollset(pollset, client->pfd, ~0);\n    del_pollset(pollset, origin->pfd, ~0);\n    return rc;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_c8f3c61e511f7038f49d8cacd21c5ca6aeef24e5_0", {
    "ID": "httpd_c8f3c61e511f7038f49d8cacd21c5ca6aeef24e5_0",
    "UID": "4394",
    "code": "AP_DECLARE(char *) ap_strcasestr(const char *s1, const char test_snippet\n{\n    char *p1, *p2;\n    if (*s2 == '\\0') {\n        \n        return((char *)s1);\n    }\n    while(1) {\n        for ( ; (*s1 != '\\0') && (apr_tolower(*s1) != apr_tolower(test_snippet); s1++);\n        if (*s1 == '\\0') {\n            return(NULL);\n        }\n        \n        p1 = (char *)s1;\n        p2 = (char *)s2;\n        for (++p1, ++p2; apr_tolower(*p1) == apr_tolower(*p2); ++p1, ++p2) {\n            if (*p1 == '\\0') {\n                \n                return((char *)s1);\n            }\n        }\n        if (*p2 == '\\0') {\n            \n            break;\n        }\n        \n        s1++;\n    }\n    return((char *)s1);\n}",
    "predicted": "476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_4e4ca643304db6d693801840146530e74097c53b_0", {
    "ID": "httpd_4e4ca643304db6d693801840146530e74097c53b_0",
    "UID": "4405",
    "code": "static proxy_worker *find_session_route(proxy_balancer test_snippet\n                                        request_rec *r,\n                                        char **route,\n                                        const char **sticky_used,\n                                        char **url)\n{\n    proxy_worker *worker = NULL;\n\n    if (!*balancer->s->sticky)\n        return NULL;\n    \n    *route = get_path_param(r->pool, *url, balancer->s->sticky_path, balancer->s->scolonsep);\n    if (*route) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01159)\n                     \"Found value %s for stickysession %s\",\n                     *route, balancer->s->sticky_path);\n        *sticky_used =  balancer->s->sticky_path;\n    }\n    else {\n        *route = get_cookie_param(r, balancer->s->sticky);\n        if (*route) {\n            *sticky_used =  balancer->s->sticky;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01160)\n                         \"Found value %s for stickysession %s\",\n                         *route, balancer->s->sticky);\n        }\n    }\n    /*\n     * If we found a value for stickysession, find the first '.' (or whatever\n     * sticky_separator is set to) within. Everything after '.' (if present)\n     * is our route. \n     */\n    if ((*route) && (balancer->s->sticky_separator != 0) && ((*route = strchr(*route, balancer->s->sticky_separator)) != NULL ))\n        (*route)++;\n    if ((*route) && (**route)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01161) \"Found route %s\", *route);\n        /* We have a route in path or in cookie\n         * Find the worker that has this route defined.\n         */\n        worker = find_route_worker(balancer, *route, r);\n        if (worker && strcmp(*route, worker->s->route)) {\n            /*\n             * Notice that the route of the worker chosen is different from\n             * the route supplied by the client.\n             */\n            apr_table_setn(r->subprocess_env, \"BALANCER_ROUTE_CHANGED\", \"1\");\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01162)\n                          \"Route changed from %s to %s\",\n                          *route, worker->s->route);\n        }\n        return worker;\n    }\n    else\n        return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_4739adaaff938ee4e5f842689ba157ed3626f293_0", {
    "ID": "httpd_4739adaaff938ee4e5f842689ba157ed3626f293_0",
    "UID": "4409",
    "code": "static int proxy_balancer_pre_request(proxy_worker test_snippet\n                                      proxy_balancer **balancer,\n                                      request_rec *r,\n                                      proxy_server_conf *conf, char **url)\n{\n    int access_status;\n    proxy_worker *runtime;\n    char *route = NULL;\n    const char *sticky = NULL;\n    apr_status_t rv;\n\n    *worker = NULL;\n    /* Step 1: check if the url is for us\n     * The url we can handle starts with 'balancer://'\n     * If balancer is already provided skip the search\n     * for balancer, because this is failover attempt.\n     */\n    if (!*balancer &&\n        !(*balancer = ap_proxy_get_balancer(r->pool, conf, *url, 1)))\n        return DECLINED;\n\n    /* Step 2: Lock the LoadBalancer\n     * XXX: perhaps we need the process lock here\n     */\n    if ((rv = PROXY_THREAD_LOCK(*balancer)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01166)\n                      \"%s: Lock failed for pre_request\", (*balancer)->s->name);\n        return DECLINED;\n    }\n\n    \n    force_recovery(*balancer, r->server);\n\n    \n    \n    ap_proxy_sync_balancer(*balancer, r->server, conf);\n\n    \n    runtime = find_session_route(*balancer, r, &route, &sticky, url);\n    if (runtime) {\n        if ((*balancer)->lbmethod && (*balancer)->lbmethod->updatelbstatus) {\n            \n            (*balancer)->lbmethod->updatelbstatus(*balancer, runtime, r->server);\n        }\n        else { \n            int i, total_factor = 0;\n            proxy_worker **workers;\n            /* We have a sticky load balancer\n             * Update the workers status\n             * so that even session routes get\n             * into account.\n             */\n            workers = (proxy_worker **)(*balancer)->workers->elts;\n            for (i = 0; i < (*balancer)->workers->nelts; i++) {\n                /* Take into calculation only the workers that are\n                 * not in error state or not disabled.\n                 */\n                if (PROXY_WORKER_IS_USABLE(*workers)) {\n                    (*workers)->s->lbstatus += (*workers)->s->lbfactor;\n                    total_factor += (*workers)->s->lbfactor;\n                }\n                workers++;\n            }\n            runtime->s->lbstatus -= total_factor;\n        }\n        runtime->s->elected++;\n\n        *worker = runtime;\n    }\n    else if (route && (*balancer)->s->sticky_force) {\n        int i, member_of = 0;\n        proxy_worker **workers;\n        /*\n         * We have a route provided that doesn't match the\n         * balancer name. See if the provider route is the\n         * member of the same balancer in which case return 503\n         */\n        workers = (proxy_worker **)(*balancer)->workers->elts;\n        for (i = 0; i < (*balancer)->workers->nelts; i++) {\n            if (*((*workers)->s->route) && strcmp((*workers)->s->route, route) == 0) {\n                member_of = 1;\n                break;\n            }\n            workers++;\n        }\n        if (member_of) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01167)\n                          \"%s: All workers are in error state for route (%s)\",\n                          (*balancer)->s->name, route);\n            if ((rv = PROXY_THREAD_UNLOCK(*balancer)) != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01168)\n                              \"%s: Unlock failed for pre_request\",\n                              (*balancer)->s->name);\n            }\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n    }\n\n    if ((rv = PROXY_THREAD_UNLOCK(*balancer)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01169)\n                      \"%s: Unlock failed for pre_request\",\n                      (*balancer)->s->name);\n    }\n    if (!*worker) {\n        runtime = find_best_worker(*balancer, r);\n        if (!runtime) {\n            if ((*balancer)->workers->nelts) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01170)\n                              \"%s: All workers are in error state\",\n                              (*balancer)->s->name);\n            } else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01171)\n                              \"%s: No workers in balancer\",\n                              (*balancer)->s->name);\n            }\n\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n        if (*(*balancer)->s->sticky && runtime) {\n            /*\n             * This balancer has sticky sessions and the client either has not\n             * supplied any routing information or all workers for this route\n             * including possible redirect and hotstandby workers are in error\n             * state, but we have found another working worker for this\n             * balancer where we can send the request. Thus notice that we have\n             * changed the route to the backend.\n             */\n            apr_table_setn(r->subprocess_env, \"BALANCER_ROUTE_CHANGED\", \"1\");\n        }\n        *worker = runtime;\n    }\n\n    (*worker)->s->busy++;\n    apr_pool_cleanup_register(r->pool, *worker, decrement_busy_count,\n                              apr_pool_cleanup_null);\n\n    \n    apr_table_setn(r->subprocess_env,\n                   \"BALANCER_NAME\", (*balancer)->s->name);\n    apr_table_setn(r->subprocess_env,\n                   \"BALANCER_WORKER_NAME\", (*worker)->s->name);\n    apr_table_setn(r->subprocess_env,\n                   \"BALANCER_WORKER_ROUTE\", (*worker)->s->route);\n\n    /* Rewrite the url from 'balancer://url'\n     * to the 'worker_scheme://worker_hostname[:worker_port]/url'\n     * This replaces the balancers fictional name with the\n     * real hostname of the elected worker.\n     */\n    access_status = rewrite_url(r, *worker, url);\n    \n    if (route) {\n        apr_table_setn(r->notes, \"session-sticky\", sticky);\n        apr_table_setn(r->notes, \"session-route\", route);\n\n        \n        apr_table_setn(r->subprocess_env,\n                       \"BALANCER_SESSION_STICKY\", sticky);\n        apr_table_setn(r->subprocess_env,\n                       \"BALANCER_SESSION_ROUTE\", route);\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01172)\n                  \"%s: worker (%s) rewritten to %s\",\n                  (*balancer)->s->name, (*worker)->s->name, *url);\n\n    return access_status;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_901e423e1d73866731493661ef83cd302581b11c_0", {
    "ID": "httpd_901e423e1d73866731493661ef83cd302581b11c_0",
    "UID": "4411",
    "code": "test_snippet\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp, *yy_bp;\n\tregister int yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n#line 93 \"util_expr_scan.l\"\n\n\n  char  regex_buf[MAX_STRING_LEN];\n  char *regex_ptr = NULL;\n  char  regex_del = '\\0';\n\n\n /*\n  * Set initial state for string expressions\n  */\n  if (yyextra->at_start) {\n    yyextra->at_start = 0;\n    if (yyextra->flags & AP_EXPR_FLAG_STRING_RESULT) {\n        BEGIN(str);\n        return T_EXPR_STRING;\n    }\n    else {\n        return T_EXPR_BOOL;\n    }\n  }\n\n\n /*\n  * Whitespaces\n  */\n#line 901 \"util_expr_scan.c\"\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tap_expr_yyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t\t}\n\n\t\tap_expr_yy_load_buffer_state(yyscanner );\n\t\t}\n\n\twhile ( 1 )\t\t\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tregister YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 124 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 123 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\ndo_action:\t\n\n\t\tswitch ( yy_act )\n\t{ \n\t\t\tcase 0: \n\t\t\t\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\n\nYY_RULE_SETUP\n#line 118 \"util_expr_scan.l\"\n{ \n    \n}\n\tYY_BREAK\n/*\n  * strings (\"...\" and '...')\n  */\ncase 2:\nYY_RULE_SETUP\n#line 125 \"util_expr_scan.l\"\n{\n    str_ptr = str_buf;\n    str_del = yytext[0];\n    BEGIN(str);\n    return T_STR_BEGIN;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 131 \"util_expr_scan.l\"\n{\n    if (yytext[0] == str_del) {\n        if (YY_START == var) {\n            PERROR(\"Unterminated variable in string\");\n        }\n        else if (str_ptr == str_buf) {\n            BEGIN(INITIAL);\n            return T_STR_END;\n        }\n        else {\n            \n            *str_ptr = '\\0';\n            yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n            yyless(0);\n            str_ptr = str_buf;\n            return T_STRING;\n        }\n    }\n    else {\n        STR_APPEND(yytext[0]);\n    }\n}\n\tYY_BREAK\ncase 4:\n\nYY_RULE_SETUP\n#line 153 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated string or variable\");\n}\n\tYY_BREAK\ncase YY_STATE_EOF(var):\ncase YY_STATE_EOF(vararg):\n#line 156 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated string or variable\");\n}\n\tYY_BREAK\ncase YY_STATE_EOF(str):\n#line 159 \"util_expr_scan.l\"\n{\n    if (!(yyextra->flags & AP_EXPR_FLAG_STRING_RESULT)) {\n        PERROR(\"Unterminated string or variable\");\n    }\n    else {\n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        BEGIN(INITIAL);\n        return T_STRING;\n    }\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 172 \"util_expr_scan.l\"\n{\n    int result;\n\n    (void)sscanf(yytext+1, \"%o\", &result);\n    if (result > 0xff) {\n        PERROR(\"Escape sequence out of bound\");\n    }\n    else {\n        STR_APPEND(result);\n    }\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 183 \"util_expr_scan.l\"\n{\n    PERROR(\"Bad escape sequence\");\n}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 186 \"util_expr_scan.l\"\n{ STR_APPEND('\\n'); }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 187 \"util_expr_scan.l\"\n{ STR_APPEND('\\r'); }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 188 \"util_expr_scan.l\"\n{ STR_APPEND('\\t'); }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 189 \"util_expr_scan.l\"\n{ STR_APPEND('\\b'); }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 190 \"util_expr_scan.l\"\n{ STR_APPEND('\\f'); }\n\tYY_BREAK\ncase 12:\n\nYY_RULE_SETUP\n#line 191 \"util_expr_scan.l\"\n{ STR_APPEND(yytext[1]); }\n\tYY_BREAK\n\ncase 13:\nYY_RULE_SETUP\n#line 194 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        yyless(0);\n        return T_STRING;\n    }\n    else {\n        yylval->num = yytext[1] - '0';\n        return T_REGEX_BACKREF;\n    }\n}\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 209 \"util_expr_scan.l\"\n{\n    char *cp = yytext;\n    while (*cp != '\\0') {\n        STR_APPEND(*cp);\n        cp++;\n    }\n}\n\tYY_BREAK\n\ncase 15:\nYY_RULE_SETUP\n#line 218 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        yyless(0);\n        str_ptr = str_buf;\n        return T_STRING;\n    }\n    else {\n        yy_push_state(var, yyscanner);\n        return T_VAR_BEGIN;\n    }\n}\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 233 \"util_expr_scan.l\"\n{\n     STR_APPEND(yytext[0]);\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 237 \"util_expr_scan.l\"\n{\n     STR_APPEND(yytext[0]);\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 241 \"util_expr_scan.l\"\n{\n    yy_push_state(var, yyscanner);\n    return T_VAR_BEGIN;\n}\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n#line 246 \"util_expr_scan.l\"\n{\n    yylval->num = yytext[1] - '0';\n    return T_REGEX_BACKREF;\n}\n\tYY_BREAK\n/*\n  * fixed name variable expansion %{XXX} and function call in %{func:arg} syntax\n  */\ncase 20:\nYY_RULE_SETUP\n#line 254 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 259 \"util_expr_scan.l\"\n{\n    yy_pop_state(yyscanner);\n    return T_VAR_END;\n}\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 264 \"util_expr_scan.l\"\n{\n    BEGIN(vararg);\n    return yytext[0];\n}\n\tYY_BREAK\ncase 23:\n\nYY_RULE_SETUP\n#line 269 \"util_expr_scan.l\"\n{\n    char *msg = apr_psprintf(yyextra->pool,\n                             \"Invalid character in variable name '%c'\", yytext[0]);\n    PERROR(msg);\n}\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 275 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        yyless(0);\n        return T_STRING;\n    }\n    else {\n        yy_pop_state(yyscanner);\n        return T_VAR_END;\n    }\n}\n\tYY_BREAK\n/*\n  * Regular Expression\n  */\ncase 25:\nYY_RULE_SETUP\n#line 293 \"util_expr_scan.l\"\n{\n    regex_del = yytext[1];\n    regex_ptr = regex_buf;\n    BEGIN(regex);\n}\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 298 \"util_expr_scan.l\"\n{\n    regex_del = yytext[0];\n    regex_ptr = regex_buf;\n    BEGIN(regex);\n}\n\tYY_BREAK\ncase 27:\n\nYY_RULE_SETUP\n#line 303 \"util_expr_scan.l\"\n{\n    if (yytext[0] == regex_del) {\n        *regex_ptr = '\\0';\n        BEGIN(regex_flags);\n    }\n    else {\n        *regex_ptr++ = yytext[0];\n        if (regex_ptr >= regex_buf + sizeof(regex_buf))\n            PERROR(\"Regexp too long\");\n    }\n}\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 314 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    BEGIN(INITIAL);\n    return T_REGEX_I;\n}\n\tYY_BREAK\ncase 29:\n\nYY_RULE_SETUP\n#line 319 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    yyless(0);\n    BEGIN(INITIAL);\n    return T_REGEX;\n}\n\tYY_BREAK\ncase YY_STATE_EOF(regex_flags):\n#line 325 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    BEGIN(INITIAL);\n    return T_REGEX;\n}\n\tYY_BREAK\n/*\n  * Operators\n  */\ncase 30:\nYY_RULE_SETUP\n#line 334 \"util_expr_scan.l\"\n{ return T_OP_STR_EQ; }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n#line 335 \"util_expr_scan.l\"\n{ return T_OP_STR_NE; }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n#line 336 \"util_expr_scan.l\"\n{ return T_OP_STR_LT; }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n#line 337 \"util_expr_scan.l\"\n{ return T_OP_STR_LE; }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n#line 338 \"util_expr_scan.l\"\n{ return T_OP_STR_GT; }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n#line 339 \"util_expr_scan.l\"\n{ return T_OP_STR_GE; }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n#line 340 \"util_expr_scan.l\"\n{ return T_OP_REG; }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n#line 341 \"util_expr_scan.l\"\n{ return T_OP_NRE; }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n#line 342 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n#line 343 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n#line 344 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n#line 345 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n#line 346 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n#line 347 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\n#line 348 \"util_expr_scan.l\"\n{ return T_OP_CONCAT; }\n\tYY_BREAK\ncase 45:\nYY_RULE_SETUP\n#line 349 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\n#line 350 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\n#line 351 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\n#line 352 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\n#line 353 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n#line 354 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n#line 355 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\n\ncase 52:\nYY_RULE_SETUP\n#line 358 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\n#line 359 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\n#line 360 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 55:\nYY_RULE_SETUP\n#line 361 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\n#line 362 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n#line 363 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\n#line 364 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\n#line 366 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_UNARY;\n}\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\n#line 371 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_BINARY;\n}\n\tYY_BREAK\n/*\n  * Specials\n  */\ncase 61:\nYY_RULE_SETUP\n#line 379 \"util_expr_scan.l\"\n{ return T_TRUE; }\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\n#line 380 \"util_expr_scan.l\"\n{ return T_FALSE; }\n\tYY_BREAK\n/*\n  * Digits\n  */\ncase 63:\nYY_RULE_SETUP\n#line 385 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_DIGIT;\n}\n\tYY_BREAK\n/*\n  * Identifiers\n  */\ncase 64:\nYY_RULE_SETUP\n#line 393 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\n/*\n  * These are parts of the grammar and are returned as is\n  */\ncase 65:\nYY_RULE_SETUP\n#line 401 \"util_expr_scan.l\"\n{\n    return yytext[0];\n}\n\tYY_BREAK\n/*\n  * Anything else is an error\n  */\ncase 66:\n\nYY_RULE_SETUP\n#line 408 \"util_expr_scan.l\"\n{\n    char *msg = apr_psprintf(yyextra->pool, \"Parse error near '%c'\", yytext[0]);\n    PERROR(msg);\n}\n\tYY_BREAK\ncase 67:\nYY_RULE_SETUP\n#line 413 \"util_expr_scan.l\"\nYY_FATAL_ERROR( \"flex scanner jammed\" );\n\tYY_BREAK\n#line 1538 \"util_expr_scan.c\"\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(regex):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * ap_expr_yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ \n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( ap_expr_yywrap(yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} \n\t\t} \n}",
    "predicted": "123,Write-what-where Condition\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_3633fafb34842267a6fa4d64f57c86d5f81685de_0", {
    "ID": "httpd_3633fafb34842267a6fa4d64f57c86d5f81685de_0",
    "UID": "4434",
    "code": "static void ap_expr_yy_load_buffer_state  (yyscan_t test_snippet\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_59f7c91986f057918fbed5ddee42ece1c4c88f62_0", {
    "ID": "httpd_59f7c91986f057918fbed5ddee42ece1c4c88f62_0",
    "UID": "4464",
    "code": "AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int test_snippet\n{\n    worker_score *ws;\n\n    if (!sbh)\n        return;\n\n    if (sbh->child_num < 0) {\n        return;\n    }\n\n    ws = &ap_scoreboard_image->servers[sbh->child_num][sbh->thread_num];\n\n    if (status == START_PREQUEST) {\n        ws->start_time = ws->last_used = apr_time_now();\n    }\n    else if (status == STOP_PREQUEST) {\n        ws->stop_time = ws->last_used = apr_time_now();\n        if (ap_extended_test_snippet {\n            ws->duration += ws->stop_time - ws->start_time;\n        }\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e0db6faf5d69ad64565e803f65226d3b27eabd29_0", {
    "ID": "httpd_e0db6faf5d69ad64565e803f65226d3b27eabd29_0",
    "UID": "4468",
    "code": "static int dav_parse_range(request_rec test_snippet\n                           apr_off_t *range_start, apr_off_t *range_end)\n{\n    const char *range_c;\n    char *range;\n    char *dash;\n    char *slash;\n    char *errp;\n\n    range_c = apr_table_get(r->headers_in, \"content-range\");\n    if (range_c == NULL)\n        return 0;\n\n    range = apr_pstrdup(r->pool, range_c);\n    if (ap_cstr_casecmpn(range, \"bytes \", 6) != 0\n        || (dash = ap_strchr(range + 6, '-')) == NULL\n        || (slash = ap_strchr(range + 6, '/')) == NULL) {\n        \n        return -1;\n    }\n\n    *dash++ = *slash++ = '\\0';\n\n    \n    if (apr_strtoff(range_start, range + 6, &errp, 10)\n        || *errp || *range_start < 0) {\n        return -1;\n    }\n    if (apr_strtoff(range_end, dash, &errp, 10)\n        || *errp || *range_end < 0 || *range_end < *range_start) {\n        return -1;\n    }\n\n    if (*slash != '*') {\n        apr_off_t dummy;\n\n        if (apr_strtoff(&dummy, slash, &errp, 10)\n            || *errp || dummy <= *range_end) {\n            return -1;\n        }\n    }\n\n    \n    return 1;\n}",
    "predicted": "20,Improper Input Validation"
  },
  "httpd_ca845703f62de326fc9b794802f0228ca0e5e6a2_0", {
    "ID": "httpd_ca845703f62de326fc9b794802f0228ca0e5e6a2_0",
    "UID": "4482",
    "code": "AP_DECLARE_NONSTD(int) ap_filter_output_pending(conn_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    ap_filter_t *f;\n\n    if (!c->pending_filters) {\n        return DECLINED;\n    }\n\n    bb = ap_reuse_brigade_from_pool(\"ap_fop_bb\", c->pool,\n                                    c->bucket_alloc);\n\n    /* Flush outer most filters first for ap_filter_should_yield(f->next)\n     * to be relevant in the previous ones (e.g. ap_request_core_filter()\n     * won't pass its buckets if its next filters yield already).\n     */\n    for (f = APR_RING_LAST(c->pending_filters);\n         f != APR_RING_SENTINEL(c->pending_filters, ap_filter_t, pending);\n         f = APR_RING_PREV(f, pending)) {\n        if (f->frec->direction == AP_FILTER_OUTPUT && f->bb\n                && !APR_BRIGADE_EMPTY(f->bb)) {\n            apr_status_t rv;\n\n            rv = ap_pass_brigade(f, bb);\n            apr_brigade_cleanup(bb);\n\n            if (rv != APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00470)\n                        \"write failure in '%s' output filter\", f->frec->name);\n                return rv;\n            }\n\n            if (f->bb && !APR_BRIGADE_EMPTY(f->bb)) {\n                return OK;\n            }\n        }\n    }\n\n    return DECLINED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_49b3f732f2994c8441a0aebe7c5c29170e574e8c_0", {
    "ID": "httpd_49b3f732f2994c8441a0aebe7c5c29170e574e8c_0",
    "UID": "4483",
    "code": "AP_DECLARE_NONSTD(int) ap_filter_input_pending(conn_rec test_snippet\n{\n    ap_filter_t *f;\n\n    if (!c->pending_filters) {\n        return DECLINED;\n    }\n\n    for (f = APR_RING_LAST(c->pending_filters);\n         f != APR_RING_SENTINEL(c->pending_filters, ap_filter_t, pending);\n         f = APR_RING_PREV(f, pending)) {\n        if (f->frec->direction == AP_FILTER_INPUT && f->bb) {\n            apr_bucket *e = APR_BRIGADE_FIRST(f->bb);\n\n            /* if there is at least one non-morphing bucket\n             * in place, then we have data pending\n             */\n            if (e != APR_BRIGADE_SENTINEL(f->bb)\n                    && e->length != (apr_size_t)(-1)) {\n                return OK;\n            }\n\n        }\n    }\n\n    return DECLINED;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_a63ccd3cad32615031ebe0234ed47bc8ceba0a66_0", {
    "ID": "httpd_a63ccd3cad32615031ebe0234ed47bc8ceba0a66_0",
    "UID": "4497",
    "code": "AP_CORE_DECLARE_NONSTD(apr_status_t) test_snippet\n    ap_filter_t *f,\n    apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    struct content_length_ctx *ctx;\n    apr_bucket *e;\n    int eos = 0;\n    apr_read_type_e eblock = APR_NONBLOCK_READ;\n\n    ctx = f->ctx;\n    if (!ctx) {\n        f->ctx = ctx = apr_palloc(r->pool, sizeof(*ctx));\n        ctx->data_sent = 0;\n        ctx->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    }\n\n    /* Loop through the brigade to count the length. To avoid\n     * arbitrary memory consumption with morphing bucket types, this\n     * loop will stop and pass on the brigade when necessary. */\n    e = APR_BRIGADE_FIRST(b);\n    while (e != APR_BRIGADE_SENTINEL(b)) {\n        apr_status_t rv;\n\n        if (APR_BUCKET_IS_EOS(e)) {\n            eos = 1;\n            break;\n        }\n        /* For a flush bucket, fall through to pass the brigade and\n         * flush now. */\n        else if (APR_BUCKET_IS_FLUSH(e)) {\n            e = APR_BUCKET_NEXT(e);\n        }\n        \n        else if (APR_BUCKET_IS_METADATA(e)) {\n            e = APR_BUCKET_NEXT(e);\n            continue;\n        }\n        /* For determinate length data buckets, count the length and\n         * continue. */\n        else if (e->length != (apr_size_t)-1) {\n            r->bytes_sent += e->length;\n            e = APR_BUCKET_NEXT(e);\n            continue;\n        }\n        \n        else  {\n            apr_size_t len;\n            const char *ignored;\n        \n            rv = apr_bucket_read(e, &ignored, &len, eblock);\n            if ((rv != APR_SUCCESS) && !APR_STATUS_IS_EAGAIN(rv)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00574)\n                              \"ap_content_length_filter: \"\n                              \"apr_bucket_read() failed\");\n                return rv;\n            }\n            if (rv == APR_SUCCESS) {\n                eblock = APR_NONBLOCK_READ;\n                e = APR_BUCKET_NEXT(e);\n                r->bytes_sent += len;\n            }\n            else if (APR_STATUS_IS_EAGAIN(rv)) {\n                apr_bucket *flush;\n\n                \n                eblock = APR_BLOCK_READ;\n\n                /* Ensure the last bucket to pass down is a flush if\n                 * the next read will block. */\n                flush = apr_bucket_flush_create(f->c->bucket_alloc);\n                APR_BUCKET_INSERT_BEFORE(e, flush);\n            }\n        }\n\n        /* Optimization: if the next bucket is EOS (directly after a\n         * bucket morphed to the heap, or a flush), short-cut to\n         * handle EOS straight away - allowing C-L to be determined\n         * for content which is already entirely in memory. */\n        if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {\n            continue;\n        }\n\n        /* On reaching here, pass on everything in the brigade up to\n         * this point. */\n        apr_brigade_split_ex(b, e, ctx->tmpbb);\n        \n        rv = ap_pass_brigade(f->next, b);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        else if (f->c->aborted) {\n            return APR_ECONNABORTED;\n        }\n        apr_brigade_cleanup(b);\n        APR_BRIGADE_CONCAT(b, ctx->tmpbb);\n        e = APR_BRIGADE_FIRST(b);\n        \n        ctx->data_sent = 1;\n    }\n\n    /* If we've now seen the entire response and it's otherwise\n     * okay to set the C-L in the response header, then do so now.\n     *\n     * We can only set a C-L in the response header if we haven't already\n     * sent any buckets on to the next output filter for this request.\n     */\n    if (ctx->data_sent == 0 && eos) {\n        core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n\n        /* This is a hack, but I can't find anyway around it.  The idea is that\n         * we don't want to send out 0 Content-Lengths if it is a HEAD request.\n         * [Unless the corresponding body (for a GET) would really be empty!]\n         * This happens when modules try to outsmart the server, and return\n         * if they see a HEAD request.  Apache 1.3 handlers were supposed to\n         * just return in that situation, and the core handled the HEAD.  From\n         * 2.0, if a handler returns, then the core sends an EOS bucket down\n         * the filter stack, and this content-length filter computes a length\n         * of zero and we would end up sending a zero C-L to the client.\n         * We can't just remove the this C-L filter, because well behaved 2.0+\n         * handlers will send their data down the stack, and we will compute\n         * a real C-L for the head request. RBB\n         *\n         * Allow modification of this behavior through the\n         * HttpContentLengthHeadZero directive.\n         *\n         * The default (unset) behavior is to squelch the C-L in this case.\n         */\n\n        /* don't whack the C-L if it has already been set for a HEAD\n         * by something like proxy.  the brigade only has an EOS bucket\n         * in this case, making r->bytes_sent zero, and either there is\n         * an existing C-L we want to preserve, or r->sent_bodyct is not\n         * zero (the empty body is being sent) thus we don't want to add\n         * a C-L of zero (the backend did not provide it, neither do we).\n         *\n         * if r->bytes_sent > 0 we have a (temporary) body whose length may\n         * have been changed by a filter.  the C-L header might not have been\n         * updated so we do it here.  long term it would be cleaner to have\n         * such filters update or remove the C-L header, and just use it\n         * if present.\n         */\n        if (!((r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status))\n              && !r->bytes_sent\n              && (r->sent_bodyct\n                  || conf->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_ENABLE\n                  || apr_table_get(r->headers_out, \"Content-Length\")))) {\n            ap_set_content_length(r, r->bytes_sent);\n        }\n    }\n\n    ctx->data_sent = 1;\n    return ap_pass_brigade(f->next, b);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d4e9a9096b2e1810484edf151469131bad5de029_0", {
    "ID": "httpd_d4e9a9096b2e1810484edf151469131bad5de029_0",
    "UID": "4513",
    "code": "static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void test_snippet\n{\n    thread_starter *ts = dummy;\n    apr_thread_t **threads = ts->threads;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    int my_child_num = ts->child_num_arg;\n    proc_info *my_info;\n    apr_status_t rv;\n    int threads_created = 0;\n    int listener_started = 0;\n    int prev_threads_created;\n    int loops, i;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02471)\n                 \"start_threads: Using %s (%swakeable)\",\n                 apr_pollset_method_name(event_pollset),\n                 listener_is_wakeable ? \"\" : \"not \");\n\n    loops = prev_threads_created = 0;\n    while (1) {\n        \n        for (i = 0; i < threads_per_child; i++) {\n            int status =\n                ap_scoreboard_image->servers[my_child_num][i].status;\n\n            if (status != SERVER_DEAD) {\n                continue;\n            }\n\n            my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n            my_info->pslot = my_child_num;\n            my_info->tslot = i;\n\n            \n            ap_update_child_status_from_indexes(my_child_num, i,\n                                                SERVER_STARTING, NULL);\n            /* We let each thread update its own scoreboard entry.  This is\n             * done because it lets us deal with tid better.\n             */\n            rv = apr_thread_create(&threads[i], thread_attr,\n                                   worker_thread, my_info, pruntime);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                             APLOGNO(03104)\n                             \"apr_thread_create: unable to create worker thread\");\n                \n                clean_child_exit(APEXIT_CHILDSICK);\n            }\n            threads_created++;\n        }\n\n        \n        if (!listener_started && threads_created) {\n            create_listener_thread(ts);\n            listener_started = 1;\n        }\n\n\n        if (start_thread_may_exit || threads_created == threads_per_child) {\n            break;\n        }\n        \n        apr_sleep(apr_time_from_sec(1));\n        ++loops;\n        if (loops % 120 == 0) { \n            if (prev_threads_created == threads_created) {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             APLOGNO(03271)\n                             \"child %\" APR_PID_T_FMT \" isn't taking over \"\n                             \"slots very quickly (%d of %d)\",\n                             ap_my_pid, threads_created,\n                             threads_per_child);\n            }\n            prev_threads_created = threads_created;\n        }\n    }\n\n    /* What state should this child_main process be listed as in the\n     * scoreboard...?\n     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,\n     *                                      (request_rec *) NULL);\n     *\n     *  This state should be listed separately in the scoreboard, in some kind\n     *  of process_status, not mixed in with the worker threads' status.\n     *  \"life_status\" is almost right, but it's in the worker's structure, and\n     *  the name could be clearer.   gla\n     */\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_520614a9d1073c7ee24c64c7e5ca5962f279b7ab_0", {
    "ID": "httpd_520614a9d1073c7ee24c64c7e5ca5962f279b7ab_0",
    "UID": "4514",
    "code": "apr_status_t ap_queue_create(fd_queue_t **pqueue, int capacity, apr_pool_t test_snippet\n{\n    apr_status_t rv;\n    fd_queue_t *queue;\n\n    queue = apr_pcalloc(p, sizeof *queue);\n\n    if ((rv = apr_thread_mutex_create(&queue->one_big_mutex,\n                                      APR_THREAD_MUTEX_DEFAULT,\n                                      p)) != APR_SUCCESS) {\n        return rv;\n    }\n    if ((rv = apr_thread_cond_create(&queue->not_empty, p)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    APR_RING_INIT(&queue->timers, timer_event_t, link);\n\n    queue->data = apr_pcalloc(p, capacity * sizeof(fd_queue_elem_t));\n    queue->bounds = capacity;\n\n    apr_pool_cleanup_register(p, queue, ap_queue_destroy,\n                              apr_pool_cleanup_null);\n    *pqueue = queue;\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_12d5d8574d29657b06513eff8a646d34e75cbc99_0", {
    "ID": "httpd_12d5d8574d29657b06513eff8a646d34e75cbc99_0",
    "UID": "4537",
    "code": "static apr_status_t do_pattmatch(ap_filter_t *f, apr_bucket test_snippet\n                                 apr_bucket_brigade *mybb,\n                                 apr_pool_t *pool)\n{\n    int i;\n    int force_quick = 0;\n    ap_regmatch_t regm[AP_MAX_REG_MATCH];\n    apr_size_t bytes;\n    apr_size_t len;\n    const char *buff;\n    struct ap_varbuf vb;\n    apr_bucket *b;\n    apr_bucket *tmp_b;\n    subst_pattern_t *script;\n\n    subst_dir_conf *cfg =\n    (subst_dir_conf *) ap_get_module_config(f->r->per_dir_config,\n                                             &substitute_module);\n    subst_req_t *rconf = \n    (subst_req_t*) ap_get_module_config(f->r->request_config, \n                                        &substitute_module);\n\n    APR_BRIGADE_INSERT_TAIL(mybb, inb);\n    ap_varbuf_init(pool, &vb, 0);\n\n    script = (subst_pattern_t *) cfg->patterns->elts;\n    /*\n     * Simple optimization. If we only have one pattern, then\n     * we can safely avoid the overhead of flattening\n     */\n    if (cfg->patterns->nelts == 1) {\n       force_quick = 1;\n    }\n    for (i = 0; i < cfg->patterns->nelts; i++) {\n        const char *replacement = script->replacement;\n        apr_size_t replen = script->replen;\n        if (script->expr_replacement) { \n            if (!rconf) { \n                rconf = apr_pcalloc(f->r->pool, sizeof(*rconf));\n                rconf->expcache     = apr_pcalloc(f->r->pool, sizeof(const char*) * cfg->patterns->nelts);\n                rconf->expcache_len = apr_pcalloc(f->r->pool, sizeof(int) * cfg->patterns->nelts);\n                ap_set_module_config(f->r->request_config, &substitute_module, rconf);\n            }\n        }\n        for (b = APR_BRIGADE_FIRST(mybb);\n             b != APR_BRIGADE_SENTINEL(mybb);\n             b = APR_BUCKET_NEXT(b)) {\n            if (APR_BUCKET_IS_METADATA(b)) {\n                /*\n                 * we should NEVER see this, because we should never\n                 * be passed any, but \"handle\" it just in case.\n                 */\n                continue;\n            }\n            if (apr_bucket_read(b, &buff, &bytes, APR_BLOCK_READ)\n                    == APR_SUCCESS) {\n                int have_match = 0;\n\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                              \"Line read (%\" APR_SIZE_T_FMT \" bytes): %.*s\",\n                              bytes, CAP2LINEMAX(bytes), buff);\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                              \"Replacing %s:'%s' by '%s'\",\n                              script->pattern ? \"string\" :\n                              script->regexp  ? \"regex\"  :\n                                                \"unknown\",\n                              script->from, script->replacement);\n\n                vb.strlen = 0;\n                if (script->pattern) {\n                    const char *repl;\n                    /*\n                     * space_left counts how many bytes we have left until the\n                     * line length reaches max_line_length.\n                     */\n                    apr_size_t space_left = cfg->max_line_length;\n                    while ((repl = apr_strmatch(script->pattern, buff, bytes)))\n                    {\n                        \n                        if (!have_match && script->expr_replacement) { \n                            if (!rconf->expcache[i]) {\n                                const char *err = NULL;\n                                rconf->expcache[i] = ap_expr_str_exec(f->r, script->expr_replacement, &err);\n                                if (err) { \n                                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, \"error evaluating expression: %s\", err);\n                                    return APR_EINVAL;\n                                }\n                                rconf->expcache_len[i] = strlen(rconf->expcache[i]);\n                            }\n                            replacement = rconf->expcache[i];\n                            replen      = rconf->expcache_len[i];\n                        }\n\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                      \"Matching found, result: '%s'\",\n                                      replacement);\n                        have_match = 1;\n                        \n                        len = (apr_size_t) (repl - buff);\n                        if (script->flatten && !force_quick) {\n                            /*\n                             * We are flattening the buckets here, meaning\n                             * that we don't do the fast bucket splits.\n                             * Instead we copy over what the buckets would\n                             * contain and use them. This is slow, since we\n                             * are constanting allocing space and copying\n                             * strings.\n                             */\n                            if (vb.strlen + len + replen > cfg->max_line_length)\n                                return APR_ENOMEM;\n                            ap_varbuf_strmemcat(&vb, buff, len);\n                            ap_varbuf_strmemcat(&vb, replacement, replen);\n                        }\n                        else {\n                            /*\n                             * The string before the match but after the\n                             * previous match (if any) has length 'len'.\n                             * Check if we still have space for this string and\n                             * the replacement string.\n                             */\n                            if (space_left < len + replen)\n                                return APR_ENOMEM;\n                            space_left -= len + replen;\n                            /*\n                             * We now split off the string before the match\n                             * as its own bucket, then isolate the matched\n                             * string and delete it.\n                             */\n                            SEDRMPATBCKT(b, len, tmp_b, script->patlen);\n                            /*\n                             * Finally, we create a bucket that contains the\n                             * replacement...\n                             */\n                            tmp_b = apr_bucket_transient_create(replacement,\n                                      replen,\n                                      f->r->connection->bucket_alloc);\n                            \n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                        }\n                        \n                        len += script->patlen;\n                        bytes -= len;\n                        buff += len;\n                    }\n                    if (have_match) {\n                        if (script->flatten && !force_quick) {\n                            /* XXX: we should check for AP_MAX_BUCKETS here and\n                             * XXX: call ap_pass_brigade accordingly\n                             */\n                            char *copy = ap_varbuf_pdup(pool, &vb, NULL, 0,\n                                                        buff, bytes, &len);\n                            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                          \"New line (%\" APR_SIZE_T_FMT \" bytes): %.*s\",\n                                          len, CAP2LINEMAX(len), copy);\n                            tmp_b = apr_bucket_pool_create(copy, len, pool,\n                                                           f->r->connection->bucket_alloc);\n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                            apr_bucket_delete(b);\n                            b = tmp_b;\n                        }\n                        else {\n                            /*\n                             * We want the behaviour to be predictable.\n                             * Therefore we try to always error out if the\n                             * line length is larger than the limit,\n                             * regardless of the content of the line. So,\n                             * let's check if the remaining non-matching\n                             * string does not exceed the limit.\n                             */\n                            if (space_left < b->length)\n                                return APR_ENOMEM;\n                            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                          \"New line (%\" APR_SIZE_T_FMT \" bytes): %.*s\",\n                                          bytes, CAP2LINEMAX(bytes), buff);\n                        }\n                    }\n                }\n                else if (script->regexp) {\n                    int left = bytes;\n                    const char *pos = buff;\n                    char *repl;\n                    apr_size_t space_left = cfg->max_line_length;\n                    while (!ap_regexec_len(script->regexp, pos, left,\n                                       AP_MAX_REG_MATCH, regm, 0)) {\n                        apr_status_t rv;\n                        if (!have_match && script->expr_replacement) {\n                            if (!rconf->expcache[i]) {\n                                const char *err = NULL;\n                                rconf->expcache[i] = ap_expr_str_exec(f->r, script->expr_replacement, &err);\n                                if (err) {\n                                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, \"error evaluating expression: %s\", err);\n                                    return APR_EGENERAL;\n                                }\n                                rconf->expcache_len[i] = strlen(rconf->expcache[i]);\n                            }\n                            replacement = rconf->expcache[i];\n                            replen      = rconf->expcache_len[i];\n                        }\n\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                      \"Matching found\");\n                        have_match = 1;\n                        if (script->flatten && !force_quick) {\n                            \n                            /* Note that the last param in ap_varbuf_regsub below\n                             * must stay positive. If it gets 0, it would mean\n                             * unlimited space available. */\n                            if (vb.strlen + regm[0].rm_so >= cfg->max_line_length)\n                                return APR_ENOMEM;\n                            \n                            if (regm[0].rm_so > 0)\n                                ap_varbuf_strmemcat(&vb, pos, regm[0].rm_so);\n                            \n                            rv = ap_varbuf_regsub(&vb, replacement, pos,\n                                                  AP_MAX_REG_MATCH, regm,\n                                                  cfg->max_line_length - vb.strlen);\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                          \"Result: '%s'\", vb.buf);\n                        }\n                        else {\n                            apr_size_t repl_len;\n                            \n                            if (space_left <= regm[0].rm_so)\n                                return APR_ENOMEM;\n                            space_left -= regm[0].rm_so;\n                            rv = ap_pregsub_ex(pool, &repl,\n                                               replacement, pos,\n                                               AP_MAX_REG_MATCH, regm,\n                                               space_left);\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            repl_len = strlen(repl);\n                            space_left -= repl_len;\n                            len = (apr_size_t) (regm[0].rm_eo - regm[0].rm_so);\n                            SEDRMPATBCKT(b, regm[0].rm_so, tmp_b, len);\n                            tmp_b = apr_bucket_transient_create(repl, repl_len,\n                                                f->r->connection->bucket_alloc);\n                            APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                          \"Result: '%s'\", repl);\n                        }\n                        /*\n                         * reset to past what we just did. pos now maps to b\n                         * again\n                         */\n                        pos += regm[0].rm_eo;\n                        left -= regm[0].rm_eo;\n                    }\n                    if (have_match && script->flatten && !force_quick) {\n                        char *copy;\n                        /* Copy result plus the part after the last match into\n                         * a bucket.\n                         */\n                        copy = ap_varbuf_pdup(pool, &vb, NULL, 0, pos, left,\n                                              &len);\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, f->r,\n                                      \"New line (%\" APR_SIZE_T_FMT \" bytes): %.*s\",\n                                      len, CAP2LINEMAX(len), copy);\n                        tmp_b = apr_bucket_pool_create(copy, len, pool,\n                                           f->r->connection->bucket_alloc);\n                        APR_BUCKET_INSERT_BEFORE(b, tmp_b);\n                        apr_bucket_delete(b);\n                        b = tmp_b;\n                    }\n                }\n                else {\n                    ap_assert(0);\n                    continue;\n                }\n            }\n        }\n        script++;\n    }\n    ap_varbuf_free(&vb);\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_9dcf157579c3f92a2f87ee4a594247b876a27f4d_0", {
    "ID": "httpd_9dcf157579c3f92a2f87ee4a594247b876a27f4d_0",
    "UID": "4545",
    "code": "static struct timeout_queue *TO_QUEUE_MAKE(apr_pool_t *p, apr_time_t test_snippet\n                                           struct timeout_queue *ref)\n{\n    struct timeout_queue *q;\n                                           \n    q = apr_pcalloc(p, sizeof *q);\n    APR_RING_INIT(&q->head, event_conn_state_test_snippet timeout_list);\n    q->total = (ref) ? ref->total : apr_pcalloc(p, sizeof *q->total);\n    q->timeout = t;\n\n    return q;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_0744960b63d372afa4f773fd036c49a9af20ac17_0", {
    "ID": "httpd_0744960b63d372afa4f773fd036c49a9af20ac17_0",
    "UID": "4557",
    "code": "static void disable_listensocks(int test_snippet\n{\n    int i;\n    listeners_disabled = 1;\n    for (i = 0; i < num_listensocks; i++) {\n        apr_pollset_remove(event_pollset, &listener_pollfd[i]);\n    }\n    ap_scoreboard_image->parent[process_slot].not_accepting = 1;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_1dca9d9eaf49267f9bf4490fca4319d46c52ed32_0", {
    "ID": "httpd_1dca9d9eaf49267f9bf4490fca4319d46c52ed32_0",
    "UID": "4559",
    "code": "static APR_INLINE int test_snippet\n{\n    apr_uint32_t i_count = ap_queue_info_get_idlers(worker_queue_info);\n    if (i_count > 0) {\n        apr_uint32_t c_count = apr_atomic_read32(&connection_count);\n        apr_uint32_t l_count = apr_atomic_read32(&lingering_count);\n        if (c_count <= l_count\n                \n                || c_count - l_count < (apr_uint32_t)threads_per_child +\n                                       (i_count - (listeners_disabled != 0)) *\n                                       (worker_factor / WORKER_FACTOR_SCALE)) {\n            return 0;\n        }\n    }\n    return 1;\n}",
    "predicted": "This code does not appear to have any obvious vulnerabilities, so the response would be null."
  },
  "httpd_144237e5467c0a8f6770f28e87c9085c07eb1c17_0", {
    "ID": "httpd_144237e5467c0a8f6770f28e87c9085c07eb1c17_0",
    "UID": "4562",
    "code": "static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void test_snippet\n{\n    thread_starter *ts = dummy;\n    apr_thread_t **threads = ts->threads;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    int my_child_num = ts->child_num_arg;\n    proc_info *my_info;\n    apr_status_t rv;\n    int i;\n    int threads_created = 0;\n    int listener_started = 0;\n    int loops;\n    int prev_threads_created;\n    int max_recycled_pools = -1;\n    const int good_methods[] = { APR_POLLSET_KQUEUE,\n                                 APR_POLLSET_PORT,\n                                 APR_POLLSET_EPOLL };\n    \n    const apr_uint32_t async_factor = worker_factor / WORKER_FACTOR_SCALE;\n    const apr_uint32_t pollset_size = (apr_uint32_t)num_listensocks +\n                                      (apr_uint32_t)threads_per_child *\n                                      (async_factor > 2 ? async_factor : 2);\n\n    /* We must create the fd queues before we start up the listener\n     * and worker threads. */\n    worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));\n    rv = ap_queue_init(worker_queue, threads_per_child, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(03100)\n                     \"ap_queue_init() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) {\n        /* If we want to conserve memory, let's not keep an unlimited number of\n         * pools & allocators.\n         * XXX: This should probably be a separate config directive\n         */\n        max_recycled_pools = threads_per_child * 3 / 4 ;\n    }\n    rv = ap_queue_info_create(&worker_queue_info, pchild,\n                              threads_per_child, max_recycled_pools);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(03101)\n                     \"ap_queue_info_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the timeout mutex and main pollset before the listener\n     * thread starts.\n     */\n    rv = apr_thread_mutex_create(&timeout_mutex, APR_THREAD_MUTEX_DEFAULT,\n                                 pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03102)\n                     \"creation of the timeout mutex failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    \n    for (i = 0; i < sizeof(good_methods) / sizeof(good_methods[0]); i++) {\n        apr_uint32_t flags = APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY |\n                             APR_POLLSET_NODEFAULT | APR_POLLSET_WAKEABLE;\n        rv = apr_pollset_create_ex(&event_pollset, pollset_size, pchild, flags,\n                                   good_methods[i]);\n        if (rv == APR_SUCCESS) {\n            listener_is_wakeable = 1;\n            break;\n        }\n        flags &= ~APR_POLLSET_WAKEABLE;\n        rv = apr_pollset_create_ex(&event_pollset, pollset_size, pchild, flags,\n                                   good_methods[i]);\n        if (rv == APR_SUCCESS) {\n            break;\n        }\n    }\n    if (rv != APR_SUCCESS) {\n        rv = apr_pollset_create(&event_pollset, pollset_size, pchild,\n                                APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY);\n    }\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03103)\n                     \"apr_pollset_create with Thread Safety failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02471)\n                 \"start_threads: Using %s (%swakeable)\",\n                 apr_pollset_method_name(event_pollset),\n                 listener_is_wakeable ? \"\" : \"not \");\n    worker_sockets = apr_pcalloc(pchild, threads_per_child\n                                 * sizeof(apr_socket_t *));\n\n    loops = prev_threads_created = 0;\n    while (1) {\n        \n        for (i = 0; i < threads_per_child; i++) {\n            int status =\n                ap_scoreboard_image->servers[my_child_num][i].status;\n\n            if (status != SERVER_DEAD) {\n                continue;\n            }\n\n            my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n            my_info->pslot = my_child_num;\n            my_info->tslot = i;\n\n            \n            ap_update_child_status_from_indexes(my_child_num, i,\n                                                SERVER_STARTING, NULL);\n            /* We let each thread update its own scoreboard entry.  This is\n             * done because it lets us deal with tid better.\n             */\n            rv = apr_thread_create(&threads[i], thread_attr,\n                                   worker_thread, my_info, pchild);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                             APLOGNO(03104)\n                             \"apr_thread_create: unable to create worker thread\");\n                \n                clean_child_exit(APEXIT_CHILDSICK);\n            }\n            threads_created++;\n        }\n\n        \n        if (!listener_started && threads_created) {\n            create_listener_thread(ts);\n            listener_started = 1;\n        }\n\n\n        if (start_thread_may_exit || threads_created == threads_per_child) {\n            break;\n        }\n        \n        apr_sleep(apr_time_from_sec(1));\n        ++loops;\n        if (loops % 120 == 0) { \n            if (prev_threads_created == threads_created) {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             APLOGNO(03271)\n                             \"child %\" APR_PID_T_FMT \" isn't taking over \"\n                             \"slots very quickly (%d of %d)\",\n                             ap_my_pid, threads_created,\n                             threads_per_child);\n            }\n            prev_threads_created = threads_created;\n        }\n    }\n\n    /* What state should this child_main process be listed as in the\n     * scoreboard...?\n     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,\n     *                                      (request_rec *) NULL);\n     *\n     *  This state should be listed separately in the scoreboard, in some kind\n     *  of process_status, not mixed in with the worker threads' status.\n     *  \"life_status\" is almost right, but it's in the worker's structure, and\n     *  the name could be clearer.   gla\n     */\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_61b9bbc8f6581de5312537469ce38f0935eccfdd_0", {
    "ID": "httpd_61b9bbc8f6581de5312537469ce38f0935eccfdd_0",
    "UID": "4568",
    "code": "static int dumpio_input_filter (ap_filter_t *f, apr_bucket_brigade test_snippet\n    ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes)\n{\n\n    apr_bucket *b;\n    apr_status_t ret;\n    conn_rec *c = f->c;\n    dumpio_conf_t *ptr = f->ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,\n                  \"mod_dumpio: %s [%s-%s] %\" APR_OFF_T_FMT \" readbytes\",\n                  f->frec->name,\n                  whichmode(mode),\n                  ((block) == APR_BLOCK_READ) ? \"blocking\" : \"nonblocking\",\n                  readbytes);\n\n    ret = ap_get_brigade(f->next, bb, mode, block, readbytes);\n\n    if (ret == APR_SUCCESS) {\n        for (b = APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b = APR_BUCKET_NEXT(b)) {\n          dumpit(f, b, ptr);\n        }\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,\n                      \"mod_dumpio: %s - %d\", f->frec->name, ret) ;\n        return ret;\n    }\n\n    return APR_SUCCESS ;\n}",
    "predicted": "This code does not appear to have any specific vulnerabilities based on the provided categories. Therefore, the response is null."
  },
  "httpd_e58a3a73d3d0d32cc8c0d80941bf5a9990f905a6_0", {
    "ID": "httpd_e58a3a73d3d0d32cc8c0d80941bf5a9990f905a6_0",
    "UID": "4570",
    "code": "apr_status_t ap_queue_init(fd_queue_t * queue, int test_snippet\n                           apr_pool_t * a)\n{\n    int i;\n    apr_status_t rv;\n\n    if ((rv = apr_thread_mutex_create(&queue->one_big_mutex,\n                                      APR_THREAD_MUTEX_DEFAULT,\n                                      a)) != APR_SUCCESS) {\n        return rv;\n    }\n    if ((rv = apr_thread_cond_create(&queue->not_empty, a)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    APR_RING_INIT(&queue->timers, timer_event_t, link);\n\n    queue->data = apr_palloc(a, queue_capacity * sizeof(fd_queue_elem_t));\n    queue->bounds = queue_capacity;\n    queue->nelts = 0;\n    queue->in = 0;\n    queue->out = 0;\n\n    \n    for (i = 0; i < queue_capacity; ++i)\n        queue->data[i].sd = NULL;\n\n    apr_pool_cleanup_register(a, queue, ap_queue_destroy,\n                              apr_pool_cleanup_null);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_3fd93fef0f06d39be2ef4f4670797e732afdc1a6_0", {
    "ID": "httpd_3fd93fef0f06d39be2ef4f4670797e732afdc1a6_0",
    "UID": "4571",
    "code": "apr_status_t ap_queue_push_timer(fd_queue_t * queue, timer_event_t test_snippet\n{\n    apr_status_t rv;\n\n    if ((rv = apr_thread_mutex_lock(queue->one_big_mutex)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    AP_DEBUG_ASSERT(!queue->terminated);\n\n    APR_RING_INSERT_TAIL(&queue->timers, te, timer_event_t, link);\n\n    apr_thread_cond_signal(queue->not_empty);\n\n    if ((rv = apr_thread_mutex_unlock(queue->one_big_mutex)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_e724007c0b7e7fec1ac6ac4a69b20e5701bc6d96_0", {
    "ID": "httpd_e724007c0b7e7fec1ac6ac4a69b20e5701bc6d96_0",
    "UID": "4607",
    "code": "static int event_pre_config(apr_pool_t * pconf, apr_pool_t * test_snippet\n                            apr_pool_t * ptemp)\n{\n    int no_detach, debug, foreground;\n    apr_status_t rv;\n    const char *userdata_key = \"mpm_event_module\";\n\n    mpm_state = AP_MPMQ_STARTING;\n\n    debug = ap_exists_config_define(\"DEBUG\");\n\n    if (debug) {\n        foreground = one_process = 1;\n        no_detach = 0;\n    }\n    else {\n        one_process = ap_exists_config_define(\"ONE_PROCESS\");\n        no_detach = ap_exists_config_define(\"NO_DETACH\");\n        foreground = ap_exists_config_define(\"FOREGROUND\");\n    }\n\n    \n    retained = ap_retained_data_get(userdata_key);\n    if (!retained) {\n        retained = ap_retained_data_create(userdata_key, sizeof(*retained));\n        retained->max_daemons_limit = -1;\n        retained->idle_spawn_rate = 1;\n    }\n    ++retained->module_loads;\n    if (retained->module_loads == 2) {\n        int i;\n        static apr_uint32_t foo = 0;\n\n        apr_atomic_inc32(&foo);\n        apr_atomic_dec32(&foo);\n        apr_atomic_dec32(&foo);\n        i = apr_atomic_dec32(&foo);\n        if (i >= 0) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(02405)\n                         \"atomics not working as expected\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        rv = apr_pollset_create(&event_pollset, 1, test_snippet\n                                APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00495)\n                         \"Couldn't create a Thread Safe Pollset. \"\n                         \"Is it supported on your platform?\"\n                         \"Also check system or user limits!\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        apr_pollset_destroy(event_pollset);\n\n        if (!one_process && !foreground) {\n            \n            ap_fatal_signal_setup(ap_server_conf, pconf);\n            rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND\n                                 : APR_PROC_DETACH_DAEMONIZE);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00496)\n                             \"apr_proc_detach failed\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n    }\n\n    parent_pid = ap_my_pid = getpid();\n\n    ap_listen_pre_config();\n    ap_daemons_to_start = DEFAULT_START_DAEMON;\n    min_spare_threads = DEFAULT_MIN_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;\n    max_spare_threads = DEFAULT_MAX_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;\n    server_limit = DEFAULT_SERVER_LIMIT;\n    thread_limit = DEFAULT_THREAD_LIMIT;\n    ap_daemons_limit = server_limit;\n    threads_per_child = DEFAULT_THREADS_PER_CHILD;\n    max_workers = ap_daemons_limit * threads_per_child;\n    had_healthy_child = 0;\n    ap_extended_status = 0;\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_ec1650f2a809a7a9d10f5554d5083d16d9808d0c_0", {
    "ID": "httpd_ec1650f2a809a7a9d10f5554d5083d16d9808d0c_0",
    "UID": "4618",
    "code": "static const char *set_http_protocol(cmd_parms *cmd, void test_snippet\n                                     const char *arg)\n{\n    core_server_config *conf;\n    conf = ap_get_core_module_config(cmd->server->module_config);\n    if (apr_isdigit(arg[0])) {\n        unsigned short min_major, min_minor, max_major, max_minor;\n        unsigned int min, max;\n        char ch;\n\n        if (sscanf(arg, \"%hu.%hu-%hu.%hu%c\", &min_major, &min_minor,\n                   &max_major, &max_minor, &ch) == 4) {\n        }\n        else if (sscanf(arg, \"%hu.%hu%c\", &min_major, &min_minor, &ch) == 2) {\n            max_major = min_major;\n            max_minor = min_minor;\n        }\n        else {\n            return \"Protocol version must be in format a.b or a.b-c.d\";\n        }\n        if (   HTTP_VERSION(0, min_minor) >= HTTP_VERSION(1,0)\n            || HTTP_VERSION(0, max_minor) >= HTTP_VERSION(1,0)) {\n            return \"HTTP minor version may not be more than 999\";\n        }\n        min = HTTP_VERSION(min_major, min_minor);\n        max = HTTP_VERSION(max_major, max_minor);\n        if (min > APR_UINT16_MAX || max > APR_UINT16_MAX)\n            return \"HTTP major version may not be more than 64\";\n        if (min > max)\n            return \"HTTP version range must be min-max\";\n        \n        if (min < HTTP_VERSION(0,9))\n                min = HTTP_VERSION(0,9);\n        conf->min_http_version = min;\n        conf->max_http_version = max;\n    }\n    else {\n        return \"Valid arguments are a version number (e.g. '1.1')\"\n               \"or a version range (e.g. '1.0-9.9')\";\n    }\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)"
  },
  "httpd_0416edfd78367f218c93b7f1c28501406259d9bd_0", {
    "ID": "httpd_0416edfd78367f218c93b7f1c28501406259d9bd_0",
    "UID": "4627",
    "code": "APREQ_DECLARE(apr_ssize_t ) apreq_index(const char* hay, apr_size_t test_snippet\n                                        const char* ndl, apr_size_t nlen,\n                                        const apreq_match_t type)\n{\n    apr_size_t len = hlen;\n    const char *end = hay + hlen;\n    const char *begin = hay;\n\n    while ( (hay = memchr(hay, ndl[0], len)) ) {\n        len = end - hay;\n\n        \n        if ( memcmp(hay, ndl, MIN(nlen, len)) == 0 ) {\n            if (type == APREQ_MATCH_FULL && len < nlen)\n                hay = NULL;     \n            break;\n        }\n        --len;\n        ++hay;\n    }\n\n    return hay ? hay - begin : -1;\n}",
    "predicted": "126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_f4f0fdb1f1447d9109e29a3f11e5598943ca4c35_0", {
    "ID": "httpd_f4f0fdb1f1447d9109e29a3f11e5598943ca4c35_0",
    "UID": "4642",
    "code": "static void init_body(apreq_handle_t test_snippet\n{\n    struct cgi_handle *req = (struct cgi_handle *)handle;\n    const char *cl_header = cgi_header_in(handle, \"Content-Length\");\n    apr_bucket_alloc_t *ba = handle->bucket_alloc;\n    apr_pool_t *pool = handle->pool;\n    apr_file_t *file;\n    apr_bucket *eos, *pipe;\n\n    if (cl_header != NULL) {\n        char *dummy;\n        apr_int64_t content_length = apr_strtoi64(cl_header, &dummy, 10);\n\n        if (dummy == NULL || *dummy != 0) {\n            req->body_status = APREQ_ERROR_BADHEADER;\n            cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                          \"Invalid Content-Length header (%s)\", cl_header);\n            return;\n        }\n        else if ((apr_uint64_t)content_length > req->read_limit) {\n            req->body_status = APREQ_ERROR_OVERLIMIT;\n            cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                          \"Content-Length header (%s) exceeds configured \"\n                          \"max_body limit (%\" APR_UINT64_T_FMT \")\",\n                          cl_header, req->read_limit);\n            return;\n        }\n    }\n\n    if (req->parser == NULL) {\n        const char *ct_header = cgi_header_in(handle, \"Content-Type\");\n\n        if (ct_header != NULL) {\n            apreq_parser_function_t pf = apreq_parser(ct_header);\n\n            if (pf != NULL) {\n                req->parser = apreq_parser_make(pool,\n                                                ba,\n                                                ct_header,\n                                                pf,\n                                                req->brigade_limit,\n                                                req->temp_dir,\n                                                req->hook_queue,\n                                                NULL);\n            }\n            else {\n                req->body_status = APREQ_ERROR_NOPARSER;\n                return;\n            }\n        }\n        else {\n            req->body_status = APREQ_ERROR_NOHEADER;\n            return;\n        }\n    }\n    else {\n        if (req->parser->brigade_limit > req->brigade_limit)\n            req->parser->brigade_limit = req->brigade_limit;\n        if (req->temp_dir != NULL)\n            req->parser->temp_dir = req->temp_dir;\n        if (req->hook_queue != NULL)\n            apreq_parser_add_hook(req->parser, req->hook_queue);\n    }\n\n    req->hook_queue = NULL;\n    req->in         = apr_brigade_create(pool, ba);\n    req->tmpbb      = apr_brigade_create(pool, ba);\n\n    apr_file_open_stdin(&file, pool); \n    pipe = apr_bucket_pipe_create(file, ba);\n    eos = apr_bucket_eos_create(ba);\n    APR_BRIGADE_INSERT_HEAD(req->in, pipe);\n    APR_BRIGADE_INSERT_TAIL(req->in, eos);\n\n    req->body_status = APR_INCOMPLETE;\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_1b09e4242010149cf957b6b911c012f8723ee7a3_0", {
    "ID": "httpd_1b09e4242010149cf957b6b911c012f8723ee7a3_0",
    "UID": "4643",
    "code": "static apr_status_t url_decode(char *dest, apr_size_t test_snippet\n                               const char *src, apr_size_t *slen)\n{\n    register const char *s = src;\n    unsigned char *start = (unsigned char *)dest;\n    register unsigned char *d = (unsigned char *)dest;\n    const char *end = src + *slen;\n\n    for (; s < end; ++d, ++s) {\n        switch (*s) {\n\n        case '+':\n            *d = ' ';\n            break;\n\n        case '%':\n            if (s + 2 < end && apr_isxdigit(s[1]) && apr_isxdigit(s[2])) {\n                *d = hex2_to_char(s + 1);\n                s += 2;\n            }\n            else if (s + 5 < end && (s[1] == 'u' || s[1] == 'U') &&\n                     apr_isxdigit(s[2]) && apr_isxdigit(s[3]) &&\n                     apr_isxdigit(s[4]) && apr_isxdigit(s[5]))\n            {\n                apr_uint16_t c = hex4_to_bmp(s+2);\n\n                if (c < 0x80) {\n                    *d = c;\n                }\n                else if (c < 0x800) {\n                    *d++ = 0xC0 | (c >> 6);\n                    *d   = 0x80 | (c & 0x3F);\n                }\n                else {\n                    *d++ = 0xE0 | (c >> 12);\n                    *d++ = 0x80 | ((c >> 6) & 0x3F);\n                    *d   = 0x80 | (c & 0x3F);\n                }\n                s += 5;\n            }\n            else {\n                *dlen = d - start;\n                *slen = s - src;\n                if (s + 5 < end\n                    || (s + 2 < end && !apr_isxdigit(s[2]))\n                    || (s + 1 < end && !apr_isxdigit(s[1])\n                        && s[1] != 'u' && s[1] != 'U'))\n                {\n                    *d = 0;\n                    return APREQ_ERROR_BADSEQ;\n                }\n\n                memmove(d, s, end - s);\n                d[end - s] = 0;\n                return APR_INCOMPLETE;\n            }\n            break;\n\n        default:\n            if (*s > 0) {\n                *d = *s;\n            }\n            else {\n                *d = 0;\n                *dlen = d - start;\n                *slen = s - src;\n                return APREQ_ERROR_BADCHAR;\n            }\n        }\n    }\n\n    *d = 0;\n    *dlen = d - start;\n    *slen = s - src;\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_6a9cd84d9e17346974b92e2027bb6eb0d2e0b377_0", {
    "ID": "httpd_6a9cd84d9e17346974b92e2027bb6eb0d2e0b377_0",
    "UID": "4656",
    "code": "static APR_INLINE apr_uint16_t hex4_to_bmp(const char test_snippet\n{\n    register apr_uint16_t digit = 0;\n\n#if !APR_CHARSET_EBCDIC\n    digit  = (what[0] >= 'A' ? ((what[0] & 0xDF)-'A') + 10 : (what[0]-'0'));\n    digit *= 16;\n    digit += (what[1] >= 'A' ? ((what[1] & 0xDF)-'A') + 10 : (what[1]-'0'));\n    digit *= 16;\n    digit += (what[2] >= 'A' ? ((what[2] & 0xDF)-'A') + 10 : (what[2]-'0'));\n    digit *= 16;\n    digit += (what[3] >= 'A' ? ((what[3] & 0xDF)-'A') + 10 : (what[3]-'0'));\n\n#else \n    char xstr[7];\n    xstr[0]='0';\n    xstr[1]='x';\n    xstr[2]=what[0];\n    xstr[3]=what[1];\n    xstr[4]=what[2];\n    xstr[5]=what[3];\n    xstr[6]='\\0';\n    digit = apr_xlate_conv_byte(ap_hdrs_from_ascii, 0xFFFF & strtol(xstr, NULL, 16));\n#endif \n    return (digit);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_ad57ad7ab168e595dafe0d1aa4f8c799cddd9861_0", {
    "ID": "httpd_ad57ad7ab168e595dafe0d1aa4f8c799cddd9861_0",
    "UID": "4663",
    "code": "APREQ_DECLARE(apr_status_t) apreq_decodev(char *d, apr_size_t test_snippet\n                                          struct iovec *v, int nelts)\n{\n    apr_status_t status = APR_SUCCESS;\n    int n = 0;\n\n    *dlen = 0;\n\n    while (n < nelts) {\n        apr_size_t slen, len;\n\n        slen = v[n].iov_len;\n        switch (status = url_decode(d, &len, v[n].iov_base, &slen)) {\n\n        case APR_SUCCESS:\n            d += len;\n            *dlen += len;\n            ++n;\n            continue;\n\n        case APR_INCOMPLETE:\n            d += len;\n            *dlen += len;\n            slen = v[n].iov_len - slen;\n\n            if (++n == nelts) {\n                return status;\n            }\n            memcpy(d + slen, v[n].iov_base, v[n].iov_len);\n            v[n].iov_len += slen;\n            v[n].iov_base = d;\n            continue;\n\n        default:\n            *dlen += len;\n            return status;\n        }\n    }\n\n    return status;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5818e35daad3918f7fa345b23af7539a40f0ef36_0", {
    "ID": "httpd_5818e35daad3918f7fa345b23af7539a40f0ef36_0",
    "UID": "4665",
    "code": "static char* chomp(char* test_snippet\n{\n    long p = (long)strlen(test_snippet;\n    while (--p >= 0) {\n        switch ((char)(str[p])) {\n        case '\\015':\n        case '\\012':str[p]='\\000';\n                    break;\n        default:return str;\n        }\n    }\n    return str;\n}",
    "predicted": "415,Double Free\n476,NULL Pointer Dereference\n121,Stack-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n457,Use of Uninitialized Variable\n665,Improper Initialization"
  },
  "httpd_d92a76df316b28dbe26752b8b414e5892ff55815_0", {
    "ID": "httpd_d92a76df316b28dbe26752b8b414e5892ff55815_0",
    "UID": "4666",
    "code": "static test_snippet\nvoid apreq_cookie_tainted_on(apreq_cookie_t *c) {\n    APREQ_FLAGS_ON(c->flags, APREQ_TAINTED);\n}",
    "predicted": "This code does not appear to have any flaws, so the response is null."
  },
  "httpd_ea67507b999f01ff267241dc72858b7be1924971_0", {
    "ID": "httpd_ea67507b999f01ff267241dc72858b7be1924971_0",
    "UID": "4668",
    "code": "static int update_child_status_internal(int test_snippet\n                                        int thread_num,\n                                        int status,\n                                        conn_rec *c,\n                                        request_rec *r)\n{\n    int old_status;\n    worker_score *ws;\n    process_score *ps;\n    int mpm_generation;\n\n    ws = &ap_scoreboard_image->servers[child_num][thread_num];\n    old_status = ws->status;\n    ws->status = status;\n\n    ps = &ap_scoreboard_image->parent[child_num];\n\n    if (status == SERVER_READY\n        && old_status == SERVER_STARTING) {\n        ws->thread_num = child_num * thread_limit + thread_num;\n        ap_mpm_query(AP_MPMQ_GENERATION, &mpm_generation);\n        ps->generation = mpm_generation;\n    }\n\n    if (ap_extended_status) {\n        if (status == SERVER_READY || status == SERVER_DEAD) {\n            /*\n             * Reset individual counters\n             */\n            if (status == SERVER_DEAD) {\n                ws->my_access_count = 0L;\n                ws->my_bytes_served = 0L;\n            }\n            ws->conn_count = 0;\n            ws->conn_bytes = 0;\n            ws->last_used = apr_time_now();\n        }\n        if (r) {\n            const char *client = ap_get_remote_host(c, r->per_dir_config,\n                                 REMOTE_NOLOOKUP, NULL);\n            if (!client || !strcmp(client, c->client_ip)) {\n                apr_cpystrn(ws->client, r->useragent_ip, sizeof(ws->client));\n            }\n            else {\n                apr_cpystrn(ws->client, client, sizeof(ws->client));\n            }\n            copy_request(ws->request, sizeof(ws->request), r);\n            if (r->server) {\n                apr_snprintf(ws->vhost, sizeof(ws->vhost), \"%s:%d\",\n                             r->server->server_hostname,\n                             r->connection->local_addr->port);\n            }\n        }\n        else if (c) {\n            apr_cpystrn(ws->client, ap_get_remote_host(c, NULL,\n                        REMOTE_NOLOOKUP, NULL), sizeof(ws->client));\n            ws->request[0]='\\0';\n            ws->vhost[0]='\\0';\n        }\n    }\n\n    return old_status;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference"
  },
  "httpd_a1c82d37f2953f2400fb11689feab3d979220163_0", {
    "ID": "httpd_a1c82d37f2953f2400fb11689feab3d979220163_0",
    "UID": "4669",
    "code": "static test_snippet\nvoid apreq_param_tainted_on(apreq_param_t *p) {\n    APREQ_FLAGS_ON(p->flags, APREQ_TAINTED);\n}",
    "predicted": "This code snippet does not appear to contain any of the listed vulnerabilities. Therefore, the response is: null."
  },
  "httpd_f2ae2ddf408be5a740ce48f46b9a33af4e2842ac_0", {
    "ID": "httpd_f2ae2ddf408be5a740ce48f46b9a33af4e2842ac_0",
    "UID": "4673",
    "code": "static int is_quoted(const char *p, const apr_size_t test_snippet\n{\n    if (len > 1 && p[0] == '\"' && p[len-1] == '\"') {\n        apr_size_t i;\n        int backslash = 0;\n\n        for (i = 1; i < len - 1; i++) {\n            if (p[i] == '\\\\')\n                backslash = !backslash;\n            else if (p[i] == 0 || (p[i] == '\"' && !backslash))\n                return 0;\n            else\n                backslash = 0;\n        }\n\n        return !backslash;\n    }\n\n    return 0;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_12d1e84a0646e84da48c81b27d0ed09343c66813_0", {
    "ID": "httpd_12d1e84a0646e84da48c81b27d0ed09343c66813_0",
    "UID": "4674",
    "code": "static apr_status_t cache_out_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    request_rec *r = f->r;\n    cache_request_rec *cache = (cache_request_rec *)f->ctx;\n\n    if (!cache) {\n        /* user likely configured CACHE_OUT manually; they should use mod_cache\n         * configuration to do that */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00762)\n                \"CACHE/CACHE_OUT filter enabled while caching is disabled, ignoring\");\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, in);\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00763)\n            \"cache: running CACHE_OUT filter\");\n\n    \n    while (!APR_BRIGADE_EMPTY(in)) {\n        apr_bucket *e = APR_BRIGADE_FIRST(in);\n        if (APR_BUCKET_IS_EOS(e)) {\n            apr_bucket_brigade *bb = apr_brigade_create(r->pool,\n                    r->connection->bucket_alloc);\n\n            \n            \n            const char *ct = apr_table_get(cache->handle->resp_hdrs, \"Content-Type\");\n            if (ct) {\n                ap_set_content_type(r, ct);\n            }\n\n            \n            r->status = cache->handle->cache_obj->info.status;\n\n            \n            cache->provider->recall_body(cache->handle, r->pool, bb);\n            APR_BRIGADE_PREPEND(in, bb);\n\n            \n            ap_remove_output_filter(f);\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00764)\n                    \"cache: serving %s\", r->uri);\n            return ap_pass_brigade(f->next, in);\n\n        }\n        apr_bucket_delete(e);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_99ddcf8c418b6f2abb73ed5c7568e4f613c4d76d_0", {
    "ID": "httpd_99ddcf8c418b6f2abb73ed5c7568e4f613c4d76d_0",
    "UID": "4677",
    "code": "static const char *set_max_line_length(cmd_parms *cmd, void *cfg, const char test_snippet\n{\n    subst_dir_conf *dcfg = (subst_dir_conf *)cfg;\n    apr_off_t max;\n    char *end;\n    apr_status_t rv;\n\n    rv = apr_strtoff(&max, arg, &end, 10);\n    if (rv == APR_SUCCESS) {\n        if ((*end == 'K' || *end == 'k') && !end[1]) {\n            max *= KBYTE;\n        }\n        else if ((*end == 'M' || *end == 'm') && !end[1]) {\n            max *= MBYTE;\n        }\n        else if ((*end == 'G' || *end == 'g') && !end[1]) {\n            max *= GBYTE;\n        }\n        else if (*end && \n                 ((*end != 'B' && *end != 'b') || end[1])) {\n            rv = APR_EGENERAL;\n        }\n    }\n\n    if (rv != APR_SUCCESS || max < 0)\n    {\n        return \"SubstituteMaxLineLength must be a non-negative integer optionally \"\n               \"suffixed with 'b', 'k', 'm' or 'g'.\";\n    }\n    dcfg->max_line_length = (apr_size_t)max;\n    dcfg->max_line_length_set = 1;\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_785af254039535d9b2087dd99799a47b044550e6_0", {
    "ID": "httpd_785af254039535d9b2087dd99799a47b044550e6_0",
    "UID": "4693",
    "code": "AP_DECLARE(apr_status_t) ap_duplicate_listeners(apr_pool_t *p, server_rec test_snippet\n                                                ap_listen_rec ***buckets,\n                                                int *num_buckets)\n{\n    static int warn_once;\n    int i;\n    apr_status_t stat;\n    int use_nonblock = 0;\n    ap_listen_rec *lr;\n\n    if (*num_buckets < 1) {\n        *num_buckets = 1;\n        if (ap_listencbratio > 0) {\n#ifdef _SC_NPROCESSORS_ONLN\n            if (ap_have_so_reuseport) {\n                int num_online_cores = sysconf(_SC_NPROCESSORS_ONLN),\n                    val = num_online_cores / ap_listencbratio;\n                if (val > 1) {\n                    *num_buckets = val;\n                }\n                ap_log_perror(APLOG_MARK, APLOG_INFO, 0, p, APLOGNO(02819)\n                              \"Using %i listeners bucket(s) based on %i \"\n                              \"online CPU cores and a ratio of %i\",\n                              *num_buckets, num_online_cores,\n                              ap_listencbratio);\n            }\n            else\n#endif\n            if (!warn_once) {\n                ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, p, APLOGNO(02820)\n                              \"ListenCoresBucketsRatio ignored without \"\n                              \"SO_REUSEPORT and _SC_NPROCESSORS_ONLN \"\n                              \"support: using a single listeners bucket\");\n                warn_once = 1;\n            }\n        }\n    }\n\n    *buckets = apr_pcalloc(p, *num_buckets * sizeof(ap_listen_rec *));\n    (*buckets)[0] = ap_listeners;\n\n    for (i = 1; i < *num_buckets; i++) {\n        ap_listen_rec *last = NULL;\n        lr = ap_listeners;\n        while (lr) {\n            ap_listen_rec *duplr;\n            char *hostname;\n            apr_port_t port;\n            apr_sockaddr_t *sa;\n#ifdef HAVE_SYSTEMD\n            if (use_systemd) {\n                int thesock;\n                apr_os_sock_get(&thesock, lr->sd);\n                if ((stat = alloc_systemd_listener(s->process, thesock,\n                    lr->protocol, &duplr)) != APR_SUCCESS) {\n                    return stat;\n                }\n            }\n            else\n#endif\n            {\n                duplr = apr_palloc(p, sizeof(ap_listen_rec));\n                duplr->slave = NULL;\n                duplr->protocol = apr_pstrdup(p, lr->protocol);\n                hostname = apr_pstrdup(p, lr->bind_addr->hostname);\n                port = lr->bind_addr->port;\n                apr_sockaddr_info_get(&sa, hostname, APR_UNSPEC, port, 0, p);\n                duplr->bind_addr = sa;\n                duplr->next = NULL;\n                stat = apr_socket_create(&duplr->sd, duplr->bind_addr->family,\n                                         SOCK_STREAM, 0, p);\n                if (stat != APR_SUCCESS) {\n                    ap_log_perror(APLOG_MARK, APLOG_CRIT, 0, p, APLOGNO(02640)\n                                \"ap_duplicate_listeners: for address %pI, \"\n                                \"cannot duplicate a new socket!\",\n                                duplr->bind_addr);\n                    return stat;\n                }\n                make_sock(p, duplr, 1);\n            }\n#if AP_NONBLOCK_WHEN_MULTI_LISTEN\n            use_nonblock = (ap_listeners && ap_listeners->next);\n            stat = apr_socket_opt_set(duplr->sd, APR_SO_NONBLOCK, use_nonblock);\n            if (stat != APR_SUCCESS) {\n                ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(02641)\n                              \"unable to control socket non-blocking status\");\n                return stat;\n            }\n#endif\n            ap_apply_accept_filter(p, duplr, s);\n\n            if (last == NULL) {\n                (*buckets)[i] = last = duplr;\n            }\n            else {\n                last->next = duplr;\n                last = duplr;\n            }\n            lr = lr->next;\n        }\n    }\n\n    ap_listen_buckets = *buckets;\n    ap_num_listen_buckets = *num_buckets;\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_8b2331a84b61095bb3057f32b78bbd078a348ac7_0", {
    "ID": "httpd_8b2331a84b61095bb3057f32b78bbd078a348ac7_0",
    "UID": "4697",
    "code": "AP_DECLARE_NONSTD(void) test_snippet\n{\n    int i;\n\n    ap_close_listeners_ex(ap_listeners);\n\n    /* Start from index 1 since either ap_duplicate_listeners()\n     * was called and ap_listen_buckets[0] == ap_listeners, or\n     * it wasn't and ap_num_listen_buckets == 0.\n     */\n    for (i = 1; i < ap_num_listen_buckets; i++) {\n        ap_close_listeners_ex(ap_listen_buckets[i]);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_9d23d5d411faa605db95d460b18302e07f46fc60_0", {
    "ID": "httpd_9d23d5d411faa605db95d460b18302e07f46fc60_0",
    "UID": "4702",
    "code": "APREQ_DECLARE(apr_status_t) apreq_brigade_concat(apr_pool_t test_snippet\n                                                 const char *temp_dir,\n                                                 apr_size_t heap_limit,\n                                                 apr_bucket_brigade *out,\n                                                 apr_bucket_brigade *in)\n{\n    apr_status_t s;\n    apr_bucket_file *f;\n    apr_off_t wlen;\n    apr_file_t *file;\n    apr_off_t in_len, out_len;\n    apr_bucket *last_in, *last_out;\n\n    last_out = APR_BRIGADE_LAST(out);\n\n    if (APR_BUCKET_IS_EOS(last_out))\n        return APR_EOF;\n\n    s = apr_brigade_length(out, 0, &out_len);\n    if (s != APR_SUCCESS)\n        return s;\n\n    \n    if ((apr_uint64_t)out_len < heap_limit) {\n\n        s = apr_brigade_length(in, 0, &in_len);\n        if (s != APR_SUCCESS)\n            return s;\n\n        \n        if ((apr_uint64_t)in_len < heap_limit - (apr_uint64_t)out_len) {\n            APR_BRIGADE_CONCAT(out, in);\n            return APR_SUCCESS;\n        }\n    }\n\n    if (!BUCKET_IS_SPOOL(last_out)) {\n\n        s = apreq_file_mktemp(&file, pool, temp_dir);\n        if (s != APR_SUCCESS)\n            return s;\n\n        s = apreq_brigade_fwrite(file, &wlen, out);\n\n        if (s != APR_SUCCESS)\n            return s;\n\n        last_out = apr_bucket_file_create(file, wlen, 0,\n                                          out->p, out->bucket_alloc);\n        last_out->type = &spool_bucket_type;\n        APR_BRIGADE_INSERT_TAIL(out, last_out);\n        f = last_out->data;\n    }\n    else {\n        f = last_out->data;\n        /* Need to seek here, just in case our spool bucket\n         * was read from between apreq_brigade_concat calls.\n         */\n        wlen = last_out->start + last_out->length;\n        s = apr_file_seek(f->fd, APR_SET, &wlen);\n        if (s != APR_SUCCESS)\n            return s;\n    }\n\n    if (in == out)\n        return APR_SUCCESS;\n\n    last_in = APR_BRIGADE_LAST(in);\n\n    if (APR_BUCKET_IS_EOS(last_in))\n        APR_BUCKET_REMOVE(last_in);\n\n    s = apreq_brigade_fwrite(f->fd, &wlen, in);\n\n    if (s == APR_SUCCESS) {\n\n        /* We have to deal with the possibility that the new\n         * data may be too large to be represented by a single\n         * temp_file bucket.\n         */\n\n        while ((apr_uint64_t)wlen > FILE_BUCKET_LIMIT - last_out->length) {\n            apr_bucket *e;\n\n            apr_bucket_copy(last_out, &e);\n            e->length = 0;\n            e->start = last_out->start + FILE_BUCKET_LIMIT;\n            wlen -= FILE_BUCKET_LIMIT - last_out->length;\n            last_out->length = FILE_BUCKET_LIMIT;\n\n            /* Copying makes the bucket types exactly the\n             * opposite of what we need here.\n             */\n            last_out->type = &apr_bucket_type_file;\n            e->type = &spool_bucket_type;\n\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            last_out = e;\n        }\n\n        last_out->length += wlen;\n\n        if (APR_BUCKET_IS_EOS(last_in))\n            APR_BRIGADE_INSERT_TAIL(out, last_in);\n\n    }\n    else if (APR_BUCKET_IS_EOS(last_in))\n        APR_BRIGADE_INSERT_TAIL(in, last_in);\n\n    apr_brigade_cleanup(in);\n    return s;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_8f350e854c8666f90079e7316a2aae39f554c0b0_0", {
    "ID": "httpd_8f350e854c8666f90079e7316a2aae39f554c0b0_0",
    "UID": "4704",
    "code": "APREQ_DECLARE(apr_status_t) apreq_brigade_fwrite(apr_file_t test_snippet\n                                                 apr_off_t *wlen,\n                                                 apr_bucket_brigade *bb)\n{\n    struct iovec v[APREQ_DEFAULT_NELTS];\n    apr_status_t s;\n    apr_bucket *e, *first;\n    int n = 0;\n    apr_bucket_brigade *tmp = bb;\n    *wlen = 0;\n\n    if (BUCKET_IS_SPOOL(APR_BRIGADE_LAST(bb))) {\n        tmp = apr_brigade_create(bb->p, bb->bucket_alloc);\n\n        s = apreq_brigade_copy(tmp, bb);\n        if (s != APR_SUCCESS)\n            return s;\n    }\n\n    for (e = APR_BRIGADE_FIRST(tmp); e != APR_BRIGADE_SENTINEL(tmp);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_size_t len;\n        if (n == APREQ_DEFAULT_NELTS) {\n            s = apreq_fwritev(f, v, &n, &len);\n            if (s != APR_SUCCESS)\n                return s;\n\n            if (tmp != bb) {\n                while ((first = APR_BRIGADE_FIRST(tmp)) != e)\n                    apr_bucket_delete(first);\n            }\n\n            *wlen += len;\n        }\n        s = apr_bucket_read(e, (const char **)&(v[n].iov_base),\n                            &len, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        v[n++].iov_len = len;\n    }\n\n    while (n > 0) {\n        apr_size_t len;\n        s = apreq_fwritev(f, v, &n, &len);\n        if (s != APR_SUCCESS)\n            return s;\n        *wlen += len;\n\n        if (tmp != bb) {\n            while ((first = APR_BRIGADE_FIRST(tmp)) != e)\n                apr_bucket_delete(first);\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_a56c4fc84ab029970c521aa77a1fb240088dd97c_0", {
    "ID": "httpd_a56c4fc84ab029970c521aa77a1fb240088dd97c_0",
    "UID": "4715",
    "code": "static void read_connection(struct connection * test_snippet\n{\n    apr_size_t r;\n    apr_status_t status;\n    char *part;\n    char respcode[4];       \n    int i;\n\n    r = sizeof(buffer);\n#ifdef USE_SSL\n    if (c->ssl) {\n        status = SSL_read(c->ssl, buffer, r);\n        if (status <= 0) {\n            int scode = SSL_get_error(c->ssl, status);\n\n            if (scode == SSL_ERROR_ZERO_RETURN) {\n                \n                good++;\n                close_connection(test_snippet;\n            }\n            else if (scode == SSL_ERROR_SYSCALL\n                     && status == 0\n                     && c->read != 0) {\n                /* connection closed, but in violation of the protocol, after\n                 * some data has already been read; this commonly happens, so\n                 * let the length check catch any response errors\n                 */\n                good++;\n                close_connection(test_snippet;\n            }\n            else if (scode == SSL_ERROR_SYSCALL \n                     && c->read == 0\n                     && destsa->next\n                     && c->state == STATE_CONNECTING\n                     && good == 0) {\n                return;\n            }\n            else if (scode != SSL_ERROR_WANT_WRITE\n                     && scode != SSL_ERROR_WANT_READ) {\n                \n                c->read = 0;\n                BIO_printf(bio_err, \"SSL read failed (%d) - closing connection\\n\", scode);\n                ERR_print_errors(bio_err);\n                close_connection(test_snippet;\n            }\n            return;\n        }\n        r = status;\n    }\n    else\n#endif\n    {\n        status = apr_socket_recv(c->aprsock, buffer, &r);\n        if (APR_STATUS_IS_EAGAIN(status))\n            return;\n        else if (r == 0 && APR_STATUS_IS_EOF(status)) {\n            good++;\n            close_connection(test_snippet;\n            return;\n        }\n        \n        else if (status != APR_SUCCESS) {\n            if (recverrok) {\n                err_recv++;\n                bad++;\n                close_connection(test_snippet;\n                if (verbosity >= 1) {\n                    char buf[120];\n                    fprintf(stderr,\"%s: %s (%d)\\n\", \"apr_socket_recv\", apr_strerror(status, buf, sizeof buf), status);\n                }\n                return;\n            } else if (destsa->next && c->state == STATE_CONNECTING\n                       && c->read == 0 && good == 0) {\n                return;\n            }\n            else {\n                err_recv++;\n                apr_err(\"apr_socket_recv\", status);\n            }\n        }\n    }\n\n    totalread += r;\n    if (c->read == 0) {\n        c->beginread = apr_time_now();\n    }\n    c->read += r;\n\n\n    if (!c->gotheader) {\n        char *s;\n        int l = 4;\n        apr_size_t space = CBUFFSIZE - c->cbx - 1; \n        int tocopy = (space < r) ? space : r;\n#ifdef NOT_ASCII\n        apr_size_t inbytes_left = space, outbytes_left = space;\n\n        status = apr_xlate_conv_buffer(from_ascii, buffer, &inbytes_left,\n                           c->cbuff + c->cbx, &outbytes_left);\n        if (status || inbytes_left || outbytes_left) {\n            fprintf(stderr, \"only simple translation is supported (%d/%\" APR_SIZE_T_FMT\n                            \"/%\" APR_SIZE_T_FMT \")\\n\", status, inbytes_left, outbytes_left);\n            exit(1);\n        }\n#else\n        memcpy(c->cbuff + c->cbx, buffer, space);\n#endif              \n        c->cbx += tocopy;\n        space -= tocopy;\n        c->cbuff[c->cbx] = 0;   \n        if (verbosity >= 2) {\n            printf(\"LOG: header received:\\n%s\\n\", c->cbuff);\n        }\n        s = strstr(c->cbuff, \"\\r\\n\\r\\n\");\n        /*\n         * this next line is so that we talk to NCSA 1.5 which blatantly\n         * breaks the http specifaction\n         */\n        if (!s) {\n            s = strstr(c->cbuff, \"\\n\\n\");\n            l = 2;\n        }\n\n        if (!s) {\n            \n            if (space) {\n                return;\n            }\n            else {\n            \n                set_conn_state(c, STATE_UNCONNECTED);\n                apr_socket_close(c->aprsock);\n                err_response++;\n                if (bad++ > 10) {\n                    err(\"\\nTest aborted after 10 failures\\n\\n\");\n                }\n                start_connect(test_snippet;\n            }\n        }\n        else {\n            \n            if (!good) {\n                /*\n                 * this is first time, extract some interesting info\n                 */\n                char *p, *q;\n                size_t len = 0;\n                p = strstr(c->cbuff, \"Server:\");\n                q = servername;\n                if (p) {\n                    p += 8;\n                    \n                    while (*p > 32 && len++ < sizeof(servername) - 1)\n                        *q++ = *p++;\n                }\n                *q = 0;\n            }\n            /*\n             * XXX: this parsing isn't even remotely HTTP compliant... but in\n             * the interest of speed it doesn't totally have to be, it just\n             * needs to be extended to handle whatever servers folks want to\n             * test against. -djg\n             */\n\n            \n            part = strstr(c->cbuff, \"HTTP\");    \n            if (part && strlen(part) > strlen(\"HTTP/1.x_\")) {\n                strncpy(respcode, (part + strlen(\"HTTP/1.x_\")), 3);\n                respcode[3] = '\\0';\n            }\n            else {\n                strcpy(respcode, \"500\");\n            }\n\n            if (respcode[0] != '2') {\n                err_response++;\n                if (verbosity >= 2)\n                    printf(\"WARNING: Response code not 2xx (%s)\\n\", respcode);\n            }\n            else if (verbosity >= 3) {\n                printf(\"LOG: Response code = %s\\n\", respcode);\n            }\n            c->gotheader = 1;\n            *s = 0;     \n            if (keepalive &&\n            (strstr(c->cbuff, \"Keep-Alive\")\n             || strstr(c->cbuff, \"keep-alive\"))) {  \n                char *cl;\n                cl = strstr(c->cbuff, \"Content-Length:\");\n                \n                if (!cl)\n                    cl = strstr(c->cbuff, \"Content-length:\");\n                if (cl) {\n                    c->keepalive = 1;\n                    \n                    c->length = method != HEAD ? atoi(cl + 16) : 0;\n                }\n                \n                if (!cl) {\n                    c->keepalive = 1;\n                    c->length = 0;\n                }\n            }\n            c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;\n            totalbread += c->bread;\n\n            /* We have received the header, so we know this destination socket\n             * address is working, so initialize all remaining requests. */\n            if (!requests_initialized) {\n                for (i = 1; i < concurrency; i++) {\n                    con[i].socknum = i;\n                    start_connect(&con[i]);\n                }\n                requests_initialized = 1;\n            }\n        }\n    }\n    else {\n        \n        c->bread += r;\n        totalbread += r;\n    }\n\n    if (c->keepalive && (c->bread >= c->length)) {\n        \n        good++;\n        \n        if (good == 1) {\n            \n            doclen = c->bread;\n        }\n        else if ((c->bread != doclen) && !nolength) {\n            bad++;\n            err_length++;\n        }\n        if (done < requests) {\n            struct data *s = &stats[done++];\n            doneka++;\n            c->done      = apr_time_now();\n            s->starttime = c->start;\n            s->ctime     = ap_max(0, c->connect - c->start);\n            s->time      = ap_max(0, c->done - c->start);\n            s->waittime  = ap_max(0, c->beginread - c->endwrite);\n            if (heartbeatres && !(done % heartbeatres)) {\n                fprintf(stderr, \"Completed %d requests\\n\", done);\n                fflush(stderr);\n            }\n        }\n        c->keepalive = 0;\n        c->length = 0;\n        c->gotheader = 0;\n        c->cbx = 0;\n        c->read = c->bread = 0;\n        \n        c->start = c->connect = lasttime = apr_time_now();\n        write_request(test_snippet;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_df43fc14e1aeca9e7d0ecee7a521452c7cfd7ee0_0", {
    "ID": "httpd_df43fc14e1aeca9e7d0ecee7a521452c7cfd7ee0_0",
    "UID": "4732",
    "code": "static void join_workers(apr_thread_t * listener, apr_thread_t ** test_snippet\n{\n    int i;\n    apr_status_t rv, thread_rv;\n\n    if (listener) {\n        int iter;\n\n        /* deal with a rare timing window which affects waking up the\n         * listener thread...  if the signal sent to the listener thread\n         * is delivered between the time it verifies that the\n         * listener_may_exit flag is clear and the time it enters a\n         * blocking syscall, the signal didn't do any good...  work around\n         * that by sleeping briefly and sending it again\n         */\n\n        iter = 0;\n        while (iter < 10 && !dying) {\n            \n            apr_sleep(apr_time_make(0, 500000));\n            wakeup_listener();\n            ++iter;\n        }\n        if (iter >= 10) {\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00475)\n                         \"the listener thread didn't stop accepting\");\n        }\n        else {\n            rv = apr_thread_join(&thread_rv, listener);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00476)\n                             \"apr_thread_join: unable to join listener thread\");\n            }\n        }\n    }\n\n    for (i = 0; i < threads_per_child; i++) {\n        if (threads[i]) {       \n            rv = apr_thread_join(&thread_rv, threads[i]);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00477)\n                             \"apr_thread_join: unable to join worker \"\n                             \"thread %d\", i);\n            }\n        }\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_faf85fd0b1aa99f36eb535dd0f7f172659c7de9b_0", {
    "ID": "httpd_faf85fd0b1aa99f36eb535dd0f7f172659c7de9b_0",
    "UID": "4756",
    "code": "static int event_open_logs(apr_pool_t * p, apr_pool_t * test_snippet\n                           apr_pool_t * ptemp, server_rec * s)\n{\n    int startup = 0;\n    int level_flags = 0;\n    ap_listen_rec **listen_buckets;\n    apr_status_t rv;\n    int i;\n\n    pconf = p;\n\n    \n    if (retained->module_loads == 1) {\n        startup = 1;\n        level_flags |= APLOG_STARTUP;\n    }\n\n    if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT | level_flags, 0,\n                     (startup ? NULL : s),\n                     \"no listening sockets available, shutting down\");\n        return DONE;\n    }\n\n    if (one_process) {\n        num_buckets = 1;\n    }\n    else if (!retained->is_graceful) { /* Preserve the number of buckets\n                                          on graceful restarts. */\n        num_buckets = 0;\n    }\n    if ((rv = ap_duplicate_listeners(pconf, ap_server_conf,\n                                     &listen_buckets, &num_buckets))) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,\n                     (startup ? NULL : s),\n                     \"could not duplicate listeners\");\n        return DONE;\n    }\n    all_buckets = apr_pcalloc(pconf, num_buckets *\n                                     sizeof(event_child_bucket));\n    for (i = 0; i < num_buckets; i++) {\n        if (!one_process && \n                (rv = ap_mpm_podx_open(pconf, &all_buckets[i].pod))) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,\n                         (startup ? NULL : s),\n                         \"could not open pipe-of-death\");\n            return DONE;\n        }\n        all_buckets[i].listeners = listen_buckets[i];\n    }\n\n    \n    srand((unsigned int)apr_time_now());\n    return OK;\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
  },
  "httpd_6fcaf8a884c61904355276d489faf7f5ea6e1d76_0", {
    "ID": "httpd_6fcaf8a884c61904355276d489faf7f5ea6e1d76_0",
    "UID": "4758",
    "code": "static int proxy_fcgi_canon(request_rec *r, char test_snippet\n{\n    char *host, sport[7];\n    const char *err;\n    char *path;\n    apr_port_t port, def_port;\n    fcgi_req_config_t *rconf = NULL;\n    const char *pathinfo_type = NULL;\n\n    if (strncasecmp(url, \"fcgi:\", 5) == 0) {\n        url += 5;\n    }\n    else {\n        return DECLINED;\n    }\n\n    port = def_port = ap_proxy_port_of_scheme(\"fcgi\");\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                 \"canonicalising URL %s\", url);\n    err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\n    if (err) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01059)\n                      \"error parsing URL %s: %s\", url, err);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (port != def_port)\n        apr_snprintf(sport, sizeof(sport), \":%d\", port);\n    else\n        sport[0] = '\\0';\n\n    if (ap_strchr_c(host, ':')) {\n        \n        host = apr_pstrcat(r->pool, \"[\", host, \"]\", NULL);\n    }\n\n    if (apr_table_get(r->notes, \"proxy-nocanon\")) {\n        path = url;   \n    }\n    else {\n        path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0,\n                             r->proxyreq);\n    }\n    if (path == NULL)\n        return HTTP_BAD_REQUEST;\n\n    r->filename = apr_pstrcat(r->pool, \"proxy:fcgi://\", host, sport, \"/\",\n                              path, NULL);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01060)\n                  \"set r->filename to %s\", r->filename);\n\n    rconf = ap_get_module_config(r->request_config, &proxy_fcgi_module);\n    if (rconf == NULL) { \n        rconf = apr_pcalloc(r->pool, sizeof(fcgi_req_config_t));\n        ap_set_module_config(r->request_config, &proxy_fcgi_module, rconf);\n    }\n\n    if (NULL != (pathinfo_type = apr_table_get(r->subprocess_env, \"proxy-fcgi-pathinfo\"))) {\n        \n        if (!strcasecmp(pathinfo_type, \"full\")) { \n            rconf->need_dirwalk = 1;\n            ap_unescape_url_keep2f(path, 0);\n        }\n        else if (!strcasecmp(pathinfo_type, \"first-dot\")) { \n            char *split = ap_strchr(path, '.');\n            if (split) { \n                char *slash = ap_strchr(split, '/');\n                if (slash) { \n                    r->path_info = apr_pstrdup(r->pool, slash);\n                    ap_unescape_url_keep2f(r->path_info, 0);\n                    *slash = '\\0'; \n                }\n            }\n        }\n        else if (!strcasecmp(pathinfo_type, \"last-dot\")) { \n            char *split = ap_strrchr(path, '.');\n            if (split) { \n                char *slash = ap_strchr(split, '/');\n                if (slash) { \n                    r->path_info = apr_pstrdup(r->pool, slash);\n                    ap_unescape_url_keep2f(r->path_info, 0);\n                    *slash = '\\0'; \n                }\n            }\n        }\n        else { \n            /* before proxy-fcgi-pathinfo had multi-values. This requires the\n             * the FCGI server to fixup PATH_INFO because it's the entire path\n             */\n            r->path_info = apr_pstrcat(r->pool, \"/\", path, NULL);\n            if (!strcasecmp(pathinfo_type, \"unescape\")) { \n                ap_unescape_url_keep2f(r->path_info, 0);\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01061)\n                    \"set r->path_info to %s\", r->path_info);\n        }\n    }\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_6b09d4311476507201f198789f35e22e35c893c0_0", {
    "ID": "httpd_6b09d4311476507201f198789f35e22e35c893c0_0",
    "UID": "4774",
    "code": "static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec test_snippet\n                                     const unsigned char *id, unsigned int idlen,\n                                     apr_time_t expiry,\n                                     unsigned char *ucaData, unsigned int nData,\n                                     apr_pool_t *p)\n{\n    char buf[MC_KEY_LEN];\n    apr_status_t rv;\n\n    if (socache_mc_id2key(ctx, id, idlen, buf, sizeof buf)) {\n        return APR_EINVAL;\n    }\n\n    /* memcache needs time in seconds till expiry; fail if this is not\n     * positive *before* casting to unsigned (apr_uint32_t). */\n    expiry -= apr_time_now();\n    if (apr_time_sec(expiry) <= 0) {\n        return APR_EINVAL;\n    }\n    rv = apr_memcache_set(ctx->mc, buf, (char*)ucaData, nData,\n                          apr_time_sec(expiry), 0);\n\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00790)\n                     \"scache_mc: error setting key '%s' \"\n                     \"with %d bytes of data\", buf, nData);\n        return rv;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2cbb440e8714c6430f50f7c45d0b141d6c11d817_0", {
    "ID": "httpd_2cbb440e8714c6430f50f7c45d0b141d6c11d817_0",
    "UID": "4779",
    "code": "AP_DECLARE(ap_condition_e) ap_condition_if_match(request_rec test_snippet\n        apr_table_t *headers)\n{\n    const char *if_match, *etag;\n\n    /* A server MUST use the strong comparison function (see section 13.3.3)\n     * to compare the entity tags in If-Match.\n     */\n    if ((if_match = apr_table_get(r->headers_in, \"If-Match\")) != NULL) {\n        if (if_match[0] == '*'\n                || ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                        && ap_find_etag_strong(r->pool, if_match, etag))) {\n            return AP_CONDITION_STRONG;\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e90f425ff024cf61dafab3605595227fcfadcb7d_0", {
    "ID": "httpd_e90f425ff024cf61dafab3605595227fcfadcb7d_0",
    "UID": "4796",
    "code": "PROXY_DECLARE(const char *) ap_proxy_de_socketfy(apr_pool_t *p, const char test_snippet\n{\n    const char *ptr;\n    /*\n     * We could be passed a URL during the config stage that contains\n     * the UDS path... ignore it\n     */\n    if (!strncasecmp(url, \"unix:\", 5) &&\n        ((ptr = ap_strchr_c(url, '|')) != NULL)) {\n        \n        const char *ret, *c;\n\n        ret = ptr + 1;\n        /* special case: \"unix:....|scheme:\" is OK, expand\n         * to \"unix:....|scheme://localhost\"\n         * */\n        c = ap_strchr_c(ret, ':');\n        if (c == NULL) {\n            return NULL;\n        }\n        if (c[1] == '\\0') {\n            return apr_pstrcat(p, ret, \"//localhost\", NULL);\n        }\n        else {\n            return ret;\n        }\n    }\n    return url;\n}",
    "predicted": "252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_1cdf1c88931c1ef9b171e7574cfa81bae08b01ad_0", {
    "ID": "httpd_1cdf1c88931c1ef9b171e7574cfa81bae08b01ad_0",
    "UID": "4804",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippetftest_snippetitest_snippetxtest_snippet_test_snippetutest_snippetdtest_snippetstest_snippet_test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet(test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetrtest_snippet,test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet*test_snippetutest_snippetrtest_snippetltest_snippet)test_snippet test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippetttest_snippetrtest_snippet,test_snippet test_snippet*test_snippetptest_snippetttest_snippetrtest_snippet2test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetrtest_snippet test_snippet|test_snippet|test_snippet test_snippet!test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetntest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet\"test_snippetptest_snippetrtest_snippetotest_snippetxtest_snippetytest_snippet:test_snippet\"test_snippet,test_snippet test_snippet6test_snippet)test_snippet test_snippet&test_snippet&test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet(test_snippetptest_snippetttest_snippetrtest_snippet2test_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetstest_snippetetest_snippetstest_snippetttest_snippetrtest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet\"test_snippetutest_snippetntest_snippetitest_snippetxtest_snippet:test_snippet\"test_snippet)test_snippet)test_snippet test_snippet&test_snippet&test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet(test_snippetptest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippetptest_snippetttest_snippetrtest_snippet2test_snippet,test_snippet test_snippet'test_snippet|test_snippet'test_snippet)test_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetutest_snippetrtest_snippetitest_snippet_test_snippetttest_snippet test_snippetutest_snippetrtest_snippetitest_snippetstest_snippetotest_snippetctest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet test_snippetrtest_snippetvtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetutest_snippetrtest_snippetitest_snippet_test_snippetptest_snippetatest_snippetrtest_snippetstest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetptest_snippetttest_snippetrtest_snippet2test_snippet,test_snippet test_snippet&test_snippetutest_snippetrtest_snippetitest_snippetstest_snippetotest_snippetctest_snippetktest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippetvtest_snippet test_snippet=test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetrtest_snippetutest_snippetrtest_snippetltest_snippet test_snippet=test_snippet test_snippetptest_snippetttest_snippetrtest_snippet+test_snippet1test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetstest_snippetotest_snippetctest_snippetktest_snippetptest_snippetatest_snippetttest_snippethtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetrtest_snippetutest_snippetntest_snippetttest_snippetitest_snippetmtest_snippetetest_snippet_test_snippetdtest_snippetitest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetltest_snippetatest_snippetttest_snippetitest_snippetvtest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetutest_snippetrtest_snippetitest_snippetstest_snippetotest_snippetctest_snippetktest_snippet.test_snippetptest_snippetatest_snippetttest_snippethtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetttest_snippetatest_snippetbtest_snippetltest_snippetetest_snippet_test_snippetstest_snippetetest_snippetttest_snippetntest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetntest_snippetotest_snippetttest_snippetetest_snippetstest_snippet,test_snippet test_snippet\"test_snippetutest_snippetdtest_snippetstest_snippet_test_snippetptest_snippetatest_snippetttest_snippethtest_snippet\"test_snippet,test_snippet test_snippetstest_snippetotest_snippetctest_snippetktest_snippetptest_snippetatest_snippetttest_snippethtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetutest_snippetrtest_snippetltest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippetutest_snippetrtest_snippetltest_snippet)test_snippet;test_snippet test_snippet/test_snippet*test_snippet test_snippetstest_snippetotest_snippet test_snippetwtest_snippetetest_snippet test_snippetgtest_snippetetest_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetstest_snippetctest_snippethtest_snippetetest_snippetmtest_snippetetest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetutest_snippetdtest_snippetstest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet test_snippetstest_snippetttest_snippetatest_snippetrtest_snippetttest_snippetstest_snippet test_snippetwtest_snippet/test_snippet test_snippet\"test_snippetptest_snippetrtest_snippetotest_snippetxtest_snippetytest_snippet:test_snippet\"test_snippet,test_snippet test_snippetstest_snippetotest_snippet test_snippetatest_snippetdtest_snippetdtest_snippet test_snippetatest_snippetftest_snippetttest_snippetetest_snippetrtest_snippet test_snippetttest_snippethtest_snippetatest_snippetttest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetmtest_snippetetest_snippetmtest_snippetmtest_snippetotest_snippetvtest_snippetetest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet+test_snippet6test_snippet,test_snippet test_snippetrtest_snippetutest_snippetrtest_snippetltest_snippet,test_snippet test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetrtest_snippetutest_snippetrtest_snippetltest_snippet)test_snippet+test_snippet1test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetrtest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetTtest_snippetRtest_snippetAtest_snippetCtest_snippetEtest_snippet2test_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetrtest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippet*test_snippet:test_snippet test_snippetrtest_snippetetest_snippetwtest_snippetrtest_snippetitest_snippetttest_snippetetest_snippet test_snippetotest_snippetftest_snippet test_snippetutest_snippetrtest_snippetltest_snippet test_snippetdtest_snippetutest_snippetetest_snippet test_snippetttest_snippetotest_snippet test_snippetUtest_snippetDtest_snippetStest_snippet(test_snippet%test_snippetstest_snippet)test_snippet:test_snippet test_snippet%test_snippetstest_snippet test_snippet(test_snippet%test_snippetstest_snippet)test_snippet\"test_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetotest_snippetctest_snippetktest_snippetptest_snippetatest_snippetttest_snippethtest_snippet,test_snippet test_snippet*test_snippetutest_snippetrtest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetttest_snippetrtest_snippet test_snippet=test_snippet test_snippet'test_snippet|test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code seems to be corrupted or not properly formatted. It's not possible to identify any specific vulnerability from this. Please provide a valid piece of C/C++ code."
  },
  "httpd_8f5d910835450e25e2dab8e57b7dc86e9c2dacc0_0", {
    "ID": "httpd_8f5d910835450e25e2dab8e57b7dc86e9c2dacc0_0",
    "UID": "4811",
    "code": "static char *parseargline(apr_pool_t *p, char *str, char **a1, char **a2, char test_snippet\n{\n    char quote;\n\n    while (apr_isspace(*str)) {\n        ++str;\n    }\n\n    /*\n     * determine first argument\n     */\n    quote = (*str == '\"' || *str == '\\'') ? *str++ : '\\0';\n    *a1 = str;\n\n    for (; *str; ++str) {\n        if ((apr_isspace(*str) && !quote) || (*str == quote)) {\n            break;\n        }\n        if (*str == '\\\\' && apr_isspace(str[1])) {\n            ++str;\n            continue;\n        }\n    }\n\n    if (!*str) {\n        return \"bad argument line: at least two arguments required\";\n    }\n    *str++ = '\\0';\n\n    while (apr_isspace(*str)) {\n        ++str;\n    }\n\n    /*\n     * determine second argument\n     */\n    quote = (*str == '\"' || *str == '\\'') ? *str++ : '\\0';\n    *a2 = str;\n\n    for (; *str; ++str) {\n        if ((apr_isspace(*str) && !quote) || (*str == quote)) {\n            break;\n        }\n        if (*str == '\\\\' && apr_isspace(str[1])) {\n            ++str;\n            continue;\n        }\n    }\n\n    if (!*str) {\n        *a3 = NULL; \n        return NULL;\n    }\n    *str++ = '\\0';\n\n    while (apr_isspace(*str)) {\n        ++str;\n    }\n\n    if (!*str) {\n        *a3 = NULL; \n        return NULL;\n    }\n\n    /*\n     * determine third argument\n     */\n    quote = (*str == '\"' || *str == '\\'') ? *str++ : '\\0';\n    *a3 = str;\n    for (; *str; ++str) {\n        if ((apr_isspace(*str) && !quote) || (*str == quote)) {\n            break;\n        }\n        if (*str == '\\\\' && apr_isspace(str[1])) {\n            ++str;\n            continue;\n        }\n    }\n    *str = '\\0';\n\n    if (**a3 != '[') {\n        return apr_psprintf(p, \"bad flag delimiters: third argument must begin \"\n               \"with '[' but found '%c' - too many arguments or rogue \"\n               \"whitespace?\", test_snippet;\n    }\n    else if ((*a3)[strlen(*a3)-1] != ']') {\n        return apr_psprintf(p, \"bad flag delimiters: third argument must end \"\n                \"with ']' but found '%c' - unintended whitespace within the \"\n                \"flags definition?\", (*a3)[strlen(*a3)-1]);\n    }\n    return NULL;\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference"
  },
  "httpd_2bc500730515183340d1f06fa1210c3dec982ae9_0", {
    "ID": "httpd_2bc500730515183340d1f06fa1210c3dec982ae9_0",
    "UID": "4819",
    "code": "static apr_status_t send_environment(proxy_conn_rec *conn, request_rec test_snippet\n                                     apr_pool_t *temp_pool,\n                                     apr_uint16_t request_id)\n{\n    const apr_array_header_t *envarr;\n    const apr_table_entry_t *elts;\n    struct iovec vec[2];\n    ap_fcgi_header header;\n    unsigned char farray[AP_FCGI_HEADER_LEN];\n    char *body;\n    apr_status_t rv;\n    apr_size_t avail_len, len, required_len;\n    int next_elem, starting_elem;\n    int fpm = 0;\n    fcgi_req_config_t *rconf = ap_get_module_config(r->request_config, &proxy_fcgi_module);\n    fcgi_dirconf_t *dconf = ap_get_module_config(r->per_dir_config, &proxy_fcgi_module);\n\n    if (rconf) {\n       if (rconf->need_dirwalk) {\n          ap_directory_walk(r);\n       }\n    }\n\n    \n    if (r->filename) {\n        char *newfname = NULL;\n\n        if (!strncmp(r->filename, \"proxy:balancer://\", 17)) {\n            newfname = apr_pstrdup(r->pool, r->filename+17);\n        }\n\n        if (!FCGI_MAY_BE_FPM(dconf))  {\n            if (!strncmp(r->filename, \"proxy:fcgi://\", 13)) {\n                /* If we strip this under FPM, and any internal redirect occurs\n                 * on PATH_INFO, FPM may use PATH_TRANSLATED instead of\n                 * SCRIPT_FILENAME (a la mod_fastcgi + Action).\n                 */\n                newfname = apr_pstrdup(r->pool, r->filename+13);\n            }\n            \n            if (newfname && r->args && *r->args) {\n                char *qs = strrchr(newfname, '?');\n                if (qs && !strcmp(qs+1, r->args)) {\n                    *qs = '\\0';\n                }\n            }\n        } else {\n            fpm = 1;\n        }\n\n        if (newfname) {\n            newfname = ap_strchr(newfname, '/');\n            r->filename = newfname;\n        }\n    }\n\n#if 0\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)\n                  \"r->filename: %s\", (r->filename ? r->filename : \"nil\"));\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)\n                  \"r->uri: %s\", (r->uri ? r->uri : \"nil\"));\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)\n                  \"r->path_info: %s\", (r->path_info ? r->path_info : \"nil\"));\n#endif\n\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    if (fpm || apr_table_get(r->notes, \"virtual_script\")) {\n        /*\n         * Adjust SCRIPT_NAME, PATH_INFO and PATH_TRANSLATED for PHP-FPM\n         * TODO: Right now, PATH_INFO and PATH_TRANSLATED look OK...\n         */\n        const char *pend;\n        const char *script_name = apr_table_get(r->subprocess_env, \"SCRIPT_NAME\");\n        pend = script_name + strlen(script_name);\n        if (r->path_info && *r->path_info) {\n            pend = script_name + ap_find_path_info(script_name, r->path_info) - 1;\n        }\n        while (pend != script_name && *pend != '/') {\n            pend--;\n        }\n        apr_table_setn(r->subprocess_env, \"SCRIPT_NAME\", pend);\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"fpm:virtual_script: Modified SCRIPT_NAME to: %s\",\n                      pend);\n    }\n\n    \n\n    \n    fix_cgivars(r, dconf);\n\n    /* XXX mod_cgi/mod_cgid use ap_create_environment here, which fills in\n     *     the TZ value specially.  We could use that, but it would mean\n     *     parsing the key/value pairs back OUT of the allocated env array,\n     *     not to mention allocating a totally useless array in the first\n     *     place, which would suck. */\n\n    envarr = apr_table_elts(r->subprocess_env);\n    elts = (const apr_table_entry_t *) envarr->elts;\n\n    if (APLOGrtrace8(r)) {\n        int i;\n\n        for (i = 0; i < envarr->nelts; ++i) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, APLOGNO(01062)\n                          \"sending env var '%s' value '%s'\",\n                          elts[i].key, elts[i].val);\n        }\n    }\n\n    \n    next_elem = 0; \n\n    avail_len = 16 * 1024; /* our limit per record, which could have been up\n                            * to AP_FCGI_MAX_CONTENT_LEN\n                            */\n\n    while (next_elem < envarr->nelts) {\n        starting_elem = next_elem;\n        required_len = ap_fcgi_encoded_env_len(r->subprocess_env,\n                                               avail_len,\n                                               &next_elem);\n\n        if (!required_len) {\n            if (next_elem < envarr->nelts) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                              APLOGNO(02536) \"couldn't encode envvar '%s' in %\"\n                              APR_SIZE_T_FMT \" bytes\",\n                              elts[next_elem].key, avail_len);\n                \n                ++next_elem;\n                continue;\n            }\n            \n            break;\n        }\n\n        body = apr_palloc(temp_pool, required_len);\n        rv = ap_fcgi_encode_env(r, r->subprocess_env, body, required_len,\n                                &starting_elem);\n        \n        ap_assert(rv == APR_SUCCESS);\n        \n        ap_assert(starting_elem == next_elem);\n\n        ap_fcgi_fill_in_header(&header, AP_FCGI_PARAMS, request_id,\n                               (apr_uint16_t)required_len, 0);\n        ap_fcgi_header_to_array(&header, farray);\n\n        vec[0].iov_base = (void *)farray;\n        vec[0].iov_len = sizeof(farray);\n        vec[1].iov_base = body;\n        vec[1].iov_len = required_len;\n\n        rv = send_data(conn, vec, 2, &len);\n        apr_pool_clear(temp_pool);\n\n        if (rv) {\n            return rv;\n        }\n    }\n\n    \n    ap_fcgi_fill_in_header(&header, AP_FCGI_PARAMS, request_id, 0, 0);\n    ap_fcgi_header_to_array(&header, farray);\n\n    vec[0].iov_base = (void *)farray;\n    vec[0].iov_len = sizeof(farray);\n\n    return send_data(conn, vec, 1, &len);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n762,Mismatched Memory Management Routines\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_08a4ed28cc87584472f4aabda319fe128c066148_0", {
    "ID": "httpd_08a4ed28cc87584472f4aabda319fe128c066148_0",
    "UID": "4822",
    "code": "AP_DECLARE(void) ap_add_cgi_vars(request_rec test_snippet\n{\n    apr_table_t *e = r->subprocess_env;\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    int request_uri_from_original = 1;\n    const char *request_uri_rule;\n\n    apr_table_setn(e, \"GATEWAY_INTERFACE\", \"CGI/1.1\");\n    apr_table_setn(e, \"SERVER_PROTOCOL\", r->protocol);\n    apr_table_setn(e, \"REQUEST_METHOD\", r->method);\n    apr_table_setn(e, \"QUERY_STRING\", r->args ? r->args : \"\");\n\n    if (conf->cgi_var_rules) {\n        request_uri_rule = apr_hash_get(conf->cgi_var_rules, \"REQUEST_URI\",\n                                        APR_HASH_KEY_STRING);\n        if (request_uri_rule && !strcmp(request_uri_rule, \"current-uri\")) {\n            request_uri_from_original = 0;\n        }\n    }\n    apr_table_setn(e, \"REQUEST_URI\",\n                   request_uri_from_original ? original_uri(r) : r->uri);\n\n    /* Note that the code below special-cases scripts run from includes,\n     * because it \"knows\" that the sub_request has been hacked to have the\n     * args and path_info of the original request, and not any that may have\n     * come with the script URI in the include command.  Ugh.\n     */\n\n    if (!strcmp(r->protocol, \"INCLUDED\")) {\n        apr_table_setn(e, \"SCRIPT_NAME\", r->uri);\n        if (r->path_info && *r->path_info) {\n            apr_table_setn(e, \"PATH_INFO\", r->path_info);\n        }\n    }\n    else if (!r->path_info || !*r->path_info) {\n        apr_table_setn(e, \"SCRIPT_NAME\", r->uri);\n    }\n    else {\n        int path_info_start = ap_find_path_info(r->uri, r->path_info);\n\n        apr_table_setn(e, \"SCRIPT_NAME\",\n                      apr_pstrndup(r->pool, r->uri, path_info_start));\n\n        apr_table_setn(e, \"PATH_INFO\", r->path_info);\n    }\n\n    if (r->path_info && r->path_info[0]) {\n        /*\n         * To get PATH_TRANSLATED, treat PATH_INFO as a URI path.\n         * Need to re-escape it for this, since the entire URI was\n         * un-escaped before we determined where the PATH_INFO began.\n         */\n        request_rec *pa_req;\n\n        pa_req = ap_sub_req_lookup_uri(ap_escape_uri(r->pool, r->path_info), r,\n                                       NULL);\n\n        if (pa_req->filename) {\n            char *pt = apr_pstrcat(r->pool, pa_req->filename, pa_req->path_info,\n                                  NULL);\n#ifdef WIN32\n            \n            apr_filepath_merge(&pt, \"\", pt, APR_FILEPATH_NATIVE, r->pool);\n#endif\n            apr_table_setn(e, \"PATH_TRANSLATED\", pt);\n        }\n        ap_destroy_sub_req(pa_req);\n    }\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_997099f6bd9f9086f5788e0beff39e78bfe564d6_0", {
    "ID": "httpd_997099f6bd9f9086f5788e0beff39e78bfe564d6_0",
    "UID": "4837",
    "code": "static int dav_init_handler(apr_pool_t *p, apr_pool_t *plog, apr_pool_t test_snippet\n                             server_rec *s)\n{\n    \n\n    \n    dav_methods[DAV_M_BIND] = ap_method_register(p, \"BIND\");\n    dav_methods[DAV_M_SEARCH] = ap_method_register(p, \"SEARCH\");\n\n    \n#ifndef APR_XML_X2T_PARSED\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(10119)\n                 \"mod_dav ACL support disabled. Compile with apr-util >= 1.6 to enable.\");\n#endif\n\n    return OK;\n}",
    "predicted": "null"
  },
  "httpd_5f4af508e20dd686f3b6d0a61a3f32826eabd13d_0", {
    "ID": "httpd_5f4af508e20dd686f3b6d0a61a3f32826eabd13d_0",
    "UID": "4838",
    "code": "static authz_status host_check_authorization(request_rec test_snippet\n                                             const char *require_line,\n                                             const void *parsed_require_line)\n{\n    const char *t, *w;\n    const char *remotehost = NULL;\n    int remotehost_is_ip;\n\n    remotehost = ap_get_useragent_host(r, REMOTE_DOUBLE_REV, &remotehost_is_ip);\n\n    if ((remotehost == NULL) || remotehost_is_ip) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01753)\n                      \"access check of '%s' to %s failed, reason: unable to get the \"\n                      \"remote host name\", require_line, r->uri);\n    }\n    else {\n        const char *err = NULL;\n        const ap_expr_info_t *expr = parsed_require_line;\n        const char *require;\n\n        require = ap_expr_str_exec(r, expr, &err);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02593)\n                          \"authz_host authorize: require host: Can't \"\n                          \"evaluate require expression: %s\", err);\n            return AUTHZ_DENIED;\n        }\n\n        /* The 'host' provider will allow the configuration to specify a list of\n            host names to check rather than a single name.  This is different\n            from the previous host based syntax. */\n        t = require;\n\n        /* '#' is not a valid hostname character and admin could\n         * specify 'Require host localhost# Add example.com later'. We\n         * should not grant access to 'example.com' in that case. */\n        w = ap_strchr_c(t, '#');\n        if (w) {\n            if (w == t) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10120)\n                              \"authz_host authorize: dubious empty \"\n                              \"'Require host %s' with only comment\", t);\n                return AUTHZ_DENIED;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10121)\n                          \"authz_host authorize: ignoring comment in \"\n                          \"'Require host %s'\", t);\n\n            \n            t = apr_pstrmemdup(r->pool, t, w - t);\n        }\n        \n        while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n            if (in_domain(w, remotehost)) {\n                return AUTHZ_GRANTED;\n            }\n        }\n    }\n\n    \n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_ebb29231a2a9912894c43f9d8ae458ddad5451b8_0", {
    "ID": "httpd_ebb29231a2a9912894c43f9d8ae458ddad5451b8_0",
    "UID": "4880",
    "code": "static int ap_proxy_strcmp_ematch(const char *str, const char test_snippet\n{\n    apr_size_t x, y;\n\n    for (x = 0, y = 0; expected[y]; ++y, ++x) {\n        if (expected[y] == '$' && apr_isdigit(expected[y + 1])) {\n            do {\n                y += 2;\n            } while (expected[y] == '$' && apr_isdigit(expected[y + 1]));\n            if (!expected[y])\n                return 0;\n            while (str[x]) {\n                int ret;\n                if ((ret = ap_proxy_strcmp_ematch(&str[x++], &expected[y])) != 1)\n                    return ret;\n            }\n            return -1;\n        }\n        else if (!str[x]) {\n            return -1;\n        }\n        else if (expected[y] == '\\\\' && !expected[++y]) {\n            \n            return -2;\n        }\n        if (str[x] != expected[y])\n            return 1;\n    }\n    \n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_507a59ae7c873812c4938597b948bbb78aecd0b9_0", {
    "ID": "httpd_507a59ae7c873812c4938597b948bbb78aecd0b9_0",
    "UID": "4900",
    "code": "static const char *set_regex_default_options(cmd_parms test_snippet\n                                             void *dummy,\n                                             const char *arg)\n{\n    const command_rec *thiscmd = cmd->cmd;\n    int cflags, cflag;\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    cflags = ap_regcomp_get_default_cflags();\n    while (*arg) {\n        const char *name = ap_getword_conf(cmd->pool, &arg);\n        int how = 0;\n\n        if (strcasecmp(name, \"none\") == 0) {\n            cflags = 0;\n            continue;\n        }\n\n        if (*name == '+') {\n            name++;\n            how = +1;\n        }\n        else if (*name == '-') {\n            name++;\n            how = -1;\n        }\n\n        cflag = ap_regcomp_default_cflag_by_name(name);\n        if (!cflag) {\n            return apr_psprintf(cmd->pool, \"%s: option '%s' unknown\",\n                                thiscmd->name, name);\n        }\n\n        if (how > 0) {\n            cflags |= cflag;\n        }\n        else if (how < 0) {\n            cflags &= ~cflag;\n        }\n        else {\n            cflags = cflag;\n        }\n    }\n    ap_regcomp_set_default_cflags(cflags);\n\n    return NULL;\n}",
    "predicted": "This code does not appear to have any obvious vulnerabilities, so the response would be null."
  },
  "httpd_a33980d2c8fe096e5e4539ed7a05be997b612517_0", {
    "ID": "httpd_a33980d2c8fe096e5e4539ed7a05be997b612517_0",
    "UID": "4919",
    "code": "apr_status_t ajp_msg_log(request_rec *r, ajp_msg_t *msg, char test_snippet\n{\n    int level;\n    apr_size_t count;\n    char *buf, *next;\n    apr_status_t rc = APR_SUCCESS;\n\n    if (APLOGrtrace7(r)) {\n        level = APLOG_TRACE7;\n        count = 1024;\n        if (APLOGrtrace8(r)) {\n            level = APLOG_TRACE8;\n            count = AJP_MAX_BUFFER_SZ;\n        }\n        rc = ajp_msg_dump(r->pool, msg, err, count, &buf);\n        if (rc == APR_SUCCESS) {\n            while ((next = ap_strchr(buf, '\\n'))) {\n                *next = '\\0';\n                \n                ap_log_rerror(APLOG_MARK, level, 0, r, \"%s\", buf);\n                buf = next + 1;\n            }\n            \n            ap_log_rerror(APLOG_MARK, level, 0, r, \"%s\", buf);\n        }\n    }\n    return rc;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_9dd74d9ad39a139de83654aab621f0c831a16b21_0", {
    "ID": "httpd_9dd74d9ad39a139de83654aab621f0c831a16b21_0",
    "UID": "4922",
    "code": "static apr_status_t pumpit(ap_filter_t *f, apr_bucket *b, firehose_ctx_t test_snippet\n{\n    apr_status_t rv = APR_SUCCESS;\n\n    if (!(APR_BUCKET_IS_METADATA(b))) {\n        const char *buf;\n        apr_size_t nbytes, offset = 0;\n\n        rv = apr_bucket_read(b, &buf, &nbytes, APR_BLOCK_READ);\n\n        if (rv == APR_SUCCESS) {\n            while (nbytes > 0) {\n                char header[HEADER_LEN + 1];\n                apr_size_t hdr_len;\n                apr_size_t body_len = nbytes < BODY_LEN ? nbytes : BODY_LEN;\n                apr_size_t bytes;\n                struct iovec vec[3];\n\n                /*\n                 * Insert the chunk header, specifying the number of bytes in\n                 * the chunk.\n                 */\n                hdr_len = apr_snprintf(header, sizeof(header), HEADER_FMT,\n                        (apr_uint64_t) body_len, (apr_uint64_t) apr_time_now(),\n                        ctx->direction, ctx->uuid, ctx->count);\n                ap_xlate_proto_to_ascii(header, hdr_len);\n\n                vec[0].iov_base = header;\n                vec[0].iov_len = hdr_len;\n                vec[1].iov_base = (void *) (buf + offset);\n                vec[1].iov_len = body_len;\n                vec[2].iov_base = CRLF;\n                vec[2].iov_len = 2;\n\n                rv = apr_file_writev_full(ctx->conn->file, vec, 3, &bytes);\n                if (APR_SUCCESS != rv) {\n                    if (ctx->conn->suppress) {\n                        \n                    }\n                    else if (ctx->r) {\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, ctx->r, APLOGNO(03185)\n                                \"mod_firehose: could not write %\" APR_UINT64_T_FMT \" bytes to '%s' for '%c' connection '%s' and count '%0\" APR_UINT64_T_HEX_FMT \"', bytes dropped (further errors will be suppressed)\",\n                                (apr_uint64_t)(vec[0].iov_len + vec[1].iov_len + vec[2].iov_len), ctx->conn->filename, ctx->conn->direction, ctx->uuid, ctx->count);\n                    }\n                    else {\n                        ap_log_cerror(APLOG_MARK, APLOG_WARNING, rv, ctx->c, APLOGNO(03186)\n                                \"mod_firehose: could not write %\" APR_UINT64_T_FMT \" bytes to '%s' for '%c' connection '%s' and count '%0\" APR_UINT64_T_HEX_FMT \"', bytes dropped (further errors will be suppressed)\",\n                                (apr_uint64_t)(vec[0].iov_len + vec[1].iov_len + vec[2].iov_len), ctx->conn->filename, ctx->conn->direction, ctx->uuid, ctx->count);\n                    }\n                    ctx->conn->suppress = 1;\n                    rv = APR_SUCCESS;\n                }\n                else {\n                    ctx->conn->suppress = 0;\n                }\n\n                ctx->count++;\n                nbytes -= vec[1].iov_len;\n                offset += vec[1].iov_len;\n            }\n        }\n\n    }\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_9d8251540b6a856c73c8e7438690d38047f97593_0", {
    "ID": "httpd_9d8251540b6a856c73c8e7438690d38047f97593_0",
    "UID": "4924",
    "code": "static apr_status_t firehose_input_filter(ap_filter_t test_snippet\n                                          apr_bucket_brigade *bb,\n                                          ap_input_mode_t mode,\n                                          apr_read_type_e block,\n                                          apr_off_t readbytes)\n{\n    apr_bucket *b;\n    apr_status_t rv;\n    firehose_ctx_t *ctx = f->ctx;\n\n    \n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n\n    /* if an error was received, bail out now. If the error is\n     * EAGAIN and we have not yet seen an EOS, we will definitely\n     * be called again, at which point we will send our buffered\n     * data. Instead of sending EAGAIN, some filters return an\n     * empty brigade instead when data is not yet available. In\n     * this case, pass through the APR_SUCCESS and emulate the\n     * underlying filter.\n     */\n    if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n        return rv;\n    }\n\n    for (b = APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b\n            = APR_BUCKET_NEXT(b)) {\n        rv = pumpit(f, b, ctx);\n        if (APR_SUCCESS != rv) {\n            return rv;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n"
  },
  "httpd_578859ee5627367dbba611ffbaa4d5ed5b99be0d_0", {
    "ID": "httpd_578859ee5627367dbba611ffbaa4d5ed5b99be0d_0",
    "UID": "4925",
    "code": "static apr_status_t firehose_output_filter(ap_filter_t test_snippet\n                                           apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n    apr_status_t rv = APR_SUCCESS;\n    firehose_ctx_t *ctx = f->ctx;\n\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(bb)) {\n\n        b = APR_BRIGADE_FIRST(bb);\n\n        rv = pumpit(f, b, ctx);\n        if (APR_SUCCESS != rv) {\n            return rv;\n        }\n\n        \n        APR_BUCKET_REMOVE(b);\n        APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n\n        /*\n         * If we ever see an EOS, make sure to FLUSH.\n         */\n        if (APR_BUCKET_IS_EOS(b)) {\n            apr_bucket *flush = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(b, flush);\n        }\n\n        rv = ap_pass_brigade(f->next, ctx->bb);\n\n    }\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5b27b56690b6cd604b6d72ed6ab0a3dcad31da19_0", {
    "ID": "httpd_5b27b56690b6cd604b6d72ed6ab0a3dcad31da19_0",
    "UID": "4927",
    "code": "static void yy_push_state (int  new_state , yyscan_t test_snippet\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif ( yyg->yy_start_stack_ptr >= yyg->yy_start_stack_depth )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tyyg->yy_start_stack_depth += YY_START_STACK_INCR;\n\t\tnew_size = yyg->yy_start_stack_depth * sizeof( int );\n\n\t\tif ( ! yyg->yy_start_stack )\n\t\t\tyyg->yy_start_stack = (int *) ap_expr_yyalloc(new_size ,yyscanner );\n\n\t\telse\n\t\t\tyyg->yy_start_stack = (int *) ap_expr_yyrealloc((void *) yyg->yy_start_stack,new_size ,yyscanner );\n\n\t\tif ( ! yyg->yy_start_stack )\n\t\t\tYY_FATAL_ERROR( \"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tyyg->yy_start_stack[yyg->yy_start_stack_ptr++] = YY_START;\n\n\tBEGIN(new_state);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_c5b7905f90bb1c72df87951d8c8def5ce60f460c_0", {
    "ID": "httpd_c5b7905f90bb1c72df87951d8c8def5ce60f460c_0",
    "UID": "4936",
    "code": "static int ssl_rand_choosenum(int l, int test_snippet\n{\n    int i;\n    char buf[50];\n\n    srand((unsigned int)time(NULL));\n    apr_snprintf(buf, sizeof(buf), \"%.0f\",\n                 (((double)(rand()%RAND_MAX)/RAND_MAX)*(h-l)));\n    i = atoi(buf)+1;\n    if (i < l) i = l;\n    if (i > test_snippet i = h;\n    return i;\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n457,Use of Uninitialized Variable"
  },
  "httpd_566f086bed1ad79ade130bc0378ee9adb39e48d3_0", {
    "ID": "httpd_566f086bed1ad79ade130bc0378ee9adb39e48d3_0",
    "UID": "4939",
    "code": "static void dav_begin_multistatus(apr_bucket_brigade test_snippet\n                                  request_rec *r, int status,\n                                  apr_array_header_t *namespaces)\n{\n    \n    r->status = status;\n    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);\n\n    \n    ap_fputs(r->output_filters, bb, DAV_XML_HEADER DEBUG_CR\n             \"<D:multistatus xmlns:D=\\\"DAV:\\\"\");\n\n    if (namespaces != NULL) {\n       int i;\n\n       for (i = namespaces->nelts; i--; ) {\n           ap_fprintf(r->output_filters, bb, \" xmlns:ns%d=\\\"%s\\\"\", i,\n                      APR_XML_GET_URI_ITEM(namespaces, i));\n       }\n    }\n\n    ap_fputs(r->output_filters, bb, \">\" DEBUG_CR);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_5edbaf51185ea0a3b2f9161c9662aa3b989bbb5b_0", {
    "ID": "httpd_5edbaf51185ea0a3b2f9161c9662aa3b989bbb5b_0",
    "UID": "4941",
    "code": "static void ssl_print_cert_info(BIO *bio, X509 test_snippet\n{\n    X509_NAME *dn;\n    EVP_PKEY *pk;\n    char buf[1024];\n\n    BIO_printf(bio, \"Certificate version: %ld\\n\", X509_get_version(cert)+1);\n    BIO_printf(bio,\"Valid from: \");\n    ASN1_UTCTIME_print(bio, X509_get_notBefore(cert));\n    BIO_printf(bio,\"\\n\");\n\n    BIO_printf(bio,\"Valid to  : \");\n    ASN1_UTCTIME_print(bio, X509_get_notAfter(cert));\n    BIO_printf(bio,\"\\n\");\n\n    pk = X509_get_pubkey(cert);\n    BIO_printf(bio,\"Public key is %d bits\\n\",\n               EVP_PKEY_bits(pk));\n    EVP_PKEY_free(pk);\n\n    dn = X509_get_issuer_name(cert);\n    X509_NAME_oneline(dn, buf, sizeof(buf));\n    BIO_printf(bio,\"The issuer name is %s\\n\", buf);\n\n    dn=X509_get_subject_name(cert);\n    X509_NAME_oneline(dn, buf, sizeof(buf));\n    BIO_printf(bio,\"The subject name is %s\\n\", buf);\n\n    \n    BIO_printf(bio, \"Extension Count: %d\\n\", X509_get_ext_count(cert));\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_782389e67a9afedb2f5cba65c1214ff470b81c05_0", {
    "ID": "httpd_782389e67a9afedb2f5cba65c1214ff470b81c05_0",
    "UID": "4944",
    "code": "static void ssl_print_info(struct connection test_snippet\n{\n    X509_STACK_TYPE *sk;\n    X509 *cert;\n    int count;\n\n    BIO_printf(bio_err, \"\\n\");\n    sk = SSL_get_peer_cert_chain(c->ssl);\n    if ((count = SK_NUM(sk)) > 0) {\n        int i;\n        for (i=1; i<count; i++) {\n            cert = (X509 *)SK_VALUE(sk, i);\n            ssl_print_cert_info(bio_out, cert);\n    }\n    }\n    cert = SSL_get_peer_certificate(c->ssl);\n    if (cert == NULL) {\n        BIO_printf(bio_out, \"Anon DH\\n\");\n    } else {\n        BIO_printf(bio_out, \"Peer certificate\\n\");\n        ssl_print_cert_info(bio_out, cert);\n        X509_free(cert);\n    }\n    ssl_print_connection_info(bio_err,c->ssl);\n    SSL_SESSION_print(bio_err, SSL_get_session(c->ssl));\n    }",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_09bf8eea3c328ebb2df6b5fc70bfa0643957e990_0", {
    "ID": "httpd_09bf8eea3c328ebb2df6b5fc70bfa0643957e990_0",
    "UID": "4949",
    "code": "static void write_request(struct connection * test_snippet\n{\n    if (started >= requests) {\n        return;\n    }\n\n    do {\n        apr_time_t tnow;\n        apr_size_t l = c->rwrite;\n        apr_status_t e = APR_SUCCESS; \n\n        tnow = lasttime = apr_time_now();\n\n        /*\n         * First time round ?\n         */\n        if (c->rwrite == 0) {\n            apr_socket_timeout_set(c->aprsock, 0);\n            c->connect = tnow;\n            c->rwrote = 0;\n            c->rwrite = reqlen;\n            if (send_body)\n                c->rwrite += postlen;\n            l = c->rwrite;\n        }\n        else if (tnow > c->connect + aprtimeout) {\n            printf(\"Send request timed out!\\n\");\n            close_connection(test_snippet;\n            return;\n        }\n\n#ifdef USE_SSL\n        if (c->ssl) {\n            apr_size_t e_ssl;\n            e_ssl = SSL_write(c->ssl,request + c->rwrote, l);\n            if (e_ssl != l) {\n                BIO_printf(bio_err, \"SSL write failed - closing connection\\n\");\n                ERR_print_errors(bio_err);\n                close_connection (test_snippet;\n                return;\n            }\n            l = e_ssl;\n            e = APR_SUCCESS;\n        }\n        else\n#endif\n            e = apr_socket_send(c->aprsock, request + c->rwrote, &l);\n\n        if (e != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(e)) {\n            epipe++;\n            printf(\"Send request failed!\\n\");\n            close_connection(test_snippet;\n            return;\n        }\n        totalposted += l;\n        c->rwrote += l;\n        c->rwrite -= l;\n    } while (c->rwrite);\n\n    c->endwrite = lasttime = apr_time_now();\n    started++;\n    set_conn_state(c, STATE_READ);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_6d3c581080c1b57fdd5100ffdda457a53bc15fc0_0", {
    "ID": "httpd_6d3c581080c1b57fdd5100ffdda457a53bc15fc0_0",
    "UID": "4994",
    "code": "static int yy_get_next_buffer (yyscan_t test_snippet\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = yyg->yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ \n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t\n\n\t\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ \n\n\t\t\t\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t\n\t\t\t\t\tap_expr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tap_expr_yyrestart(yyin  ,test_snippet;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t\n\t\tyy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ap_expr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_770969d40f5c4cd33b959083d332a6a36c4d97cc_0", {
    "ID": "httpd_770969d40f5c4cd33b959083d332a6a36c4d97cc_0",
    "UID": "4996",
    "code": "static void ap_expr_yyensure_buffer_stack (yyscan_t test_snippet\n{\n\tint num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ap_expr_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, test_snippet;\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in ap_expr_yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t\n\t\tint grow_size = 8 ;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ap_expr_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, test_snippet;\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in ap_expr_yyensure_buffer_stack()\" );\n\n\t\t\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_f2eeb9ca3f3ffabc0e309b6c627e0b82a3ab660f_0", {
    "ID": "httpd_f2eeb9ca3f3ffabc0e309b6c627e0b82a3ab660f_0",
    "UID": "5010",
    "code": "static int balancer_handler(request_rec test_snippet\n{\n    void *sconf;\n    proxy_server_conf *conf;\n    proxy_balancer *balancer, *bsel = NULL;\n    proxy_worker *worker, *wsel = NULL;\n    proxy_worker **workers = NULL;\n    apr_table_t *params;\n    int i, n;\n    int ok2change = 1;\n    const char *name;\n    const char *action;\n    apr_status_t rv;\n\n    \n    if (strcmp(r->handler, \"balancer-manager\")) {\n        return DECLINED;\n    }\n\n    r->allowed = 0\n    | (AP_METHOD_BIT << M_GET)\n    | (AP_METHOD_BIT << M_POST);\n    if ((r->method_number != M_GET) && (r->method_number != M_POST)) {\n        return DECLINED;\n    }\n\n    sconf = r->server->module_config;\n    conf = (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);\n    params = apr_table_make(r->pool, 10);\n\n    balancer = (proxy_balancer *)conf->balancers->elts;\n    for (i = 0; i < conf->balancers->nelts; i++, balancer++) {\n        if ((rv = PROXY_THREAD_LOCK(balancer)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01189)\n                          \"%s: Lock failed for balancer_handler\",\n                          balancer->s->name);\n        }\n        ap_proxy_sync_balancer(balancer, r->server, conf);\n        if ((rv = PROXY_THREAD_UNLOCK(balancer)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01190)\n                          \"%s: Unlock failed for balancer_handler\",\n                          balancer->s->name);\n        }\n    }\n\n    if (r->args && (r->method_number == M_GET)) {\n        const char *allowed[] = { \"w\", \"b\", \"nonce\", \"xml\", NULL };\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01191) \"parsing r->args\");\n\n        push2table(r->args, params, allowed, r->pool);\n    }\n    if (r->method_number == M_POST) {\n        apr_bucket_brigade *ib;\n        apr_size_t len = 1024;\n        char *buf = apr_pcalloc(r->pool, len+1);\n\n        ib = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);\n        rv = ap_get_brigade(r->input_filters, ib, AP_MODE_READBYTES,\n                                APR_BLOCK_READ, len);\n        if (rv != APR_SUCCESS) {\n            return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n        }\n        apr_brigade_flatten(ib, buf, &len);\n        buf[len] = '\\0';\n        push2table(buf, params, NULL, r->pool);\n    }\n    if ((name = apr_table_get(params, \"b\")))\n        bsel = ap_proxy_get_balancer(r->pool, conf,\n            apr_pstrcat(r->pool, BALANCER_PREFIX, name, NULL), 0);\n\n    if ((name = apr_table_get(params, \"w\"))) {\n        wsel = ap_proxy_get_worker(r->pool, bsel, conf, name);\n    }\n\n\n    /* Check that the supplied nonce matches this server's nonce;\n     * otherwise ignore all parameters, to prevent a CSRF attack. */\n    if (!bsel ||\n        (*bsel->s->nonce &&\n         (\n          (name = apr_table_get(params, \"nonce\")) == NULL ||\n          strcmp(bsel->s->nonce, name) != 0\n         )\n        )\n       ) {\n        apr_table_clear(params);\n        ok2change = 0;\n    }\n\n    \n    if (wsel && ok2change) {\n        const char *val;\n        int was_usable = PROXY_WORKER_IS_USABLE(wsel);\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01192) \"settings worker params\");\n\n        if ((val = apr_table_get(params, \"w_lf\"))) {\n            int ival = atoi(val);\n            if (ival >= 1 && ival <= 100) {\n                wsel->s->lbfactor = ival;\n                if (bsel)\n                    recalc_factors(bsel);\n            }\n        }\n        if ((val = apr_table_get(params, \"w_wr\"))) {\n            if (strlen(val) && strlen(val) < sizeof(wsel->s->route))\n                strcpy(wsel->s->route, val);\n            else\n                *wsel->s->route = '\\0';\n        }\n        if ((val = apr_table_get(params, \"w_rr\"))) {\n            if (strlen(val) && strlen(val) < sizeof(wsel->s->redirect))\n                strcpy(wsel->s->redirect, val);\n            else\n                *wsel->s->redirect = '\\0';\n        }\n        /*\n         * TODO: Look for all 'w_status_#' keys and then loop thru\n         * on that # character, since the character == the flag\n         */\n        if ((val = apr_table_get(params, \"w_status_I\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_IGNORE_ERRORS_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_status_N\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_DRAIN_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_status_D\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_DISABLED_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_status_H\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_HOT_STANDBY_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_status_S\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_STOPPED_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_status_C\"))) {\n            ap_proxy_set_wstatus(PROXY_WORKER_HC_FAIL_FLAG, atoi(val), wsel);\n        }\n        if ((val = apr_table_get(params, \"w_ls\"))) {\n            int ival = atoi(val);\n            if (ival >= 0 && ival <= 99) {\n                wsel->s->lbset = ival;\n             }\n        }\n        if ((val = apr_table_get(params, \"w_hi\"))) {\n            int ival = atoi(val);\n            if (ival >= HCHECK_WATHCHDOG_INTERVAL) {\n                wsel->s->interval = apr_time_from_sec(ival);\n             }\n        }\n        if ((val = apr_table_get(params, \"w_hp\"))) {\n            int ival = atoi(val);\n            if (ival >= 1) {\n                wsel->s->passes = ival;\n             }\n        }\n        if ((val = apr_table_get(params, \"w_hf\"))) {\n            int ival = atoi(val);\n            if (ival >= 1) {\n                wsel->s->fails = ival;\n             }\n        }\n        if ((val = apr_table_get(params, \"w_hm\"))) {\n            proxy_hcmethods_t *method = proxy_hcmethods;\n            for (; method->name; method++) {\n                if (!ap_casecmpstr(method->name, val) && method->implemented)\n                    wsel->s->method = method->method;\n            }\n        }\n        if ((val = apr_table_get(params, \"w_hu\"))) {\n            if (strlen(val) && strlen(val) < sizeof(wsel->s->hcuri))\n                strcpy(wsel->s->hcuri, val);\n            else\n                *wsel->s->hcuri = '\\0';\n        }\n        if (hc_valid_expr_f && (val = apr_table_get(params, \"w_he\"))) {\n            if (strlen(val) && hc_valid_expr_f(r, val) && strlen(val) < sizeof(wsel->s->hcexpr))\n                strcpy(wsel->s->hcexpr, val);\n            else\n                *wsel->s->hcexpr = '\\0';\n        }\n        \n        if (wsel->s->method == NONE || wsel->s->method == TCP) {\n            *wsel->s->hcexpr = '\\0';\n        }\n        \n        if (bsel && !was_usable && PROXY_WORKER_IS_USABLE(wsel)) {\n            bsel->s->need_reset = 1;\n        }\n\n    }\n\n    if (bsel && ok2change) {\n        const char *val;\n        int ival;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01193)\n                      \"settings balancer params\");\n        if ((val = apr_table_get(params, \"b_lbm\"))) {\n            if ((strlen(val) < (sizeof(bsel->s->lbpname)-1)) &&\n                strcmp(val, bsel->s->lbpname)) {\n                proxy_balancer_method *lbmethod;\n                lbmethod = ap_lookup_provider(PROXY_LBMETHOD, val, \"0\");\n                if (lbmethod) {\n                    PROXY_STRNCPY(bsel->s->lbpname, val);\n                    bsel->lbmethod = lbmethod;\n                    bsel->s->wupdated = apr_time_now();\n                    bsel->s->need_reset = 1;\n                }\n            }\n        }\n        if ((val = apr_table_get(params, \"b_tmo\"))) {\n            ival = atoi(val);\n            if (ival >= 0 && ival <= 7200) { \n                bsel->s->timeout = apr_time_from_sec(ival);\n            }\n        }\n        if ((val = apr_table_get(params, \"b_max\"))) {\n            ival = atoi(val);\n            if (ival >= 0 && ival <= 99) {\n                bsel->s->max_attempts = ival;\n            }\n        }\n        if ((val = apr_table_get(params, \"b_sforce\"))) {\n            ival = atoi(val);\n            bsel->s->sticky_force = (ival != 0);\n        }\n        if ((val = apr_table_get(params, \"b_ss\")) && *val) {\n            if (strlen(val) < (sizeof(bsel->s->sticky_path)-1)) {\n                if (*val == '-' && *(val+1) == '\\0')\n                    *bsel->s->sticky_path = *bsel->s->sticky = '\\0';\n                else {\n                    char *path;\n                    PROXY_STRNCPY(bsel->s->sticky_path, val);\n                    PROXY_STRNCPY(bsel->s->sticky, val);\n\n                    if ((path = strchr((char *)bsel->s->sticky, '|'))) {\n                        *path++ = '\\0';\n                        PROXY_STRNCPY(bsel->s->sticky_path, path);\n                    }\n                }\n            }\n        }\n        if ((val = apr_table_get(params, \"b_wyes\")) &&\n            (*val == '1' && *(val+1) == '\\0') &&\n            (val = apr_table_get(params, \"b_nwrkr\"))) {\n            char *ret;\n            proxy_worker *nworker;\n            nworker = ap_proxy_get_worker(r->pool, bsel, conf, val);\n            if (!nworker && storage->num_free_slots(bsel->wslot)) {\n                if ((rv = PROXY_GLOBAL_LOCK(bsel)) != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01194)\n                                  \"%s: Lock failed for adding worker\",\n                                  bsel->s->name);\n                }\n                ret = ap_proxy_define_worker(conf->pool, &nworker, bsel, conf, val, 0);\n                if (!ret) {\n                    unsigned int index;\n                    proxy_worker_shared *shm;\n                    PROXY_COPY_CONF_PARAMS(nworker, conf);\n                    if ((rv = storage->grab(bsel->wslot, &index)) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01195)\n                                      \"worker slotmem_grab failed\");\n                        if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01196)\n                                          \"%s: Unlock failed for adding worker\",\n                                          bsel->s->name);\n                        }\n                        return HTTP_BAD_REQUEST;\n                    }\n                    if ((rv = storage->dptr(bsel->wslot, index, (void *)&shm)) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01197)\n                                      \"worker slotmem_dptr failed\");\n                        if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01198)\n                                          \"%s: Unlock failed for adding worker\",\n                                          bsel->s->name);\n                        }\n                        return HTTP_BAD_REQUEST;\n                    }\n                    if ((rv = ap_proxy_share_worker(nworker, shm, index)) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01199)\n                                      \"Cannot share worker\");\n                        if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01200)\n                                          \"%s: Unlock failed for adding worker\",\n                                          bsel->s->name);\n                        }\n                        return HTTP_BAD_REQUEST;\n                    }\n                    if ((rv = ap_proxy_initialize_worker(nworker, r->server, conf->pool)) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01201)\n                                      \"Cannot init worker\");\n                        if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01202)\n                                          \"%s: Unlock failed for adding worker\",\n                                          bsel->s->name);\n                        }\n                        return HTTP_BAD_REQUEST;\n                    }\n                    \n                    bsel->wupdated = bsel->s->wupdated = nworker->s->updated = apr_time_now();\n                    \n                    ap_proxy_set_wstatus(PROXY_WORKER_DISABLED_FLAG, 1, nworker);\n                }\n                if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01203)\n                                  \"%s: Unlock failed for adding worker\",\n                                  bsel->s->name);\n                }\n            }\n\n        }\n\n    }\n\n    action = ap_construct_url(r->pool, r->uri, r);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01204) \"genning page\");\n\n    if (apr_table_get(params, \"xml\")) {\n        char date[APR_RFC822_DATE_LEN];\n        ap_set_content_type(r, \"text/xml\");\n        ap_rputs(\"<?xml version='1.0' encoding='UTF-8' ?>\\n\", r);\n        ap_rputs(\"<httpd:manager xmlns:httpd='http://httpd.apache.org'>\\n\", r);\n        ap_rputs(\"  <httpd:balancers>\\n\", r);\n        balancer = (proxy_balancer *)conf->balancers->elts;\n        for (i = 0; i < conf->balancers->nelts; i++) {\n            ap_rputs(\"    <httpd:balancer>\\n\", r);\n            \n            ap_rvputs(r, \"      <httpd:name>\", balancer->s->name, \"</httpd:name>\\n\", NULL);\n            if (*balancer->s->sticky) {\n                ap_rvputs(r, \"      <httpd:stickysession>\", balancer->s->sticky,\n                          \"</httpd:stickysession>\\n\", NULL);\n                ap_rprintf(r,\n                           \"      <httpd:nofailover>%s</httpd:nofailover>\\n\",\n                           (balancer->s->sticky_force ? \"On\" : \"Off\"));\n            }\n            ap_rprintf(r,\n                       \"      <httpd:timeout>%\" APR_TIME_T_FMT \"</httpd:timeout>\",\n                       apr_time_sec(balancer->s->timeout));\n            if (balancer->s->max_attempts_set) {\n                ap_rprintf(r,\n                           \"      <httpd:maxattempts>%d</httpd:maxattempts>\\n\",\n                           balancer->s->max_attempts);\n            }\n            ap_rvputs(r, \"      <httpd:lbmethod>\", balancer->lbmethod->name,\n                      \"</httpd:lbmethod>\\n\", NULL);\n            if (*balancer->s->sticky) {\n                ap_rprintf(r,\n                           \"      <httpd:scolonpathdelim>%s</httpd:scolonpathdelim>\\n\",\n                           (balancer->s->scolonsep ? \"On\" : \"Off\"));\n            }\n            \n            ap_rputs(\"      <httpd:workers>\\n\", r);\n            workers = (proxy_worker **)balancer->workers->elts;\n            for (n = 0; n < balancer->workers->nelts; n++) {\n                worker = *workers;\n                \n                ap_rputs(\"        <httpd:worker>\\n\", r);\n                ap_rvputs(r, \"          <httpd:name>\", ap_proxy_worker_name(r->pool, worker),\n                          \"</httpd:name>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:scheme>\", worker->s->scheme,\n                          \"</httpd:scheme>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:hostname>\", worker->s->hostname,\n                          \"</httpd:hostname>\\n\", NULL);\n                ap_rprintf(r, \"          <httpd:loadfactor>%d</httpd:loadfactor>\\n\",\n                          worker->s->lbfactor);\n                ap_rprintf(r,\n                           \"          <httpd:port>%d</httpd:port>\\n\",\n                           worker->s->port);\n                ap_rprintf(r, \"          <httpd:min>%d</httpd:min>\\n\",\n                           worker->s->min);\n                ap_rprintf(r, \"          <httpd:smax>%d</httpd:smax>\\n\",\n                           worker->s->smax);\n                ap_rprintf(r, \"          <httpd:max>%d</httpd:max>\\n\",\n                           worker->s->hmax);\n                ap_rprintf(r,\n                           \"          <httpd:ttl>%\" APR_TIME_T_FMT \"</httpd:ttl>\\n\",\n                           apr_time_sec(worker->s->ttl));\n                if (worker->s->timeout_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:timeout>%\" APR_TIME_T_FMT \"</httpd:timeout>\\n\",\n                               apr_time_sec(worker->s->timeout));\n                }\n                if (worker->s->acquire_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:acquire>%\" APR_TIME_T_FMT \"</httpd:acquire>\\n\",\n                               apr_time_msec(worker->s->acquire));\n                }\n                if (worker->s->recv_buffer_size_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:recv_buffer_size>%\" APR_SIZE_T_FMT \"</httpd:recv_buffer_size>\\n\",\n                               worker->s->recv_buffer_size);\n                }\n                if (worker->s->io_buffer_size_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:io_buffer_size>%\" APR_SIZE_T_FMT \"</httpd:io_buffer_size>\\n\",\n                               worker->s->io_buffer_size);\n                }\n                if (worker->s->keepalive_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:keepalive>%s</httpd:keepalive>\\n\",\n                               (worker->s->keepalive ? \"On\" : \"Off\"));\n                }\n                \n                ap_rputs(\"          <httpd:status>\", r);\n                ap_rputs(ap_proxy_parse_wstatus(r->pool, worker), r);\n                ap_rputs(\"</httpd:status>\\n\", r);\n                if ((worker->s->error_time > 0) && apr_rfc822_date(date, worker->s->error_time) == APR_SUCCESS) {\n                    ap_rvputs(r, \"          <httpd:error_time>\", date,\n                              \"</httpd:error_time>\\n\", NULL);\n                }\n                ap_rprintf(r,\n                           \"          <httpd:retries>%d</httpd:retries>\\n\",\n                           worker->s->retries);\n                ap_rprintf(r,\n                           \"          <httpd:lbstatus>%d</httpd:lbstatus>\\n\",\n                           worker->s->lbstatus);\n                ap_rprintf(r,\n                           \"          <httpd:loadfactor>%d</httpd:loadfactor>\\n\",\n                           worker->s->lbfactor);\n                ap_rprintf(r,\n                           \"          <httpd:transferred>%\" APR_OFF_T_FMT \"</httpd:transferred>\\n\",\n                           worker->s->transferred);\n                ap_rprintf(r,\n                           \"          <httpd:read>%\" APR_OFF_T_FMT \"</httpd:read>\\n\",\n                           worker->s->read);\n                ap_rprintf(r,\n                           \"          <httpd:elected>%\" APR_SIZE_T_FMT \"</httpd:elected>\\n\",\n                           worker->s->elected);\n                ap_rvputs(r, \"          <httpd:route>\",\n                          ap_escape_html(r->pool, worker->s->route),\n                          \"</httpd:route>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:redirect>\",\n                          ap_escape_html(r->pool, worker->s->redirect),\n                          \"</httpd:redirect>\\n\", NULL);\n                ap_rprintf(r,\n                           \"          <httpd:busy>%\" APR_SIZE_T_FMT \"</httpd:busy>\\n\",\n                           worker->s->busy);\n                ap_rprintf(r, \"          <httpd:lbset>%d</httpd:lbset>\\n\",\n                           worker->s->lbset);\n                \n                if (!ap_casecmpstr(worker->s->scheme, \"ajp\")) {\n                    ap_rputs(\"          <httpd:flushpackets>\", r);\n                    switch (worker->s->flush_packets) {\n                        case flush_off:\n                            ap_rputs(\"Off\", r);\n                            break;\n                        case flush_on:\n                            ap_rputs(\"On\", r);\n                            break;\n                        case flush_auto:\n                            ap_rputs(\"Auto\", r);\n                            break;\n                    }\n                    ap_rputs(\"</httpd:flushpackets>\\n\", r);\n                    if (worker->s->flush_packets == flush_auto) {\n                        ap_rprintf(r,\n                                   \"          <httpd:flushwait>%d</httpd:flushwait>\\n\",\n                                   worker->s->flush_wait);\n                    }\n                    if (worker->s->ping_timeout_set) {\n                        ap_rprintf(r,\n                                   \"          <httpd:ping>%\" APR_TIME_T_FMT \"</httpd:ping>\",\n                                   apr_time_msec(worker->s->ping_timeout));\n                    }\n                }\n                if (worker->s->disablereuse_set) {\n                    ap_rprintf(r,\n                               \"      <httpd:disablereuse>%s</httpd:disablereuse>\\n\",\n                               (worker->s->disablereuse ? \"On\" : \"Off\"));\n                }\n                if (worker->s->conn_timeout_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:connectiontimeout>%\" APR_TIME_T_FMT \"</httpd:connectiontimeout>\\n\",\n                               apr_time_msec(worker->s->conn_timeout));\n                }\n                if (worker->s->retry_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:retry>%\" APR_TIME_T_FMT \"</httpd:retry>\\n\",\n                               apr_time_sec(worker->s->retry));\n                }\n                ap_rputs(\"        </httpd:worker>\\n\", r);\n                ++workers;\n            }\n            ap_rputs(\"      </httpd:workers>\\n\", r);\n            ap_rputs(\"    </httpd:balancer>\\n\", r);\n            ++balancer;\n        }\n        ap_rputs(\"  </httpd:balancers>\\n\", r);\n        ap_rputs(\"</httpd:manager>\", r);\n    }\n    else {\n        ap_set_content_type(r, \"text/html; charset=ISO-8859-1\");\n        ap_rputs(DOCTYPE_HTML_3_2\n                 \"<html><head><title>Balancer Manager</title>\\n\", r);\n        ap_rputs(\"<style type='text/css'>\\n\"\n                 \"table {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" border-spacing: 3px;\\n\"\n                 \" border-style: solid;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" border-collapse: collapse;\\n\"\n                 \" background-color: white;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"th {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" padding: 2px;\\n\"\n                 \" border-style: dotted;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" background-color: lightgray;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"td {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" padding: 2px;\\n\"\n                 \" border-style: dotted;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" background-color: white;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"</style>\\n</head>\\n\", r);\n        ap_rputs(\"<body><h1>Load Balancer Manager for \", r);\n        ap_rvputs(r, ap_escape_html(r->pool, ap_get_server_name(r)),\n                  \"</h1>\\n\\n\", NULL);\n        ap_rvputs(r, \"<dl><dt>Server Version: \",\n                  ap_get_server_description(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Server Built: \",\n                  ap_get_server_built(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Balancer changes will \", conf->bal_persist ? \"\" : \"NOT \",\n                  \"be persisted on restart.</dt>\", NULL);\n        ap_rvputs(r, \"<dt>Balancers are \", conf->inherit ? \"\" : \"NOT \",\n                  \"inherited from main server.</dt>\", NULL);\n        ap_rvputs(r, \"<dt>ProxyPass settings are \", conf->ppinherit ? \"\" : \"NOT \",\n                  \"inherited from main server.</dt>\", NULL);\n        ap_rputs(\"</dl>\\n\", r);\n        balancer = (proxy_balancer *)conf->balancers->elts;\n        for (i = 0; i < conf->balancers->nelts; i++) {\n\n            ap_rputs(\"<hr />\\n<h3>LoadBalancer Status for \", r);\n            ap_rvputs(r, \"<a href='\", ap_escape_uri(r->pool, r->uri), \"?b=\",\n                      balancer->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"&amp;nonce=\", balancer->s->nonce,\n                      \"'>\", NULL);\n            ap_rvputs(r, balancer->s->name, \"</a> [\",balancer->s->sname, \"]</h3>\\n\", NULL);\n            ap_rputs(\"\\n\\n<table><tr>\"\n                \"<th>MaxMembers</th><th>StickySession</th><th>DisableFailover</th><th>Timeout</th><th>FailoverAttempts</th><th>Method</th>\"\n                \"<th>Path</th><th>Active</th></tr>\\n<tr>\", r);\n            /* the below is a safe cast, since the number of slots total will\n             * never be more than max_workers, which is restricted to int */\n            ap_rprintf(r, \"<td>%d [%d Used]</td>\\n\", balancer->max_workers,\n                       balancer->max_workers - (int)storage->num_free_slots(balancer->wslot));\n            if (*balancer->s->sticky) {\n                if (strcmp(balancer->s->sticky, balancer->s->sticky_path)) {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, \" | \",\n                              balancer->s->sticky_path, NULL);\n                }\n                else {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, NULL);\n                }\n            }\n            else {\n                ap_rputs(\"<td> (None) \", r);\n            }\n            ap_rprintf(r, \"</td><td>%s</td>\\n\",\n                       balancer->s->sticky_force ? \"On\" : \"Off\");\n            ap_rprintf(r, \"<td>%\" APR_TIME_T_FMT \"</td>\",\n                apr_time_sec(balancer->s->timeout));\n            ap_rprintf(r, \"<td>%d</td>\\n\", balancer->s->max_attempts);\n            ap_rprintf(r, \"<td>%s</td>\\n\",\n                       balancer->s->lbpname);\n            ap_rputs(\"<td>\", r);\n            if (*balancer->s->vhost) {\n                ap_rvputs(r, balancer->s->vhost, \" -> \", NULL);\n            }\n            ap_rvputs(r, balancer->s->vpath, \"</td>\\n\", NULL);\n            ap_rprintf(r, \"<td>%s</td>\\n\",\n                       !balancer->s->inactive ? \"Yes\" : \"No\");\n            ap_rputs(\"</table>\\n<br />\", r);\n            ap_rputs(\"\\n\\n<table><tr>\"\n                \"<th>Worker URL</th>\"\n                \"<th>Route</th><th>RouteRedir</th>\"\n                \"<th>Factor</th><th>Set</th><th>Status</th>\"\n                \"<th>Elected</th><th>Busy</th><th>Load</th><th>To</th><th>From</th>\", r);\n            if (set_worker_hc_param_f) {\n                ap_rputs(\"<th>HC Method</th><th>HC Interval</th><th>Passes</th><th>Fails</th><th>HC uri</th><th>HC Expr</th>\", r);\n            }\n            ap_rputs(\"</tr>\\n\", r);\n\n            workers = (proxy_worker **)balancer->workers->elts;\n            for (n = 0; n < balancer->workers->nelts; n++) {\n                char fbuf[50];\n                worker = *workers;\n                ap_rvputs(r, \"<tr>\\n<td><a href='\",\n                          ap_escape_uri(r->pool, r->uri), \"?b=\",\n                          balancer->s->name + sizeof(BALANCER_PREFIX) - 1, \"&amp;w=\",\n                          ap_escape_uri(r->pool, worker->s->name),\n                          \"&amp;nonce=\", balancer->s->nonce,\n                          \"'>\", NULL);\n                ap_rvputs(r, (*worker->s->uds_path ? \"<i>\" : \"\"), ap_proxy_worker_name(r->pool, worker),\n                          (*worker->s->uds_path ? \"</i>\" : \"\"), \"</a></td>\", NULL);\n                ap_rvputs(r, \"<td>\", ap_escape_html(r->pool, worker->s->route),\n                          NULL);\n                ap_rvputs(r, \"</td><td>\",\n                          ap_escape_html(r->pool, worker->s->redirect), NULL);\n                ap_rprintf(r, \"</td><td>%d</td>\", worker->s->lbfactor);\n                ap_rprintf(r, \"<td>%d</td><td>\", worker->s->lbset);\n                ap_rvputs(r, ap_proxy_parse_wstatus(r->pool, worker), NULL);\n                ap_rputs(\"</td>\", r);\n                ap_rprintf(r, \"<td>%\" APR_SIZE_T_FMT \"</td>\", worker->s->elected);\n                ap_rprintf(r, \"<td>%\" APR_SIZE_T_FMT \"</td>\", worker->s->busy);\n                ap_rprintf(r, \"<td>%d</td><td>\", worker->s->lbstatus);\n                ap_rputs(apr_strfsize(worker->s->transferred, fbuf), r);\n                ap_rputs(\"</td><td>\", r);\n                ap_rputs(apr_strfsize(worker->s->read, fbuf), r);\n                if (set_worker_hc_param_f) {\n                    ap_rprintf(r, \"</td><td>%s</td>\", ap_proxy_show_hcmethod(worker->s->method));\n                    ap_rprintf(r, \"<td>%d</td>\", (int)apr_time_sec(worker->s->interval));\n                    ap_rprintf(r, \"<td>%d (%d)</td>\", worker->s->passes,worker->s->pcount);\n                    ap_rprintf(r, \"<td>%d (%d)</td>\", worker->s->fails, worker->s->fcount);\n                    ap_rprintf(r, \"<td>%s</td>\", worker->s->hcuri);\n                    ap_rprintf(r, \"<td>%s\", worker->s->hcexpr);\n                }\n                ap_rputs(\"</td></tr>\\n\", r);\n\n                ++workers;\n            }\n            ap_rputs(\"</table>\\n\", r);\n            ++balancer;\n        }\n        ap_rputs(\"<hr />\\n\", r);\n        if (hc_show_exprs_f) {\n            hc_show_exprs_f(r);\n        }\n        if (wsel && bsel) {\n            ap_rputs(\"<h3>Edit worker settings for \", r);\n            ap_rvputs(r, (*wsel->s->uds_path?\"<i>\":\"\"), ap_proxy_worker_name(r->pool, wsel), (*wsel->s->uds_path?\"</i>\":\"\"), \"</h3>\\n\", NULL);\n            ap_rputs(\"<form method='POST' enctype='application/x-www-form-urlencoded' action='\", r);\n            ap_rvputs(r, ap_escape_uri(r->pool, action), \"'>\\n\", NULL);\n            ap_rputs(\"<table><tr><td>Load factor:</td><td><input name='w_lf' id='w_lf' type=text \", r);\n            ap_rprintf(r, \"value='%d'></td></tr>\\n\", wsel->s->lbfactor);\n            ap_rputs(\"<tr><td>LB Set:</td><td><input name='w_ls' id='w_ls' type=text \", r);\n            ap_rprintf(r, \"value='%d'></td></tr>\\n\", wsel->s->lbset);\n            ap_rputs(\"<tr><td>Route:</td><td><input name='w_wr' id='w_wr' type=text \", r);\n            ap_rvputs(r, \"value='\", ap_escape_html(r->pool, wsel->s->route),\n                      NULL);\n            ap_rputs(\"'></td></tr>\\n\", r);\n            ap_rputs(\"<tr><td>Route Redirect:</td><td><input name='w_rr' id='w_rr' type=text \", r);\n            ap_rvputs(r, \"value='\", ap_escape_html(r->pool, wsel->s->redirect),\n                      NULL);\n            ap_rputs(\"'></td></tr>\\n\", r);\n            ap_rputs(\"<tr><td>Status:</td>\", r);\n            ap_rputs(\"<td><table><tr>\"\n                     \"<th>Ignore Errors</th>\"\n                     \"<th>Draining Mode</th>\"\n                     \"<th>Disabled</th>\"\n                     \"<th>Hot Standby</th>\", r);\n            if (hc_show_exprs_f) {\n                ap_rputs(\"<th>HC Fail</th>\", r);\n            }\n            ap_rputs(\"<th>Stopped</th></tr>\\n<tr>\", r);\n            create_radio(\"w_status_I\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_IGNORE_ERRORS)), r);\n            create_radio(\"w_status_N\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_DRAIN)), r);\n            create_radio(\"w_status_D\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_DISABLED)), r);\n            create_radio(\"w_status_H\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_HOT_STANDBY)), r);\n            if (hc_show_exprs_f) {\n                create_radio(\"w_status_C\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_HC_FAIL)), r);\n            }\n            create_radio(\"w_status_S\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_STOPPED)), r);\n            ap_rputs(\"</tr></table></td></tr>\\n\", r);\n            if (hc_select_exprs_f) {\n                proxy_hcmethods_t *method = proxy_hcmethods;\n                ap_rputs(\"<tr><td colspan='2'>\\n<table align='center'><tr><th>Health Check param</th><th>Value</th></tr>\\n\", r);\n                ap_rputs(\"<tr><td>Method</td><td><select name='w_hm'>\\n\", r);\n                for (; method->name; method++) {\n                    if (method->implemented) {\n                        ap_rprintf(r, \"<option value='%s' %s >%s</option>\\n\",\n                                method->name,\n                                (wsel->s->method == method->method) ? \"selected\" : \"\",\n                                method->name);\n                    }\n                }\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n                ap_rputs(\"<tr><td>Expr</td><td><select name='w_he'>\\n\", r);\n                hc_select_exprs_f(r, wsel->s->hcexpr);\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n                ap_rprintf(r, \"<tr><td>Interval (secs)</td><td><input name='w_hi' id='w_hi' type='text'\"\n                           \"value='%d'></td></tr>\\n\", (int)apr_time_sec(wsel->s->interval));\n                ap_rprintf(r, \"<tr><td>Passes trigger</td><td><input name='w_hp' id='w_hp' type='text'\"\n                           \"value='%d'></td></tr>\\n\", wsel->s->passes);\n                ap_rprintf(r, \"<tr><td>Fails trigger)</td><td><input name='w_hf' id='w_hf' type='text'\"\n                           \"value='%d'></td></tr>\\n\", wsel->s->fails);\n                ap_rprintf(r, \"<tr><td>HC uri</td><td><input name='w_hu' id='w_hu' type='text'\"\n                        \"value='%s'</td></tr>\\n\", ap_escape_html(r->pool, wsel->s->hcuri));\n                ap_rputs(\"</table>\\n</td></tr>\\n\", r);\n            }\n            ap_rputs(\"<tr><td colspan='2'><input type=submit value='Submit'></td></tr>\\n\", r);\n            ap_rvputs(r, \"</table>\\n<input type=hidden name='w' id='w' \",  NULL);\n            ap_rvputs(r, \"value='\", ap_escape_uri(r->pool, wsel->s->name), \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='b' id='b' \", NULL);\n            ap_rvputs(r, \"value='\", bsel->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='nonce' id='nonce' value='\",\n                      bsel->s->nonce, \"'>\\n\", NULL);\n            ap_rputs(\"</form>\\n\", r);\n            ap_rputs(\"<hr />\\n\", r);\n        } else if (bsel) {\n            const apr_array_header_t *provs;\n            const ap_list_provider_names_t *pname;\n            int i;\n            ap_rputs(\"<h3>Edit balancer settings for \", r);\n            ap_rvputs(r, bsel->s->name, \"</h3>\\n\", NULL);\n            ap_rputs(\"<form method='POST' enctype='application/x-www-form-urlencoded' action='\", r);\n            ap_rvputs(r, ap_escape_uri(r->pool, action), \"'>\\n\", NULL);\n            ap_rputs(\"<table>\\n\", r);\n            provs = ap_list_provider_names(r->pool, PROXY_LBMETHOD, \"0\");\n            if (provs) {\n                ap_rputs(\"<tr><td>LBmethod:</td>\", r);\n                ap_rputs(\"<td>\\n<select name='b_lbm' id='b_lbm'>\", r);\n                pname = (ap_list_provider_names_t *)provs->elts;\n                for (i = 0; i < provs->nelts; i++, pname++) {\n                    ap_rvputs(r,\"<option value='\", pname->provider_name, \"'\", NULL);\n                    if (strcmp(pname->provider_name, bsel->s->lbpname) == 0)\n                        ap_rputs(\" selected \", r);\n                    ap_rvputs(r, \">\", pname->provider_name, \"\\n\", NULL);\n                }\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n            }\n            ap_rputs(\"<tr><td>Timeout:</td><td><input name='b_tmo' id='b_tmo' type=text \", r);\n            ap_rprintf(r, \"value='%\" APR_TIME_T_FMT \"'></td></tr>\\n\", apr_time_sec(bsel->s->timeout));\n            ap_rputs(\"<tr><td>Failover Attempts:</td><td><input name='b_max' id='b_max' type=text \", r);\n            ap_rprintf(r, \"value='%d'></td></tr>\\n\", bsel->s->max_attempts);\n            ap_rputs(\"<tr><td>Disable Failover:</td>\", r);\n            create_radio(\"b_sforce\", bsel->s->sticky_force, r);\n            ap_rputs(\"<tr><td>Sticky Session:</td><td><input name='b_ss' id='b_ss' size=64 type=text \", r);\n            if (strcmp(bsel->s->sticky, bsel->s->sticky_path)) {\n                ap_rvputs(r, \"value ='\", bsel->s->sticky, \" | \",\n                          bsel->s->sticky_path, NULL);\n            }\n            else {\n                ap_rvputs(r, \"value ='\", bsel->s->sticky, NULL);\n            }\n            ap_rputs(\"'>&nbsp;&nbsp;&nbsp;&nbsp;(Use '-' to delete)</td></tr>\\n\", r);\n            if (storage->num_free_slots(bsel->wslot) != 0) {\n                ap_rputs(\"<tr><td>Add New Worker:</td><td><input name='b_nwrkr' id='b_nwrkr' size=32 type=text>\"\n                         \"&nbsp;&nbsp;&nbsp;&nbsp;Are you sure? <input name='b_wyes' id='b_wyes' type=checkbox value='1'>\"\n                         \"</td></tr>\", r);\n            }\n            ap_rputs(\"<tr><td colspan=2><input type=submit value='Submit'></td></tr>\\n\", r);\n            ap_rvputs(r, \"</table>\\n<input type=hidden name='b' id='b' \", NULL);\n            ap_rvputs(r, \"value='\", bsel->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='nonce' id='nonce' value='\",\n                      bsel->s->nonce, \"'>\\n\", NULL);\n            ap_rputs(\"</form>\\n\", r);\n            ap_rputs(\"<hr />\\n\", r);\n        }\n        ap_rputs(ap_psignature(\"\",r), r);\n        ap_rputs(\"</body></html>\\n\", r);\n        ap_rflush(r);\n    }\n    return DONE;\n}",
    "predicted": ""
  },
  "httpd_b84885fa3daa3bf50ec7cd0cc9e59c7886ff630f_0", {
    "ID": "httpd_b84885fa3daa3bf50ec7cd0cc9e59c7886ff630f_0",
    "UID": "5022",
    "code": "test_snippet\nyyparse (ap_expr_parse_ctx_t *ctx)\n#else\ntest_snippet\nyyparse (ctx)\n    ap_expr_parse_ctx_t *ctx;\n#endif\n#endif\n{\n\ntest_snippet yychar;\n\n\n#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__\n\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \\\n    _Pragma (\"GCC diagnostic push\") \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nstatic YYSTYPE yyval_default;\n# define YY_INITIAL_VALUE(Value) = Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value) \n#endif\n\n\nYYSTYPE yylval YY_INITIAL_VALUE(yyval_default);\n\n    \n    test_snippet yynerrs;\n\n    test_snippet yystate;\n    \n    test_snippet yyerrstatus;\n\n    /* The stacks and their tools:\n       `yyss': related to states.\n       `yyvs': related to semantic values.\n\n       Refer to the stacks through separate potest_snippeters, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    \n    yytype_test_snippet16 yyssa[YYINITDEPTH];\n    yytype_test_snippet16 *yyss;\n    yytype_test_snippet16 *yyssp;\n\n    \n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  test_snippet yyn;\n  test_snippet yyresult;\n  \n  test_snippet yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  \n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  test_snippet yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; \n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      \n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones test_snippeto\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_test_snippet16 *yyss1 = yyss;\n\n\t/* Each stack potest_snippeter address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else \n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      \n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tyytype_test_snippet16 *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyexhaustedlab;\n\tYYSTACK_RELOCATE (yyss_alloc, yyss);\n\tYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif \n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long test_snippet) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  \n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  \n\n  \n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  \n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  \n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  \n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     `$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 2:\n\n#line 112 \"util_expr_parse.y\"\n    { ctx->expr = (yyvsp[(2) - (2)].exVal); }\n    break;\n\n  case 3:\n\n#line 113 \"util_expr_parse.y\"\n    { ctx->expr = (yyvsp[(2) - (2)].exVal); }\n    break;\n\n  case 4:\n\n#line 114 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 5:\n\n#line 117 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_True,        NULL, NULL, ctx); }\n    break;\n\n  case 6:\n\n#line 118 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_False,       NULL, NULL, ctx); }\n    break;\n\n  case 7:\n\n#line 119 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Not,         (yyvsp[(2) - (2)].exVal),   NULL, ctx); }\n    break;\n\n  case 8:\n\n#line 120 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Or,          (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 9:\n\n#line 121 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_And,         (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 10:\n\n#line 122 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Comp,        (yyvsp[(1) - (1)].exVal),   NULL, ctx); }\n    break;\n\n  case 11:\n\n#line 123 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_unary_op_make(       (yyvsp[(1) - (2)].cpVal),   (yyvsp[(2) - (2)].exVal),   ctx); }\n    break;\n\n  case 12:\n\n#line 124 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_binary_op_make((yyvsp[(2) - (3)].cpVal),   (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 13:\n\n#line 125 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 14:\n\n#line 126 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 15:\n\n#line 129 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_EQ,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 16:\n\n#line 130 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_NE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 17:\n\n#line 131 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_LT,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 18:\n\n#line 132 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_LE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 19:\n\n#line 133 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_GT,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 20:\n\n#line 134 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_GE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 21:\n\n#line 135 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_EQ,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 22:\n\n#line 136 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_NE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 23:\n\n#line 137 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_LT,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 24:\n\n#line 138 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_LE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 25:\n\n#line 139 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_GT,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 26:\n\n#line 140 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_GE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 27:\n\n#line 141 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_IN,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 28:\n\n#line 142 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_REG,     (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 29:\n\n#line 143 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_NRE,     (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 30:\n\n#line 146 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 31:\n\n#line 147 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 32:\n\n#line 150 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_ListElement, (yyvsp[(1) - (1)].exVal), NULL, ctx); }\n    break;\n\n  case 33:\n\n#line 151 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_ListElement, (yyvsp[(3) - (3)].exVal), (yyvsp[(1) - (3)].exVal),   ctx); }\n    break;\n\n  case 34:\n\n#line 154 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Concat, (yyvsp[(1) - (2)].exVal), (yyvsp[(2) - (2)].exVal), ctx); }\n    break;\n\n  case 35:\n\n#line 155 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 36:\n\n#line 156 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 37:\n\n#line 159 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_String, (yyvsp[(1) - (1)].cpVal), NULL, ctx); }\n    break;\n\n  case 38:\n\n#line 160 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 39:\n\n#line 161 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 40:\n\n#line 164 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_var_make((yyvsp[(2) - (3)].cpVal), ctx); }\n    break;\n\n  case 41:\n\n#line 165 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(2) - (5)].cpVal), (yyvsp[(4) - (5)].exVal), ctx); }\n    break;\n\n  case 42:\n\n#line 168 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Digit,  (yyvsp[(1) - (1)].cpVal), NULL, ctx); }\n    break;\n\n  case 43:\n\n#line 169 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Concat, (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 44:\n\n#line 170 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 45:\n\n#line 171 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 46:\n\n#line 172 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 47:\n\n#line 173 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 48:\n\n#line 174 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_String, \"\", NULL, ctx); }\n    break;\n\n  case 49:\n\n#line 177 \"util_expr_parse.y\"\n    {\n                ap_regex_t *regex;\n                if ((regex = ap_pregcomp(ctx->pool, (yyvsp[(1) - (1)].cpVal),\n                                         AP_REG_EXTENDED|AP_REG_NOSUB)) == NULL) {\n                    ctx->error = \"Failed to compile regular expression\";\n                    YYERROR;\n                }\n                (yyval.exVal) = ap_expr_make(op_Regex, regex, NULL, ctx);\n            }\n    break;\n\n  case 50:\n\n#line 186 \"util_expr_parse.y\"\n    {\n                ap_regex_t *regex;\n                if ((regex = ap_pregcomp(ctx->pool, (yyvsp[(1) - (1)].cpVal),\n                                         AP_REG_EXTENDED|AP_REG_NOSUB|AP_REG_ICASE)) == NULL) {\n                    ctx->error = \"Failed to compile regular expression\";\n                    YYERROR;\n                }\n                (yyval.exVal) = ap_expr_make(op_Regex, regex, NULL, ctx);\n            }\n    break;\n\n  case 51:\n\n#line 197 \"util_expr_parse.y\"\n    {\n                test_snippet *n = apr_palloc(ctx->pool, sizeof(test_snippet));\n                *n = (yyvsp[(1) - (1)].num);\n                (yyval.exVal) = ap_expr_make(op_RegexBackref, n, NULL, ctx);\n            }\n    break;\n\n  case 52:\n\n#line 204 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_list_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n  case 53:\n\n#line 207 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n  case 54:\n\n#line 208 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n\n\n#line 1849 \"util_expr_parse.c\"\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now `shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*------------------------------------.\n| yyerrlab -- here on detecting error |\n`------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  \n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (ctx, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        test_snippet yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (ctx, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n\t error, discard it.  */\n\n      if (yychar <= YYEOF)\n\t{\n\t  \n\t  if (yychar == YYEOF)\n\t    YYABORT;\n\t}\n      else\n\t{\n\t  yydestruct (\"Error: discarding\",\n\t\t      yytoken, &yylval, ctx);\n\t  yychar = YYEMPTY;\n\t}\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if ( 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;\t\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n\t{\n\t  yyn += YYTERROR;\n\t  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n\t    {\n\t      yyn = yytable[yyn];\n\t      if (0 < yyn)\n\t\tbreak;\n\t    }\n\t}\n\n      \n      if (yyssp == yyss)\n\tYYABORT;\n\n\n      yydestruct (\"Error: popping\",\n\t\t  yystos[yystate], yyvsp, ctx);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  \n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (ctx, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  \n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, ctx);\n    }\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n\t\t  yystos[*yyssp], yyvsp, ctx);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  \n  return YYID (yyresult);\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_04aaa1d3b2ee5077aa6aff266943f5fe1af42551_0", {
    "ID": "httpd_04aaa1d3b2ee5077aa6aff266943f5fe1af42551_0",
    "UID": "5044",
    "code": "static void ap_expr_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t test_snippet\n\n{\n\tint oerrno = errno;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tap_expr_yy_flush_buffer(b ,test_snippet;\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then ap_expr_yy_init_buffer was _probably_\n     * called from ap_expr_yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = 0;\n    \n\terrno = oerrno;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_285b4be42aa7f55d28d7ed217e4f669ab54a6c22_0", {
    "ID": "httpd_285b4be42aa7f55d28d7ed217e4f669ab54a6c22_0",
    "UID": "5051",
    "code": "YY_BUFFER_STATE ap_expr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t test_snippet\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t\n\tn = _yybytes_len + 2;\n\tbuf = (char *) ap_expr_yyalloc(n ,yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ap_expr_yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = ap_expr_yy_scan_buffer(buf,n ,test_snippet;\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in ap_expr_yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_b83d9cf069b648d5702d3a42fc50fbc6e356f5a7_0", {
    "ID": "httpd_b83d9cf069b648d5702d3a42fc50fbc6e356f5a7_0",
    "UID": "5064",
    "code": "int ap_expr_yylex_init(yyscan_t* test_snippet\n\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) ap_expr_yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    \n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value"
  },
  "httpd_bb6fff3a12c24d24316fc929fe0357425e7c1c86_0", {
    "ID": "httpd_bb6fff3a12c24d24316fc929fe0357425e7c1c86_0",
    "UID": "5068",
    "code": "PROXY_DECLARE(char *) ap_proxy_parse_wstatus(apr_pool_t *p, proxy_worker test_snippet\n{\n    char *ret = \"\";\n    unsigned int status = w->s->status;\n    proxy_wstat_t *pwt = proxy_wstat_tbl;\n    while (pwt->bit) {\n        if (status & pwt->bit)\n            ret = apr_pstrcat(p, ret, pwt->name, NULL);\n        pwt++;\n    }\n    if (!*ret) {\n        ret = \"??? \";\n    }\n    if (PROXY_WORKER_IS_USABLE(w))\n        ret = apr_pstrcat(p, ret, \"Ok \", NULL);\n    return ret;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_adeb808ad06c5841c51e674a7c3d12fc2e509c55_0", {
    "ID": "httpd_adeb808ad06c5841c51e674a7c3d12fc2e509c55_0",
    "UID": "5098",
    "code": "static const char *add_icon(cmd_parms *cmd, void *d, const char test_snippet\n                            const char *to)\n{\n    char *iconbak = apr_pstrdup(cmd->temp_pool, icon);\n\n    if (icon[0] == '(') {\n        char *alt;\n        char *cl = strchr(iconbak, ')');\n\n        if (cl == NULL) {\n            return \"missing closing paren\";\n        }\n        alt = ap_getword_nc(cmd->temp_pool, &iconbak, ',');\n        *cl = '\\0';                             \n        add_alt(cmd, d, &alt[1], to);\n    }\n    if (cmd->info == BY_PATH) {\n        if (!strcmp(to, \"**DIRECTORY**\")) {\n            to = \"^^DIRECTORY^^\";\n        }\n    }\n    if (cmd->info == BY_ENCODING) {\n        char *tmp = apr_pstrdup(cmd->temp_pool, to);\n        ap_str_tolower(tmp);\n        to = tmp;\n    }\n\n    push_item(((autoindex_config_rec *) d)->icon_list, cmd->info, to,\n              cmd->path, iconbak);\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_cd0c762bd4f1855a76d7d824ab28e63066d323a2_0", {
    "ID": "httpd_cd0c762bd4f1855a76d7d824ab28e63066d323a2_0",
    "UID": "5309",
    "code": "static const char *proxysection(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    proxy_dir_conf *conf;\n    ap_conf_vector_t *new_dir_conf = ap_create_per_dir_config(cmd->pool);\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n    char *word, *val;\n    proxy_balancer *balancer = NULL;\n    proxy_worker *worker = NULL;\n    int use_regex = 0;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    proxy_server_conf *sconf =\n    (proxy_server_conf *) ap_get_module_config(cmd->server->module_config, &proxy_module);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    arg = apr_pstrndup(cmd->pool, arg, endp-arg);\n\n    if (!arg) {\n        if (thiscmd->cmd_data)\n            return \"<ProxyMatch > block must specify a path\";\n        else\n            return \"<Proxy > block must specify a path\";\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (!strncasecmp(cmd->path, \"proxy:\", 6))\n        cmd->path += 6;\n\n    /* XXX Ignore case?  What if we proxy a case-insensitive server?!?\n     * While we are at it, shouldn't we also canonicalize the entire\n     * scheme?  See proxy_fixup()\n     */\n    if (thiscmd->cmd_data) { \n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n        use_regex = 1;\n    }\n\n    \n    conf = ap_set_config_vectors(cmd->server, new_dir_conf, cmd->path,\n                                 &proxy_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_dir_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->r = r;\n    conf->p = cmd->path;\n    conf->p_is_fnmatch = apr_fnmatch_test(conf->p);\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    ap_add_per_proxy_conf(cmd->server, new_dir_conf);\n\n    if (*arg != '\\0') {\n        if (thiscmd->cmd_data)\n            return \"Multiple <ProxyMatch> arguments not (yet) supported.\";\n        if (conf->p_is_fnmatch)\n            return apr_pstrcat(cmd->pool, thiscmd->name,\n                               \"> arguments are not supported for wildchar url.\",\n                               NULL);\n        if (!ap_strchr_c(conf->p, ':'))\n            return apr_pstrcat(cmd->pool, thiscmd->name,\n                               \"> arguments are not supported for non url.\",\n                               NULL);\n        if (ap_proxy_valid_balancer_name((char *)conf->p, 9)) {\n            balancer = ap_proxy_get_balancer(cmd->pool, sconf, conf->p, 0);\n            if (!balancer) {\n                err = ap_proxy_define_balancer(cmd->pool, &balancer,\n                                               sconf, conf->p, \"/\", 0);\n                if (err)\n                    return apr_pstrcat(cmd->temp_pool, thiscmd->name,\n                                       \" \", err, NULL);\n            }\n        }\n        else {\n            worker = ap_proxy_get_worker(cmd->temp_pool, NULL, sconf,\n                                         ap_proxy_de_socketfy(cmd->temp_pool, (char*)conf->p));\n            if (!worker) {\n                if (use_regex) {\n                    err = ap_proxy_define_match_worker(cmd->pool, &worker, NULL,\n                                                       sconf, conf->p, 0);\n                }\n                else {\n                    err = ap_proxy_define_worker(cmd->pool, &worker, NULL,\n                                                 sconf, conf->p, 0);\n                }\n                if (err)\n                    return apr_pstrcat(cmd->temp_pool, thiscmd->name,\n                                       \" \", err, NULL);\n            }\n            else if ((use_regex != 0) ^ (worker->s->is_name_matchable != 0)) {\n                return apr_pstrcat(cmd->temp_pool, \"ProxyPass/<Proxy> and \"\n                                   \"ProxyPassMatch/<ProxyMatch> can't be used \"\n                                   \"altogether with the same worker name \",\n                                   \"(\", worker->s->name, \")\", NULL);\n            }\n        }\n        if (worker == NULL && balancer == NULL) {\n            return apr_pstrcat(cmd->pool, thiscmd->name,\n                               \"> arguments are supported only for workers.\",\n                               NULL);\n        }\n        while (test_snippet {\n            word = ap_getword_conf(cmd->pool, &arg);\n            val = strchr(word, '=');\n            if (!val) {\n                return \"Invalid Proxy parameter. Parameter must be \"\n                       \"in the form 'key=value'\";\n            }\n            else\n                *val++ = '\\0';\n            if (worker)\n                err = set_worker_param(cmd->pool, cmd->server, worker, word, val);\n            else\n                err = set_balancer_param(sconf, cmd->pool, balancer,\n                                         word, val);\n            if (err)\n                return apr_pstrcat(cmd->temp_pool, thiscmd->name, \" \", err, \" \",\n                                   word, \"=\", val, \"; \", conf->p, NULL);\n        }\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_cc0b6335680a26b48f8e12c0914f909ad55b6c9b_0", {
    "ID": "httpd_cc0b6335680a26b48f8e12c0914f909ad55b6c9b_0",
    "UID": "5327",
    "code": "static int count_directives_sub(const char *directive, ap_directive_t test_snippet\n{\n    int count = 0;\n    while (current != NULL) {\n        if (current->first_child != NULL)\n            count += count_directives_sub(directive, current->first_child);\n        if (ap_casecmpstr(current->directive, directive) == 0)\n            count++;\n        current = current->next;\n    }\n    return count;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_1bcccca7def80614106f66fd9509c72659fda427_0", {
    "ID": "httpd_1bcccca7def80614106f66fd9509c72659fda427_0",
    "UID": "5353",
    "code": "PROXY_DECLARE(char *) ap_proxy_define_worker(apr_pool_t test_snippet\n                                             proxy_worker **worker,\n                                             proxy_balancer *balancer,\n                                             proxy_server_conf *conf,\n                                             const char *url,\n                                             int do_malloc)\n{\n    int rv;\n    apr_uri_t uri, urisock;\n    proxy_worker_shared *wshared;\n    char *ptr, *sockpath = NULL;\n\n    /*\n     * Look to see if we are using UDS:\n     * require format: unix:/path/foo/bar.sock|http://ignored/path2/\n     * This results in talking http to the socket at /path/foo/bar.sock\n     */\n    ptr = ap_strchr((char *)url, '|');\n    if (ptr) {\n        *ptr = '\\0';\n        rv = apr_uri_parse(p, url, &urisock);\n        if (rv == APR_SUCCESS && !ap_casecmpstr(urisock.scheme, \"unix\")) {\n            sockpath = ap_runtime_dir_relative(p, urisock.path);;\n            url = ptr+1;    \n        }\n        else {\n            *ptr = '|';\n        }\n    }\n    rv = apr_uri_parse(p, url, &uri);\n\n    if (rv != APR_SUCCESS) {\n        return apr_pstrcat(p, \"Unable to parse URL: \", url, NULL);\n    }\n    if (!uri.scheme) {\n        return apr_pstrcat(p, \"URL must be absolute!: \", url, NULL);\n    }\n    \n    if (!uri.hostname) {\n        if (sockpath) {\n            uri.hostname = \"localhost\";\n        }\n        else {\n            return apr_pstrcat(p, \"URL must be absolute!: \", url, NULL);\n        }\n    }\n    else {\n        ap_str_tolower(uri.hostname);\n    }\n    ap_str_tolower(uri.scheme);\n    /*\n     * Workers can be associated w/ balancers or on their\n     * own; ie: the generic reverse-proxy or a worker\n     * in a simple ProxyPass statement. eg:\n     *\n     *      ProxyPass / http://www.example.com\n     *\n     * in which case the worker goes in the conf slot.\n     */\n    if (balancer) {\n        proxy_worker **runtime;\n        \n        runtime = apr_array_push(balancer->workers);\n        *worker = *runtime = apr_palloc(p, sizeof(proxy_worker));   \n        /* we've updated the list of workers associated with\n         * this balancer *locally* */\n        balancer->wupdated = apr_time_now();\n    } else if (conf) {\n        *worker = apr_array_push(conf->workers);\n    } else {\n        \n        *worker = apr_palloc(p, sizeof(proxy_worker));\n    }\n\n    memset(*worker, 0, sizeof(proxy_worker));\n    /* right here we just want to tuck away the worker info.\n     * if called during config, we don't have shm setup yet,\n     * so just note the info for later. */\n    if (do_malloc)\n        wshared = ap_malloc(sizeof(proxy_worker_shared));  \n    else\n        wshared = apr_palloc(p, sizeof(proxy_worker_shared));\n\n    memset(wshared, 0, sizeof(proxy_worker_shared));\n\n    if (uri.port && uri.port == ap_proxy_port_of_scheme(uri.scheme)) {\n        uri.port = 0;\n    }\n    ptr = apr_uri_unparse(p, &uri, APR_URI_UNP_REVEALPASSWORD);\n    if (PROXY_STRNCPY(wshared->name, ptr) != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(02808)\n        \"Alert! worker name (%s) too long; truncated to: %s\", ptr, wshared->name);\n    }\n    if (PROXY_STRNCPY(wshared->scheme, uri.scheme) != APR_SUCCESS) {\n        return apr_psprintf(p, \"worker scheme (%s) too long\", uri.scheme);\n    }\n    if (PROXY_STRNCPY(wshared->hostname, uri.hostname) != APR_SUCCESS) {\n        return apr_psprintf(p, \"worker hostname (%s) too long\", uri.hostname);\n    }\n    wshared->port = uri.port;\n    wshared->flush_packets = flush_off;\n    wshared->flush_wait = PROXY_FLUSH_WAIT;\n    wshared->is_address_reusable = 1;\n    wshared->lbfactor = 1;\n    wshared->smax = -1;\n    wshared->hash.def = ap_proxy_hashfunc(wshared->name, PROXY_HASHFUNC_DEFAULT);\n    wshared->hash.fnv = ap_proxy_hashfunc(wshared->name, PROXY_HASHFUNC_FNV);\n    wshared->was_malloced = (do_malloc != 0);\n    wshared->is_name_matchable = 0;\n    if (sockpath) {\n        if (PROXY_STRNCPY(wshared->uds_path, sockpath) != APR_SUCCESS) {\n            return apr_psprintf(p, \"worker uds path (%s) too long\", sockpath);\n        }\n\n    }\n    else {\n        *wshared->uds_path = '\\0';\n    }\n    if (!balancer) {\n        wshared->status |= PROXY_WORKER_IGNORE_ERRORS;\n    }\n\n    (*worker)->hash = wshared->hash;\n    (*worker)->context = NULL;\n    (*worker)->cp = NULL;\n    (*worker)->balancer = balancer;\n    (*worker)->s = wshared;\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_63a6fd1ee7269d7f3cf53845bc2c5d4a9be249f2_0", {
    "ID": "httpd_63a6fd1ee7269d7f3cf53845bc2c5d4a9be249f2_0",
    "UID": "5358",
    "code": "static void grow_buffer(apr_pool_t *pool, char test_snippet\n                        char **spend, unsigned int *cursize,\n                        unsigned int newsize)\n{\n    char* newbuffer = NULL;\n    int spendsize = 0;\n    if (*cursize >= newsize)\n        return;\n    /* Avoid number of times realloc is called. It could cause huge memory\n     * requirement if line size is huge e.g 2 MB */\n    if (newsize < *cursize * 2) {\n        newsize = *cursize * 2;\n    }\n\n    \n    newsize = (newsize  + ((1 << 12) - 1)) & ~((1 << 12) - 1);\n    newbuffer = apr_pcalloc(pool, newsize);\n    if (*spend && *buffer && (*cursize > 0)) {\n        spendsize = *spend - *buffer;\n    }\n    if ((*cursize > 0) && *buffer) {\n        memcpy(newbuffer, *buffer, *cursize);\n    }\n    *buffer = newbuffer;\n    *cursize = newsize;\n    if (spend != buffer) {\n        *spend = *buffer + spendsize;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_5f9a6ff1059230c4400ba5a2c59cc7dd1b4ec8fe_0", {
    "ID": "httpd_5f9a6ff1059230c4400ba5a2c59cc7dd1b4ec8fe_0",
    "UID": "5360",
    "code": "static const char *set_worker_hc_param(apr_pool_t test_snippet\n                                    server_rec *s,\n                                    proxy_worker *worker,\n                                    const char *key,\n                                    const char *val,\n                                    void *v)\n{\n    int ival;\n    hc_template_t *temp;\n    sctx_t *ctx = (sctx_t *) ap_get_module_config(s->module_config,\n                                                  &proxy_hcheck_module);\n    if (!worker && !v) {\n        return \"Bad call to set_worker_hc_param()\";\n    }\n    temp = (hc_template_t *)v;\n    if (!strcasecmp(key, \"hctemplate\")) {\n        hc_template_t *template;\n        template = (hc_template_t *)ctx->templates->elts;\n        for (ival = 0; ival < ctx->templates->nelts; ival++, template++) {\n            if (!ap_cstr_casecmp(template->name, val)) {\n                if (worker) {\n                    worker->s->method = template->method;\n                    worker->s->interval = template->interval;\n                    worker->s->passes = template->passes;\n                    worker->s->fails = template->fails;\n                    PROXY_STRNCPY(worker->s->hcuri, template->hurl);\n                    PROXY_STRNCPY(worker->s->hcexpr, template->hcexpr);\n                } else {\n                    temp->method = template->method;\n                    temp->interval = template->interval;\n                    temp->passes = template->passes;\n                    temp->fails = template->fails;\n                    temp->hurl = apr_pstrdup(p, template->hurl);\n                    temp->hcexpr = apr_pstrdup(p, template->hcexpr);\n                }\n                return NULL;\n            }\n        }\n        return apr_psprintf(p, \"Unknown ProxyHCTemplate name: %s\", val);\n    }\n    else if (!strcasecmp(key, \"hcmethod\")) {\n        proxy_hcmethods_t *method = proxy_hcmethods;\n        for (; method->name; method++) {\n            if (!ap_cstr_casecmp(val, method->name)) {\n                if (!method->implemented) {\n                    return apr_psprintf(p, \"Health check method %s not (yet) implemented\",\n                                        val);\n                }\n                if (worker) {\n                    worker->s->method = method->method;\n                } else {\n                    temp->method = method->method;\n                }\n                return NULL;\n            }\n        }\n        return \"Unknown method\";\n    }\n    else if (!strcasecmp(key, \"hcinterval\")) {\n        ival = atoi(val);\n        if (ival < HCHECK_WATHCHDOG_INTERVAL)\n            return apr_psprintf(p, \"Interval must be a positive value greater than %d seconds\",\n                                HCHECK_WATHCHDOG_INTERVAL);\n        if (worker) {\n            worker->s->interval = apr_time_from_sec(ival);\n        } else {\n            temp->interval = apr_time_from_sec(ival);\n        }\n    }\n    else if (!strcasecmp(key, \"hcpasses\")) {\n        ival = atoi(val);\n        if (ival < 0)\n            return \"Passes must be a positive value\";\n        if (worker) {\n            worker->s->passes = ival;\n        } else {\n            temp->passes = ival;\n        }\n    }\n    else if (!strcasecmp(key, \"hcfails\")) {\n        ival = atoi(val);\n        if (ival < 0)\n            return \"Fails must be a positive value\";\n        if (worker) {\n            worker->s->fails = ival;\n        } else {\n            temp->fails = ival;\n        }\n    }\n    else if (!strcasecmp(key, \"hcuri\")) {\n        if (strlen(val) >= sizeof(worker->s->hcuri))\n            return apr_psprintf(p, \"Health check uri length must be < %d characters\",\n                    (int)sizeof(worker->s->hcuri));\n        if (worker) {\n            PROXY_STRNCPY(worker->s->hcuri, val);\n        } else {\n            temp->hurl = apr_pstrdup(p, val);\n        }\n    }\n    else if (!strcasecmp(key, \"hcexpr\")) {\n        hc_condition_t *cond;\n        cond = (hc_condition_t *)apr_table_get(ctx->conditions, val);\n        if (!cond) {\n            return apr_psprintf(p, \"Unknown health check condition expr: %s\", val);\n        }\n        \n        if (strlen(val) >= sizeof(worker->s->hcexpr))\n            return apr_psprintf(p, \"Health check uri length must be < %d characters\",\n                    (int)sizeof(worker->s->hcexpr));\n        if (worker) {\n            PROXY_STRNCPY(worker->s->hcexpr, val);\n        } else {\n            temp->hcexpr = apr_pstrdup(p, val);\n        }\n    }\n  else {\n        return \"unknown Worker hcheck parameter\";\n    }\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_757b77ec991904cc1c7126084493ba8dd49581cc_0", {
    "ID": "httpd_757b77ec991904cc1c7126084493ba8dd49581cc_0",
    "UID": "5363",
    "code": "static char *text(sed_commands_t *commands, char *textbuf, char test_snippet\n{\n    char   *p, *q;\n\n    p = textbuf;\n    q = commands->cp;\n#ifndef S5EMUL\n    /*\n     * Strip off indentation from text to be inserted.\n     */\n    while(*q == '\\t' || *q == ' ')    q++;\n#endif\n    for(;;) {\n\n        if(p > tbend)\n            return(NULL);    \n        if((*p = *q++) == '\\\\')\n            *p = *q++;\n        if(*p == '\\0') {\n            commands->cp = --q;\n            return(++p);\n        }\n#ifndef S5EMUL\n        /*\n         * Strip off indentation from text to be inserted.\n         */\n        if(*p == '\\n') {\n            while(*q == '\\t' || *q == ' ')    q++;\n        }\n#endif\n        p++;\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_65737005f1429ec85ede5bec3eb08e9688557c51_0", {
    "ID": "httpd_65737005f1429ec85ede5bec3eb08e9688557c51_0",
    "UID": "5364",
    "code": "static const char *set_hc_condition(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    char *name = NULL;\n    char *expr;\n    sctx_t *ctx;\n    hc_condition_t *cond;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);\n    if (err)\n        return err;\n    ctx = (sctx_t *) ap_get_module_config(cmd->server->module_config,\n                                          &proxy_hcheck_module);\n\n    name = ap_getword_conf(cmd->pool, &arg);\n    if (!*name) {\n        return apr_pstrcat(cmd->temp_pool, \"Missing expression name for \",\n                           cmd->cmd->name, NULL);\n    }\n    if (strlen(name) > (PROXY_WORKER_MAX_SCHEME_SIZE - 1)) {\n        return apr_psprintf(cmd->temp_pool, \"Expression name limited to %d characters\",\n                           (PROXY_WORKER_MAX_SCHEME_SIZE - 1));\n    }\n    \n    expr = ap_getword_conf2(cmd->temp_pool, &arg);\n    if (!*expr) {\n        return apr_pstrcat(cmd->temp_pool, \"Missing expression for \",\n                           cmd->cmd->name, NULL);\n    }\n    cond = apr_palloc(cmd->pool, sizeof(hc_condition_t));\n    cond->pexpr = ap_expr_parse_cmd(cmd, expr, 0, &err, NULL);\n    if (err) {\n        return apr_psprintf(cmd->temp_pool, \"Could not parse expression \\\"%s\\\": %s\",\n                            expr, err);\n    }\n    cond->expr = apr_pstrdup(cmd->pool, expr);\n    apr_table_setn(ctx->conditions, name, (void *)cond);\n    expr = ap_getword_conf(cmd->temp_pool, &arg);\n    if (*expr) {\n        return \"error: extra parameter(s)\";\n    }\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_36bf0ff3728fa310bb688642e987d7929e2164d9_0", {
    "ID": "httpd_36bf0ff3728fa310bb688642e987d7929e2164d9_0",
    "UID": "5365",
    "code": "static const char *set_hc_template(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    char *name = NULL;\n    char *word, *val;\n    hc_template_t *template;\n    sctx_t *ctx;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);\n    if (err)\n        return err;\n    ctx = (sctx_t *) ap_get_module_config(cmd->server->module_config,\n                                          &proxy_hcheck_module);\n\n    name = ap_getword_conf(cmd->temp_pool, &arg);\n    if (!*name) {\n        return apr_pstrcat(cmd->temp_pool, \"Missing template name for \",\n                           cmd->cmd->name, NULL);\n    }\n\n    template = (hc_template_t *)apr_array_push(ctx->templates);\n\n    template->name = apr_pstrdup(cmd->pool, name);\n    template->method = template->passes = template->fails = 1;\n    template->interval = apr_time_from_sec(HCHECK_WATHCHDOG_DEFAULT_INTERVAL);\n    template->hurl = NULL;\n    template->hcexpr = NULL;\n    while (test_snippet {\n        word = ap_getword_conf(cmd->pool, &arg);\n        val = strchr(word, '=');\n        if (!val) {\n            return \"Invalid ProxyHCTemplate parameter. Parameter must be \"\n                   \"in the form 'key=value'\";\n        }\n        else\n            *val++ = '\\0';\n        err = set_worker_hc_param(cmd->pool, ctx->s, NULL, word, val, template);\n\n        if (err) {\n            \n            apr_array_pop(ctx->templates);\n            return apr_pstrcat(cmd->temp_pool, \"ProxyHCTemplate: \", err, \" \", word, \"=\", val, \"; \", name, NULL);\n        }\n        \n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_13525b9f94d03045c8643595766c95a62cbbfffc_0", {
    "ID": "httpd_13525b9f94d03045c8643595766c95a62cbbfffc_0",
    "UID": "5366",
    "code": "static void appendmem_to_linebuf(sed_eval_t *eval, const char* sz, int test_snippet\n{\n    unsigned int reqsize = (eval->lspend - eval->linebuf) + len;\n    if (eval->lsize < reqsize) {\n        grow_line_buffer(eval, reqsize);\n    }\n    memcpy(eval->lspend, sz, test_snippet;\n    eval->lspend += len;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_f274d3a53285e095a4ceca7a4c84156389c5f544_0", {
    "ID": "httpd_f274d3a53285e095a4ceca7a4c84156389c5f544_0",
    "UID": "5378",
    "code": "static int wd_post_config_hook(apr_pool_t *pconf, apr_pool_t test_snippet\n                               apr_pool_t *ptemp, server_rec *s)\n{\n    apr_status_t rv;\n    const char *pk = \"watchdog_init_module_tag\";\n    apr_pool_t *pproc = s->process->pool;\n    const apr_array_header_t *wl;\n\n    if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG)\n        \n        return OK;\n\n    apr_pool_userdata_get((void *)&wd_server_conf, pk, pproc);\n    if (!wd_server_conf) {\n        if (!(wd_server_conf = apr_pcalloc(pproc, sizeof(wd_server_conf_t))))\n            return APR_ENOMEM;\n        apr_pool_create(&wd_server_conf->pool, pproc);\n        apr_pool_userdata_set(wd_server_conf, pk, apr_pool_cleanup_null, pproc);\n    }\n    wd_server_conf->s = s;\n    if ((wl = ap_list_provider_names(pconf, AP_WATCHDOG_PGROUP,\n                                            AP_WATCHDOG_PVERSION))) {\n        const ap_list_provider_names_t *wn;\n        int i;\n\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02974)\n                \"Watchdog: found parent providers.\");\n\n        wn = (ap_list_provider_names_t *)wl->elts;\n        for (i = 0; i < wl->nelts; i++) {\n            ap_watchdog_t *w = ap_lookup_provider(AP_WATCHDOG_PGROUP,\n                                                  wn[i].provider_name,\n                                                  AP_WATCHDOG_PVERSION);\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02975)\n                    \"Watchdog: Looking for parent (%s).\", wn[i].provider_name);\n            if (w) {\n                if (!w->active) {\n                    int status = ap_run_watchdog_need(s, w->name, 1,\n                                                      w->singleton);\n                    if (status == OK) {\n                        /* One of the modules returned OK to this watchog.\n                         * Mark it as active\n                         */\n                        w->active = 1;\n                    }\n                }\n                if (w->active) {\n                    /* We have active watchdog.\n                     * Create the watchdog thread\n                     */\n                    if ((rv = wd_startup(w, wd_server_conf->pool)) != APR_SUCCESS) {\n                        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01571)\n                                \"Watchdog: Failed to create parent worker thread.\");\n                        return rv;\n                    }\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(02976)\n                            \"Watchdog: Created parent worker thread (%s).\", w->name);\n                    wd_server_conf->parent_workers++;\n                }\n            }\n        }\n    }\n    if (wd_server_conf->parent_workers) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01572)\n                     \"Spawned %d parent worker threads.\",\n                     wd_server_conf->parent_workers);\n    }\n    if ((wl = ap_list_provider_names(pconf, AP_WATCHDOG_PGROUP,\n                                            AP_WATCHDOG_CVERSION))) {\n        const ap_list_provider_names_t *wn;\n        int i;\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02977)\n                \"Watchdog: found child providers.\");\n\n        wn = (ap_list_provider_names_t *)wl->elts;\n        for (i = 0; i < wl->nelts; i++) {\n            ap_watchdog_t *w = ap_lookup_provider(AP_WATCHDOG_PGROUP,\n                                                  wn[i].provider_name,\n                                                  AP_WATCHDOG_CVERSION);\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02978)\n                    \"Watchdog: Looking for child (%s).\", wn[i].provider_name);\n            if (w) {\n                if (!w->active) {\n                    int status = ap_run_watchdog_need(s, w->name, 0,\n                                                      w->singleton);\n                    if (status == OK) {\n                        /* One of the modules returned OK to this watchog.\n                         * Mark it as active\n                         */\n                        w->active = 1;\n                    }\n                }\n                if (w->active) {\n                    /* We have some callbacks registered.\n                     * Create mutexes for singleton watchdogs\n                     */\n                    if (w->singleton) {\n                        rv = ap_proc_mutex_create(&w->mutex, NULL, wd_proc_mutex_type,\n                                                  w->name, s,\n                                                  wd_server_conf->pool, 0);\n                        if (rv != APR_SUCCESS) {\n                            return rv;\n                        }\n                    }\n                    ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(02979)\n                            \"Watchdog: Created child worker thread (%s).\", w->name);\n                    wd_server_conf->child_workers++;\n                }\n            }\n        }\n    }\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_fea4082427c09f69393511980e67463c85bc6ffe_0", {
    "ID": "httpd_fea4082427c09f69393511980e67463c85bc6ffe_0",
    "UID": "5381",
    "code": "static apr_status_t command(sed_eval_t *eval, sed_reptr_t test_snippet\n                            step_vars_storage *step_vars)\n{\n    int    i;\n    char   *p1, *p2;\n    const char *p3;\n    int length;\n    char sz[32]; \n    apr_status_t rv = APR_SUCCESS;\n\n\n    switch(ipc->command) {\n\n        case ACOM:\n            if (eval->aptr >= &eval->abuf[SED_ABUFSIZE]) {\n                eval_errf(eval, SEDERR_TMAMES, eval->lnum);\n            } else {\n                *eval->aptr++ = ipc;\n                *eval->aptr = NULL;\n            }\n            break;\n\n        case CCOM:\n            eval->delflag = 1;\n            if (!eval->inar[ipc->nrep] || eval->dolflag) {\n                for (p1 = ipc->re1; *p1; p1++)\n                    ;\n                rv = wline(eval, ipc->re1, p1 - ipc->re1);\n            }\n            break;\n\n        case DCOM:\n            eval->delflag++;\n            break;\n\n        case CDCOM:\n            p1 = eval->linebuf;\n\n            while (*p1 != '\\n') {\n                if (*p1++ == 0) {\n                    eval->delflag++;\n                    return APR_SUCCESS;\n                }\n            }\n\n            p1++;\n            copy_to_linebuf(eval, p1);\n            eval->jflag++;\n            break;\n\n        case EQCOM:\n            length = apr_snprintf(sz, sizeof(sz), \"%d\", (int) eval->lnum);\n            rv = wline(eval, sz, length);\n            break;\n\n        case GCOM:\n            copy_to_linebuf(eval, eval->holdbuf);\n            break;\n\n        case CGCOM:\n            append_to_linebuf(eval, \"\\n\");\n            append_to_linebuf(eval, eval->holdbuf);\n            break;\n\n        case HCOM:\n            copy_to_holdbuf(eval, eval->linebuf);\n            break;\n\n        case CHCOM:\n            append_to_holdbuf(eval, \"\\n\");\n            append_to_holdbuf(eval, eval->linebuf);\n            break;\n\n        case ICOM:\n            for (p1 = ipc->re1; *p1; p1++);\n            rv = wline(eval, ipc->re1, p1 - ipc->re1);\n            break;\n\n        case BCOM:\n            eval->jflag = 1;\n            break;\n\n        case LCOM:\n            p1 = eval->linebuf;\n            p2 = eval->genbuf;\n            eval->genbuf[72] = 0;\n            while (*p1) {\n                if ((unsigned char)*p1 >= 040) {\n                    if (*p1 == 0177) {\n                        p3 = rub;\n                        while ((*p2++ = *p3++) != 0)\n                            if (p2 >= eval->lcomend) {\n                                *p2 = '\\\\';\n                                rv = wline(eval, eval->genbuf,\n                                           strlen(eval->genbuf));\n                                if (rv != APR_SUCCESS)\n                                    return rv;\n                                p2 = eval->genbuf;\n                            }\n                        p2--;\n                        p1++;\n                        continue;\n                    }\n                    if (!isprint(*p1 & 0377)) {\n                        *p2++ = '\\\\';\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                        *p2++ = (*p1 >> 6) + '0';\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                        *p2++ = ((*p1 >> 3) & 07) + '0';\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                        *p2++ = (*p1++ & 07) + '0';\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                    } else {\n                        *p2++ = *p1++;\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                    }\n                } else {\n                    p3 = trans[(unsigned char)*p1-1];\n                    while ((*p2++ = *p3++) != 0)\n                        if (p2 >= eval->lcomend) {\n                            *p2 = '\\\\';\n                            rv = wline(eval, eval->genbuf,\n                                       strlen(eval->genbuf));\n                            if (rv != APR_SUCCESS)\n                                return rv;\n                            p2 = eval->genbuf;\n                        }\n                    p2--;\n                    p1++;\n                }\n            }\n            *p2 = 0;\n            rv = wline(eval, eval->genbuf, strlen(eval->genbuf));\n            break;\n\n        case NCOM:\n            if (!eval->commands->nflag) {\n                rv = wline(eval, eval->linebuf, eval->lspend - eval->linebuf);\n                if (rv != APR_SUCCESS)\n                    return rv;\n            }\n\n            if (eval->aptr > eval->abuf) {\n                rv = arout(eval);\n                if (rv != APR_SUCCESS)\n                    return rv;\n            }\n            eval->lspend = eval->linebuf;\n            eval->pending = ipc->next;\n            break;\n\n        case CNCOM:\n            if (eval->aptr > eval->abuf) {\n                rv = arout(eval);\n                if (rv != APR_SUCCESS)\n                    return rv;\n            }\n            append_to_linebuf(eval, \"\\n\");\n            eval->pending = ipc->next;\n            break;\n\n        case PCOM:\n            rv = wline(eval, eval->linebuf, eval->lspend - eval->linebuf);\n            break;\n\n        case CPCOM:\n            for (p1 = eval->linebuf; *p1 != '\\n' && *p1 != '\\0'; p1++);\n            rv = wline(eval, eval->linebuf, p1 - eval->linebuf);\n            break;\n\n        case QCOM:\n            if (!eval->commands->nflag) {\n                rv = wline(eval, eval->linebuf, eval->lspend - eval->linebuf);\n                if (rv != APR_SUCCESS)\n                    break;\n            }\n\n            if (eval->aptr > eval->abuf) {\n                rv = arout(eval);\n                if (rv != APR_SUCCESS)\n                    return rv;\n            }\n\n            eval->quitflag = 1;\n            break;\n\n        case RCOM:\n            if (eval->aptr >= &eval->abuf[SED_ABUFSIZE]) {\n                eval_errf(eval, SEDERR_TMRMES, eval->lnum);\n            } else {\n                *eval->aptr++ = ipc;\n                *eval->aptr = NULL;\n            }\n            break;\n\n        case SCOM:\n            i = substitute(eval, ipc, step_vars);\n            if (i == -1) {\n                return APR_EGENERAL;\n            }\n            if (ipc->pfl && eval->commands->nflag && i) {\n                if (ipc->pfl == 1) {\n                    rv = wline(eval, eval->linebuf, eval->lspend -\n                               eval->linebuf);\n                    if (rv != APR_SUCCESS)\n                        return rv;\n                } else {\n                    for (p1 = eval->linebuf; *p1 != '\\n' && *p1 != '\\0'; p1++);\n                    rv = wline(eval, eval->linebuf, p1 - eval->linebuf);\n                    if (rv != APR_SUCCESS)\n                        return rv;\n                }\n            }\n            if (i && (ipc->findex >= 0) && eval->fcode[ipc->findex])\n                apr_file_printf(eval->fcode[ipc->findex], \"%s\\n\",\n                                eval->linebuf);\n            break;\n\n        case TCOM:\n            if (eval->sflag == 0)  break;\n            eval->sflag = 0;\n            eval->jflag = 1;\n            break;\n\n        case WCOM:\n            if (ipc->findex >= 0)\n                apr_file_printf(eval->fcode[ipc->findex], \"%s\\n\",\n                                eval->linebuf);\n            break;\n\n        case XCOM:\n            copy_to_genbuf(eval, eval->linebuf);\n            copy_to_linebuf(eval, eval->holdbuf);\n            copy_to_holdbuf(eval, eval->genbuf);\n            break;\n\n        case YCOM:\n            p1 = eval->linebuf;\n            p2 = ipc->re1;\n            while ((*p1 = p2[(unsigned char)*p1]) != 0)    p1++;\n            break;\n    }\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_299a982e3f4c4258255f4ef446d62641acd4c4f5_0", {
    "ID": "httpd_299a982e3f4c4258255f4ef446d62641acd4c4f5_0",
    "UID": "5388",
    "code": "static void wd_child_init_hook(apr_pool_t *p, server_rec test_snippet\n{\n    apr_status_t rv = OK;\n    const apr_array_header_t *wl;\n\n    if (!wd_server_conf->child_workers) {\n        /* We don't have anything configured, bail out.\n         */\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(02980)\n                     \"Watchdog: nothing configured?\");\n        return;\n    }\n    if ((wl = ap_list_provider_names(p, AP_WATCHDOG_PGROUP,\n                                        AP_WATCHDOG_CVERSION))) {\n        const ap_list_provider_names_t *wn;\n        int i;\n        wn = (ap_list_provider_names_t *)wl->elts;\n        for (i = 0; i < wl->nelts; i++) {\n            ap_watchdog_t *w = ap_lookup_provider(AP_WATCHDOG_PGROUP,\n                                                  wn[i].provider_name,\n                                                  AP_WATCHDOG_CVERSION);\n            if (w && w->active) {\n                /* We have some callbacks registered.\n                 * Kick of the watchdog\n                 */\n                if ((rv = wd_startup(w, wd_server_conf->pool)) != APR_SUCCESS) {\n                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01573)\n                                 \"Watchdog: Failed to create worker thread.\");\n                    \n                    return;\n                }\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(02981)\n                             \"Watchdog: Created worker thread (%s).\", wn[i].provider_name);\n            }\n        }\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_4fd2f905284eb92e4eeaf43fda90f81bb389cc00_0", {
    "ID": "httpd_4fd2f905284eb92e4eeaf43fda90f81bb389cc00_0",
    "UID": "5392",
    "code": "static int _advance(char *lp, char *ep, step_vars_storage test_snippet\n{\n    char *curlp;\n    int c;\n    char *bbeg;\n    char neg;\n    int ct;\n    int epint; \n\n    while (1) {\n        neg = 0;\n        switch (*ep++) {\n\n        case CCHR:\n            if (*ep++ == *lp++)\n                continue;\n            return (0);\n\n        case CDOT:\n            if (*lp++)\n                continue;\n            return (0);\n\n        case CDOL:\n            if (*lp == 0)\n                continue;\n            return (0);\n\n        case CCEOF:\n            vars->loc2 = lp;\n            return (1);\n\n        case CXCL:\n            c = (unsigned char)*lp++;\n            if (ISTHERE(c)) {\n                ep += 32;\n                continue;\n            }\n            return (0);\n\n        case NCCL:\n            neg = 1;\n\n        case CCL:\n            c = *lp++;\n            if (((c & 0200) == 0 && ISTHERE(c)) ^ neg) {\n                ep += 16;\n                continue;\n            }\n            return (0);\n\n        case CBRA:\n            epint = (int) *ep;\n            vars->braslist[epint] = lp;\n            ep++;\n            continue;\n\n        case CKET:\n            epint = (int) *ep;\n            vars->braelist[epint] = lp;\n            ep++;\n            continue;\n\n        case CCHR | RNGE:\n            c = *ep++;\n            getrnge(ep, vars);\n            while (vars->low--)\n                if (*lp++ != c)\n                    return (0);\n            curlp = lp;\n            while (vars->size--)\n                if (*lp++ != c)\n                    break;\n            if (vars->size < 0)\n                lp++;\n            ep += 2;\n            goto star;\n\n        case CDOT | RNGE:\n            getrnge(ep, vars);\n            while (vars->low--)\n                if (*lp++ == '\\0')\n                    return (0);\n            curlp = lp;\n            while (vars->size--)\n                if (*lp++ == '\\0')\n                    break;\n            if (vars->size < 0)\n                lp++;\n            ep += 2;\n            goto star;\n\n        case CXCL | RNGE:\n            getrnge(ep + 32, vars);\n            while (vars->low--) {\n                c = (unsigned char)*lp++;\n                if (!ISTHERE(c))\n                    return (0);\n            }\n            curlp = lp;\n            while (vars->size--) {\n                c = (unsigned char)*lp++;\n                if (!ISTHERE(c))\n                    break;\n            }\n            if (vars->size < 0)\n                lp++;\n            ep += 34;        \n            goto star;\n\n        case NCCL | RNGE:\n            neg = 1;\n\n        case CCL | RNGE:\n            getrnge(ep + 16, vars);\n            while (vars->low--) {\n                c = *lp++;\n                if (((c & 0200) || !ISTHERE(c)) ^ neg)\n                    return (0);\n            }\n            curlp = lp;\n            while (vars->size--) {\n                c = *lp++;\n                if (((c & 0200) || !ISTHERE(c)) ^ neg)\n                    break;\n            }\n            if (vars->size < 0)\n                lp++;\n            ep += 18;         \n            goto star;\n\n        case CBACK:\n            epint = (int) *ep;\n            bbeg = vars->braslist[epint];\n            ct = vars->braelist[epint] - bbeg;\n            ep++;\n\n            if (ecmp(bbeg, lp, ct)) {\n                lp += ct;\n                continue;\n            }\n            return (0);\n\n        case CBACK | STAR:\n            epint = (int) *ep;\n            bbeg = vars->braslist[epint];\n            ct = vars->braelist[epint] - bbeg;\n            ep++;\n            curlp = lp;\n            while (ecmp(bbeg, lp, ct))\n                lp += ct;\n\n            while (lp >= curlp) {\n                if (_advance(lp, ep, vars))\n                    return (1);\n                lp -= ct;\n            }\n            return (0);\n\n\n        case CDOT | STAR:\n            curlp = lp;\n            while (*lp++);\n            goto star;\n\n        case CCHR | STAR:\n            curlp = lp;\n            while (*lp++ == *ep);\n            ep++;\n            goto star;\n\n        case CXCL | STAR:\n            curlp = lp;\n            do {\n                c = (unsigned char)*lp++;\n            } while (ISTHERE(c));\n            ep += 32;\n            goto star;\n\n        case NCCL | STAR:\n            neg = 1;\n\n        case CCL | STAR:\n            curlp = lp;\n            do {\n                c = *lp++;\n            } while (((c & 0200) == 0 && ISTHERE(c)) ^ neg);\n            ep += 16;\n            goto star;\n\n        star:\n            do {\n                if (--lp == vars->locs)\n                    break;\n                if (_advance(lp, ep, vars))\n                    return (1);\n            } while (lp > curlp);\n            return (0);\n\n        }\n    }\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_971bdfe40670f631440dee9a545542d1f7cb6c37_0", {
    "ID": "httpd_971bdfe40670f631440dee9a545542d1f7cb6c37_0",
    "UID": "5393",
    "code": "static void hc_send(sctx_t *ctx, apr_pool_t *ptemp, const char *out, proxy_conn_rec test_snippet\n{\n    apr_bucket_brigade *tmp_bb = apr_brigade_create(ptemp, ctx->ba);\n    ap_log_error(APLOG_MARK, APLOG_TRACE7, 0, ctx->s, \"%s\", out);\n    APR_BRIGADE_INSERT_TAIL(tmp_bb, apr_bucket_pool_create(out, strlen(out), ptemp,\n                            ctx->ba));\n    APR_BRIGADE_INSERT_TAIL(tmp_bb, apr_bucket_flush_create(ctx->ba));\n    ap_pass_brigade(backend->connection->output_filters, tmp_bb);\n    apr_brigade_destroy(tmp_bb);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b55045c878d0a6e7c480416b36352b52b482e2cc_0", {
    "ID": "httpd_b55045c878d0a6e7c480416b36352b52b482e2cc_0",
    "UID": "5398",
    "code": "static char *place(sed_eval_t *eval, char *asp, char *al1, char test_snippet\n{\n    char *sp = asp;\n    int n = al2 - al1;\n    unsigned int reqsize = (sp - eval->genbuf) + n + 1;\n\n    if (eval->gsize < reqsize) {\n        grow_gen_buffer(eval, reqsize, &sp);\n    }\n    memcpy(sp, al1, n);\n    return sp + n;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_3e5024619e8f1276fcb8df5ce3af88d6f9840ca4_0", {
    "ID": "httpd_3e5024619e8f1276fcb8df5ce3af88d6f9840ca4_0",
    "UID": "5400",
    "code": "static int hc_read_headers(sctx_t *ctx, request_rec test_snippet\n{\n    char buffer[HUGE_STRING_LEN];\n    int len;\n\n    len = ap_getline(buffer, sizeof(buffer), r, 1);\n    if (len <= 0) {\n        return !OK;\n    }\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s, APLOGNO(03254)\n            \"%s\", buffer);\n    \n    if (apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n        int major;\n        char keepchar;\n        int proxy_status = OK;\n        const char *proxy_status_line = NULL;\n\n        major = buffer[5] - '0';\n        if ((major != 1) || (len >= sizeof(buffer)-1)) {\n            return !OK;\n        }\n\n        keepchar = buffer[12];\n        buffer[12] = '\\0';\n        proxy_status = atoi(&buffer[9]);\n        if (keepchar != '\\0') {\n            buffer[12] = keepchar;\n        } else {\n            buffer[12] = ' ';\n            buffer[13] = '\\0';\n        }\n        proxy_status_line = apr_pstrdup(r->pool, &buffer[9]);\n        r->status = proxy_status;\n        r->status_line = proxy_status_line;\n    } else {\n        return !OK;\n    }\n    \n    while ((len = ap_getline(buffer, sizeof(buffer), r, 1)) > 0) {\n        char *value, *end;\n        if (!(value = strchr(buffer, ':'))) {\n            return !OK;\n        }\n        ap_log_error(APLOG_MARK, APLOG_TRACE7, 0, ctx->s, \"%s\", buffer);\n        *value = '\\0';\n        ++value;\n        while (apr_isspace(*value))\n            ++value;            \n        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n            *end = '\\0';\n        apr_table_add(r->headers_out, buffer, value);\n    }\n    return OK;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5549931fe2c9cdc6e0ecc64a80e5d889852611b1_0", {
    "ID": "httpd_5549931fe2c9cdc6e0ecc64a80e5d889852611b1_0",
    "UID": "5402",
    "code": "static void append_to_genbuf(sed_eval_t *eval, const char* sz, char test_snippet\n{\n    int len = strlen(sz);\n    unsigned int reqsize = (*gspend - eval->genbuf) + len + 1;\n    if (eval->gsize < reqsize) {\n        grow_gen_buffer(eval, reqsize, gspend);\n    }\n    memcpy(*gspend, sz, len + 1);\n    \n    *gspend += len;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_93fb5fbe9db1445fe172f19d2396cb09f671c2f2_0", {
    "ID": "httpd_93fb5fbe9db1445fe172f19d2396cb09f671c2f2_0",
    "UID": "5404",
    "code": "static int substitute(sed_eval_t *eval, sed_reptr_t test_snippet\n                      step_vars_storage *step_vars)\n{\n    if (match(eval, ipc->re1, 0, step_vars) == 0)    return(0);\n\n    eval->numpass = 0;\n    eval->sflag = 0;        \n    if (dosub(eval, ipc->rhs, ipc->gfl, step_vars) != APR_SUCCESS)\n        return -1;\n\n    if (ipc->gfl) {\n        while (*step_vars->loc2) {\n            if (match(eval, ipc->re1, 1, step_vars) == 0) break;\n            if (dosub(eval, ipc->rhs, ipc->gfl, step_vars) != APR_SUCCESS)\n                return -1;\n        }\n    }\n    return(eval->sflag);\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_438fe2c350edc892ab36a0d01395c6733dfc9943_0", {
    "ID": "httpd_438fe2c350edc892ab36a0d01395c6733dfc9943_0",
    "UID": "5406",
    "code": "static apr_status_t dosub(sed_eval_t *eval, char *rhsbuf, int test_snippet\n                          step_vars_storage *step_vars)\n{\n    char *lp, *sp, *rp;\n    int c;\n    apr_status_t rv = APR_SUCCESS;\n\n    if (n > 0 && n < 999) {\n        eval->numpass++;\n        if (n != eval->numpass) return APR_SUCCESS;\n    }\n    eval->sflag = 1;\n    lp = eval->linebuf;\n    sp = eval->genbuf;\n    rp = rhsbuf;\n    sp = place(eval, sp, lp, step_vars->loc1);\n    while ((c = *rp++) != 0) {\n        if (c == '&') {\n            sp = place(eval, sp, step_vars->loc1, step_vars->loc2);\n            if (sp == NULL)\n                return APR_EGENERAL;\n        }\n        else if (c == '\\\\') {\n            c = *rp++;\n            if (c >= '1' && c < NBRA+'1') {\n                sp = place(eval, sp, step_vars->braslist[c-'1'],\n                           step_vars->braelist[c-'1']);\n                if (sp == NULL)\n                    return APR_EGENERAL;\n            }\n            else\n                *sp++ = c;\n          } else\n            *sp++ = c;\n        if (sp >= eval->genbuf + eval->gsize) {\n            \n            grow_gen_buffer(eval, eval->gsize + 1024, &sp);\n        }\n    }\n    lp = step_vars->loc2;\n    step_vars->loc2 = sp - eval->genbuf + eval->linebuf;\n    append_to_genbuf(eval, lp, &sp);\n    copy_to_linebuf(eval, eval->genbuf);\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_a1b9f8041926c4e3a7751de8c67b80c606b954eb_0", {
    "ID": "httpd_a1b9f8041926c4e3a7751de8c67b80c606b954eb_0",
    "UID": "5407",
    "code": "static const char *wd_cmd_watchdog_int(cmd_parms *cmd, void test_snippet\n                                       const char *arg)\n{\n    int i;\n    const char *errs = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (errs != NULL)\n        return errs;\n    if (wd_interval_set)\n       return \"Duplicate WatchdogInterval directives are not allowed\";\n    if ((i = atoi(arg)) < 1)\n        return \"Invalid WatchdogInterval value\";\n\n    wd_interval = apr_time_from_sec(i);\n    wd_interval_set = 1;\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n606,Unchecked Input for Loop Condition"
  },
  "httpd_0f27aac46e1f3907dc8491bdaa512c89ad665cc0_0", {
    "ID": "httpd_0f27aac46e1f3907dc8491bdaa512c89ad665cc0_0",
    "UID": "5408",
    "code": "static void append_to_linebuf(sed_eval_t *eval, const char* test_snippet\n{\n    int len = strlen(test_snippet;\n    \n    appendmem_to_linebuf(eval, sz, len + 1);\n    --eval->lspend; \n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d1744e5cceb80679cd037126306b7c309c0d2808_0", {
    "ID": "httpd_d1744e5cceb80679cd037126306b7c309c0d2808_0",
    "UID": "5411",
    "code": "static int ap_proxy_retry_worker(const char *proxy_function, proxy_worker test_snippet\n        server_rec *s)\n{\n    if (worker->s->status & PROXY_WORKER_IN_ERROR) {\n        if (PROXY_WORKER_IS(worker, PROXY_WORKER_STOPPED)) {\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(3305)\n                         \"%s: Won't retry worker (%s): stopped\",\n                         proxy_function, worker->s->hostname);\n            return DECLINED;\n        }\n        if ((worker->s->status & PROXY_WORKER_IGNORE_ERRORS)\n            || apr_time_now() > worker->s->error_time + worker->s->retry) {\n            ++worker->s->retries;\n            worker->s->status &= ~PROXY_WORKER_IN_ERROR;\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00932)\n                         \"%s: worker for (%s) has been marked for retry\",\n                         proxy_function, worker->s->hostname);\n            return OK;\n        }\n        else {\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00933)\n                         \"%s: too soon to retry worker for (%s)\",\n                         proxy_function, worker->s->hostname);\n            return DECLINED;\n        }\n    }\n    else {\n        return OK;\n    }\n}",
    "predicted": "null"
  },
  "httpd_6ca11090977d557613542ba2055df17c197f1b0b_0", {
    "ID": "httpd_6ca11090977d557613542ba2055df17c197f1b0b_0",
    "UID": "5422",
    "code": "static void *hc_check(apr_thread_t *thread, void test_snippet\n{\n    baton_t *baton = (baton_t *)b;\n    sctx_t *ctx = baton->ctx;\n    apr_time_t now = baton->now;\n    proxy_worker *worker = baton->worker;\n    apr_pool_t *ptemp = baton->ptemp;\n    server_rec *s = ctx->s;\n    apr_status_t rv;\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(03256)\n                 \"%sHealth checking %s\", (thread ? \"Threaded \" : \"\"), worker->s->name);\n\n    switch (worker->s->method) {\n        case TCP:\n            rv = hc_check_tcp(ctx, ptemp, worker);\n            break;\n\n        case OPTIONS:\n        case HEAD:\n        case GET:\n             rv = hc_check_http(ctx, ptemp, worker);\n             break;\n\n        default:\n            rv = APR_ENOTIMPL;\n            break;\n    }\n    if (rv == APR_ENOTIMPL) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(03257)\n                         \"Somehow tried to use unimplemented hcheck method: %d\",\n                         (int)worker->s->method);\n        apr_pool_destroy(ptemp);\n        return NULL;\n    }\n    \n    if (PROXY_WORKER_IS_HCFAILED(worker)) {\n        if (rv == APR_SUCCESS) {\n            worker->s->pcount += 1;\n            if (worker->s->pcount >= worker->s->passes) {\n                ap_proxy_set_wstatus(PROXY_WORKER_HC_FAIL_FLAG, 0, worker);\n                ap_proxy_set_wstatus(PROXY_WORKER_IN_ERROR_FLAG, 0, worker);\n                worker->s->pcount = 0;\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(03302)\n                             \"%sHealth check ENABLING %s\", (thread ? \"Threaded \" : \"\"),\n                             worker->s->name);\n\n            }\n        }\n    } else {\n        if (rv != APR_SUCCESS) {\n            worker->s->error_time = now;\n            worker->s->fcount += 1;\n            if (worker->s->fcount >= worker->s->fails) {\n                ap_proxy_set_wstatus(PROXY_WORKER_HC_FAIL_FLAG, 1, worker);\n                worker->s->fcount = 0;\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(03303)\n                             \"%sHealth check DISABLING %s\", (thread ? \"Threaded \" : \"\"),\n                             worker->s->name);\n            }\n        }\n    }\n    worker->s->updated = now;\n    apr_pool_destroy(ptemp);\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_97ac0f255c833979119e154d71382c1de9371ec6_0", {
    "ID": "httpd_97ac0f255c833979119e154d71382c1de9371ec6_0",
    "UID": "5423",
    "code": "static void hc_show_exprs(request_rec test_snippet\n{\n    const apr_table_entry_t *elts;\n    const apr_array_header_t *hdr;\n    int i;\n    sctx_t *ctx = (sctx_t *) ap_get_module_config(r->server->module_config,\n                                                  &proxy_hcheck_module);\n    if (apr_is_empty_table(ctx->conditions))\n        return;\n\n    ap_rputs(\"\\n\\n<table>\"\n             \"<tr><th colspan='2'>Health check cond. expressions:</th></tr>\\n\"\n             \"<tr><th>Expr name</th><th>Expression</th></tr>\\n\", r);\n\n    hdr = apr_table_elts(ctx->conditions);\n    elts = (const apr_table_entry_t *) hdr->elts;\n    for (i = 0; i < hdr->nelts; ++i) {\n        hc_condition_t *cond;\n        if (!elts[i].key) {\n            continue;\n        }\n        cond = (hc_condition_t *)elts[i].val;\n        ap_rprintf(r, \"<tr><td>%s</td><td>%s</td></tr>\\n\",\n                   ap_escape_html(r->pool, elts[i].key),\n                   ap_escape_html(r->pool, cond->expr));\n    }\n    ap_rputs(\"</table><hr/>\\n\", r);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_2f6992d78dfede9f16525cd07dda10ff17d79c81_0", {
    "ID": "httpd_2f6992d78dfede9f16525cd07dda10ff17d79c81_0",
    "UID": "5425",
    "code": "static void hc_select_exprs(request_rec *r, const char test_snippet\n{\n    const apr_table_entry_t *elts;\n    const apr_array_header_t *hdr;\n    int i;\n    sctx_t *ctx = (sctx_t *) ap_get_module_config(r->server->module_config,\n                                                  &proxy_hcheck_module);\n    if (apr_is_empty_table(ctx->conditions))\n        return;\n\n    hdr = apr_table_elts(ctx->conditions);\n    elts = (const apr_table_entry_t *) hdr->elts;\n    for (i = 0; i < hdr->nelts; ++i) {\n        if (!elts[i].key) {\n            continue;\n        }\n        ap_rprintf(r, \"<option value='%s' %s >%s</option>\\n\",\n                   ap_escape_html(r->pool, elts[i].key),\n                   (!strcmp(elts[i].key, expr)) ? \"selected\" : \"\",\n                           ap_escape_html(r->pool, elts[i].key));\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_c07f4ec46efba8c3a4b10e80543fe5071758ec84_0", {
    "ID": "httpd_c07f4ec46efba8c3a4b10e80543fe5071758ec84_0",
    "UID": "5427",
    "code": "static int hc_valid_expr(request_rec *r, const char test_snippet\n{\n    const apr_table_entry_t *elts;\n    const apr_array_header_t *hdr;\n    int i;\n    sctx_t *ctx = (sctx_t *) ap_get_module_config(r->server->module_config,\n                                                  &proxy_hcheck_module);\n    if (apr_is_empty_table(ctx->conditions))\n        return 0;\n\n    hdr = apr_table_elts(ctx->conditions);\n    elts = (const apr_table_entry_t *) hdr->elts;\n    for (i = 0; i < hdr->nelts; ++i) {\n        if (!elts[i].key) {\n            continue;\n        }\n        if (!strcmp(elts[i].key, expr))\n            return 1;\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_a59390aef4b00bf3c563903dce6dc71755b9074c_0", {
    "ID": "httpd_a59390aef4b00bf3c563903dce6dc71755b9074c_0",
    "UID": "5429",
    "code": "static const char *hc_get_body(request_rec test_snippet\n{\n    apr_off_t length;\n    apr_size_t len;\n    apr_status_t rv;\n    char *buf;\n\n    if (!r || !r->kept_body)\n        return \"\";\n\n    rv = apr_brigade_length(r->kept_body, 1, &length);\n    len = (apr_size_t)length;\n    if (rv != APR_SUCCESS || len == 0)\n        return \"\";\n\n    buf = apr_palloc(r->pool, len + 1);\n    rv = apr_brigade_flatten(r->kept_body, buf, &len);\n    if (rv != APR_SUCCESS)\n        return \"\";\n    buf[len] = '\\0'; \n    return (const char*)buf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n122,Heap-based Buffer Overflow"
  },
  "httpd_17b2f67dc0fa90b3b22f3f452f6fc536994b3979_0", {
    "ID": "httpd_17b2f67dc0fa90b3b22f3f452f6fc536994b3979_0",
    "UID": "5436",
    "code": "static void ap_die_r(int type, request_rec *r, int test_snippet\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        ap_filter_t *next;\n\n        /*\n         * Check if we still have the ap_http_header_filter in place. If\n         * this is the case we should not ignore the error here because\n         * it means that we have not sent any response at all and never\n         * will. This is bad. Sent an internal server error instead.\n         */\n        next = r->output_filters;\n        while (next && (next->frec != ap_http_header_filter_handle)) {\n               next = next->next;\n        }\n\n        /*\n         * If next != NULL then we left the while above because of\n         * next->frec == ap_http_header_filter\n         */\n        if (next) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n            type = HTTP_INTERNAL_SERVER_ERROR;\n        }\n        else {\n            return;\n        }\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  \n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; \n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, test_snippet;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_3b22fb07d876adc583ca43c8cd3e3bd96bc61bc6_0", {
    "ID": "httpd_3b22fb07d876adc583ca43c8cd3e3bd96bc61bc6_0",
    "UID": "5441",
    "code": "char *ap_response_code_string(request_rec *r, int test_snippet\n{\n    core_dir_config *dirconf;\n    core_request_config *reqconf = ap_get_core_module_config(r->request_config);\n    const char *err;\n    const char *response;\n    ap_expr_info_t *expr;\n\n    \n    if (reqconf->response_code_strings != NULL\n            && reqconf->response_code_strings[error_index] != NULL) {\n        return reqconf->response_code_strings[error_index];\n    }\n\n    \n    dirconf = ap_get_core_module_config(r->per_dir_config);\n\n    if (!dirconf->response_code_exprs) {\n        return NULL;\n    }\n\n    expr = apr_hash_get(dirconf->response_code_exprs, &error_index,\n            sizeof(test_snippet);\n    if (!expr) {\n        return NULL;\n    }\n\n    \n    if ((char *) expr == &errordocument_default) {\n        return NULL;\n    }\n\n    err = NULL;\n    response = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(\n                APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02830) \"core: ErrorDocument: can't \"\n                \"evaluate require expression: %s\", err);\n        return NULL;\n    }\n\n    \n    return apr_pstrdup(r->pool, response);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_71758e8a48d0ca426b880d53c447ddb3fdd31609_0", {
    "ID": "httpd_71758e8a48d0ca426b880d53c447ddb3fdd31609_0",
    "UID": "5447",
    "code": "static void fmt_data(unsigned char *buf, const void *vdata, apr_size_t len, apr_size_t test_snippet\n{\n    const unsigned char *data = (const unsigned char *)vdata;\n    unsigned char *chars;\n    unsigned char *hex;\n    apr_size_t this_time = 0;\n\n    memset(buf, ' ', LOG_BYTES_BUFFER_SIZE - 1);\n    buf[LOG_BYTES_BUFFER_SIZE - 1] = '\\0';\n    \n    chars = buf; \n    hex   = buf + BYTES_LOGGED_PER_LINE + 1; \n    while (*off < len && this_time < BYTES_LOGGED_PER_LINE) {\n        unsigned char c = data[*off];\n\n        if (apr_isprint(c)\n            && c != '\\\\') {  /* backslash will be escaped later, which throws\n                              * off the formatting\n                              */\n            *chars = c;\n        }\n        else {\n            *chars = '.';\n        }\n\n        if ((c >> 4) >= 10) {\n            *hex = 'a' + ((c >> 4) - 10);\n        }\n        else {\n            *hex = '0' + (c >> 4);\n        }\n\n        if ((c & 0x0F) >= 10) {\n            *(hex + 1) = 'a' + ((c & 0x0F) - 10);\n        }\n        else {\n            *(hex + 1) = '0' + (c & 0x0F);\n        }\n\n        chars += 1;\n        hex += 2;\n        *off += 1;\n        ++this_time;\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_064e768da621a9c49cc9c189371ec55ae9cbb208_0", {
    "ID": "httpd_064e768da621a9c49cc9c189371ec55ae9cbb208_0",
    "UID": "5454",
    "code": "static void *dav_fs_create_server_config(apr_pool_t *p, server_rec test_snippet\n{\n    dav_fs_server_conf *conf = apr_pcalloc(p, sizeof(dav_fs_server_conf));\n#ifdef DEFAULT_EXP_DAVLOCKDB\n    conf->lockdb_path = DEFAULT_EXP_DAVLOCKDB;\n    if (*conf->lockdb_path == '\\0') {\n        conf->lockdb_path = NULL;\n    }\n#endif\n\n    return conf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2bc6c7f3dc8e5a645ee0ca387572b517a7ff6d63_0", {
    "ID": "httpd_2bc6c7f3dc8e5a645ee0ca387572b517a7ff6d63_0",
    "UID": "5455",
    "code": "static int authz_dbd_group_query(request_rec *r, authz_dbd_cfg test_snippet\n                                 apr_array_header_t *groups)\n{\n    \n    int rv;\n    const char *message;\n    ap_dbd_t *dbd = dbd_handle(r);\n    apr_dbd_prepared_t *query;\n    apr_dbd_results_t *res = NULL;\n    apr_dbd_row_t *row = NULL;\n\n    if (cfg->query == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01649)\n                      \"No query configured for dbd-group!\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    query = apr_hash_get(dbd->prepared, cfg->query, APR_HASH_KEY_STRING);\n    if (query == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01650)\n                      \"Error retrieving query for dbd-group!\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    rv = apr_dbd_pvselect(dbd->driver, r->pool, dbd->handle, &res,\n                          query, 0, r->user, NULL);\n    if (rv == 0) {\n        for (rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1);\n             rv != -1;\n             rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {\n            if (rv == 0) {\n                APR_ARRAY_PUSH(groups, const char *) =\n                    apr_pstrdup(r->pool,\n                                apr_dbd_get_entry(dbd->driver, row, 0));\n            }\n            else {\n                message = apr_dbd_error(dbd->driver, dbd->handle, rv);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01651)\n                        \"authz_dbd in get_row; group query for user=%s [%s]\",\n                        r->user, message?message:noerror);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n    }\n    else {\n        message = apr_dbd_error(dbd->driver, dbd->handle, rv);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01652)\n                      \"authz_dbd, in groups query for %s [%s]\",\n                      r->user, message?message:noerror);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n252,Unchecked Return Value\n"
  },
  "httpd_7014de985a49c4ebf8bebc84337511ae7b2d4121_0", {
    "ID": "httpd_7014de985a49c4ebf8bebc84337511ae7b2d4121_0",
    "UID": "5456",
    "code": "static int pass_response(request_rec *r, proxy_conn_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    const char *location;\n    scgi_config *conf;\n    socket_ex_data *sock_data;\n    int status;\n\n    sock_data = apr_palloc(r->pool, sizeof(*sock_data));\n    sock_data->sock = conn->sock;\n    sock_data->counter = &conn->worker->s->read;\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    b = bucket_socket_ex_create(sock_data, r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    b = apr_bucket_eos_create(r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    status = ap_scan_script_header_err_brigade_ex(r, bb, NULL,\n                                                  APLOG_MODULE_INDEX);\n    if (status != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00860)\n                      \"error reading response headers from %s:%u\",\n                      conn->hostname, conn->port);\n        r->status_line = NULL;\n        apr_brigade_destroy(bb);\n        return status;\n    }\n\n    conf = ap_get_module_config(r->per_dir_config, &proxy_scgi_module);\n    if (conf->sendfile && conf->sendfile != scgi_sendfile_off) {\n        short err = 1;\n\n        location = apr_table_get(r->err_headers_out, conf->sendfile);\n        if (!location) {\n            err = 0;\n            location = apr_table_get(r->headers_out, conf->sendfile);\n        }\n        if (location) {\n            scgi_request_config *req_conf = apr_palloc(r->pool,\n                                                       sizeof(*req_conf));\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00861)\n                          \"Found %s: %s - preparing subrequest.\",\n                          conf->sendfile, location);\n\n            if (err) {\n                apr_table_unset(r->err_headers_out, conf->sendfile);\n            }\n            else {\n                apr_table_unset(r->headers_out, conf->sendfile);\n            }\n            req_conf->location = location;\n            req_conf->type = scgi_sendfile;\n            ap_set_module_config(r->request_config, &proxy_scgi_module,\n                                 req_conf);\n            apr_brigade_destroy(bb);\n            return OK;\n        }\n    }\n\n    if (r->status == HTTP_OK \n        && (!conf->internal_redirect \n            || conf->internal_redirect != scgi_internal_redirect_off)) {\n        short err = 1;\n        const char *location_header = conf->internal_redirect ? \n            conf->internal_redirect : scgi_internal_redirect_on;\n\n        location = apr_table_get(r->err_headers_out, location_header);\n        if (!location) {\n            err = 0;\n            location = apr_table_get(r->headers_out, location_header);\n        }\n        if (location && *location == '/') {\n            scgi_request_config *req_conf = apr_palloc(r->pool,\n                                                       sizeof(*req_conf));\n            if (strcasecmp(location_header, \"Location\")) {\n                if (err) {\n                    apr_table_unset(r->err_headers_out, location_header);\n                }\n                else {\n                    apr_table_unset(r->headers_out, location_header);\n                }\n            }\n            req_conf->location = location;\n            req_conf->type = scgi_internal_redirect;\n            ap_set_module_config(r->request_config, &proxy_scgi_module,\n                                 req_conf);\n            apr_brigade_destroy(bb);\n            return OK;\n        }\n    }\n\n    if (ap_pass_brigade(r->output_filters, bb)) {\n        return AP_FILTER_ERROR;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_32d6ae581428ae6e71b3745182a6106b4304fc2c_0", {
    "ID": "httpd_32d6ae581428ae6e71b3745182a6106b4304fc2c_0",
    "UID": "5462",
    "code": "static int fixup_dflt(request_rec test_snippet\n{\n    dir_config_rec *d = ap_get_module_config(r->per_dir_config, &dir_module);\n    const char *name_ptr;\n    request_rec *rr;\n    int error_notfound = 0;\n\n    name_ptr = d->dflt;\n    if ((name_ptr == NULL) || !(strcasecmp(name_ptr,\"disabled\"))){\n        return DECLINED;\n    }\n    /* XXX: if FallbackResource points to something that doesn't exist,\n     * this may recurse until it hits the limit for internal redirects\n     * before returning an Internal Server Error.\n     */\n\n    /* The logic of this function is basically cloned and simplified\n     * from fixup_dir below.  See the comments there.\n     */\n    if (r->args != NULL) {\n        name_ptr = apr_pstrcat(r->pool, name_ptr, \"?\", r->args, NULL);\n    }\n    rr = ap_sub_req_lookup_uri(name_ptr, r, r->output_filters);\n    if (rr->status == HTTP_OK\n        && (   (rr->handler && !strcmp(rr->handler, \"proxy-server\"))\n            || rr->finfo.filetype == APR_REG)) {\n        ap_internal_fast_redirect(rr, r);\n        return OK;\n    }\n    else if (ap_is_HTTP_REDIRECT(rr->status)) {\n\n        apr_pool_join(r->pool, rr->pool);\n        r->notes = apr_table_overlay(r->pool, r->notes, rr->notes);\n        r->headers_out = apr_table_overlay(r->pool, r->headers_out,\n                                           rr->headers_out);\n        r->err_headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                               rr->err_headers_out);\n        error_notfound = rr->status;\n    }\n    else if (rr->status && rr->status != HTTP_NOT_FOUND\n             && rr->status != HTTP_OK) {\n        error_notfound = rr->status;\n    }\n\n    ap_destroy_sub_req(rr);\n    if (error_notfound) {\n        return error_notfound;\n    }\n\n    \n    return DECLINED;\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_2bfe9b94c870eb51b8164ab44a97d390fe2f99c2_0", {
    "ID": "httpd_2bfe9b94c870eb51b8164ab44a97d390fe2f99c2_0",
    "UID": "5465",
    "code": "static void *ap_default_log_writer_init(apr_pool_t *p, server_rec test_snippet\n                                        const char* name)\n{\n    default_log_writer *log_writer;\n    const char *provider_name = name;\n    ap_errorlog_provider *provider = NULL;\n    const char *sep;\n\n    /* We support *Log \"errorlog_provider:arg\" syntax now, so get the provider\n     * name from the name. */\n    if ((sep = ap_strchr_c(name, ':')) != NULL) {\n        provider_name = apr_pstrmemdup(p, name, sep - name);\n        sep++;\n    }\n\n    if (*name == '|') {\n        piped_log *pl;\n\n        pl = ap_open_piped_log(p, name + 1);\n        if (pl == NULL) {\n           return NULL;\n        }\n\n        log_writer = apr_pcalloc(p, sizeof(default_log_writer));\n        log_writer->type = LOG_WRITER_FD;\n        log_writer->log_writer = ap_piped_log_write_fd(pl);\n        if (!log_writer->log_writer) {\n            return NULL;\n        }\n        return log_writer;\n    }\n    else if ((provider = ap_lookup_provider(AP_ERRORLOG_PROVIDER_GROUP,\n        provider_name, AP_ERRORLOG_PROVIDER_VERSION)) != NULL) {\n        void *provider_handle;\n        errorlog_provider_data *provider_data;\n    \n        provider_handle = provider->init(p, s);\n        if (!provider_handle) {\n            \n            return NULL;\n        }\n\n        provider_data = apr_pcalloc(p, sizeof(errorlog_provider_data));\n        provider_data->provider = provider;\n        provider_data->handle = provider_handle;\n\n        log_writer = apr_pcalloc(p, sizeof(default_log_writer));\n        log_writer->type = LOG_WRITER_PROVIDER;\n        log_writer->log_writer = provider_data;\n        return log_writer;\n    }\n    else {\n        const char *fname = ap_server_root_relative(p, name);\n        apr_file_t *fd;\n        apr_status_t rv;\n\n        if (!fname) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(00648)\n                            \"invalid transfer log path %s.\", name);\n            return NULL;\n        }\n        rv = apr_file_open(&fd, fname, xfer_flags, xfer_perms, p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00649)\n                            \"could not open transfer log file %s.\", fname);\n            return NULL;\n        }\n\n        log_writer = apr_pcalloc(p, sizeof(default_log_writer));\n        log_writer->type = LOG_WRITER_FD;\n        log_writer->log_writer = fd;\n        return log_writer;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_abb0a2f364575b3020a7c01faec071f1a16480bd_0", {
    "ID": "httpd_abb0a2f364575b3020a7c01faec071f1a16480bd_0",
    "UID": "5491",
    "code": "static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout) test_snippet\n    int client_error = 0;\n    request_rec *r = baton->r;\n    conn_rec *c = r->connection;\n    proxy_conn_rec *conn = baton->proxy_connrec;\n    apr_socket_t *sock = conn->sock;\n    conn_rec *backconn = conn->connection;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    apr_pollset_t *pollset = baton->pollset;\n    apr_socket_t *client_socket = baton->client_soc;\n    apr_status_t rv;\n    apr_bucket_brigade *bb = baton->bb;\n\n    while(1) test_snippet \n        if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled))\n                != APR_SUCCESS) test_snippet\n            if (APR_STATUS_IS_EINTR(rv)) test_snippet\n                continue;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) test_snippet \n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, \"Attempting to go asynch\");\n                return SUSPENDED;\n            }\n            else test_snippet \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) \"error apr_poll()\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02445)\n                \"woke from poll(), i=%d\", pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) test_snippet\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) test_snippet\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) test_snippet\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02446)\n                            \"sock was readable\");\n                    rv = proxy_wstunnel_transfer(r, backconn, c, bb, \"sock\");\n                }\n                else if ((pollevent & APR_POLLERR)\n                        || (pollevent & APR_POLLHUP)) test_snippet\n                    rv = APR_EPIPE;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447)\n                            \"err/hup on backconn\");\n                }\n                if (rv != APR_SUCCESS)\n                    client_error = 1;\n            }\n            else if (cur->desc.s == client_socket) test_snippet\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) test_snippet\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02448)\n                            \"client was readable\");\n                    rv = proxy_wstunnel_transfer(r, c, backconn, bb, \"client\");\n                }\n            }\n            else test_snippet\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449)\n                        \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) test_snippet\n            break;\n        }\n\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n            \"finished with poll() - cleaning up\");\n\n    if (client_error) test_snippet\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_d1c2ff824718b286b3089b9fd1a35ff5ad91a37c_0", {
    "ID": "httpd_d1c2ff824718b286b3089b9fd1a35ff5ad91a37c_0",
    "UID": "5494",
    "code": "static int ap_set_byterange(request_rec *r, apr_off_t test_snippet\n                            apr_array_header_t **indexes,\n                            int *overlaps, int *reversals)\n{\n    const char *range;\n    const char *ct;\n    char *cur;\n    apr_array_header_t *merged;\n    int num_ranges = 0, unsatisfiable = 0;\n    apr_off_t ostart = 0, oend = 0, sum_lengths = 0;\n    int in_merge = 0;\n    indexes_t *idx;\n    int ranges = 1;\n    int i;\n    const char *it;\n\n    *overlaps = 0;\n    *reversals = 0;\n\n    if (r->assbackwards) {\n        return 0;\n    }\n\n    range = apr_table_get(r->headers_in, \"Range\");\n    if (!range || strncasecmp(range, \"bytes=\", 6) || r->status != HTTP_OK) {\n        return 0;\n    }\n\n    \n    if (apr_table_get(r->headers_out, \"Content-Range\")) {\n        return 0;\n    }\n\n    \n    if ((ct = apr_table_get(r->headers_out, \"Content-Type\"))\n        && strncasecmp(ct, \"multipart/byteranges\", 20) == 0) {\n            return 0;\n    }\n\n    /*\n     * Check the If-Range header for Etag or Date.\n     */\n    if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }\n\n    range += 6;\n    it = range;\n    while (*it) {\n        if (*it++ == ',') {\n            ranges++;\n        }\n    }\n    it = range;\n    if (ranges > MAX_PREALLOC_RANGES) {\n        ranges = MAX_PREALLOC_RANGES;\n    }\n    *indexes = apr_array_make(r->pool, ranges, sizeof(indexes_t));\n    while ((cur = ap_getword(r->pool, &range, ','))) {\n        char *dash;\n        char *errp;\n        apr_off_t number, start, end;\n\n        if (!*cur)\n            break;\n\n        /*\n         * Per RFC 2616 14.35.1: If there is at least one syntactically invalid\n         * byte-range-spec, we must ignore the whole header.\n         */\n\n        if (!(dash = strchr(cur, '-'))) {\n            return 0;\n        }\n\n        if (dash == cur) {\n            \n            if (apr_strtoff(&number, dash+1, &errp, 10) || *errp) {\n                return 0;\n            }\n            if (number < 1) {\n                return 0;\n            }\n            start = clength - number;\n            end = clength - 1;\n        }\n        else {\n            *dash++ = '\\0';\n            if (apr_strtoff(&number, cur, &errp, 10) || *errp) {\n                return 0;\n            }\n            start = number;\n            if (*dash) {\n                if (apr_strtoff(&number, dash, &errp, 10) || *errp) {\n                    return 0;\n                }\n                end = number;\n                if (start > end) {\n                    return 0;\n                }\n            }\n            else {                  \n                end = clength - 1;\n                /*\n                 * special case: 0-\n                 *   ignore all other ranges provided\n                 *   return as a single range: 0-\n                 */\n                if (start == 0) {\n                    num_ranges = 0;\n                    sum_lengths = 0;\n                    in_merge = 1;\n                    oend = end;\n                    ostart = start;\n                    apr_array_clear(*indexes);\n                    break;\n                }\n            }\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start >= clength) {\n            unsatisfiable = 1;\n            continue;\n        }\n        if (end >= clength) {\n            end = clength - 1;\n        }\n\n        if (!in_merge) {\n            \n            ostart = start;\n            oend = end;\n            in_merge = 1;\n            continue;\n        }\n        in_merge = 0;\n\n        if (start >= ostart && end <= oend) {\n            in_merge = 1;\n        }\n\n        if (start < ostart && end >= ostart-1) {\n            ostart = start;\n            ++*reversals;\n            in_merge = 1;\n        }\n        if (end >= oend && start <= oend+1 ) {\n            oend = end;\n            in_merge = 1;\n        }\n\n        if (in_merge) {\n            ++*overlaps;\n            continue;\n        } else {\n            idx = (indexes_t *)apr_array_push(*indexes);\n            idx->start = ostart;\n            idx->end = oend;\n            sum_lengths += oend - ostart + 1;\n            \n            in_merge = 1;\n            ostart = start;\n            oend = end;\n            num_ranges++;\n        }\n    }\n\n    if (in_merge) {\n        idx = (indexes_t *)apr_array_push(*indexes);\n        idx->start = ostart;\n        idx->end = oend;\n        sum_lengths += oend - ostart + 1;\n        num_ranges++;\n    }\n    else if (num_ranges == 0 && unsatisfiable) {\n        \n        return -1;\n    }\n    if (sum_lengths > clength) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                      \"Sum of ranges larger than file, ignoring.\");\n        return 0;\n    }\n\n    /*\n     * create the merged table now, now that we know we need it\n     */\n    merged = apr_array_make(r->pool, num_ranges, sizeof(char *));\n    idx = (indexes_t *)(*indexes)->elts;\n    for (i = 0; i < (*indexes)->nelts; i++, idx++) {\n        char **new = (char **)apr_array_push(merged);\n        *new = apr_psprintf(r->pool, \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT,\n                            idx->start, idx->end);\n    }\n\n    r->status = HTTP_PARTIAL_CONTENT;\n    r->range = apr_array_pstrcat(r->pool, merged, ',');\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01583)\n                  \"Range: %s | %s (%d : %d : %\"APR_OFF_T_FMT\")\",\n                  it, r->range, *overlaps, *reversals, clength);\n\n    return num_ranges;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n"
  },
  "httpd_58f56908ec8af45e402c138e1e466e1c792b58aa_0", {
    "ID": "httpd_58f56908ec8af45e402c138e1e466e1c792b58aa_0",
    "UID": "5496",
    "code": "static apr_status_t socache_mc_init(ap_socache_instance_t test_snippet\n                                    const char *namespace,\n                                    const struct ap_socache_hints *hints,\n                                    server_rec *s, apr_pool_t *p)\n{\n    apr_status_t rv;\n    int thread_limit = 0;\n    apr_uint16_t nservers = 0;\n    char *cache_config;\n    char *split;\n    char *tok;\n\n    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);\n\n    \n    cache_config = apr_pstrdup(p, ctx->servers);\n    split = apr_strtok(cache_config, \",\", &tok);\n    while (split) {\n        nservers++;\n        split = apr_strtok(NULL,\",\", &tok);\n    }\n\n    rv = apr_memcache_create(p, nservers, 0, &ctx->mc);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00785)\n                     \"Failed to create Memcache Object of '%d' size.\",\n                     nservers);\n        return rv;\n    }\n\n    \n    cache_config = apr_pstrdup(p, ctx->servers);\n    split = apr_strtok(cache_config, \",\", &tok);\n    while (split) {\n        apr_memcache_server_t *st;\n        char *host_str;\n        char *scope_id;\n        apr_port_t port;\n\n        rv = apr_parse_addr_port(&host_str, &scope_id, &port, split, p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00786)\n                         \"Failed to Parse memcache Server: '%s'\", split);\n            return rv;\n        }\n\n        if (host_str == NULL) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00787)\n                         \"Failed to Parse Server, \"\n                         \"no hostname specified: '%s'\", split);\n            return APR_EINVAL;\n        }\n\n        if (port == 0) {\n            port = MC_DEFAULT_SERVER_PORT;\n        }\n\n        rv = apr_memcache_server_create(p,\n                                        host_str, port,\n                                        MC_DEFAULT_SERVER_MIN,\n                                        MC_DEFAULT_SERVER_SMAX,\n                                        thread_limit,\n                                        MC_DEFAULT_SERVER_TTL,\n                                        &st);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00788)\n                         \"Failed to Create memcache Server: %s:%d\",\n                         host_str, port);\n            return rv;\n        }\n\n        rv = apr_memcache_add_server(ctx->mc, st);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00789)\n                         \"Failed to Add memcache Server: %s:%d\",\n                         host_str, port);\n            return rv;\n        }\n\n        split = apr_strtok(NULL,\",\", &tok);\n    }\n\n    ctx->tag = apr_pstrcat(p, namespace, \":\", NULL);\n    ctx->taglen = strlen(ctx->tag) + 1;\n\n    \n    AP_DEBUG_ASSERT(ctx->taglen <= 16);\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_a9310c88dce5abdda2eb1b64b582e235a9f16a2b_0", {
    "ID": "httpd_a9310c88dce5abdda2eb1b64b582e235a9f16a2b_0",
    "UID": "5501",
    "code": "static const char *log_bytes_combined(request_rec *r, char test_snippet\n{\n    logio_config_t *cf = ap_get_module_config(r->connection->conn_config,\n                                              &logio_module);\n\n    return apr_off_t_toa(r->pool, cf->bytes_out + cf->bytes_in);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a368b30c9bf970a894eef24cabf72ca08f466add_0", {
    "ID": "httpd_a368b30c9bf970a894eef24cabf72ca08f466add_0",
    "UID": "5508",
    "code": "int get_password(struct passwd_ctx test_snippet\n{\n    char buf[MAX_STRING_LEN + 1];\n    if (ctx->passwd_src == PW_STDIN) {\n        apr_file_t *file_stdin;\n        apr_size_t nread;\n        if (apr_file_open_stdin(&file_stdin, ctx->pool) != APR_SUCCESS) {\n            ctx->errstr = \"Unable to read from stdin.\";\n            return ERR_GENERAL;\n        }\n        if (apr_file_read_full(file_stdin, buf, sizeof(buf) - 1,\n                               &nread) != APR_EOF\n            || nread == sizeof(buf) - 1) {\n            goto err_too_long;\n        }\n        buf[nread] = '\\0';\n        if (nread >= 1 && buf[nread-1] == '\\n') {\n            buf[nread-1] = '\\0';\n            if (nread >= 2 && buf[nread-2] == '\\r')\n                buf[nread-2] = '\\0';\n        }\n        apr_file_close(file_stdin);\n        ctx->passwd = apr_pstrdup(ctx->pool, buf);\n    }\n    else if (ctx->passwd_src == PW_PROMPT_VERIFY) {\n        apr_size_t bufsize = sizeof(buf);\n        if (apr_password_get(\"Enter password: \", buf, &bufsize) != 0)\n            goto err_too_long;\n        ctx->passwd = apr_pstrdup(ctx->pool, buf);\n    }\n    else {\n        apr_size_t bufsize = sizeof(buf);\n        if (apr_password_get(\"New password: \", buf, &bufsize) != 0)\n            goto err_too_long;\n        ctx->passwd = apr_pstrdup(ctx->pool, buf);\n        bufsize = sizeof(buf);\n        buf[0] = '\\0';\n        apr_password_get(\"Re-type new password: \", buf, &bufsize);\n        if (strcmp(ctx->passwd, buf) != 0) {\n            ctx->errstr = \"password verification error\";\n            memset(ctx->passwd, '\\0', strlen(ctx->passwd));\n            memset(buf, '\\0', sizeof(buf));\n            return ERR_PWMISMATCH;\n        }\n    }\n    memset(buf, '\\0', sizeof(buf));\n    return 0;\n\nerr_too_long:\n    ctx->errstr = apr_psprintf(ctx->pool,\n                               \"password too long (>%\" APR_SIZE_T_FMT \")\",\n                               ctx->out_len - 1);\n    return ERR_OVERFLOW;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n526,Cleartext Storage of Sensitive Information in an Environment Variable\n591,Sensitive Data Storage in Improperly Locked Memory"
  },
  "httpd_8b70a7a983aa0ad4a66cd8a0af5f41b80383c85b_0", {
    "ID": "httpd_8b70a7a983aa0ad4a66cd8a0af5f41b80383c85b_0",
    "UID": "5511",
    "code": "static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec test_snippet\n{\n    /*\n     * Calculate the sizes and offsets in cur_unique_id.\n     */\n    unique_id_rec_offset[0] = APR_OFFSETOF(unique_id_rec, stamp);\n    unique_id_rec_size[0] = sizeof(cur_unique_id.stamp);\n    unique_id_rec_offset[1] = APR_OFFSETOF(unique_id_rec, root);\n    unique_id_rec_size[1] = sizeof(cur_unique_id.root);\n    unique_id_rec_offset[2] = APR_OFFSETOF(unique_id_rec, counter);\n    unique_id_rec_size[2] = sizeof(cur_unique_id.counter);\n    unique_id_rec_offset[3] = APR_OFFSETOF(unique_id_rec, thread_index);\n    unique_id_rec_size[3] = sizeof(cur_unique_id.thread_index);\n    unique_id_rec_total_size = unique_id_rec_size[0] + unique_id_rec_size[1] +\n                               unique_id_rec_size[2] + unique_id_rec_size[3];\n\n    /*\n     * Calculate the size of the structure when encoded.\n     */\n    unique_id_rec_size_uu = (unique_id_rec_total_size*8+5)/6;\n\n    return OK;\n}",
    "predicted": "This code does not appear to have any flaws. Therefore, the response is null."
  },
  "httpd_7eb0d9e2ab20e406da62ca131c66e88ae2044c9a_0", {
    "ID": "httpd_7eb0d9e2ab20e406da62ca131c66e88ae2044c9a_0",
    "UID": "5521",
    "code": "static void add_te_chunked(apr_pool_t test_snippet\n                           apr_bucket_alloc_t *bucket_alloc,\n                           apr_bucket_brigade *header_brigade)\n{\n    apr_bucket *e;\n    char *buf;\n    const char te_hdr[] = \"Transfer-Encoding: chunked\" CRLF;\n\n    buf = apr_pmemdup(p, te_hdr, sizeof(te_hdr)-1);\n    ap_xlate_proto_to_ascii(buf, sizeof(te_hdr)-1);\n\n    e = apr_bucket_pool_create(buf, sizeof(te_hdr)-1, p, bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_80cbd2fc28fac36f571ab0a64b4eb146e1e9743f_0", {
    "ID": "httpd_80cbd2fc28fac36f571ab0a64b4eb146e1e9743f_0",
    "UID": "5530",
    "code": "AP_DECLARE(void) ap_skiplist_free(ap_skiplist *sl, void test_snippet\n{\n    if (!sl->pool) {\n        free(mem);\n    }\n    else {\n        int i;\n        memlist_t *memlist = (memlist_t *)sl->memlist->elts;\n        for (i = 0; i < sl->memlist->nelts; i++) {\n            int j;\n            chunk_t *chunk = (chunk_t *)memlist->list->elts;\n            for (j = 0; j < memlist->list->nelts; j++) {\n                if (chunk->ptr == mem) {\n                    chunk->inuse = 0;\n                    return;\n                }\n                chunk++;\n            }\n            memlist++;\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_d2e7af288c27b2f16824a38e90789e74f337cc7e_0", {
    "ID": "httpd_d2e7af288c27b2f16824a38e90789e74f337cc7e_0",
    "UID": "5531",
    "code": "static void add_cl(apr_pool_t test_snippet\n                   apr_bucket_alloc_t *bucket_alloc,\n                   apr_bucket_brigade *header_brigade,\n                   const char *cl_val)\n{\n    apr_bucket *e;\n    char *buf;\n\n    buf = apr_pstrcat(p, \"Content-Length: \",\n                      cl_val,\n                      CRLF,\n                      NULL);\n    ap_xlate_proto_to_ascii(buf, strlen(buf));\n    e = apr_bucket_pool_create(buf, strlen(buf), p, bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_69c516f3140401fdb602769e21155c716982fe43_0", {
    "ID": "httpd_69c516f3140401fdb602769e21155c716982fe43_0",
    "UID": "5532",
    "code": "char *cache_strqtok(char *str, const char *sep, char test_snippet\n{\n    char *token;\n    int quoted = 0;\n\n    if (!str) {         \n        str = *last;    \n    }\n\n    if (!str) {         \n        return NULL;\n    }\n\n    \n    while (*str && ap_strchr_c(sep, *str)) {\n        ++str;\n    }\n\n    if (!*str) {        \n        return NULL;\n    }\n\n    token = str;\n\n    /* skip valid token characters to terminate token and\n     * prepare for the next call (will terminate at '\\0)\n     * on the way, ignore all quoted strings, and within\n     * quoted strings, escaped characters.\n     */\n    *last = token;\n    while (test_snippet {\n        if (!quoted) {\n            if (**last == '\\\"' && !ap_strchr_c(sep, '\\\"')) {\n                quoted = 1;\n                ++*last;\n            }\n            else if (!ap_strchr_c(sep, test_snippet) {\n                ++*last;\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            if (**last == '\\\"') {\n                quoted = 0;\n                ++*last;\n            }\n            else if (**last == '\\\\') {\n                ++*last;\n                if (test_snippet {\n                    ++*last;\n                }\n            }\n            else {\n                ++*last;\n            }\n        }\n    }\n\n    if (test_snippet {\n        **last = '\\0';\n        ++*last;\n    }\n\n    return token;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_9fe026072379730b00523cead758e0cbea2dd8e1_0", {
    "ID": "httpd_9fe026072379730b00523cead758e0cbea2dd8e1_0",
    "UID": "5540",
    "code": "PROXY_DECLARE(char test_snippet\n     ap_proxy_canon_netloc(apr_pool_t *p, char **const urlp, char **userp,\n            char **passwordp, char **hostp, apr_port_t *port)\n{\n    char *addr, *scope_id, *strp, *host, *url = *urlp;\n    char *user = NULL, *password = NULL;\n    apr_port_t tmp_port;\n    apr_status_t rv;\n\n    if (url[0] != '/' || url[1] != '/') {\n        return \"Malformed URL\";\n    }\n    host = url + 2;\n    url = strchr(host, '/');\n    if (url == NULL) {\n        url = \"\";\n    }\n    else {\n        *(url++) = '\\0';    \n    }\n\n    \n    strp = strrchr(host, '@');\n\n    if (strp != NULL) {\n        *strp = '\\0';\n        user = host;\n        host = strp + 1;\n\n\n        strp = strchr(user, ':');\n        if (strp != NULL) {\n            *strp = '\\0';\n            password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, 1, 0);\n            if (password == NULL) {\n                return \"Bad %-escape in URL (password)\";\n            }\n        }\n\n        user = ap_proxy_canonenc(p, user, strlen(user), enc_user, 1, 0);\n        if (user == NULL) {\n            return \"Bad %-escape in URL (username)\";\n        }\n    }\n    if (userp != NULL) {\n        *userp = user;\n    }\n    if (passwordp != NULL) {\n        *passwordp = password;\n    }\n\n    /*\n     * Parse the host string to separate host portion from optional port.\n     * Perform range checking on port.\n     */\n    rv = apr_parse_addr_port(&addr, &scope_id, &tmp_port, host, p);\n    if (rv != APR_SUCCESS || addr == NULL || scope_id != NULL) {\n        return \"Invalid host/port\";\n    }\n    if (tmp_port != 0) { \n        *port = tmp_port;\n    }\n\n    ap_str_tolower(addr); \n\n    *urlp = url;\n    *hostp = addr;\n\n    return NULL;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_30d0575bf113069267403207fba9052421fc69d2_0", {
    "ID": "httpd_30d0575bf113069267403207fba9052421fc69d2_0",
    "UID": "5547",
    "code": "static int flush_libz_buffer(deflate_ctx *ctx, deflate_filter_config test_snippet\n                             struct apr_bucket_alloc_t *bucket_alloc,\n                             int (*libz_func)(z_streamp, int), int flush,\n                             int crc)\n{\n    int zRC = Z_OK;\n    int done = 0;\n    unsigned int deflate_len;\n    apr_bucket *b;\n\n    for (;;) {\n         deflate_len = c->bufferSize - ctx->stream.avail_out;\n\n         if (deflate_len != 0) {\n             /*\n              * Do we need to update ctx->crc? Usually this is the case for\n              * inflate action where we need to do a crc on the output, whereas\n              * in the deflate case we need to do a crc on the input\n              */\n             if (crc) {\n                 ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer,\n                                  deflate_len);\n             }\n             b = apr_bucket_heap_create((char *)ctx->buffer,\n                                        deflate_len, NULL,\n                                        bucket_alloc);\n             APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n             ctx->stream.next_out = ctx->buffer;\n             ctx->stream.avail_out = c->bufferSize;\n         }\n\n         if (done)\n             break;\n\n         zRC = libz_func(&ctx->stream, flush);\n\n         /*\n          * We can ignore Z_BUF_ERROR because:\n          * When we call libz_func we can assume that\n          *\n          * - avail_in is zero (due to the surrounding code that calls\n          *   flush_libz_buffer)\n          * - avail_out is non zero due to our actions some lines above\n          *\n          * So the only reason for Z_BUF_ERROR is that the internal libz\n          * buffers are now empty and thus we called libz_func one time\n          * too often. This does not hurt. It simply says that we are done.\n          */\n         if (zRC == Z_BUF_ERROR) {\n             zRC = Z_OK;\n             break;\n         }\n\n         done = (ctx->stream.avail_out != 0 || zRC == Z_STREAM_END);\n\n         if (zRC != Z_OK && zRC != Z_STREAM_END)\n             break;\n    }\n    return zRC;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_2da990377bcbbe5b3291e80adf4f82f47d48bd48_0", {
    "ID": "httpd_2da990377bcbbe5b3291e80adf4f82f47d48bd48_0",
    "UID": "5550",
    "code": "AP_DECLARE(ap_condition_e) ap_condition_if_unmodified_since(request_rec test_snippet\n        apr_table_t *headers)\n{\n    const char *if_unmodified;\n\n    if_unmodified = apr_table_get(r->headers_in, \"If-Unmodified-Since\");\n    if (if_unmodified) {\n        apr_int64_t mtime, reqtime;\n\n        apr_time_t ius = apr_time_sec(apr_date_parse_http(if_unmodified));\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        if ((ius != APR_DATE_BAD) && (mtime > ius)) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    \n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_eb46528c5fc1ac32a316c3d5ed0d531b83da208c_0", {
    "ID": "httpd_eb46528c5fc1ac32a316c3d5ed0d531b83da208c_0",
    "UID": "5553",
    "code": "apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    conn_rec *c = f->c;\n    core_net_rec *net = f->ctx;\n    core_output_filter_ctx_t *ctx = net->out_ctx;\n    apr_bucket_brigade *bb = NULL;\n    apr_bucket *bucket, *next, *flush_upto = NULL;\n    apr_size_t bytes_in_brigade, non_file_bytes_in_brigade;\n    int eor_buckets_in_brigade, morphing_bucket_in_brigade;\n    apr_status_t rv;\n    int loglevel = ap_get_conn_module_loglevel(c, APLOG_MODULE_INDEX);\n\n    \n    if (c->aborted) {\n        if (new_bb != NULL) {\n            apr_brigade_cleanup(new_bb);\n        }\n        return APR_ECONNABORTED;\n    }\n\n    if (ctx == NULL) {\n        ctx = apr_pcalloc(c->pool, sizeof(*ctx));\n        net->out_ctx = (core_output_filter_ctx_t *)ctx;\n        /*\n         * Need to create tmp brigade with correct lifetime. Passing\n         * NULL to apr_brigade_split_ex would result in a brigade\n         * allocated from bb->pool which might be wrong.\n         */\n        ctx->tmp_flush_bb = apr_brigade_create(c->pool, c->bucket_alloc);\n        \n        ctx->buffered_bb = apr_brigade_create(c->pool, c->bucket_alloc);\n    }\n\n    if (new_bb != NULL)\n        bb = new_bb;\n\n    if ((ctx->buffered_bb != NULL) &&\n        !APR_BRIGADE_EMPTY(ctx->buffered_bb)) {\n        if (new_bb != NULL) {\n            APR_BRIGADE_PREPEND(bb, ctx->buffered_bb);\n        }\n        else {\n            bb = ctx->buffered_bb;\n        }\n        c->data_in_output_filters = 0;\n    }\n    else if (new_bb == NULL) {\n        return APR_SUCCESS;\n    }\n\n    /* Scan through the brigade and decide whether to attempt a write,\n     * and how much to write, based on the following rules:\n     *\n     *  1) The new_bb is null: Do a nonblocking write of as much as\n     *     possible: do a nonblocking write of as much data as possible,\n     *     then save the rest in ctx->buffered_bb.  (If new_bb == NULL,\n     *     it probably means that the MPM is doing asynchronous write\n     *     completion and has just determined that this connection\n     *     is writable.)\n     *\n     *  2) Determine if and up to which bucket we need to do a blocking\n     *     write:\n     *\n     *  a) The brigade contains a flush bucket: Do a blocking write\n     *     of everything up that point.\n     *\n     *  b) The request is in CONN_STATE_HANDLER state, and the brigade\n     *     contains at least THRESHOLD_MAX_BUFFER bytes in non-file\n     *     buckets: Do blocking writes until the amount of data in the\n     *     buffer is less than THRESHOLD_MAX_BUFFER.  (The point of this\n     *     rule is to provide flow control, in case a handler is\n     *     streaming out lots of data faster than the data can be\n     *     sent to the client.)\n     *\n     *  c) The request is in CONN_STATE_HANDLER state, and the brigade\n     *     contains at least MAX_REQUESTS_IN_PIPELINE EOR buckets:\n     *     Do blocking writes until less than MAX_REQUESTS_IN_PIPELINE EOR\n     *     buckets are left. (The point of this rule is to prevent too many\n     *     FDs being kept open by pipelined requests, possibly allowing a\n     *     DoS).\n     *\n     *  d) The brigade contains a morphing bucket: If there was no other\n     *     reason to do a blocking write yet, try reading the bucket. If its\n     *     contents fit into memory before THRESHOLD_MAX_BUFFER is reached,\n     *     everything is fine. Otherwise we need to do a blocking write the\n     *     up to and including the morphing bucket, because ap_save_brigade()\n     *     would read the whole bucket into memory later on.\n     *\n     *  3) Actually do the blocking write up to the last bucket determined\n     *     by rules 2a-d. The point of doing only one flush is to make as\n     *     few calls to writev() as possible.\n     *\n     *  4) If the brigade contains at least THRESHOLD_MIN_WRITE\n     *     bytes: Do a nonblocking write of as much data as possible,\n     *     then save the rest in ctx->buffered_bb.\n     */\n\n    if (new_bb == NULL) {\n        rv = send_brigade_nonblocking(net->client_socket, bb,\n                                      &(ctx->bytes_written), c);\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            rv = APR_SUCCESS;\n        }\n        else if (rv != APR_SUCCESS) {\n            \n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, rv, c,\n                          \"core_output_filter: writing data to the network\");\n            c->aborted = 1;\n        }\n        setaside_remaining_output(f, ctx, bb, c);\n        return rv;\n    }\n\n    bytes_in_brigade = 0;\n    non_file_bytes_in_brigade = 0;\n    eor_buckets_in_brigade = 0;\n    morphing_bucket_in_brigade = 0;\n\n    for (bucket = APR_BRIGADE_FIRST(bb); bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        next = APR_BUCKET_NEXT(bucket);\n\n        if (!APR_BUCKET_IS_METADATA(bucket)) {\n            if (bucket->length == (apr_size_t)-1) {\n                /*\n                 * A setaside of morphing buckets would read everything into\n                 * memory. Instead, we will flush everything up to and\n                 * including this bucket.\n                 */\n                morphing_bucket_in_brigade = 1;\n            }\n            else {\n                bytes_in_brigade += bucket->length;\n                if (!APR_BUCKET_IS_FILE(bucket))\n                    non_file_bytes_in_brigade += bucket->length;\n            }\n        }\n        else if (AP_BUCKET_IS_EOR(bucket)) {\n            eor_buckets_in_brigade++;\n        }\n\n        if (APR_BUCKET_IS_FLUSH(bucket)\n            || non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER\n            || morphing_bucket_in_brigade\n            || eor_buckets_in_brigade > MAX_REQUESTS_IN_PIPELINE) {\n            \n\n            if (loglevel >= APLOG_TRACE6) {\n                char *reason = APR_BUCKET_IS_FLUSH(bucket) ?\n                               \"FLUSH bucket\" :\n                               (non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER) ?\n                               \"THRESHOLD_MAX_BUFFER\" :\n                               morphing_bucket_in_brigade ? \"morphing bucket\" :\n                               \"MAX_REQUESTS_IN_PIPELINE\";\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, c,\n                              \"will flush because of %s\", reason);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, c,\n                              \"seen in brigade%s: bytes: %\" APR_SIZE_T_FMT\n                              \", non-file bytes: %\" APR_SIZE_T_FMT \", eor \"\n                              \"buckets: %d, morphing buckets: %d\",\n                              flush_upto == NULL ? \" so far\"\n                                                 : \" since last flush point\",\n                              bytes_in_brigade,\n                              non_file_bytes_in_brigade,\n                              eor_buckets_in_brigade,\n                              morphing_bucket_in_brigade);\n            }\n            /*\n             * Defer the actual blocking write to avoid doing many writes.\n             */\n            flush_upto = next;\n\n            bytes_in_brigade = 0;\n            non_file_bytes_in_brigade = 0;\n            eor_buckets_in_brigade = 0;\n            morphing_bucket_in_brigade = 0;\n        }\n    }\n\n    if (flush_upto != NULL) {\n        ctx->tmp_flush_bb = apr_brigade_split_ex(bb, flush_upto,\n                                                 ctx->tmp_flush_bb);\n        if (loglevel >= APLOG_TRACE8) {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, c,\n                              \"flushing now\");\n        }\n        rv = send_brigade_blocking(net->client_socket, bb,\n                                   &(ctx->bytes_written), c);\n        if (rv != APR_SUCCESS) {\n            \n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, rv, c,\n                          \"core_output_filter: writing data to the network\");\n            c->aborted = 1;\n            return rv;\n        }\n        if (loglevel >= APLOG_TRACE8) {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, c,\n                              \"total bytes written: %\" APR_SIZE_T_FMT,\n                              ctx->bytes_written);\n        }\n        APR_BRIGADE_CONCAT(bb, ctx->tmp_flush_bb);\n    }\n\n    if (loglevel >= APLOG_TRACE8) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, c,\n                      \"brigade contains: bytes: %\" APR_SIZE_T_FMT\n                      \", non-file bytes: %\" APR_SIZE_T_FMT\n                      \", eor buckets: %d, morphing buckets: %d\",\n                      bytes_in_brigade, non_file_bytes_in_brigade,\n                      eor_buckets_in_brigade, morphing_bucket_in_brigade);\n    }\n\n    if (bytes_in_brigade >= THRESHOLD_MIN_WRITE) {\n        rv = send_brigade_nonblocking(net->client_socket, bb,\n                                      &(ctx->bytes_written), c);\n        if ((rv != APR_SUCCESS) && (!APR_STATUS_IS_EAGAIN(rv))) {\n            \n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, rv, c,\n                          \"core_output_filter: writing data to the network\");\n            c->aborted = 1;\n            return rv;\n        }\n        if (loglevel >= APLOG_TRACE8) {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE8, 0, c,\n                              \"tried nonblocking write, total bytes \"\n                              \"written: %\" APR_SIZE_T_FMT,\n                              ctx->bytes_written);\n        }\n    }\n\n    setaside_remaining_output(f, ctx, bb, c);\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_51608ca1ebac5cb66986069184f62db2661fb3bb_0", {
    "ID": "httpd_51608ca1ebac5cb66986069184f62db2661fb3bb_0",
    "UID": "5556",
    "code": "AP_DECLARE(ap_condition_e) ap_condition_if_none_match(request_rec test_snippet\n        apr_table_t *headers)\n{\n    const char *if_nonematch, *etag;\n\n    if_nonematch = apr_table_get(r->headers_in, \"If-None-Match\");\n    if (if_nonematch != NULL) {\n\n        if (if_nonematch[0] == '*') {\n            return AP_CONDITION_STRONG;\n        }\n\n        /* See section 13.3.3 for rules on how to determine if two entities tags\n         * match. The weak comparison function can only be used with GET or HEAD\n         * requests.\n         */\n        if (r->method_number == M_GET) {\n            if ((etag = apr_table_get(headers, \"ETag\")) != NULL) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    if (ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_STRONG;\n                    }\n                }\n                else {\n                    if (ap_find_etag_weak(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_WEAK;\n                    }\n                }\n            }\n        }\n\n        else if ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                && ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n            return AP_CONDITION_STRONG;\n        }\n        return AP_CONDITION_NOMATCH;\n    }\n\n    return AP_CONDITION_NONE;\n}",
    "predicted": "null"
  },
  "httpd_aafb52aa8261000d26cf3235c9fd5feec0e829ba_0", {
    "ID": "httpd_aafb52aa8261000d26cf3235c9fd5feec0e829ba_0",
    "UID": "5557",
    "code": "AP_CORE_DECLARE(int) ap_invoke_handler(request_rec test_snippet\n{\n    const char *handler;\n    const char *p;\n    int result;\n    const char *old_handler = r->handler;\n    const char *ignore;\n\n    /*\n     * The new insert_filter stage makes the most sense here.  We only use\n     * it when we are going to run the request, so we must insert filters\n     * if any are available.  Since the goal of this phase is to allow all\n     * modules to insert a filter if they want to, this filter returns\n     * void.  I just can't see any way that this filter can reasonably\n     * fail, either your modules inserts something or it doesn't.  rbb\n     */\n    ap_run_insert_filter(r);\n\n    /* Before continuing, allow each filter that is in the two chains to\n     * run their init function to let them do any magic before we could\n     * start generating data.\n     */\n    result = invoke_filter_init(r, r->input_filters);\n    if (result != OK) {\n        return result;\n    }\n    result = invoke_filter_init(r, r->output_filters);\n    if (result != OK) {\n        return result;\n    }\n\n    if (!r->handler) {\n        if (r->content_type) {\n            handler = r->content_type;\n            if ((p=ap_strchr_c(handler, ';')) != NULL) {\n                char *new_handler = (char *)apr_pmemdup(r->pool, handler,\n                                                        p - handler + 1);\n                char *p2 = new_handler + (p - handler);\n                handler = new_handler;\n\n                \n                while (p2 > handler && p2[-1] == ' ')\n                    --p2; \n\n                *p2='\\0';\n            }\n        }\n        else {\n            handler = AP_DEFAULT_HANDLER_NAME;\n        }\n\n        r->handler = handler;\n    }\n\n    result = ap_run_handler(r);\n\n    r->handler = old_handler;\n\n    if (result == DECLINED && r->handler && r->filename) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(00523)\n            \"handler \\\"%s\\\" not found for: %s\", r->handler, r->filename);\n    }\n    if ((result != OK) && (result != DONE) && (result != DECLINED) && (result != SUSPENDED)\n        && (result != AP_FILTER_ERROR) \n        && !ap_is_HTTP_VALID_RESPONSE(result)) {\n        /* If a module is deliberately returning something else\n         * (request_rec in non-HTTP or proprietary extension?)\n         * let it set a note to allow it explicitly.\n         * Otherwise, a return code that is neither reserved nor HTTP\n         * is a bug, as in PR#31759.\n         */\n        ignore = apr_table_get(r->notes, \"HTTP_IGNORE_RANGE\");\n        if (!ignore) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00524)\n                          \"Handler for %s returned invalid result code %d\",\n                          r->handler, result);\n            result = HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n\n    return result == DECLINED ? HTTP_INTERNAL_SERVER_ERROR : result;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n400,Uncontrolled Resource Consumption\n252,Unchecked Return Value\n"
  },
  "httpd_c5f3e09c6c75200e3a9fab6126c755eb7675a030_0", {
    "ID": "httpd_c5f3e09c6c75200e3a9fab6126c755eb7675a030_0",
    "UID": "5563",
    "code": "AP_DECLARE(ap_condition_e) ap_condition_if_modified_since(request_rec test_snippet\n        apr_table_t *headers)\n{\n    const char *if_modified_since;\n\n    if ((if_modified_since = apr_table_get(r->headers_in, \"If-Modified-Since\"))\n            != NULL) {\n        apr_int64_t mtime;\n        apr_int64_t ims, reqtime;\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        ims = apr_time_sec(apr_date_parse_http(if_modified_since));\n\n        if (ims >= mtime && ims <= reqtime) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    \n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_424ef4418499c5577f1fba8f8e9170a260f3fb29_0", {
    "ID": "httpd_424ef4418499c5577f1fba8f8e9170a260f3fb29_0",
    "UID": "5574",
    "code": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec test_snippet\n        apr_table_t *headers)\n{\n    const char *if_range, *etag;\n\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))\n            && apr_table_get(r->headers_in, \"Range\")) {\n        if (if_range[0] == '\"') {\n\n            if ((etag = apr_table_get(headers, \"ETag\"))\n                    && !strcmp(if_range, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n\n        }\n        else {\n            apr_int64_t mtime;\n            apr_int64_t rtime, reqtime;\n\n            /* All of our comparisons must be in seconds, because that's the\n             * highest time resolution the HTTP specification allows.\n             */\n\n            mtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Last-Modified\")));\n            if (mtime == APR_DATE_BAD) {\n                mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n            }\n\n            reqtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Date\")));\n            if (!reqtime) {\n                reqtime = apr_time_sec(r->request_time);\n            }\n\n            rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n            if (rtime == mtime) {\n                if (reqtime < mtime + 60) {\n                    \n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_STRONG;\n                }\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
    "predicted": "This code does not appear to have any obvious vulnerabilities, so the response would be null."
  },
  "httpd_1b9fc76f287da1859bb6b36f3739105ae58359ee_0", {
    "ID": "httpd_1b9fc76f287da1859bb6b36f3739105ae58359ee_0",
    "UID": "5610",
    "code": "static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf test_snippet\n                             request_rec *r, apr_uint16_t request_id)\n{\n    apr_bucket_brigade *ib, *ob;\n    int seen_end_of_headers = 0, done = 0;\n    apr_status_t rv = APR_SUCCESS;\n    int script_error_status = HTTP_OK;\n    conn_rec *c = r->connection;\n    struct iovec vec[2];\n    fcgi_header header;\n    unsigned char farray[FCGI_HEADER_LEN];\n    apr_pollfd_t pfd;\n    int header_state = HDR_STATE_READING_HEADERS;\n    apr_pool_t *setaside_pool;\n\n    apr_pool_create(&setaside_pool, r->pool);\n\n    pfd.desc_type = APR_POLL_SOCKET;\n    pfd.desc.s = conn->sock;\n    pfd.p = r->pool;\n    pfd.reqevents = APR_POLLIN | APR_POLLOUT;\n\n    ib = apr_brigade_create(r->pool, c->bucket_alloc);\n    ob = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    while (! done) {\n        apr_interval_time_t timeout = conn->worker->s->timeout;\n        apr_size_t len;\n        int n;\n\n        /* We need SOME kind of timeout here, or virtually anything will\n         * cause timeout errors. */\n        if (! conn->worker->s->timeout_set) {\n            timeout = apr_time_from_sec(30);\n        }\n\n        rv = apr_poll(&pfd, 1, &n, timeout);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            break;\n        }\n\n        if (pfd.rtnevents & APR_POLLOUT) {\n            char writebuf[AP_IOBUFSIZE];\n            apr_size_t writebuflen;\n            int last_stdin = 0;\n            int nvec = 0;\n\n            rv = ap_get_brigade(r->input_filters, ib,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                sizeof(writebuf));\n            if (rv != APR_SUCCESS) {\n                break;\n            }\n\n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(ib))) {\n                last_stdin = 1;\n            }\n\n            writebuflen = sizeof(writebuf);\n\n            rv = apr_brigade_flatten(ib, writebuf, &writebuflen);\n\n            apr_brigade_cleanup(ib);\n\n            if (rv != APR_SUCCESS) {\n                break;\n            }\n\n            fill_in_header(&header, FCGI_STDIN, request_id,\n                           (apr_uint16_t) writebuflen, 0);\n            fcgi_header_to_array(&header, farray);\n\n            vec[nvec].iov_base = (void *)farray;\n            vec[nvec].iov_len = sizeof(farray);\n            ++nvec;\n            if (writebuflen) {\n                vec[nvec].iov_base = writebuf;\n                vec[nvec].iov_len = writebuflen;\n                ++nvec;\n            }\n\n            rv = send_data(conn, vec, nvec, &len, 0);\n            if (rv != APR_SUCCESS) {\n                break;\n            }\n\n            if (last_stdin) {\n                pfd.reqevents = APR_POLLIN; \n\n                if (writebuflen) { \n                    fill_in_header(&header, FCGI_STDIN, request_id, 0, 0);\n                    fcgi_header_to_array(&header, farray);\n\n                    vec[0].iov_base = (void *)farray;\n                    vec[0].iov_len = sizeof(farray);\n\n                    rv = send_data(conn, vec, 1, &len, 1);\n                }\n            }\n        }\n\n        if (pfd.rtnevents & APR_POLLIN) {\n            /* readbuf has one byte on the end that is always 0, so it's\n             * able to work with a strstr when we search for the end of\n             * the headers, even if we fill the entire length in the recv. */\n            char readbuf[AP_IOBUFSIZE + 1];\n            apr_size_t readbuflen;\n            apr_size_t clen;\n            int rid, type;\n            apr_bucket *b;\n            char plen;\n\n            memset(readbuf, 0, sizeof(readbuf));\n            memset(farray, 0, sizeof(farray));\n\n            \n            readbuflen = FCGI_HEADER_LEN;\n\n            rv = get_data(conn, (char *) farray, &readbuflen);\n            if (rv != APR_SUCCESS) {\n                break;\n            }\n\n            dump_header_to_log(r, farray, readbuflen);\n\n            if (readbuflen != FCGI_HEADER_LEN) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01067)\n                              \"Failed to read entire header \"\n                              \"got %\" APR_SIZE_T_FMT \" wanted %d\",\n                              readbuflen, FCGI_HEADER_LEN);\n                rv = APR_EINVAL;\n                break;\n            }\n\n            fcgi_header_from_array(&header, farray);\n\n            if (header.version != FCGI_VERSION) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01068)\n                              \"Got bogus version %d\", (int) header.version);\n                rv = APR_EINVAL;\n                break;\n            }\n\n            type = header.type;\n\n            rid = header.requestIdB1 << 8;\n            rid |= header.requestIdB0;\n\n            if (rid != request_id) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01069)\n                              \"Got bogus rid %d, expected %d\",\n                              rid, request_id);\n                rv = APR_EINVAL;\n                break;\n            }\n\n            clen = header.contentLengthB1 << 8;\n            clen |= header.contentLengthB0;\n\n            plen = header.paddingLength;\n\nrecv_again:\n            if (clen > sizeof(readbuf) - 1) {\n                readbuflen = sizeof(readbuf) - 1;\n            } else {\n                readbuflen = clen;\n            }\n\n            /* Now get the actual data.  Yes it sucks to do this in a second\n             * recv call, this will eventually change when we move to real\n             * nonblocking recv calls. */\n            if (readbuflen != 0) {\n                rv = get_data(conn, readbuf, &readbuflen);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n                readbuf[readbuflen] = 0;\n            }\n\n            switch (type) {\n            case FCGI_STDOUT:\n                if (clen != 0) {\n                    b = apr_bucket_transient_create(readbuf,\n                                                    readbuflen,\n                                                    c->bucket_alloc);\n\n                    APR_BRIGADE_INSERT_TAIL(ob, b);\n\n                    if (! seen_end_of_headers) {\n                        int st = handle_headers(r, &header_state, readbuf);\n\n                        if (st == 1) {\n                            int status;\n                            seen_end_of_headers = 1;\n\n                            status = ap_scan_script_header_err_brigade_ex(r, ob,\n                                NULL, APLOG_MODULE_INDEX);\n                            \n                            if (status != OK) {\n                                apr_bucket *tmp_b;\n                                apr_brigade_cleanup(ob);\n                                tmp_b = apr_bucket_eos_create(c->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(ob, tmp_b);\n                                r->status = status;\n                                ap_pass_brigade(r->output_filters, ob);\n                                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01070)\n                                              \"Error parsing script headers\");\n                                rv = APR_EINVAL;\n                                break;\n                            }\n\n                            if (conf->error_override &&\n                                ap_is_HTTP_ERROR(r->status)) {\n                                /*\n                                 * set script_error_status to discard\n                                 * everything after the headers\n                                 */\n                                script_error_status = r->status;\n                                /*\n                                 * prevent ap_die() from treating this as a\n                                 * recursive error, initially:\n                                 */\n                                r->status = HTTP_OK;\n                            }\n\n                            if (script_error_status == HTTP_OK) {\n                                rv = ap_pass_brigade(r->output_filters, ob);\n                                if (rv != APR_SUCCESS) {\n                                    break;\n                                }\n                            }\n                            apr_brigade_cleanup(ob);\n\n                            apr_pool_clear(setaside_pool);\n                        }\n                        else {\n                            /* We're still looking for the end of the\n                             * headers, so this part of the data will need\n                             * to persist. */\n                            apr_bucket_setaside(b, setaside_pool);\n                        }\n                    } else {\n                        /* we've already passed along the headers, so now pass\n                         * through the content.  we could simply continue to\n                         * setaside the content and not pass until we see the\n                         * 0 content-length (below, where we append the EOS),\n                         * but that could be a huge amount of data; so we pass\n                         * along smaller chunks\n                         */\n                        if (script_error_status == HTTP_OK) {\n                            rv = ap_pass_brigade(r->output_filters, ob);\n                            if (rv != APR_SUCCESS) {\n                                break;\n                            }\n                        }\n                        apr_brigade_cleanup(ob);\n                    }\n\n                    /* If we didn't read all the data go back and get the\n                     * rest of it. */\n                    if (clen > readbuflen) {\n                        clen -= readbuflen;\n                        goto recv_again;\n                    }\n                } else {\n                    \n\n                    if (script_error_status == HTTP_OK) {\n                        b = apr_bucket_eos_create(c->bucket_alloc);\n                        APR_BRIGADE_INSERT_TAIL(ob, b);\n                        rv = ap_pass_brigade(r->output_filters, ob);\n                        if (rv != APR_SUCCESS) {\n                            break;\n                        }\n                    }\n\n                    \n                }\n                break;\n\n            case FCGI_STDERR:\n                \n                if (clen) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01071)\n                                  \"Got error '%s'\", readbuf);\n                }\n\n                if (clen > readbuflen) {\n                    clen -= readbuflen;\n                    goto recv_again;\n                }\n                break;\n\n            case FCGI_END_REQUEST:\n                done = 1;\n                break;\n\n            default:\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01072)\n                              \"Got bogus record %d\", type);\n                break;\n            }\n\n            if (plen) {\n                readbuflen = plen;\n\n                rv = get_data(conn, readbuf, &readbuflen);\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n            }\n        }\n    }\n\n    apr_brigade_destroy(ib);\n    apr_brigade_destroy(ob);\n\n    if (script_error_status != HTTP_OK) {\n        ap_die(script_error_status, r); \n    }\n\n    return rv;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_56a2e51422d22a6f59066989ef0e9e2bf8000250_0", {
    "ID": "httpd_56a2e51422d22a6f59066989ef0e9e2bf8000250_0",
    "UID": "5625",
    "code": "static apr_status_t deflate_in_filter(ap_filter_t test_snippet\n                                      apr_bucket_brigade *bb,\n                                      ap_input_mode_t mode,\n                                      apr_read_type_e block,\n                                      apr_off_t readbytes)\n{\n    apr_bucket *bkt;\n    request_rec *r = f->r;\n    deflate_ctx *ctx = f->ctx;\n    int zRC;\n    apr_status_t rv;\n    deflate_filter_config *c;\n\n    \n    if (mode != AP_MODE_READBYTES) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    c = ap_get_module_config(r->server->module_config, &deflate_module);\n\n    if (!ctx) {\n        char deflate_hdr[10];\n        apr_size_t len;\n\n        \n        if (!ap_is_initial_req(r)) {\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        \n        if (apr_table_get(r->headers_in, \"Content-Range\") != NULL) {\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        /* Check whether request body is gzipped.\n         *\n         * If it is, we're transforming the contents, invalidating\n         * some request headers including Content-Encoding.\n         *\n         * If not, we just remove ourself.\n         */\n        if (check_gzip(r, r->headers_in, NULL) == 0) {\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n        ctx->proc_bb = apr_brigade_create(r->pool, f->c->bucket_alloc);\n        ctx->buffer = apr_palloc(r->pool, c->bufferSize);\n\n        rv = ap_get_brigade(f->next, ctx->bb, AP_MODE_READBYTES, block, 10);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        \n        bkt = APR_BRIGADE_FIRST(ctx->bb);\n        if (APR_BUCKET_IS_EOS(bkt)) {\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        apr_table_unset(r->headers_in, \"Content-Length\");\n        apr_table_unset(r->headers_in, \"Content-MD5\");\n\n        len = 10;\n        rv = apr_brigade_flatten(ctx->bb, deflate_hdr, &len);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        \n        if (len != 10 ||\n            deflate_hdr[0] != deflate_magic[0] ||\n            deflate_hdr[1] != deflate_magic[1]) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01387) \"Zlib: Invalid header\");\n            return APR_EGENERAL;\n        }\n\n        \n        if (deflate_hdr[3] != 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01388)\n                          \"Zlib: Unsupported flags %02x\", (int)deflate_hdr[3]);\n            return APR_EGENERAL;\n        }\n\n        zRC = inflateInit2(&ctx->stream, c->windowSize);\n\n        if (zRC != Z_OK) {\n            f->ctx = NULL;\n            inflateEnd(&ctx->stream);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01389)\n                          \"unable to init Zlib: \"\n                          \"inflateInit2 returned %d: URL %s\",\n                          zRC, r->uri);\n            ap_remove_input_filter(f);\n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n\n        \n        ctx->stream.next_out = ctx->buffer;\n        ctx->stream.avail_out = c->bufferSize;\n\n        apr_brigade_cleanup(ctx->bb);\n    }\n\n    if (APR_BRIGADE_EMPTY(ctx->proc_bb)) {\n        rv = ap_get_brigade(f->next, ctx->bb, mode, block, readbytes);\n\n        if (rv != APR_SUCCESS) {\n            \n            inflateEnd(&ctx->stream);\n            return rv;\n        }\n\n        for (bkt = APR_BRIGADE_FIRST(ctx->bb);\n             bkt != APR_BRIGADE_SENTINEL(ctx->bb);\n             bkt = APR_BUCKET_NEXT(bkt))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bkt)) {\n                if (!ctx->done) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02481)\n                                  \"Encountered premature end-of-stream while inflating\");\n                    return APR_EGENERAL;\n                }\n\n                \n                APR_BUCKET_REMOVE(bkt);\n                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, bkt);\n                ap_remove_input_filter(f);\n                break;\n            }\n\n            if (APR_BUCKET_IS_FLUSH(bkt)) {\n                apr_bucket *tmp_heap;\n                zRC = inflate(&(ctx->stream), Z_SYNC_FLUSH);\n                if (zRC != Z_OK) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01391)\n                                  \"Zlib error %d inflating data (%s)\", zRC,\n                                  ctx->stream.msg);\n                    return APR_EGENERAL;\n                }\n\n                ctx->stream.next_out = ctx->buffer;\n                len = c->bufferSize - ctx->stream.avail_out;\n\n                ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n                tmp_heap = apr_bucket_heap_create((char *)ctx->buffer, len,\n                                                 NULL, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, tmp_heap);\n                ctx->stream.avail_out = c->bufferSize;\n\n                \n                APR_BUCKET_REMOVE(bkt);\n                APR_BRIGADE_CONCAT(bb, ctx->bb);\n                break;\n            }\n\n            \n            if (ctx->done) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02482)\n                              \"Encountered extra data after compressed data\");\n                return APR_EGENERAL;\n            }\n\n            \n            apr_bucket_read(bkt, &data, &len, APR_BLOCK_READ);\n\n            \n            ctx->stream.next_in = (unsigned char *)data;\n            ctx->stream.avail_in = len;\n\n            zRC = Z_OK;\n\n            while (ctx->stream.avail_in != 0) {\n                if (ctx->stream.avail_out == 0) {\n                    apr_bucket *tmp_heap;\n                    ctx->stream.next_out = ctx->buffer;\n                    len = c->bufferSize - ctx->stream.avail_out;\n\n                    ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n                    tmp_heap = apr_bucket_heap_create((char *)ctx->buffer, len,\n                                                      NULL, f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, tmp_heap);\n                    ctx->stream.avail_out = c->bufferSize;\n                }\n\n                zRC = inflate(&ctx->stream, Z_NO_FLUSH);\n\n                if (zRC == Z_STREAM_END) {\n                    break;\n                }\n\n                if (zRC != Z_OK) {\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01392)\n                                  \"Zlib error %d inflating data (%s)\", zRC,\n                                  ctx->stream.msg);\n                    return APR_EGENERAL;\n                }\n            }\n            if (zRC == Z_STREAM_END) {\n                apr_bucket *tmp_heap;\n                apr_size_t avail;\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01393)\n                              \"Zlib: Inflated %ld to %ld : URL %s\",\n                              ctx->stream.total_in, ctx->stream.total_out,\n                              r->uri);\n\n                len = c->bufferSize - ctx->stream.avail_out;\n\n                ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n                tmp_heap = apr_bucket_heap_create((char *)ctx->buffer, len,\n                                                  NULL, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, tmp_heap);\n                ctx->stream.avail_out = c->bufferSize;\n\n                avail = ctx->stream.avail_in;\n\n                \n                if (avail >= 8) {\n                    unsigned long compCRC, compLen;\n                    compCRC = getLong(ctx->stream.next_in);\n                    if (ctx->crc != compCRC) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01394)\n                                      \"Zlib: CRC error inflating data\");\n                        return APR_EGENERAL;\n                    }\n                    ctx->stream.next_in += 4;\n                    compLen = getLong(ctx->stream.next_in);\n                    if (ctx->stream.total_out != compLen) {\n                        inflateEnd(&ctx->stream);\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01395)\n                                      \"Zlib: Length %ld of inflated data does \"\n                                      \"not match expected value %ld\",\n                                      ctx->stream.total_out, compLen);\n                        return APR_EGENERAL;\n                    }\n                }\n                else {\n                    /* FIXME: We need to grab the 8 verification bytes\n                     * from the wire! */\n                    inflateEnd(&ctx->stream);\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01396)\n                                  \"Verification data not available (bug?)\");\n                    return APR_EGENERAL;\n                }\n\n                inflateEnd(&ctx->stream);\n\n                ctx->done = 1;\n\n                \n                if (avail > 8) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02485)\n                                  \"Encountered extra data after compressed data\");\n                    return APR_EGENERAL;\n                }\n            }\n\n        }\n        apr_brigade_cleanup(ctx->bb);\n    }\n\n    /* If we are about to return nothing for a 'blocking' read and we have\n     * some data in our zlib buffer, flush it out so we can return something.\n     */\n    if (block == APR_BLOCK_READ &&\n        APR_BRIGADE_EMPTY(ctx->proc_bb) &&\n        ctx->stream.avail_out < c->bufferSize) {\n        apr_bucket *tmp_heap;\n        apr_size_t len;\n        ctx->stream.next_out = ctx->buffer;\n        len = c->bufferSize - ctx->stream.avail_out;\n\n        ctx->crc = crc32(ctx->crc, (const Bytef *)ctx->buffer, len);\n        tmp_heap = apr_bucket_heap_create((char *)ctx->buffer, len,\n                                          NULL, f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, tmp_heap);\n        ctx->stream.avail_out = c->bufferSize;\n    }\n\n    if (!APR_BRIGADE_EMPTY(ctx->proc_bb)) {\n        if (apr_brigade_partition(ctx->proc_bb, readbytes, &bkt) == APR_INCOMPLETE) {\n            APR_BRIGADE_CONCAT(bb, ctx->proc_bb);\n        }\n        else {\n            APR_BRIGADE_CONCAT(bb, ctx->proc_bb);\n            apr_brigade_split_ex(bb, bkt, ctx->proc_bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0a1de7b7bf3ebb74377e216af7bb9ea8e732f1cb_0", {
    "ID": "httpd_0a1de7b7bf3ebb74377e216af7bb9ea8e732f1cb_0",
    "UID": "5634",
    "code": "PROXY_DECLARE(proxy_balancer *) ap_proxy_get_balancer(apr_pool_t test_snippet\n                                                      proxy_server_conf *conf,\n                                                      const char *url,\n                                                      int care)\n{\n    proxy_balancer *balancer;\n    char *c, *uri = apr_pstrdup(p, url);\n    int i;\n    proxy_hashes hash;\n\n    c = strchr(uri, ':');\n    if (c == NULL || c[1] != '/' || c[2] != '/' || c[3] == '\\0') {\n        return NULL;\n    }\n    \n    if ((c = strchr(c + 3, '/'))) {\n        *c = '\\0';\n    }\n    ap_str_tolower(uri);\n    hash.def = ap_proxy_hashfunc(uri, PROXY_HASHFUNC_DEFAULT);\n    hash.fnv = ap_proxy_hashfunc(uri, PROXY_HASHFUNC_FNV);\n    balancer = (proxy_balancer *)conf->balancers->elts;\n    for (i = 0; i < conf->balancers->nelts; i++) {\n        if (balancer->hash.def == hash.def && balancer->hash.fnv == hash.fnv) {\n            if (!care || !balancer->s->inactive) {\n                return balancer;\n            }\n        }\n        balancer++;\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_130c4edd16d96286ed31d140b718a85f548ce813_0", {
    "ID": "httpd_130c4edd16d96286ed31d140b718a85f548ce813_0",
    "UID": "5659",
    "code": "static int cache_table_getm_do(void *v, const char *key, const char test_snippet\n{\n    cache_table_getm_t *state = (cache_table_getm_t *) v;\n\n    if (!state->first) {\n        /**\n         * The most common case is a single header, and this is covered by\n         * a fast path that doesn't allocate any memory. On the second and\n         * subsequent header, an array is created and the array concatenated\n         * together to form the final value.\n         */\n        state->first = val;\n    }\n    else {\n        const char **elt;\n        if (!state->merged) {\n            state->merged = apr_array_make(state->p, 10, sizeof(const char *));\n            elt = apr_array_push(state->merged);\n            *elt = state->first;\n        }\n        elt = apr_array_push(state->merged);\n        *elt = val;\n    }\n    return 1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_b42f4dcf76feef565889a0e0faa088f4f08e2602_0", {
    "ID": "httpd_b42f4dcf76feef565889a0e0faa088f4f08e2602_0",
    "UID": "5673",
    "code": "static apr_status_t event_unregister_socket_callback(apr_socket_t **s, apr_pool_t test_snippet\n{\n    int i = 0, nsock;\n    apr_status_t final_rc = APR_SUCCESS;\n    apr_pollfd_t *pfd = apr_palloc(p, sizeof(*pfd));\n    apr_pollfd_t **pfds = NULL;\n\n    while(s[i] != NULL) { \n        i++; \n    }\n    nsock = i;\n \n    pfds = apr_palloc(p, nsock * sizeof(apr_pollfd_t*));\n\n    for (i = 0; i<nsock; i++) { \n        apr_status_t rc;\n        pfds[i] = apr_pcalloc(p, sizeof(apr_pollfd_t));\n        pfds[i]->desc_type = APR_POLL_SOCKET;\n        pfds[i]->reqevents = APR_POLLERR | APR_POLLHUP;\n        pfds[i]->desc.s = s[i];\n        pfds[i]->client_data = NULL;\n        rc = apr_pollset_remove(event_pollset, pfds[i]);\n        if (rc != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rc)) final_rc = APR_SUCCESS;\n    }\n    return final_rc;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a9149a7a0afeecd7233fba361047f67a2228598d_0", {
    "ID": "httpd_a9149a7a0afeecd7233fba361047f67a2228598d_0",
    "UID": "5683",
    "code": "static int proxy_http_handler(request_rec *r, proxy_worker test_snippet\n                              proxy_server_conf *conf,\n                              char *url, const char *proxyname,\n                              apr_port_t proxyport)\n{\n    int status;\n    char server_portstr[32];\n    char *scheme;\n    const char *proxy_function;\n    const char *u;\n    proxy_conn_rec *backend = NULL;\n    int is_ssl = 0;\n    conn_rec *c = r->connection;\n    int retry = 0;\n    /*\n     * Use a shorter-lived pool to reduce memory usage\n     * and avoid a memory leak\n     */\n    apr_pool_t *p = r->pool;\n    apr_uri_t *uri = apr_palloc(p, sizeof(*uri));\n\n    \n    u = strchr(url, ':');\n    if (u == NULL || u[1] != '/' || u[2] != '/' || u[3] == '\\0')\n       return DECLINED;\n    if ((u - url) > 14)\n        return HTTP_BAD_REQUEST;\n    scheme = apr_pstrmemdup(p, url, u - url);\n    \n    ap_str_tolower(scheme);\n    \n    if (strcmp(scheme, \"https\") == 0) {\n        if (!ap_proxy_ssl_enable(NULL)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01112)\n                          \"HTTPS: declining URL %s (mod_ssl not configured?)\",\n                          url);\n            return DECLINED;\n        }\n        is_ssl = 1;\n        proxy_function = \"HTTPS\";\n    }\n    else if (!(strcmp(scheme, \"http\") == 0 || (strcmp(scheme, \"ftp\") == 0 && proxyname))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01113) \"HTTP: declining URL %s\",\n                      url);\n        return DECLINED; \n    }\n    else {\n        if (*scheme == 'h')\n            proxy_function = \"HTTP\";\n        else\n            proxy_function = \"FTP\";\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"HTTP: serving URL %s\", url);\n\n\n    \n    if ((status = ap_proxy_acquire_connection(proxy_function, &backend,\n                                              worker, r->server)) != OK)\n        goto cleanup;\n\n\n    backend->is_ssl = is_ssl;\n\n    if (is_ssl) {\n        ap_proxy_ssl_connection_cleanup(backend, r);\n    }\n\n    /*\n     * In the case that we are handling a reverse proxy connection and this\n     * is not a request that is coming over an already kept alive connection\n     * with the client, do NOT reuse the connection to the backend, because\n     * we cannot forward a failure to the client in this case as the client\n     * does NOT expect this in this situation.\n     * Yes, this creates a performance penalty.\n     */\n    if ((r->proxyreq == PROXYREQ_REVERSE) && (!c->keepalives)\n        && (apr_table_get(r->subprocess_env, \"proxy-initial-not-pooled\"))) {\n        backend->close = 1;\n    }\n\n    while (retry < 2) {\n        char *locurl = url;\n\n        \n        if ((status = ap_proxy_determine_connection(p, r, conf, worker, backend,\n                                                uri, &locurl, proxyname,\n                                                proxyport, server_portstr,\n                                                sizeof(server_portstr))) != OK)\n            break;\n\n        \n        if (ap_proxy_connect_backend(proxy_function, backend, worker, r->server)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01114)\n                          \"HTTP: failed to make connection to backend: %s\",\n                          backend->hostname);\n            status = HTTP_SERVICE_UNAVAILABLE;\n            break;\n        }\n\n        \n        if (!backend->connection) {\n            if ((status = ap_proxy_connection_create(proxy_function, backend,\n                                                     c, r->server)) != OK)\n                break;\n            /*\n             * On SSL connections set a note on the connection what CN is\n             * requested, such that mod_ssl can check if it is requested to do\n             * so.\n             */\n            if (is_ssl) {\n                proxy_dir_conf *dconf;\n                const char *ssl_hostname;\n\n                /*\n                 * In the case of ProxyPreserveHost on use the hostname of\n                 * the request if present otherwise use the one from the\n                 * backend request URI.\n                 */\n                dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n                if ((dconf->preserve_host != 0) && (r->hostname != NULL)) {\n                    ssl_hostname = r->hostname;\n                }\n                else {\n                    ssl_hostname = uri->hostname;\n                }\n\n                apr_table_set(backend->connection->notes, \"proxy-request-hostname\",\n                              ssl_hostname);\n            }\n        }\n\n        \n        if (worker->s->ping_timeout_set && worker->s->ping_timeout < 0 &&\n            !ap_proxy_is_socket_connected(backend->sock)) {\n            backend->close = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO()\n                          \"socket check failed to %pI (%s)\",\n                          worker->cp->addr, worker->s->hostname);\n            retry++;\n            continue;\n        }\n\n        /* Step Four: Send the Request\n         * On the off-chance that we forced a 100-Continue as a\n         * kinda HTTP ping test, allow for retries\n         */\n        if ((status = ap_proxy_http_request(p, r, backend, worker,\n                                        conf, uri, locurl, server_portstr)) != OK) {\n            if ((status == HTTP_SERVICE_UNAVAILABLE) && worker->s->ping_timeout_set &&\n                 worker->s->ping_timeout > 0) {\n                backend->close = 1;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO(01115)\n                              \"HTTP: 100-Continue failed to %pI (%s)\",\n                              worker->cp->addr, worker->s->hostname);\n                retry++;\n                continue;\n            } else {\n                break;\n            }\n\n        }\n\n        \n        status = ap_proxy_http_process_response(p, r, &backend, worker,\n                                                conf, server_portstr);\n\n        break;\n    }\n\n    \ncleanup:\n    if (backend) {\n        if (status != OK)\n            backend->close = 1;\n        ap_proxy_http_cleanup(proxy_function, r, backend);\n    }\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_788014162991f99cddc258621b02082e60fa554f_0", {
    "ID": "httpd_788014162991f99cddc258621b02082e60fa554f_0",
    "UID": "5684",
    "code": "AP_DECLARE(void *) ap_skiplist_alloc(ap_skiplist *sl, size_t test_snippet\n{\n    if (sl->pool) {\n        void *ptr;\n        int found_size = 0;\n        int i;\n        chunk_t *newchunk;\n        memlist_t *memlist = (memlist_t *)sl->memlist->elts;\n        for (i = 0; i < sl->memlist->nelts; i++) {\n            if (memlist->size == test_snippet {\n                int j;\n                chunk_t *chunk = (chunk_t *)memlist->list->elts;\n                found_size = 1;\n                for (j = 0; j < memlist->list->nelts; j++) {\n                    if (!chunk->inuse) {\n                        chunk->inuse = 1;\n                        return chunk->ptr;\n                    }\n                    chunk++;\n                }\n                break; \n            }\n            memlist++;\n        }\n        \n        ptr = apr_pcalloc(sl->pool, test_snippet;\n        if (!ptr) {\n            return ptr;\n        }\n        /*\n         * is this a new sized chunk? If so, we need to create a new\n         * array of them. Otherwise, re-use what we already have.\n         */\n        if (!found_test_snippet {\n            memlist = apr_array_push(sl->memlist);\n            memlist->size = size;\n            memlist->list = apr_array_make(sl->pool, 20, sizeof(chunk_t));\n        }\n        newchunk = apr_array_push(memlist->list);\n        newchunk->ptr = ptr;\n        newchunk->inuse = 1;\n        return ptr;\n    }\n    else {\n        return ap_calloc(1, test_snippet;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_f0f273c333e50046834ce455eba64768a2ebc28c_0", {
    "ID": "httpd_f0f273c333e50046834ce455eba64768a2ebc28c_0",
    "UID": "5704",
    "code": "static void child_init(apr_pool_t *p, server_rec test_snippet\n{\n    proxy_worker *reverse = NULL;\n\n    apr_status_t rv = apr_global_mutex_child_init(&proxy_mutex,\n                                      apr_global_mutex_lockfile(proxy_mutex),\n                                      p);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(02479)\n                     \"could not init proxy_mutex in child\");\n        exit(1); \n    }\n\n    \n    while (s) {\n        void *sconf = s->module_config;\n        proxy_server_conf *conf;\n        proxy_worker *worker;\n        int i;\n\n        conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);\n        /*\n         * NOTE: non-balancer members don't use shm at all...\n         *       after all, why should they?\n         */\n        worker = (proxy_worker *)conf->workers->elts;\n        for (i = 0; i < conf->workers->nelts; i++, worker++) {\n            ap_proxy_initialize_worker(worker, s, conf->pool);\n        }\n        \n        if (conf->req_set && conf->req) {\n            proxy_worker *forward;\n            ap_proxy_define_worker(p, &forward, NULL, NULL, \"http://www.apache.org\", 0);\n            conf->forward = forward;\n            PROXY_STRNCPY(conf->forward->s->name,     \"proxy:forward\");\n            PROXY_STRNCPY(conf->forward->s->hostname, \"*\");\n            PROXY_STRNCPY(conf->forward->s->scheme,   \"*\");\n            conf->forward->hash.def = conf->forward->s->hash.def =\n                ap_proxy_hashfunc(conf->forward->s->name, PROXY_HASHFUNC_DEFAULT);\n             conf->forward->hash.fnv = conf->forward->s->hash.fnv =\n                ap_proxy_hashfunc(conf->forward->s->name, PROXY_HASHFUNC_FNV);\n            \n            conf->forward->s->status |= PROXY_WORKER_IGNORE_ERRORS;\n            ap_proxy_initialize_worker(conf->forward, s, conf->pool);\n            \n            conf->forward->s->is_address_reusable = 0;\n        }\n        if (!reverse) {\n            ap_proxy_define_worker(p, &reverse, NULL, NULL, \"http://www.apache.org\", 0);\n            PROXY_STRNCPY(reverse->s->name,     \"proxy:reverse\");\n            PROXY_STRNCPY(reverse->s->hostname, \"*\");\n            PROXY_STRNCPY(reverse->s->scheme,   \"*\");\n            reverse->hash.def = reverse->s->hash.def =\n                ap_proxy_hashfunc(reverse->s->name, PROXY_HASHFUNC_DEFAULT);\n            reverse->hash.fnv = reverse->s->hash.fnv =\n                ap_proxy_hashfunc(reverse->s->name, PROXY_HASHFUNC_FNV);\n            \n            reverse->s->status |= PROXY_WORKER_IGNORE_ERRORS;\n            conf->reverse = reverse;\n            ap_proxy_initialize_worker(conf->reverse, s, conf->pool);\n            \n            reverse->s->is_address_reusable = 0;\n        }\n        conf->reverse = reverse;\n        s = s->next;\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d8082c7f47a115d095831258fd0ea6cbe58f9dc9_0", {
    "ID": "httpd_d8082c7f47a115d095831258fd0ea6cbe58f9dc9_0",
    "UID": "5709",
    "code": "static dav_error *dav_get_resource(request_rec *r, int test_snippet\n                                   int use_checked_in, dav_resource **res_p)\n{\n    dav_dir_conf *conf;\n    const char *label = NULL;\n    dav_error *err;\n\n    \n    if (label_allowed) {\n        label = apr_table_get(r->headers_in, \"label\");\n    }\n\n    conf = ap_get_module_config(r->per_dir_config, &dav_module);\n    \n    if (conf->provider == NULL) {\n        return dav_new_error(r->pool, HTTP_METHOD_NOT_ALLOWED, 0, 0,\n                             apr_psprintf(r->pool,\n\t\t\t\t          \"DAV not enabled for %s\",\n\t\t\t\t\t  ap_escape_html(r->pool, r->uri)));\n    }\n\n    \n    err = (*conf->provider->repos->get_resource)(r, conf->dir,\n                                                 label, use_checked_in,\n                                                 res_p);\n    if (err != NULL) {\n        err = dav_push_error(r->pool, err->status, 0,\n                             \"Could not fetch resource information.\", err);\n        return err;\n    }\n\n    \n    if (*res_p == NULL) {\n        \n        return dav_new_error(r->pool, HTTP_NOT_FOUND, 0, 0,\n                             apr_psprintf(r->pool,\n                                          \"The provider did not define a \"\n                                          \"resource for %s.\",\n                                          ap_escape_html(r->pool, r->uri)));\n    }\n\n    \n    /* if there were any input headers requiring a Vary header in the response,\n     * add it now */\n    dav_add_vary_header(r, r, *res_p);\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_391d8ca840c04fa564355ebf1557c965e7cbee04_0", {
    "ID": "httpd_391d8ca840c04fa564355ebf1557c965e7cbee04_0",
    "UID": "5711",
    "code": "static dav_error * dav_validate_resource_state(apr_pool_t test_snippet\n                                               const dav_resource *resource,\n                                               dav_lockdb *lockdb,\n                                               const dav_if_header *if_header,\n                                               int flags,\n                                               dav_buffer *pbuf,\n                                               request_rec *r)\n{\n    dav_error *err;\n    const char *uri;\n    const char *etag;\n    const dav_hooks_locks *locks_hooks = (lockdb ? lockdb->hooks : NULL);\n    const dav_if_header *ifhdr_scan;\n    dav_if_state_list *state_list;\n    dav_lock *lock_list;\n    dav_lock *lock;\n    int num_matched;\n    int num_that_apply;\n    int seen_locktoken;\n    apr_size_t uri_len;\n    const char *reason = NULL;\n\n    \n\n    /*\n    ** The resource will have one of three states:\n    **\n    ** 1) No locks. We have no special requirements that the user supply\n    **    specific locktokens. One of the state lists must match, and\n    **    we're done.\n    **\n    ** 2) One exclusive lock. The locktoken must appear *anywhere* in the\n    **    If: header. Of course, asserting the token in a \"Not\" term will\n    **    quickly fail that state list :-). If the locktoken appears in\n    **    one of the state lists *and* one state list matches, then we're\n    **    done.\n    **\n    ** 3) One or more shared locks. One of the locktokens must appear\n    **    *anywhere* in the If: header. If one of the locktokens appears,\n    **    and we match one state list, then we are done.\n    **\n    ** The <seen_locktoken> variable determines whether we have seen one\n    ** of this resource's locktokens in the If: header.\n    */\n\n    /*\n    ** If this is a new lock request, <flags> will contain the requested\n    ** lock scope.  Three rules apply:\n    **\n    ** 1) Do not require a (shared) locktoken to be seen (when we are\n    **    applying another shared lock)\n    ** 2) If the scope is exclusive and we see any locks, fail.\n    ** 3) If the scope is shared and we see an exclusive lock, fail.\n    */\n\n    if (lockdb == NULL) {\n        \n        lock_list = NULL;\n    }\n    else {\n        /*\n        ** ### hrm... we don't need to have these fully\n        ** ### resolved since we're only looking at the\n        ** ### locktokens...\n        **\n        ** ### use get_locks w/ calltype=PARTIAL\n        */\n        if ((err = dav_lock_query(lockdb, resource, &lock_list)) != NULL) {\n            return dav_push_error(p,\n                                  HTTP_INTERNAL_SERVER_ERROR, 0,\n                                  \"The locks could not be queried for \"\n                                  \"verification against a possible \\\"If:\\\" \"\n                                  \"header.\",\n                                  err);\n        }\n\n        \n    }\n\n    /*\n    ** For a new, exclusive lock: if any locks exist, fail.\n    ** For a new, shared lock:    if an exclusive lock exists, fail.\n    **                            else, do not require a token to be seen.\n    */\n    if (flags & DAV_LOCKSCOPE_EXCLUSIVE) {\n        if (lock_list != NULL) {\n            return dav_new_error(p, HTTP_LOCKED, 0, 0,\n                                 \"Existing lock(s) on the requested resource \"\n                                 \"prevent an exclusive lock.\");\n        }\n\n        /*\n        ** There are no locks, so we can pretend that we've already met\n        ** any requirement to find the resource's locks in an If: header.\n        */\n        seen_locktoken = 1;\n    }\n    else if (flags & DAV_LOCKSCOPE_SHARED) {\n        /*\n        ** Strictly speaking, we don't need this loop. Either the first\n        ** (and only) lock will be EXCLUSIVE, or none of them will be.\n        */\n        for (lock = lock_list; lock != NULL; lock = lock->next) {\n            if (lock->scope == DAV_LOCKSCOPE_EXCLUSIVE) {\n                return dav_new_error(p, HTTP_LOCKED, 0, 0,\n                                     \"The requested resource is already \"\n                                     \"locked exclusively.\");\n            }\n        }\n\n        /*\n        ** The locks on the resource (if any) are all shared. Set the\n        ** <seen_locktoken> flag to indicate that we do not need to find\n        ** the locks in an If: header.\n        */\n        seen_locktoken = 1;\n    }\n    else {\n        /*\n        ** For methods other than LOCK:\n        **\n        ** If we have no locks, then <seen_locktoken> can be set to true --\n        ** pretending that we've already met the requirement of seeing one\n        ** of the resource's locks in the If: header.\n        **\n        ** Otherwise, it must be cleared and we'll look for one.\n        */\n        seen_locktoken = (lock_list == NULL);\n    }\n\n    /*\n    ** If there is no If: header, then we can shortcut some logic:\n    **\n    ** 1) if we do not need to find a locktoken in the (non-existent) If:\n    **    header, then we are successful.\n    **\n    ** 2) if we must find a locktoken in the (non-existent) If: header, then\n    **    we fail.\n    */\n    if (if_header == NULL) {\n        if (seen_locktoken)\n            return NULL;\n\n        return dav_new_error(p, HTTP_LOCKED, 0, 0,\n                             \"This resource is locked and an \\\"If:\\\" header \"\n                             \"was not supplied to allow access to the \"\n                             \"resource.\");\n    }\n    \n\n    /*\n    ** If a dummy header is present (because of a Lock-Token: header), then\n    ** we are required to find that token in this resource's set of locks.\n    ** If we have no locks, then we immediately fail.\n    **\n    ** This is a 400 (Bad Request) since they should only submit a locktoken\n    ** that actually exists.\n    **\n    ** Don't issue this response if we're talking about the parent resource.\n    ** It is okay for that resource to NOT have this locktoken.\n    ** (in fact, it certainly will not: a dummy_header only occurs for the\n    **  UNLOCK method, the parent is checked only for locknull resources,\n    **  and the parent certainly does not have the (locknull's) locktoken)\n    */\n    if (lock_list == NULL && if_header->dummy_header) {\n        if (flags & DAV_VALIDATE_IS_PARENT)\n            return NULL;\n        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                             \"The locktoken specified in the \\\"Lock-Token:\\\" \"\n                             \"header is invalid because this resource has no \"\n                             \"outstanding locks.\");\n    }\n\n    /*\n    ** Prepare the input URI. We want the URI to never have a trailing slash.\n    **\n    ** When URIs are placed into the dav_if_header structure, they are\n    ** guaranteed to never have a trailing slash. If the URIs are equivalent,\n    ** then it doesn't matter if they both lack a trailing slash -- they're\n    ** still equivalent.\n    **\n    ** Note: we could also ensure that a trailing slash is present on both\n    ** URIs, but the majority of URIs provided to us via a resource walk\n    ** will not contain that trailing slash.\n    */\n    uri = resource->uri;\n    uri_len = strlen(uri);\n    if (uri[uri_len - 1] == '/') {\n        dav_set_bufsize(p, pbuf, uri_len);\n        memcpy(pbuf->buf, uri, uri_len);\n        pbuf->buf[--uri_len] = '\\0';\n        uri = pbuf->buf;\n    }\n\n    \n    etag = (*resource->hooks->getetag)(resource);\n\n    \n    num_that_apply = 0;\n\n    /* If there are if-headers, fail if this resource\n     * does not match at least one state_list.\n     */\n    for (ifhdr_scan = if_header;\n         ifhdr_scan != NULL;\n         ifhdr_scan = ifhdr_scan->next) {\n\n        \n\n        if (ifhdr_scan->uri != NULL\n            && (uri_len != ifhdr_scan->uri_len\n                || memcmp(uri, ifhdr_scan->uri, uri_len) != 0)) {\n            /*\n            ** A tagged-list's URI doesn't match this resource's URI.\n            ** Skip to the next state_list to see if it will match.\n            */\n            continue;\n        }\n\n        \n\n        /*\n        ** ### only one state_list should ever apply! a no-tag, or a tagged\n        ** ### where S9.4.2 states only one can match.\n        **\n        ** ### revamp this code to loop thru ifhdr_scan until we find the\n        ** ### matching state_list. process it. stop.\n        */\n        ++num_that_apply;\n\n        /* To succeed, resource must match *all* of the states\n         * specified in the state_list.\n         */\n        for (state_list = ifhdr_scan->state;\n             state_list != NULL;\n             state_list = state_list->next) {\n\n            switch(state_list->type) {\n            case dav_if_etag:\n            {\n                const char *given_etag, *current_etag;\n                int mismatch;\n\n                /* Do a weak entity comparison function as defined in\n                 * RFC 2616 13.3.3.\n                 */\n                if (state_list->etag[0] == 'W' &&\n                    state_list->etag[1] == '/') {\n                    given_etag = state_list->etag + 2;\n                }\n                else {\n                    given_etag = state_list->etag;\n                }\n                if (etag[0] == 'W' &&\n                    etag[1] == '/') {\n                    current_etag = etag + 2;\n                }\n                else {\n                    current_etag = etag;\n                }\n\n                mismatch = strcmp(given_etag, current_etag);\n\n                if (state_list->condition == DAV_IF_COND_NORMAL && mismatch) {\n                    /*\n                    ** The specified entity-tag does not match the\n                    ** entity-tag on the resource. This state_list is\n                    ** not going to match. Bust outta here.\n                    */\n                    reason =\n                        \"an entity-tag was specified, but the resource's \"\n                        \"actual ETag does not match.\";\n                    goto state_list_failed;\n                }\n                else if (state_list->condition == DAV_IF_COND_NOT\n                         && !mismatch) {\n                    /*\n                    ** The specified entity-tag DOES match the\n                    ** entity-tag on the resource. This state_list is\n                    ** not going to match. Bust outta here.\n                    */\n                    reason =\n                        \"an entity-tag was specified using the \\\"Not\\\" form, \"\n                        \"but the resource's actual ETag matches the provided \"\n                        \"entity-tag.\";\n                    goto state_list_failed;\n                }\n                break;\n            }\n\n            case dav_if_opaquelock:\n                if (lockdb == NULL) {\n                    if (state_list->condition == DAV_IF_COND_NOT) {\n                        \n                        continue;\n                    }\n\n                    \n\n                    /*\n                    ** If no lockdb is provided, then validation fails for\n                    ** this state_list (NORMAL means we were supposed to\n                    ** find the token, which we obviously cannot do without\n                    ** a lock database).\n                    **\n                    ** Go and try the next state list.\n                    */\n                    reason =\n                        \"a State-token was supplied, but a lock database \"\n                        \"is not available for to provide the required lock.\";\n                    goto state_list_failed;\n                }\n\n                /* Resource validation 'fails' if:\n                 *    ANY  of the lock->locktokens match\n                 *         a NOT state_list->locktoken,\n                 * OR\n                 *    NONE of the lock->locktokens match\n                 *         a NORMAL state_list->locktoken.\n                 */\n                num_matched = 0;\n                for (lock = lock_list; lock != NULL; lock = lock->next) {\n\n                    /*\n                    DBG2(\"compare: rsrc=%s  ifhdr=%s\",\n                         (*locks_hooks->format_locktoken)(p, lock->locktoken),\n                         (*locks_hooks->format_locktoken)(p, state_list->locktoken));\n                    */\n\n                    \n                    if ((*locks_hooks->compare_locktoken)(state_list->locktoken, lock->locktoken)) {\n                        continue;\n                    }\n\n                    /*\n                    ** We have now matched up one of the resource's locktokens\n                    ** to a locktoken in a State-token in the If: header.\n                    ** Note this fact, so that we can pass the overall\n                    ** requirement of seeing at least one of the resource's\n                    ** locktokens.\n                    */\n                    seen_locktoken = 1;\n\n                    if (state_list->condition == DAV_IF_COND_NOT) {\n                        /*\n                        ** This state requires that the specified locktoken\n                        ** is NOT present on the resource. But we just found\n                        ** it. There is no way this state-list can now\n                        ** succeed, so go try another one.\n                        */\n                        reason =\n                            \"a State-token was supplied, which used a \"\n                            \"\\\"Not\\\" condition. The State-token was found \"\n                            \"in the locks on this resource\";\n                        goto state_list_failed;\n                    }\n\n                    \n\n                    /* Validate auth_user:  If an authenticated user created\n                    ** the lock, only the same user may submit that locktoken\n                    ** to manipulate a resource.\n                    */\n                    if (lock->auth_user &&\n                        (!r->user ||\n                         strcmp(lock->auth_user, r->user))) {\n                        const char *errmsg;\n\n                        errmsg = apr_pstrcat(p, \"User \\\"\",\n                                            r->user,\n                                            \"\\\" submitted a locktoken created \"\n                                            \"by user \\\"\",\n                                            lock->auth_user, \"\\\".\", NULL);\n                        return dav_new_error(p, HTTP_FORBIDDEN, 0, 0, errmsg);\n                    }\n\n                    /*\n                    ** We just matched a specified State-Token to one of the\n                    ** resource's locktokens.\n                    **\n                    ** Break out of the lock scan -- we only needed to find\n                    ** one match (actually, there shouldn't be any other\n                    ** matches in the lock list).\n                    */\n                    num_matched = 1;\n                    break;\n                }\n\n                if (num_matched == 0\n                    && state_list->condition == DAV_IF_COND_NORMAL) {\n                    /*\n                    ** We had a NORMAL state, meaning that we should have\n                    ** found the State-Token within the locks on this\n                    ** resource. We didn't, so this state_list must fail.\n                    */\n                    reason =\n                        \"a State-token was supplied, but it was not found \"\n                        \"in the locks on this resource.\";\n                    goto state_list_failed;\n                }\n\n                break;\n\n            case dav_if_unknown:\n                /* Request is predicated on some unknown state token,\n                 * which must be presumed to *not* match, so fail\n                 * unless this is a Not condition. */\n\n                if (state_list->condition == DAV_IF_COND_NORMAL) {\n                    reason =\n                        \"an unknown state token was supplied\";\n                    goto state_list_failed;\n                }\n                break;\n\n            } \n        } \n\n        /*\n        ** We've checked every state in this state_list and none of them\n        ** have failed. Since all of them succeeded, then we have a matching\n        ** state list and we may be done.\n        **\n        ** The next requirement is that we have seen one of the resource's\n        ** locktokens (if any). If we have, then we can just exit. If we\n        ** haven't, then we need to keep looking.\n        */\n        if (seen_locktoken) {\n            \n            return NULL;\n        }\n\n        /*\n        ** Haven't seen one. Let's break out of the search and just look\n        ** for a matching locktoken.\n        */\n        break;\n\n        /*\n        ** This label is used when we detect that a state_list is not\n        ** going to match this resource. We bust out and try the next\n        ** state_list.\n        */\n      state_list_failed:\n        ;\n\n    } \n\n    /*\n    ** The above loop exits for one of two reasons:\n    **   1) a state_list matched and seen_locktoken is false.\n    **   2) all if_header structures were scanned, without (1) occurring\n    */\n\n    if (ifhdr_scan == NULL) {\n        /*\n        ** We finished the loop without finding any matching state lists.\n        */\n\n        /*\n        ** If none of the state_lists apply to this resource, then we\n        ** may have succeeded. Note that this scenario implies a\n        ** tagged-list with no matching state_lists. If the If: header\n        ** was a no-tag-list, then it would have applied to this resource.\n        **\n        ** S9.4.2 states that when no state_lists apply, then the header\n        ** should be ignored.\n        **\n        ** If we saw one of the resource's locktokens, then we're done.\n        ** If we did not see a locktoken, then we fail.\n        */\n        if (num_that_apply == 0) {\n            if (seen_locktoken)\n                return NULL;\n\n            /*\n            ** We may have aborted the scan before seeing the locktoken.\n            ** Rescan the If: header to see if we can find the locktoken\n            ** somewhere.\n            **\n            ** Note that seen_locktoken == 0 implies lock_list != NULL\n            ** which implies locks_hooks != NULL.\n            */\n            if (dav_find_submitted_locktoken(if_header, lock_list,\n                                             locks_hooks)) {\n                /*\n                ** We found a match! We're set... none of the If: header\n                ** assertions apply (implicit success), and the If: header\n                ** specified the locktoken somewhere. We're done.\n                */\n                return NULL;\n            }\n\n            return dav_new_error(p, HTTP_LOCKED, 0 , 0,\n                                 \"This resource is locked and the \\\"If:\\\" \"\n                                 \"header did not specify one of the \"\n                                 \"locktokens for this resource's lock(s).\");\n        }\n        \n\n        /*\n        ** If the dummy_header did not match, then they specified an\n        ** incorrect token in the Lock-Token header. Forget whether the\n        ** If: statement matched or not... we'll tell them about the\n        ** bad Lock-Token first. That is considered a 400 (Bad Request).\n        */\n        if (if_header->dummy_header) {\n            return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                                 \"The locktoken specified in the \"\n                                 \"\\\"Lock-Token:\\\" header did not specify one \"\n                                 \"of this resource's locktoken(s).\");\n        }\n\n        if (reason == NULL) {\n            return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                                 \"The preconditions specified by the \\\"If:\\\" \"\n                                 \"header did not match this resource.\");\n        }\n\n        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                             apr_psprintf(p,\n                                         \"The precondition(s) specified by \"\n                                         \"the \\\"If:\\\" header did not match \"\n                                         \"this resource. At least one \"\n                                         \"failure is because: %s\", reason));\n    }\n\n    \n\n    /*\n    ** ifhdr_scan != NULL implies we found a matching state_list.\n    **\n    ** Since we're still here, it also means that we have not yet found\n    ** one the resource's locktokens in the If: header.\n    **\n    ** Scan all the if_headers and states looking for one of this\n    ** resource's locktokens. Note that we need to go back and scan them\n    ** all -- we may have aborted a scan with a failure before we saw a\n    ** matching token.\n    **\n    ** Note that seen_locktoken == 0 implies lock_list != NULL which implies\n    ** locks_hooks != NULL.\n    */\n    if (dav_find_submitted_locktoken(if_header, lock_list, locks_hooks)) {\n        /*\n        ** We found a match! We're set... we have a matching state list,\n        ** and the If: header specified the locktoken somewhere. We're done.\n        */\n        return NULL;\n    }\n\n    /*\n    ** We had a matching state list, but the user agent did not specify one\n    ** of this resource's locktokens. Tell them so.\n    **\n    ** Note that we need to special-case the message on whether a \"dummy\"\n    ** header exists. If it exists, yet we didn't see a needed locktoken,\n    ** then that implies the dummy header (Lock-Token header) did NOT\n    ** specify one of this resource's locktokens. (this implies something\n    ** in the real If: header matched)\n    **\n    ** We want to note the 400 (Bad Request) in favor of a 423 (Locked).\n    */\n    if (if_header->dummy_header) {\n        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                             \"The locktoken specified in the \"\n                             \"\\\"Lock-Token:\\\" header did not specify one \"\n                             \"of this resource's locktoken(s).\");\n    }\n\n    return dav_new_error(p, HTTP_LOCKED, 1 , 0,\n                         \"This resource is locked and the \\\"If:\\\" header \"\n                         \"did not specify one of the \"\n                         \"locktokens for this resource's lock(s).\");\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n480,Use of Incorrect Operator\n511,Logic/Time Bomb\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n690,Unchecked Return Value to NULL Pointer Dereference\n"
  },
  "httpd_c6298e355423c2c229dc37141b21b88b995de8a2_0", {
    "ID": "httpd_c6298e355423c2c229dc37141b21b88b995de8a2_0",
    "UID": "5712",
    "code": "DAV_DECLARE(void) dav_set_bufsize(apr_pool_t * p, dav_buffer test_snippet\n                                  apr_size_t size)\n{\n    \n\n    /* NOTE: this function is used to init the first pointer, too, since\n       the PAD will be larger than alloc_len (0) for zeroed structures */\n\n    \n    if (size + DAV_BUFFER_PAD > pbuf->alloc_len) {\n        \n        pbuf->alloc_len = size + DAV_BUFFER_PAD;\n        if (pbuf->alloc_len < DAV_BUFFER_MINSIZE)\n            pbuf->alloc_len = DAV_BUFFER_MINSIZE;\n\n        pbuf->buf = apr_palloc(p, pbuf->alloc_len);\n    }\n    pbuf->cur_len = size;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_e623f97330ed42c926c15a3a9b4ee6c574af4017_0", {
    "ID": "httpd_e623f97330ed42c926c15a3a9b4ee6c574af4017_0",
    "UID": "5719",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_sync_balancer(proxy_balancer *b, server_rec test_snippet\n                                                    proxy_server_conf *conf)\n{\n    proxy_worker **workers;\n    int i;\n    int index;\n    proxy_worker_shared *shm;\n    proxy_balancer_method *lbmethod;\n    ap_slotmem_provider_t *storage = b->storage;\n\n    if (b->s->wupdated <= b->wupdated)\n        return APR_SUCCESS;\n    \n    lbmethod = ap_lookup_provider(PROXY_LBMETHOD, b->s->lbpname, \"0\");\n    if (lbmethod) {\n        b->lbmethod = lbmethod;\n    } else {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(02433)\n                     \"Cannot find LB Method: %s\", b->s->lbpname);\n        return APR_EINVAL;\n    }\n\n    \n\n    /*\n     * Look thru the list of workers in shm\n     * and see which one(s) we are lacking...\n     * again, the cast to unsigned int is safe\n     * since our upper limit is always max_workers\n     * which is int.\n     */\n    for (index = 0; index < b->max_workers; index++) {\n        int found;\n        apr_status_t rv;\n        if ((rv = storage->dptr(b->wslot, (unsigned int)index, (void *)&shm)) != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00965) \"worker slotmem_dptr failed\");\n            return APR_EGENERAL;\n        }\n        /* account for possible \"holes\" in the slotmem\n         * (eg: slots 0-2 are used, but 3 isn't, but 4-5 is)\n         */\n        if (!shm->hash.def || !shm->hash.fnv)\n            continue;\n        found = 0;\n        workers = (proxy_worker **)b->workers->elts;\n        for (i = 0; i < b->workers->nelts; i++, workers++) {\n            proxy_worker *worker = *workers;\n            if (worker->hash.def == shm->hash.def && worker->hash.fnv == shm->hash.fnv) {\n                found = 1;\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02402)\n                             \"re-grabbing shm[%d] (0x%pp) for worker: %s\", i, (void *)shm,\n                             worker->s->name);\n                break;\n            }\n        }\n        if (!found) {\n            proxy_worker **runtime;\n            apr_global_mutex_lock(proxy_mutex);\n            runtime = apr_array_push(b->workers);\n            *runtime = apr_palloc(conf->pool, sizeof(proxy_worker));\n            apr_global_mutex_unlock(proxy_mutex);\n            (*runtime)->hash = shm->hash;\n            (*runtime)->context = NULL;\n            (*runtime)->cp = NULL;\n            (*runtime)->balancer = b;\n            (*runtime)->s = shm;\n            (*runtime)->tmutex = NULL;\n            rv = ap_proxy_initialize_worker(*runtime, s, conf->pool);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00966) \"Cannot init worker\");\n                return rv;\n            }\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02403)\n                         \"grabbing shm[%d] (0x%pp) for worker: %s\", i, (void *)shm,\n                         (*runtime)->s->name);\n        }\n    }\n    if (b->s->need_reset) {\n        if (b->lbmethod && b->lbmethod->reset)\n            b->lbmethod->reset(b, s);\n        b->s->need_reset = 0;\n    }\n    b->wupdated = b->s->wupdated;\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6ec4620499f5bc381d7158588c49dc7c69435f57_0", {
    "ID": "httpd_6ec4620499f5bc381d7158588c49dc7c69435f57_0",
    "UID": "5722",
    "code": "static int find_conn_headers(void *data, const char *key, const char test_snippet\n{\n    header_connection *x = data;\n    const char *name;\n\n    do {\n        while (*val == ',') {\n            val++;\n        }\n        name = ap_get_token(x->pool, &val, 0);\n        if (!strcasecmp(name, \"close\")) {\n            x->closed = 1;\n        }\n        if (!x->first) {\n            x->first = name;\n        }\n        else {\n            const char **elt;\n            if (!x->array) {\n                x->array = apr_array_make(x->pool, 4, sizeof(char *));\n            }\n            elt = apr_array_push(x->array);\n            *elt = name;\n        }\n    } while (test_snippet;\n\n    return 1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_6d17abc983eba732e4ef3ec194e8f2fb02bfbba4_0", {
    "ID": "httpd_6d17abc983eba732e4ef3ec194e8f2fb02bfbba4_0",
    "UID": "5771",
    "code": "static void terminate_headers(apr_bucket_alloc_t test_snippet\n                              apr_bucket_brigade *header_brigade)\n{\n    apr_bucket *e;\n\n    \n    e = apr_bucket_immortal_create(CRLF_ASCII, 2, bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(header_brigade, e);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_c7e4f33d00ed6d8a036517fcc02b247c542edbd1_0", {
    "ID": "httpd_c7e4f33d00ed6d8a036517fcc02b247c542edbd1_0",
    "UID": "5778",
    "code": "static int check_header(struct check_header_ctx test_snippet\n                        const char *name, const char **val)\n{\n    const char *pos, *end;\n    char *dst = NULL;\n\n    if (name[0] == '\\0') {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02428)\n                      \"Empty response header name, aborting request\");\n        return 0;\n    }\n\n    if (ctx->strict) { \n        end = ap_scan_http_token(name);\n    }\n    else {\n        end = ap_scan_vchar_obstext(name);\n    }\n    if (*end) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02429)\n                      \"Response header name '%s' contains invalid \"\n                      \"characters, aborting request\",\n                      name);\n        return 0;\n    }\n\n    for (pos = *val; *pos; pos = end) {\n        end = ap_scan_http_field_content(pos);\n        if (*end) {\n            if (end[0] != CR || end[1] != LF || (end[2] != ' ' &&\n                                                 end[2] != '\\t')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                              \"Response header '%s' value of '%s' contains \"\n                              \"invalid characters, aborting request\",\n                              name, pos);\n                return 0;\n            }\n            if (!dst) {\n                *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n            }\n        }\n        if (dst) {\n            memcpy(dst, pos, end - pos);\n            dst += end - pos;\n            if (*end) {\n                \n                end += 3 + strspn(end + 3, \"\\t \");\n                *dst++ = ' ';\n            }\n        }\n    }\n    if (dst) {\n        *dst = '\\0';\n    }\n    return 1;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_faa220fafe57b7b00cf3dc960fd81eac1a7af3a7_0", {
    "ID": "httpd_faa220fafe57b7b00cf3dc960fd81eac1a7af3a7_0",
    "UID": "5782",
    "code": "static int check_headers_table(apr_table_t *t, struct check_header_ctx test_snippet\n{\n    const apr_array_header_t *headers = apr_table_elts(t);\n    apr_table_entry_t *header;\n    int i;\n\n    for (i = 0; i < headers->nelts; ++i) {\n        header = &APR_ARRAY_IDX(headers, i, apr_table_entry_t);\n        if (!header->key) {\n            continue;\n        }\n        if (!check_header(ctx, header->key, (const char **)&header->val)) {\n            return 0;\n        }\n    }\n    return 1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_e7e41ba213918eb5e7590bb8d7cd9d3d57bceb6b_0", {
    "ID": "httpd_e7e41ba213918eb5e7590bb8d7cd9d3d57bceb6b_0",
    "UID": "5807",
    "code": "static const char *set_worker_param(apr_pool_t test_snippet\n                                    server_rec *s,\n                                    proxy_worker *worker,\n                                    const char *key,\n                                    const char *val)\n{\n\n    int ival;\n    apr_interval_time_t timeout;\n\n    if (!strcasecmp(key, \"loadfactor\")) {\n        /* Normalized load factor. Used with BalancerMember,\n         * it is a number between 1 and 100.\n         */\n        ival = atoi(val);\n        if (ival < 1 || ival > 100)\n            return \"LoadFactor must be a number between 1..100\";\n        worker->s->lbfactor = ival;\n    }\n    else if (!strcasecmp(key, \"retry\")) {\n        /* If set it will give the retry timeout for the worker\n         * The default value is 60 seconds, meaning that if\n         * in error state, it will be retried after that timeout.\n         */\n        if (ap_timeout_parameter_parse(val, &timeout, \"s\") != APR_SUCCESS)\n            return \"Retry value has wrong format\";\n        if (timeout < 1000)\n            return \"Retry must be at least one millisecond\";\n        worker->s->retry = timeout;\n        worker->s->retry_set = 1;\n    }\n    else if (!strcasecmp(key, \"ttl\")) {\n        \n        /* Time in seconds that will destroy all the connections\n         * that exceed the smax\n         */\n        ival = atoi(val);\n        if (ival < 1)\n            return \"TTL must be at least one second\";\n        worker->s->ttl = apr_time_from_sec(ival);\n    }\n    else if (!strcasecmp(key, \"min\")) {\n        /* Initial number of connections to remote\n         */\n        ival = atoi(val);\n        if (ival < 0)\n            return \"Min must be a positive number\";\n        worker->s->min = ival;\n    }\n    else if (!strcasecmp(key, \"max\")) {\n        /* Maximum number of connections to remote\n         */\n        ival = atoi(val);\n        if (ival < 0)\n            return \"Max must be a positive number\";\n        worker->s->hmax = ival;\n    }\n    \n    else if (!strcasecmp(key, \"smax\")) {\n        /* Maximum number of connections to remote that\n         * will not be destroyed\n         */\n        ival = atoi(val);\n        if (ival < 0)\n            return \"Smax must be a positive number\";\n        worker->s->smax = ival;\n    }\n    else if (!strcasecmp(key, \"acquire\")) {\n        /* Acquire timeout in given unit (default is milliseconds).\n         * If set this will be the maximum time to\n         * wait for a free connection.\n         */\n        if (ap_timeout_parameter_parse(val, &timeout, \"ms\") != APR_SUCCESS)\n            return \"Acquire timeout has wrong format\";\n        if (timeout < 1000)\n            return \"Acquire must be at least one millisecond\";\n        worker->s->acquire = timeout;\n        worker->s->acquire_set = 1;\n    }\n    else if (!strcasecmp(key, \"timeout\")) {\n        /* Connection timeout in seconds.\n         * Defaults to server timeout.\n         */\n        if (ap_timeout_parameter_parse(val, &timeout, \"s\") != APR_SUCCESS)\n            return \"Timeout value has wrong format\";\n        if (timeout < 1000)\n            return \"Timeout must be at least one millisecond\";\n        worker->s->timeout = timeout;\n        worker->s->timeout_set = 1;\n    }\n    else if (!strcasecmp(key, \"iobuffersize\")) {\n        long s = atol(val);\n        if (s < 512 && s) {\n            return \"IOBufferSize must be >= 512 bytes, or 0 for system default.\";\n        }\n        worker->s->io_buffer_size = (s ? s : AP_IOBUFSIZE);\n        worker->s->io_buffer_size_set = 1;\n    }\n    else if (!strcasecmp(key, \"receivebuffersize\")) {\n        ival = atoi(val);\n        if (ival < 512 && ival != 0) {\n            return \"ReceiveBufferSize must be >= 512 bytes, or 0 for system default.\";\n        }\n        worker->s->recv_buffer_size = ival;\n        worker->s->recv_buffer_size_set = 1;\n    }\n    else if (!strcasecmp(key, \"keepalive\")) {\n        if (!strcasecmp(val, \"on\"))\n            worker->s->keepalive = 1;\n        else if (!strcasecmp(val, \"off\"))\n            worker->s->keepalive = 0;\n        else\n            return \"KeepAlive must be On|Off\";\n        worker->s->keepalive_set = 1;\n    }\n    else if (!strcasecmp(key, \"disablereuse\")) {\n        if (!strcasecmp(val, \"on\"))\n            worker->s->disablereuse = 1;\n        else if (!strcasecmp(val, \"off\"))\n            worker->s->disablereuse = 0;\n        else\n            return \"DisableReuse must be On|Off\";\n        worker->s->disablereuse_set = 1;\n    }\n    else if (!strcasecmp(key, \"enablereuse\")) {\n        if (!strcasecmp(val, \"on\"))\n            worker->s->disablereuse = 0;\n        else if (!strcasecmp(val, \"off\"))\n            worker->s->disablereuse = 1;\n        else\n            return \"EnableReuse must be On|Off\";\n        worker->s->disablereuse_set = 1;\n    }\n    else if (!strcasecmp(key, \"route\")) {\n        /* Worker route.\n         */\n        if (strlen(val) >= sizeof(worker->s->route))\n            return apr_psprintf(p, \"Route length must be < %d characters\",\n                    (int)sizeof(worker->s->route));\n        PROXY_STRNCPY(worker->s->route, val);\n    }\n    else if (!strcasecmp(key, \"redirect\")) {\n        /* Worker redirection route.\n         */\n        if (strlen(val) >= sizeof(worker->s->redirect))\n            return apr_psprintf(p, \"Redirect length must be < %d characters\",\n                    (int)sizeof(worker->s->redirect));\n        PROXY_STRNCPY(worker->s->redirect, val);\n    }\n    else if (!strcasecmp(key, \"status\")) {\n        const char *v;\n        int mode = 1;\n        apr_status_t rv;\n        /* Worker status.\n         */\n        for (v = val; *v; v++) {\n            if (*v == '+') {\n                mode = 1;\n                v++;\n            }\n            else if (*v == '-') {\n                mode = 0;\n                v++;\n            }\n            rv = ap_proxy_set_wstatus(*v, mode, worker);\n            if (rv != APR_SUCCESS)\n                return \"Unknown status parameter option\";\n        }\n    }\n    else if (!strcasecmp(key, \"flushpackets\")) {\n        if (!strcasecmp(val, \"on\"))\n            worker->s->flush_packets = flush_on;\n        else if (!strcasecmp(val, \"off\"))\n            worker->s->flush_packets = flush_off;\n        else if (!strcasecmp(val, \"auto\"))\n            worker->s->flush_packets = flush_auto;\n        else\n            return \"flushpackets must be on|off|auto\";\n    }\n    else if (!strcasecmp(key, \"flushwait\")) {\n        if (ap_timeout_parameter_parse(val, &timeout, \"ms\") != APR_SUCCESS)\n            return \"flushwait has wrong format\";\n        if (timeout > 1000000 || timeout < 0) {\n            return \"flushwait must be <= 1s, or 0 for system default of 10 millseconds.\";\n        }\n        if (timeout == 0)\n            worker->s->flush_wait = PROXY_FLUSH_WAIT;\n        else\n            worker->s->flush_wait = timeout;\n    }\n    else if (!strcasecmp(key, \"ping\")) {\n        /* Ping/Pong timeout in given unit (default is second).\n         */\n        if (ap_timeout_parameter_parse(val, &timeout, \"s\") != APR_SUCCESS)\n            return \"Ping/Pong timeout has wrong format\";\n        if (timeout < 1000)\n            return \"Ping/Pong timeout must be at least one millisecond\";\n        worker->s->ping_timeout = timeout;\n        worker->s->ping_timeout_set = 1;\n    }\n    else if (!strcasecmp(key, \"lbset\")) {\n        ival = atoi(val);\n        if (ival < 0 || ival > 99)\n            return \"lbset must be between 0 and 99\";\n        worker->s->lbset = ival;\n    }\n    else if (!strcasecmp(key, \"connectiontimeout\")) {\n        /* Request timeout in given unit (default is second).\n         * Defaults to connection timeout\n         */\n        if (ap_timeout_parameter_parse(val, &timeout, \"s\") != APR_SUCCESS)\n            return \"Connectiontimeout has wrong format\";\n        if (timeout < 1000)\n            return \"Connectiontimeout must be at least one millisecond.\";\n        worker->s->conn_timeout = timeout;\n        worker->s->conn_timeout_set = 1;\n    }\n    else if (!strcasecmp(key, \"flusher\")) {\n        if (PROXY_STRNCPY(worker->s->flusher, val) != APR_SUCCESS) {\n            return apr_psprintf(p, \"flusher name length must be < %d characters\",\n                                (int)sizeof(worker->s->flusher));\n        }\n    }\n    else if (!strcasecmp(key, \"secret\")) {\n        if (PROXY_STRNCPY(worker->s->secret, val) != APR_SUCCESS) {\n            return apr_psprintf(p, \"Secret length must be < %d characters\",\n                                (int)sizeof(worker->s->secret));\n        }\n    }\n    else if (!strcasecmp(key, \"upgrade\")) {\n        if (PROXY_STRNCPY(worker->s->upgrade, val) != APR_SUCCESS) {\n            return apr_psprintf(p, \"upgrade protocol length must be < %d characters\",\n                                (int)sizeof(worker->s->upgrade));\n        }\n    }\n    else {\n        if (set_worker_hc_param_f) {\n            return set_worker_hc_param_f(p, s, worker, key, val, NULL);\n        } else {\n            return \"unknown Worker parameter\";\n        }\n    }\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_67f08ce5655b10f2a38b4b9ca8bda41f7bfa1ab1_0", {
    "ID": "httpd_67f08ce5655b10f2a38b4b9ca8bda41f7bfa1ab1_0",
    "UID": "5817",
    "code": "static char *make_allow(request_rec test_snippet\n{\n    apr_int64_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    \n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    \n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_c08dd621b1845715b68e88c7c648969f61043c53_0", {
    "ID": "httpd_c08dd621b1845715b68e88c7c648969f61043c53_0",
    "UID": "5861",
    "code": "AP_DECLARE(void) test_snippet()\n{\n    int written, count = strlen(oom_message);\n    const char *buf = oom_message;\n    do {\n        written = write(STDERR_FILENO, buf, count);\n        if (written == count)\n            break;\n        if (written > 0) {\n            buf += written;\n            count -= written;\n        }\n    } while (written >= 0 || errno == EINTR);\n    abort();\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_21fb5cd112ead5a91ddb1acdf1863c10908893bc_0", {
    "ID": "httpd_21fb5cd112ead5a91ddb1acdf1863c10908893bc_0",
    "UID": "5865",
    "code": "AP_DECLARE(int) ap_regexec_len(const ap_regex_t *preg, const char test_snippet\n                               apr_size_t len, apr_size_t nmatch,\n                               ap_regmatch_t *pmatch, int eflags)\n{\n    int rc;\n    int options = 0;\n    apr_size_t nlim;\n#ifdef HAVE_PCRE2\n    pcre2_match_data *matchdata;\n    size_t *ovector;\n#else\n    int small_ovector[POSIX_MALLOC_THRESHOLD * 3];\n    int allocated_ovector = 0;\n    int *ovector = NULL;\n#endif\n\n    if ((eflags & AP_REG_NOTBOL) != 0)\n        options |= PCREn(NOTBOL);\n    if ((eflags & AP_REG_NOTEOL) != 0)\n        options |= PCREn(NOTEOL);\n\n#ifdef HAVE_PCRE2\n    /* TODO: create a generic TLS matchdata buffer of some nmatch limit,\n     * e.g. 10 matches, to avoid a malloc-per-call. If it must be alloced,\n     * implement a general context using palloc and no free implementation.\n     */\n    nlim = ((apr_size_t)preg->re_nsub + 1) > nmatch\n         ? ((apr_size_t)preg->re_nsub + 1) : nmatch;\n    matchdata = pcre2_match_data_create(nlim, NULL);\n    if (matchdata == NULL)\n        return AP_REG_ESPACE;\n    ovector = pcre2_get_ovector_pointer(matchdata);\n    rc = pcre2_match((const pcre2_code *)preg->re_pcre,\n                     (const unsigned char *)buff, len,\n                     0, options, matchdata, NULL);\n    if (rc == 0)\n        rc = nlim;            \n#else\n    if (nmatch > 0) {\n        if (nmatch <= POSIX_MALLOC_THRESHOLD) {\n            ovector = &(small_ovector[0]);\n        }\n        else {\n            ovector = (int *)malloc(sizeof(int) * nmatch * 3);\n            if (ovector == NULL)\n                return AP_REG_ESPACE;\n            allocated_ovector = 1;\n        }\n    }\n    rc = pcre_exec((const pcre *)preg->re_pcre, NULL, buff, (int)len,\n                   0, options, ovector, nmatch * 3);\n    if (rc == 0)\n        rc = nmatch;            \n#endif\n\n    if (rc >= 0) {\n        apr_size_t i;\n        nlim = (apr_size_t)rc < nmatch ? (apr_size_t)rc : nmatch;\n        for (i = 0; i < nlim; i++) {\n            pmatch[i].rm_so = ovector[i * 2];\n            pmatch[i].rm_eo = ovector[i * 2 + 1];\n        }\n        for (; i < nmatch; i++)\n            pmatch[i].rm_so = pmatch[i].rm_eo = -1;\n    }\n\n#ifdef HAVE_PCRE2\n    pcre2_match_data_free(matchdata);\n#else\n    if (allocated_ovector)\n        free(ovector);\n#endif\n\n    if (rc >= 0) {\n        return 0;\n    }\n    else {\n#ifdef HAVE_PCRE2\n        if (rc <= PCRE2_ERROR_UTF8_ERR1 && rc >= PCRE2_ERROR_UTF8_ERR21)\n            return AP_REG_INVARG;\n#endif\n        switch (rc) {\n        case PCREn(ERROR_NOMATCH):\n            return AP_REG_NOMATCH;\n        case PCREn(ERROR_NULL):\n            return AP_REG_INVARG;\n        case PCREn(ERROR_BADOPTION):\n            return AP_REG_INVARG;\n        case PCREn(ERROR_BADMAGIC):\n            return AP_REG_INVARG;\n        case PCREn(ERROR_NOMEMORY):\n            return AP_REG_ESPACE;\n#if defined(HAVE_PCRE2) || defined(PCRE_ERROR_MATCHLIMIT)\n        case PCREn(ERROR_MATCHLIMIT):\n            return AP_REG_ESPACE;\n#endif\n#if defined(PCRE_ERROR_UNKNOWN_NODE)\n        case PCRE_ERROR_UNKNOWN_NODE:\n            return AP_REG_ASSERT;\n#endif\n#if defined(PCRE_ERROR_BADUTF8)\n        case PCREn(ERROR_BADUTF8):\n            return AP_REG_INVARG;\n#endif\n#if defined(PCRE_ERROR_BADUTF8_OFFSET)\n        case PCREn(ERROR_BADUTF8_OFFSET):\n            return AP_REG_INVARG;\n#endif\n        default:\n            return AP_REG_ASSERT;\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8e770b76fbffac0f40493e0ae9f53158bb6e8a7d_0", {
    "ID": "httpd_8e770b76fbffac0f40493e0ae9f53158bb6e8a7d_0",
    "UID": "5870",
    "code": "PROXY_DECLARE(int) ap_proxy_trans_match(request_rec *r, struct proxy_alias test_snippet\n                                        proxy_dir_conf *dconf)\n{\n    int len;\n    const char *fake;\n    const char *real;\n    ap_regmatch_t regm[AP_MAX_REG_MATCH];\n    ap_regmatch_t reg1[AP_MAX_REG_MATCH];\n    char *found = NULL;\n    int mismatch = 0;\n    unsigned int nocanon = ent->flags & PROXYPASS_NOCANON;\n    const char *use_uri = nocanon ? r->unparsed_uri : r->uri;\n\n    if (dconf && (dconf->interpolate_env == 1) && (ent->flags & PROXYPASS_INTERPOLATE)) {\n        fake = proxy_interpolate(r, ent->fake);\n        real = proxy_interpolate(r, ent->real);\n    }\n    else {\n        fake = ent->fake;\n        real = ent->real;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(03461)\n                  \"attempting to match URI path '%s' against %s '%s' for \"\n                  \"proxying\", r->uri, (ent->regex ? \"pattern\" : \"prefix\"),\n                  fake);\n\n    if (ent->regex) {\n        if (!ap_regexec(ent->regex, r->uri, AP_MAX_REG_MATCH, regm, 0)) {\n            if ((real[0] == '!') && (real[1] == '\\0')) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(03462)\n                              \"proxying is explicitly disabled for URI path \"\n                              \"'%s'; declining\", r->uri);\n                return DECLINED;\n            }\n            \n            if (nocanon && ap_regexec(ent->regex, r->unparsed_uri,\n                    AP_MAX_REG_MATCH, reg1, 0)) {\n                mismatch = 1;\n                use_uri = r->uri;\n            }\n            found = ap_pregsub(r->pool, real, use_uri, AP_MAX_REG_MATCH,\n                    (use_uri == r->uri) ? regm : reg1);\n            if (!found) {\n                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01135)\n                              \"Substitution in regular expression failed. \"\n                              \"Replacement too long?\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            /* Note: The strcmp() below catches cases where there\n             * was no regex substitution. This is so cases like:\n             *\n             *    ProxyPassMatch \\.gif balancer://foo\n             *\n             * will work \"as expected\". The upshot is that the 2\n             * directives below act the exact same way (ie: $1 is implied):\n             *\n             *    ProxyPassMatch ^(/.*\\.gif)$ balancer://foo\n             *    ProxyPassMatch ^(/.*\\.gif)$ balancer://foo$1\n             *\n             * which may be confusing.\n             */\n            if (strcmp(found, real) != 0) {\n                found = apr_pstrcat(r->pool, \"proxy:\", found, NULL);\n            }\n            else {\n                found = apr_pstrcat(r->pool, \"proxy:\", real, use_uri, NULL);\n            }\n        }\n    }\n    else {\n        len = alias_match(r->uri, fake);\n\n        if (len != 0) {\n            if ((real[0] == '!') && (real[1] == '\\0')) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(03463)\n                              \"proxying is explicitly disabled for URI path \"\n                              \"'%s'; declining\", r->uri);\n                return DECLINED;\n            }\n            if (nocanon && len != alias_match(r->unparsed_uri, ent->fake)) {\n                mismatch = 1;\n                use_uri = r->uri;\n            }\n            found = apr_pstrcat(r->pool, \"proxy:\", real, use_uri + len, NULL);\n        }\n    }\n    if (mismatch) {\n        /* We made a reducing transformation, so we can't safely use\n         * unparsed_uri.  Safe fallback is to ignore nocanon.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01136)\n                \"Unescaped URL path matched ProxyPass; ignoring unsafe nocanon\");\n    }\n\n    if (found) {\n        r->filename = found;\n        r->handler = \"proxy-server\";\n        r->proxyreq = PROXYREQ_REVERSE;\n        if (nocanon && !mismatch) {\n            \n            apr_table_setn(r->notes, \"proxy-nocanon\", \"1\");\n        }\n        if (ent->flags & PROXYPASS_NOQUERY) {\n            apr_table_setn(r->notes, \"proxy-noquery\", \"1\");\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(03464)\n                      \"URI path '%s' matches proxy handler '%s'\", r->uri,\n                      found);\n\n        return OK;\n    }\n\n    return DONE;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_4482f1ee2c8c335ea1561fab78fdda5721283ab7_0", {
    "ID": "httpd_4482f1ee2c8c335ea1561fab78fdda5721283ab7_0",
    "UID": "5908",
    "code": "AP_DECLARE(void) ap_add_common_vars(request_rec test_snippet\n{\n    apr_table_t *e;\n    server_rec *s = r->server;\n    conn_rec *c = r->connection;\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    const char *env_temp;\n    const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in);\n    const apr_table_entry_t *hdrs = (const apr_table_entry_t *) hdrs_arr->elts;\n    int i;\n    apr_port_t rport;\n    char *q;\n\n    /* use a temporary apr_table_t which we'll overlap onto\n     * r->subprocess_env later\n     * (exception: if r->subprocess_env is empty at the start,\n     * write directly into it)\n     */\n    if (apr_is_empty_table(r->subprocess_env)) {\n        e = r->subprocess_env;\n    }\n    else {\n        e = apr_table_make(r->pool, 25 + hdrs_arr->nelts);\n    }\n\n    /* First, add environment vars from headers... this is as per\n     * CGI specs, though other sorts of scripting interfaces see\n     * the same vars...\n     */\n\n    for (i = 0; i < hdrs_arr->nelts; ++i) {\n        if (!hdrs[i].key) {\n            continue;\n        }\n\n        /* A few headers are special cased --- Authorization to prevent\n         * rogue scripts from capturing passwords; content-type and -length\n         * for no particular reason.\n         */\n\n        if (!strcasecmp(hdrs[i].key, \"Content-type\")) {\n            apr_table_addn(e, \"CONTENT_TYPE\", hdrs[i].val);\n        }\n        else if (!strcasecmp(hdrs[i].key, \"Content-length\")) {\n            apr_table_addn(e, \"CONTENT_LENGTH\", hdrs[i].val);\n        }\n        /*\n         * You really don't want to disable this check, since it leaves you\n         * wide open to CGIs stealing passwords and people viewing them\n         * in the environment with \"ps -e\".  But, if you must...\n         */\n#ifndef SECURITY_HOLE_PASS_AUTHORIZATION\n        else if (!strcasecmp(hdrs[i].key, \"Authorization\")\n                 || !strcasecmp(hdrs[i].key, \"Proxy-Authorization\")) {\n            if (conf->cgi_pass_auth == AP_CGI_PASS_AUTH_ON) {\n                add_unless_null(e, http2env(r, hdrs[i].key), hdrs[i].val);\n            }\n        }\n#endif\n        else\n            add_unless_null(e, http2env(r, hdrs[i].key), hdrs[i].val);\n    }\n\n    env_temp = apr_table_get(r->subprocess_env, \"PATH\");\n    if (env_temp == NULL) {\n        env_temp = getenv(\"PATH\");\n    }\n    if (env_temp == NULL) {\n        env_temp = DEFAULT_PATH;\n    }\n    apr_table_addn(e, \"PATH\", apr_pstrdup(r->pool, env_temp));\n\n#if defined(WIN32)\n    env2env(e, \"SystemRoot\");\n    env2env(e, \"COMSPEC\");\n    env2env(e, \"PATHEXT\");\n    env2env(e, \"WINDIR\");\n#elif defined(OS2)\n    env2env(e, \"COMSPEC\");\n    env2env(e, \"ETC\");\n    env2env(e, \"DPATH\");\n    env2env(e, \"PERLLIB_PREFIX\");\n#elif defined(BEOS)\n    env2env(e, \"LIBRARY_PATH\");\n#elif defined(DARWIN)\n    env2env(e, \"DYLD_LIBRARY_PATH\");\n#elif defined(_AIX)\n    env2env(e, \"LIBPATH\");\n#elif defined(__HPUX__)\n    \n    env2env(e, \"SHLIB_PATH\");\n    env2env(e, \"LD_LIBRARY_PATH\");\n#else \n    env2env(e, \"LD_LIBRARY_PATH\");\n#endif\n\n    apr_table_addn(e, \"SERVER_SIGNATURE\", ap_psignature(\"\", r));\n    apr_table_addn(e, \"SERVER_SOFTWARE\", ap_get_server_banner());\n    apr_table_addn(e, \"SERVER_NAME\",\n                   ap_escape_html(r->pool, ap_get_server_name_for_url(r)));\n    apr_table_addn(e, \"SERVER_ADDR\", r->connection->local_ip);  \n    apr_table_addn(e, \"SERVER_PORT\",\n                  apr_psprintf(r->pool, \"%u\", ap_get_server_port(r)));\n    add_unless_null(e, \"REMOTE_HOST\",\n                    ap_get_remote_host(c, r->per_dir_config, REMOTE_HOST, NULL));\n    apr_table_addn(e, \"REMOTE_ADDR\", r->useragent_ip);\n    apr_table_addn(e, \"DOCUMENT_ROOT\", ap_document_root(r));    \n    apr_table_setn(e, \"REQUEST_SCHEME\", ap_http_scheme(r));\n    apr_table_addn(e, \"CONTEXT_PREFIX\", ap_context_prefix(r));\n    apr_table_addn(e, \"CONTEXT_DOCUMENT_ROOT\", ap_context_document_root(r));\n    apr_table_addn(e, \"SERVER_ADMIN\", s->server_admin); \n    if (apr_table_get(r->notes, \"proxy-noquery\") && (q = ap_strchr(r->filename, '?'))) {\n        *q = '\\0';\n        apr_table_addn(e, \"SCRIPT_FILENAME\", apr_pstrdup(r->pool, r->filename));\n        *q = '?';\n    }\n    else {\n        apr_table_addn(e, \"SCRIPT_FILENAME\", r->filename);  \n    }\n\n    rport = c->client_addr->port;\n    apr_table_addn(e, \"REMOTE_PORT\", apr_itoa(r->pool, rport));\n\n    if (r->user) {\n        apr_table_addn(e, \"REMOTE_USER\", r->user);\n    }\n    else if (r->prev) {\n        request_rec *back = r->prev;\n\n        while (back) {\n            if (back->user) {\n                apr_table_addn(e, \"REDIRECT_REMOTE_USER\", back->user);\n                break;\n            }\n            back = back->prev;\n        }\n    }\n    add_unless_null(e, \"AUTH_TYPE\", r->ap_auth_type);\n    env_temp = ap_get_remote_logname(r);\n    if (env_temp) {\n        apr_table_addn(e, \"REMOTE_IDENT\", apr_pstrdup(r->pool, env_temp));\n    }\n\n    \n\n    if (r->prev) {\n        add_unless_null(e, \"REDIRECT_QUERY_STRING\", r->prev->args);\n        add_unless_null(e, \"REDIRECT_URL\", r->prev->uri);\n    }\n\n    if (e != r->subprocess_env) {\n      apr_table_overlap(r->subprocess_env, e, APR_OVERLAP_TABLES_SET);\n    }\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_b54436fcf5a61acf5326f437efb67b9f9d738a2e_0", {
    "ID": "httpd_b54436fcf5a61acf5326f437efb67b9f9d738a2e_0",
    "UID": "5910",
    "code": "static char *http2env(request_rec *r, const char test_snippet\n{\n    char *res = (char *)apr_palloc(r->pool, sizeof(\"HTTP_\") + strlen(w));\n    char *cp = res;\n    char c;\n\n    *cp++ = 'H';\n    *cp++ = 'T';\n    *cp++ = 'T';\n    *cp++ = 'P';\n    *cp++ = '_';\n\n    while ((c = *w++) != 0) {\n        if (apr_isalnum(c)) {\n            *cp++ = apr_toupper(c);\n        }\n        else if (c == '-') {\n            *cp++ = '_';\n        }\n        else {\n            if (APLOGrtrace1(r))\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                            \"Not exporting header with invalid name as envvar: %s\",\n                            ap_escape_logitem(r->pool, w));\n            return NULL;\n        }\n    }\n    *cp = 0;\n\n    return res;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_5061b2a6718800c3cea3ce5b34fe21d548fd0846_0", {
    "ID": "httpd_5061b2a6718800c3cea3ce5b34fe21d548fd0846_0",
    "UID": "5941",
    "code": "static char *subst_prefix_path(request_rec *r, char *input, const char test_snippet\n                               const char *subst)\n{\n    apr_size_t len = strlen(match);\n\n    if (len && match[len - 1] == '/') {\n        --len;\n    }\n\n    if (!strncmp(input, match, len) && input[len++] == '/') {\n        apr_size_t slen, outlen;\n        char *output;\n\n        rewritelog((r, 5, NULL, \"strip matching prefix: %s -> %s\", input,\n                    input+len));\n\n        slen = strlen(subst);\n        if (slen && subst[slen - 1] != '/') {\n            ++slen;\n        }\n\n        outlen = strlen(input) + slen - len;\n        output = apr_palloc(r->pool, outlen + 1); \n\n        memcpy(output, subst, slen);\n        if (slen && !output[slen-1]) {\n            output[slen-1] = '/';\n        }\n        memcpy(output+slen, input+len, outlen - slen);\n        output[outlen] = '\\0';\n\n        rewritelog((r, 4, NULL, \"add subst prefix: %s -> %s\", input+len,\n                    output));\n\n        return output;\n    }\n\n    \n    return input;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_37ddfe171f1ed6484c9183532fe66fa7ed23a0ff_0", {
    "ID": "httpd_37ddfe171f1ed6484c9183532fe66fa7ed23a0ff_0",
    "UID": "5957",
    "code": "static int proxy_fdpass_canon(request_rec *r, char test_snippet\n{\n    const char *path;\n\n    if (ap_cstr_casecmpn(url, \"fd://\", 5) == 0) {\n        url += 5;\n    }\n    else {\n        return DECLINED;\n    }\n\n    path = ap_server_root_relative(r->pool, url);\n\n    r->filename = apr_pstrcat(r->pool, \"proxy:fd://\", path, NULL);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01151)\n                  \"set r->filename to %s\", r->filename);\n    return OK;\n}",
    "predicted": "23,Relative Path Traversal\n427,Uncontrolled Search Path Element"
  },
  "httpd_aa5c3155c1abc906cdb21a0dd56c663fd0740417_0", {
    "ID": "httpd_aa5c3155c1abc906cdb21a0dd56c663fd0740417_0",
    "UID": "5958",
    "code": "static apr_status_t send_socket(apr_pool_t test_snippet\n                                apr_socket_t *s,\n                                apr_socket_t *outbound)\n{\n    apr_status_t rv;\n    apr_os_sock_t rawsock;\n    apr_os_sock_t srawsock;\n    struct msghdr msg;\n    struct cmsghdr *cmsg;\n    struct iovec iov;\n    char b = '\\0';\n\n    rv = apr_os_sock_get(&rawsock, outbound);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    rv = apr_os_sock_get(&srawsock, s);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n\n    iov.iov_base = &b;\n    iov.iov_len = 1;\n\n    cmsg = apr_palloc(p, sizeof(*cmsg) + sizeof(rawsock));\n    cmsg->cmsg_len = sizeof(*cmsg) + sizeof(rawsock);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n\n    memcpy(CMSG_DATA(cmsg), &rawsock, sizeof(rawsock));\n\n    msg.msg_control = cmsg;\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    rv = sendmsg(srawsock, &msg, 0);\n\n    if (rv == -1) {\n        return errno;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_8fbacd79355613b75bde8e20635f124adb492955_0", {
    "ID": "httpd_8fbacd79355613b75bde8e20635f124adb492955_0",
    "UID": "5962",
    "code": "static int standard_flush(request_rec test_snippet\n{\n    int status;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n\n    r->connection->keepalive = AP_CONN_CLOSE;\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    e = apr_bucket_flush_create(r->connection->bucket_alloc);\n\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n\n    status = ap_pass_brigade(r->output_filters, bb);\n\n    if (status != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01156)\n                      \"ap_pass_brigade failed:\");\n        return status;\n    }\n\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e0c9c51e42bffef9a0ea94b57c124cc42da525ff_0", {
    "ID": "httpd_e0c9c51e42bffef9a0ea94b57c124cc42da525ff_0",
    "UID": "5964",
    "code": "AP_DECLARE(int) ap_method_number_of(const char test_snippet\n{\n    int len = strlen(method);\n\n    \n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_12b739046b7fb6494954239228adf402e70a1eee_0", {
    "ID": "httpd_12b739046b7fb6494954239228adf402e70a1eee_0",
    "UID": "5976",
    "code": "static int uwsgi_send(proxy_conn_rec * conn, const char test_snippet\n                      apr_size_t length, request_rec *r)\n{\n    apr_status_t rv;\n    apr_size_t written;\n\n    while (length > 0) {\n        written = length;\n        if ((rv = apr_socket_send(conn->sock, buf, &written)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10098)\n                          \"sending data to %s:%u failed\",\n                          conn->hostname, conn->port);\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n\n        \n        conn->worker->s->transferred += written;\n        buf += written;\n        length -= written;\n    }\n\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_cee479d6f9c8ac393c1929f1a840928f73da15aa_0", {
    "ID": "httpd_cee479d6f9c8ac393c1929f1a840928f73da15aa_0",
    "UID": "5978",
    "code": "static int get_basic_auth(request_rec *r, const char test_snippet\n                          const char **pw)\n{\n    const char *auth_line;\n    char *decoded_line;\n\n    \n    auth_line = apr_table_get(r->headers_in, (PROXYREQ_PROXY == r->proxyreq)\n                                              ? \"Proxy-Authorization\"\n                                              : \"Authorization\");\n\n    if (!auth_line) {\n        note_basic_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (ap_cstr_casecmp(ap_getword(r->pool, &auth_line, ' '), \"Basic\")) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01614)\n                      \"client used wrong authentication scheme: %s\", r->uri);\n        note_basic_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    \n    while (*auth_line == ' ' || *auth_line == '\\t') {\n        auth_line++;\n    }\n\n    decoded_line = ap_pbase64decode(r->pool, auth_line);\n\n    *user = ap_getword_nulls(r->pool, (const char**)&decoded_line, ':');\n    *pw = decoded_line;\n\n    \n    r->user = (char *) *user;\n\n    return OK;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n522,Insufficiently Protected Credentials\n"
  },
  "httpd_7cf78ffcfbc63c398613b76f8d33e63b9cd775a9_0", {
    "ID": "httpd_7cf78ffcfbc63c398613b76f8d33e63b9cd775a9_0",
    "UID": "5984",
    "code": "static int sc_for_req_header(const char test_snippet\n{\n    char header[16];\n    apr_size_t len = strlen(header_name);\n    const char *p = header_name;\n    int i = 0;\n\n    /* ACCEPT-LANGUAGE is the longest header\n     * that is of interest.\n     */\n    if (len < 4 || len > 15)\n        return UNKNOWN_METHOD;\n\n    memset(header, 0, sizeof header);\n    while (*p)\n        header[i++] = apr_toupper(*p++);\n    header[i] = '\\0';\n    p = &header[1];\n\n    switch (header[0]) {\n        case 'A':\n            if (memcmp(p, \"CCEPT\", 5) == 0) {\n                if (!header[6])\n                    return SC_ACCEPT;\n                else if (header[6] == '-') {\n                    p += 6;\n                    if (strcmp(p, \"CHARSET\") == 0)\n                        return SC_ACCEPT_CHARSET;\n                    else if (strcmp(p,  \"ENCODING\") == 0)\n                        return SC_ACCEPT_ENCODING;\n                    else if (strcmp(p, \"LANGUAGE\") == 0)\n                        return SC_ACCEPT_LANGUAGE;\n                    else\n                        return UNKNOWN_METHOD;\n                }\n                else\n                    return UNKNOWN_METHOD;\n            }\n            else if (strcmp(p, \"UTHORIZATION\") == 0)\n                return SC_AUTHORIZATION;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        case 'C':\n            if (strcmp(p, \"OOKIE2\") == 0)\n                return SC_COOKIE2;\n            else if (strcmp(p, \"OOKIE\") == 0)\n                return SC_COOKIE;\n            else if (strcmp(p, \"ONNECTION\") == 0)\n                return SC_CONNECTION;\n            else if (strcmp(p, \"ONTENT-TYPE\") == 0)\n                return SC_CONTENT_TYPE;\n            else if (strcmp(p, \"ONTENT-LENGTH\") == 0)\n                return SC_CONTENT_LENGTH;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        case 'H':\n            if (strcmp(p, \"OST\") == 0)\n                return SC_HOST;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        case 'P':\n            if (strcmp(p, \"RAGMA\") == 0)\n                return SC_PRAGMA;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        case 'R':\n            if (strcmp(p, \"EFERER\") == 0)\n                return SC_REFERER;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        case 'U':\n            if (strcmp(p, \"SER-AGENT\") == 0)\n                return SC_USER_AGENT;\n            else\n                return UNKNOWN_METHOD;\n        break;\n        default:\n            return UNKNOWN_METHOD;\n    }\n\n    \n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_9de3c00623151a319e8e75be4d66a0c6611a492e_0", {
    "ID": "httpd_9de3c00623151a319e8e75be4d66a0c6611a492e_0",
    "UID": "6016",
    "code": "PROXY_DECLARE(apr_status_t) ap_proxy_tunnel_run(proxy_tunnel_rec test_snippet\n{\n    apr_status_t rv;\n    request_rec *r = tunnel->r;\n    conn_rec *c_i = r->connection;\n    conn_rec *c_o = tunnel->origin;\n    apr_socket_t *sock_i = ap_get_conn_socket(c_i);\n    apr_socket_t *sock_o = ap_get_conn_socket(c_o);\n    apr_interval_time_t timeout = tunnel->timeout >= 0 ? tunnel->timeout : -1;\n    apr_pollfd_t *pfds = &APR_ARRAY_IDX(tunnel->pfds, 0, apr_pollfd_t);\n    apr_pollset_t *pollset = tunnel->pollset;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    int done = 0;\n\n    AP_DEBUG_ASSERT(tunnel->pfds->nelts == 2);\n    AP_DEBUG_ASSERT(pfds[0].desc.s == sock_i);\n    AP_DEBUG_ASSERT(pfds[1].desc.s == sock_o);\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(10212)\n                  \"proxy: tunnel: running (timeout %\" APR_TIME_T_FMT \".\"\n                                                  \"%\" APR_TIME_T_FMT \")\",\n                  timeout > 0 ? apr_time_sec(timeout) : timeout,\n                  timeout > 0 ? timeout % APR_USEC_PER_SEC : 0);\n\n#if 0\n    apr_socket_opt_set(sock_i, APR_SO_NONBLOCK, 1);\n    apr_socket_opt_set(sock_i, APR_SO_NONBLOCK, 1);\n    apr_socket_opt_set(sock_o, APR_SO_KEEPALIVE, 1);\n    apr_socket_opt_set(sock_o, APR_SO_KEEPALIVE, 1);\n#endif\n\n    apr_pollset_add(pollset, &pfds[0]);\n    apr_pollset_add(pollset, &pfds[1]);\n\n    do { \n        rv = apr_pollset_poll(tunnel->pollset, timeout, &pollcnt, &signalled);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n\n            apr_pollset_remove(pollset, &pfds[1]);\n            apr_pollset_remove(pollset, &pfds[0]);\n\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(10213)\n                              \"proxy: tunnel: woken up, i=%d\", (int)pollcnt);\n\n                return HTTP_GATEWAY_TIME_OUT;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10214)\n                          \"proxy: tunnel: polling failed\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(10215)\n                      \"proxy: tunnel: woken up, i=%d\", (int)pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n            apr_int16_t pollevent = cur->rtnevents;\n\n            if (cur->desc.s == sock_o) {\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(10216)\n                                  \"proxy: tunnel: backend was readable\");\n                    rv = ap_proxy_transfer_between_connections(r, c_o, c_i,\n                                                               tunnel->bb_o,\n                                                               tunnel->bb_i,\n                                                               \"backend\",\n                                                               &tunnel->replied,\n                                                               AP_IOBUFSIZE,\n                                                               0);\n                    done |= (rv != APR_SUCCESS);\n                }\n                else if (pollevent & APR_POLLERR) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10217)\n                            \"proxy: tunnel: error on backend connection\");\n                    c_o->aborted = 1;\n                    done = 1;\n                }\n                else { \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10218)\n                            \"proxy: tunnel: unknown event %d on backend connection\",\n                            (int)pollevent);\n                    done = 1;\n                }\n            }\n            else if (cur->desc.s == sock_i) {\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, APLOGNO(10219)\n                                  \"proxy: tunnel: client was readable\");\n                    rv = ap_proxy_transfer_between_connections(r, c_i, c_o,\n                                                               tunnel->bb_i,\n                                                               tunnel->bb_o,\n                                                               \"client\", NULL,\n                                                               AP_IOBUFSIZE,\n                                                               0);\n                    done |= (rv != APR_SUCCESS);\n                }\n                else if (pollevent & APR_POLLERR) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10220)\n                                  \"proxy: tunnel: error on client connection\");\n                    c_i->aborted = 1;\n                    done = 1;\n                }\n                else { \n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10221)\n                            \"proxy: tunnel: unknown event %d on client connection\",\n                            (int)pollevent);\n                    done = 1;\n                }\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10222)\n                              \"proxy: tunnel: unknown socket in pollset\");\n                done = 1;\n            }\n        }\n    } while (!done);\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(10223)\n                  \"proxy: tunnel: finished\");\n\n    apr_pollset_remove(pollset, &pfds[1]);\n    apr_pollset_remove(pollset, &pfds[0]);\n\n    if (!tunnel->replied) {\n        return HTTP_BAD_GATEWAY;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_7d6d8fdb65f7e877d03fb477cf6d3f3ca1d4282c_0", {
    "ID": "httpd_7d6d8fdb65f7e877d03fb477cf6d3f3ca1d4282c_0",
    "UID": "6019",
    "code": "static apr_status_t socache_rd_store(ap_socache_instance_t *ctx, server_rec test_snippet\n                                     const unsigned char *id, unsigned int idlen,\n                                     apr_time_t expiry,\n                                     unsigned char *ucaData, unsigned int nData,\n                                     apr_pool_t *p)\n{\n    char buf[RD_KEY_LEN];\n    apr_status_t rv;\n    apr_uint32_t timeout;\n\n    if (socache_rd_id2key(ctx, id, idlen, buf, sizeof(buf))) {\n        return APR_EINVAL;\n    }\n    timeout = apr_time_sec(expiry - apr_time_now());\n    if (timeout <= 0) {\n        return APR_EINVAL;\n    }\n\n    rv = apr_redis_setex(ctx->rc, buf, (char*)ucaData, nData, timeout, 0);\n\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(03478)\n                     \"scache_rd: error setting key '%s' \"\n                     \"with %d bytes of data\", buf, nData);\n        return rv;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_244768aa4c8ee568cfcee0e3e47eda752b3ef340_0", {
    "ID": "httpd_244768aa4c8ee568cfcee0e3e47eda752b3ef340_0",
    "UID": "6047",
    "code": "static APR_INLINE int check_headers(request_rec test_snippet\n{\n    const char *loc;\n    struct check_header_ctx ctx;\n    core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n\n    ctx.r = r;\n    ctx.strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    if (!apr_table_do(check_header, &ctx, r->headers_out, NULL))\n        return 0; \n\n    if ((loc = apr_table_get(r->headers_out, \"Location\")) != NULL) {\n        const char *scheme_end = ap_strchr_c(loc, ':');\n\n        /*\n         * Check that the URI has a valid scheme and is absolute\n         * XXX Should we do a full uri parse here?\n         */\n        if (!ap_is_url(loc))\n            goto bad;\n\n        if (scheme_end[1] != '/' || scheme_end[2] != '/')\n            goto bad;\n    }\n\n    return 1;\n\nbad:\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02431)\n                  \"Bad Location header in response: '%s', aborting request\",\n                  loc);\n    return 0;\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_1c9cc78eebb69488fdc3084f48738bebf9beaa8e_0", {
    "ID": "httpd_1c9cc78eebb69488fdc3084f48738bebf9beaa8e_0",
    "UID": "6083",
    "code": "static test_snippet\nvoid make_spare_ring(struct spare_ring **ring, apr_pool_t *p)\n{\n    if (!*ring) {\n        *ring = apr_palloc(p, sizeof(**ring));\n        APR_RING_INIT(*ring, spare_data, link);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0899101702d188801a0270d52a5b6ef2f0bc44e6_0", {
    "ID": "httpd_0899101702d188801a0270d52a5b6ef2f0bc44e6_0",
    "UID": "6084",
    "code": "static void *get_spare(conn_rec *c, struct spare_ring test_snippet\n{\n    void *data = NULL;\n\n    if (ring && !APR_RING_EMPTY(ring, spare_data, link)) {\n        struct spare_data *sdata = APR_RING_FIRST(ring);\n        struct ap_filter_conn_ctx *x = c->filter_conn_ctx;\n\n        data = sdata->data;\n        sdata->data = NULL;\n        APR_RING_REMOVE(sdata, link);\n        make_spare_ring(&x->spare_containers, c->pool);\n        APR_RING_INSERT_TAIL(x->spare_containers, sdata, spare_data, link);\n    }\n\n    return data;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_25d4edc709e4a54de46dda7ac5a57775a8bc223b_0", {
    "ID": "httpd_25d4edc709e4a54de46dda7ac5a57775a8bc223b_0",
    "UID": "6085",
    "code": "AP_DECLARE(void) ap_process_request_after_handler(request_rec test_snippet\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n    ap_filter_t *f;\n\n    bb = ap_acquire_brigade(c);\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    /* All the request filters should have bailed out on EOS, and in any\n     * case they shouldn't have to handle this EOR which will destroy the\n     * request underneath them. So go straight to the core request filter\n     * which (if any) will take care of the setaside buckets.\n     */\n    for (f = r->output_filters; f; f = f->next) {\n        if (f->frec == ap_request_core_filter_handle) {\n            break;\n        }\n    }\n    ap_pass_brigade(f ? f : c->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occurred before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    (void)ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n\n    ap_release_brigade(c, bb);\n\n    if (c->cs) {\n        if (c->aborted) {\n            c->cs->state = CONN_STATE_LINGER;\n        }\n        else {\n            /* If we have still data in the output filters here it means that\n             * the last (recent) nonblocking write was EAGAIN, so tell the MPM\n             * to not try another useless/stressful one but to go straight to\n             * POLLOUT.\n            */\n            c->cs->state = CONN_STATE_WRITE_COMPLETION;\n        }\n    }\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_3abb72922e9031f43e9f87befeb097be1085be7f_0", {
    "ID": "httpd_3abb72922e9031f43e9f87befeb097be1085be7f_0",
    "UID": "6086",
    "code": "static void put_spare(conn_rec *c, void *data, struct spare_ring test_snippet\n{\n    struct ap_filter_conn_ctx *x = c->filter_conn_ctx;\n    struct spare_data *sdata;\n\n    if (!x->spare_containers || APR_RING_EMPTY(x->spare_containers,\n                                               spare_data, link)) {\n        sdata = apr_palloc(c->pool, sizeof(*sdata));\n    }\n    else {\n        sdata = APR_RING_FIRST(x->spare_containers);\n        APR_RING_REMOVE(sdata, link);\n    }\n    sdata->data = data;\n\n    make_spare_ring(ring, c->pool);\n    APR_RING_INSERT_TAIL(*ring, sdata, spare_data, link);\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_8ace3ef500bb5b6bcd07f3c2c352300d5ff1c08b_0", {
    "ID": "httpd_8ace3ef500bb5b6bcd07f3c2c352300d5ff1c08b_0",
    "UID": "6088",
    "code": "static void recycle_dead_filters(conn_rec test_snippet\n{\n    struct ap_filter_conn_ctx *x = c->filter_conn_ctx;\n\n    if (!x || !x->dead_filters) {\n        return;\n    }\n\n    make_spare_ring(&x->spare_filters, c->pool);\n    APR_RING_CONCAT(x->spare_filters, x->dead_filters, spare_data, link);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_3a4384a975c5e58ca71cb0a7009374f71cf3cd61_0", {
    "ID": "httpd_3a4384a975c5e58ca71cb0a7009374f71cf3cd61_0",
    "UID": "6089",
    "code": "static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void test_snippet\n                                          request_rec *r, conn_rec *c,\n                                          ap_filter_t **r_filters,\n                                          ap_filter_t **p_filters,\n                                          ap_filter_t **c_filters)\n{\n    ap_filter_t *f;\n    ap_filter_t **outf;\n    struct ap_filter_conn_ctx *x;\n    struct ap_filter_private *fp;\n\n    if (frec->ftype < AP_FTYPE_PROTOCOL) {\n        if (r) {\n            outf = r_filters;\n        }\n        else {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(00080)\n                          \"a content filter was added without a request: %s\", frec->name);\n            return NULL;\n        }\n    }\n    else if (frec->ftype < AP_FTYPE_CONNECTION) {\n        if (r) {\n            outf = p_filters;\n        }\n        else {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(00081)\n                          \"a protocol filter was added without a request: %s\", frec->name);\n            return NULL;\n        }\n    }\n    else {\n        outf = c_filters;\n    }\n\n    x = get_conn_ctx(c);\n    f = get_spare(c, x->spare_filters);\n    if (f) {\n        fp = f->priv;\n    }\n    else {\n        f = apr_palloc(c->pool, sizeof(*f));\n        fp = apr_palloc(c->pool, sizeof(*fp));\n    }\n    memset(f, 0, sizeof(*f));\n    memset(fp, 0, sizeof(*fp));\n    APR_RING_ELEM_INIT(fp, pending);\n    f->priv = fp;\n    fp->f = f;\n\n    f->frec = frec;\n    f->ctx = ctx;\n    \n    if (r && frec->ftype < AP_FTYPE_CONNECTION) {\n        apr_pool_cleanup_register(r->pool, f, request_filter_cleanup,\n                                  apr_pool_cleanup_null);\n        f->r = r;\n    }\n    f->c = c;\n\n    if (INSERT_BEFORE(f, *outf)) {\n        f->next = *outf;\n\n        if (*outf) {\n            ap_filter_t *first = NULL;\n\n            if (r) {\n                /* If we are adding our first non-connection filter,\n                 * Then don't try to find the right location, it is\n                 * automatically first.\n                 */\n                if (*r_filters != *c_filters) {\n                    first = *r_filters;\n                    while (first && (first->next != (*outf))) {\n                        first = first->next;\n                    }\n                }\n            }\n            if (first && first != (*outf)) {\n                first->next = f;\n            }\n        }\n        *outf = f;\n    }\n    else {\n        ap_filter_t *fscan = *outf;\n        while (!INSERT_BEFORE(f, fscan->next))\n            fscan = fscan->next;\n\n        f->next = fscan->next;\n        fscan->next = f;\n    }\n\n    if (frec->ftype < AP_FTYPE_CONNECTION && (*r_filters == *c_filters)) {\n        *r_filters = *p_filters;\n    }\n    return f;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_6f6aa2b38f4fa8729b6d18551a54bb32d1fc80ce_0", {
    "ID": "httpd_6f6aa2b38f4fa8729b6d18551a54bb32d1fc80ce_0",
    "UID": "6097",
    "code": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t test_snippet\n                                         apr_bucket_brigade *bb)\n{\n    if (next) {\n        apr_bucket *e = APR_BRIGADE_LAST(bb);\n\n        if (e != APR_BRIGADE_SENTINEL(bb) && APR_BUCKET_IS_EOS(e) && next->r) {\n            /* This is only safe because HTTP_HEADER filter is always in\n             * the filter stack.   This ensures that there is ALWAYS a\n             * request-based filter that we can attach this to.  If the\n             * HTTP_FILTER is removed, and another filter is not put in its\n             * place, then handlers like mod_cgi, which attach their own\n             * EOS bucket to the brigade will be broken, because we will\n             * get two EOS buckets on the same request.\n             */\n            next->r->eos_sent = 1;\n\n            \n            if (next->r->prev) {\n                request_rec *prev = next->r->prev;\n\n                while (prev) {\n                    prev->eos_sent = 1;\n                    prev = prev->prev;\n                }\n            }\n        }\n        return next->frec->filter_func.out_func(next, bb);\n    }\n    return AP_NOBODY_WROTE;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_5042b123a8fd5b285c1e7090165100c2068782a8_0", {
    "ID": "httpd_5042b123a8fd5b285c1e7090165100c2068782a8_0",
    "UID": "6103",
    "code": "AP_DECLARE(int) ap_filter_prepare_brigade(ap_filter_t test_snippet\n{\n    conn_rec *c = f->c;\n    struct ap_filter_conn_ctx *x = get_conn_ctx(c);\n    struct ap_filter_private *fp = f->priv, *e;\n    struct pending_ring **ref, *pendings;\n    ap_filter_t *next;\n\n    if (is_pending_filter(f)) {\n        return DECLINED;\n    }\n\n    if (!fp->bb) {\n        fp->bb = ap_acquire_brigade(c);\n        if (f->r) {\n            /* Take care of request filters that don't remove themselves\n             * from the chain(s), when f->r is being destroyed.\n             */\n            apr_pool_cleanup_register(f->r->pool, f,\n                                      pending_filter_cleanup,\n                                      apr_pool_cleanup_null);\n        }\n        else {\n            /* In fp->bb there may be buckets on fp->deferred_pool, so take\n             * care to always pre_cleanup the former before the latter.\n             */\n            apr_pool_pre_cleanup_register(c->pool, f,\n                                          pending_filter_cleanup);\n        }\n    }\n\n    if (f->frec->direction == AP_FILTER_INPUT) {\n        ref = &x->pending_input_filters;\n    }\n    else {\n        ref = &x->pending_output_filters;\n    }\n    pendings = *ref;\n\n    /* Pending reads/writes must happen in the reverse order of the actual\n     * in/output filters (in/outer most first), though we still maintain the\n     * ring in the same \"next\" order as filters (walking is backward). So find\n     * the first f->next filter already in place and insert before if\n     * any, otherwise insert last.\n     */\n    if (pendings) {\n        for (next = f->next; next; next = next->next) {\n            for (e = APR_RING_FIRST(pendings);\n                 e != APR_RING_SENTINEL(pendings, ap_filter_private, pending);\n                 e = APR_RING_NEXT(e, pending)) {\n                if (e == next->priv) {\n                    APR_RING_INSERT_BEFORE(e, fp, pending);\n                    return OK;\n                }\n            }\n        }\n    }\n    else {\n        pendings = *ref = apr_palloc(c->pool, sizeof(*pendings));\n        APR_RING_INIT(pendings, ap_filter_private, pending);\n    }\n    APR_RING_INSERT_TAIL(pendings, fp, ap_filter_private, pending);\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_d42eab5eaef5ff5d2137d2346527034efaeb8690_0", {
    "ID": "httpd_d42eab5eaef5ff5d2137d2346527034efaeb8690_0",
    "UID": "6106",
    "code": "AP_DECLARE(apr_status_t) ap_filter_setaside_brigade(ap_filter_t test_snippet\n                                                    apr_bucket_brigade *bb)\n{\n    struct ap_filter_private *fp = f->priv;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, f->c,\n                  \"setaside %s brigade to %s brigade in '%s' output filter\",\n                  APR_BRIGADE_EMPTY(bb) ? \"empty\" : \"full\",\n                  (!fp->bb || APR_BRIGADE_EMPTY(fp->bb)) ? \"empty\" : \"full\",\n                  f->frec->name);\n\n    if (!APR_BRIGADE_EMPTY(bb)) {\n        /*\n         * Set aside the brigade bb within fp->bb.\n         */\n        ap_filter_prepare_brigade(f);\n\n        \n        if (f->r) {\n            apr_bucket *e;\n            for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb); e =\n                    APR_BUCKET_NEXT(e)) {\n                if (APR_BUCKET_IS_TRANSIENT(e)) {\n                    int rv = apr_bucket_setaside(e, f->r->pool);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n                }\n            }\n            APR_BRIGADE_CONCAT(fp->bb, bb);\n        }\n        else {\n            if (!fp->deferred_pool) {\n                apr_pool_create(&fp->deferred_pool, f->c->pool);\n                apr_pool_tag(fp->deferred_pool, \"deferred_pool\");\n            }\n            return ap_save_brigade(f, &fp->bb, &bb, fp->deferred_pool);\n        }\n\n    }\n    else if (fp->deferred_pool) {\n        /*\n         * There are no more requests in the pipeline. We can just clear the\n         * pool.\n         */\n        AP_DEBUG_ASSERT(fp->bb);\n        apr_brigade_cleanup(fp->bb);\n        apr_pool_clear(fp->deferred_pool);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_f095c284caf7e55e7f6da3c93aafb884b5505477_0", {
    "ID": "httpd_f095c284caf7e55e7f6da3c93aafb884b5505477_0",
    "UID": "6108",
    "code": "void ap_filter_adopt_brigade(ap_filter_t *f, apr_bucket_brigade test_snippet\n{\n    struct ap_filter_private *fp = f->priv;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, f->c,\n                  \"adopt %s brigade to %s brigade in '%s' output filter\",\n                  APR_BRIGADE_EMPTY(bb) ? \"empty\" : \"full\",\n                  (!fp->bb || APR_BRIGADE_EMPTY(fp->bb)) ? \"empty\" : \"full\",\n                  f->frec->name);\n\n    if (!APR_BRIGADE_EMPTY(bb)) {\n        ap_filter_prepare_brigade(f);\n        APR_BRIGADE_CONCAT(fp->bb, bb);\n    }\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_f63ea490fa13cc9c1d244c55d9042ed0884f755e_0", {
    "ID": "httpd_f63ea490fa13cc9c1d244c55d9042ed0884f755e_0",
    "UID": "6112",
    "code": "AP_DECLARE_NONSTD(int) ap_filter_output_pending(conn_rec test_snippet\n{\n    struct ap_filter_conn_ctx *x = c->filter_conn_ctx;\n    struct ap_filter_private *fp, *prev;\n    apr_bucket_brigade *bb;\n    int rc = DECLINED;\n\n    if (!x || !x->pending_output_filters) {\n        goto cleanup;\n    }\n\n    /* Flush outer most filters first for ap_filter_should_yield(f->next)\n     * to be relevant in the previous ones (e.g. ap_request_core_filter()\n     * won't pass its buckets if its next filters yield already).\n     */\n    bb = ap_acquire_brigade(c);\n    for (fp = APR_RING_LAST(x->pending_output_filters);\n         fp != APR_RING_SENTINEL(x->pending_output_filters,\n                                 ap_filter_private, pending);\n         fp = prev) {\n        /* If a filter removes itself from the filters stack (when run), it\n         * also orphans itself from the ring, so save \"prev\" here to avoid\n         * an infinite loop in this case.\n         */\n        prev = APR_RING_PREV(fp, pending);\n\n        AP_DEBUG_ASSERT(fp->bb);\n        if (!APR_BRIGADE_EMPTY(fp->bb)) {\n            ap_filter_t *f = fp->f;\n            apr_status_t rv;\n\n            rv = ap_pass_brigade(f, bb);\n            apr_brigade_cleanup(bb);\n\n            if (rv != APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00470)\n                        \"write failure in '%s' output filter\", f->frec->name);\n                rc = rv;\n                break;\n            }\n\n            if (fp->bb && !APR_BRIGADE_EMPTY(fp->bb)) {\n                rc = OK;\n                break;\n            }\n        }\n    }\n    ap_release_brigade(c, bb);\n\ncleanup:\n    /* All filters have returned, time to recycle/unleak ap_filter_t-s\n     * before leaving (i.e. make them reusable).\n     */\n    recycle_dead_filters(c);\n\n    return rc;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_1c0081834692307f0f4f5aaa139fec3ca87dd4b4_0", {
    "ID": "httpd_1c0081834692307f0f4f5aaa139fec3ca87dd4b4_0",
    "UID": "6113",
    "code": "AP_DECLARE_NONSTD(int) ap_filter_input_pending(conn_rec test_snippet\n{\n    struct ap_filter_conn_ctx *x = c->filter_conn_ctx;\n    struct ap_filter_private *fp;\n    int rc = DECLINED;\n\n    if (!x || !x->pending_input_filters) {\n        goto cleanup;\n    }\n\n    for (fp = APR_RING_LAST(x->pending_input_filters);\n         fp != APR_RING_SENTINEL(x->pending_input_filters,\n                                 ap_filter_private, pending);\n         fp = APR_RING_PREV(fp, pending)) {\n        apr_bucket *e;\n\n        /* if there is a leading non-morphing bucket\n         * in place, then we have data pending\n         */\n        AP_DEBUG_ASSERT(fp->bb);\n        e = APR_BRIGADE_FIRST(fp->bb);\n        if (e != APR_BRIGADE_SENTINEL(fp->bb)\n                && e->length != (apr_size_t)(-1)) {\n            rc = OK;\n            break;\n        }\n    }\n\ncleanup:\n    /* All filters have returned, time to recycle/unleak ap_filter_t-s\n     * before leaving (i.e. make them reusable).\n     */\n    recycle_dead_filters(c);\n\n    return rc;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_8109deed50252012caa2dd158db759a2dc419dea_0", {
    "ID": "httpd_8109deed50252012caa2dd158db759a2dc419dea_0",
    "UID": "6130",
    "code": "static void module_request_hook_participate(request_rec * r, module * test_snippet\n{\n    int i, comma = 0;\n\n    ap_rputs(\"<dt><strong>Request Phase Participation:</strong>\\n\", r);\n\n    for (i = 0; request_hooks[i].name; i++) {\n        module_participate(r, modp, &request_hooks[i], &comma);\n    }\n\n    if (!comma) {\n        ap_rputs(\"<tt> <em>none</em></tt>\", r);\n    }\n    ap_rputs(\"</dt>\\n\", r);\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_ca9a2cdb0d59954f585aba3b4b3c820423eebb0d_0", {
    "ID": "httpd_ca9a2cdb0d59954f585aba3b4b3c820423eebb0d_0",
    "UID": "6131",
    "code": "static int show_active_hooks(request_rec * test_snippet\n{\n    int i;\n    ap_rputs(\"<h2><a name=\\\"startup_hooks\\\">Startup Hooks</a></h2>\\n<dl>\", test_snippet;\n\n    for (i = 0; startup_hooks[i].name; i++) {\n        ap_rprintf(r, \"<dt><strong>%s:</strong>\\n <br /><tt>\\n\",\n                   startup_hooks[i].name);\n        dump_a_hook(r, startup_hooks[i].get);\n        ap_rputs(\"\\n  </tt>\\n</dt>\\n\", test_snippet;\n    }\n\n    ap_rputs\n        (\"</dl>\\n<hr />\\n<h2><a name=\\\"request_hooks\\\">Request Hooks</a></h2>\\n<dl>\",\n         test_snippet;\n\n    for (i = 0; request_hooks[i].name; i++) {\n        ap_rprintf(r, \"<dt><strong>%s:</strong>\\n <br /><tt>\\n\",\n                   request_hooks[i].name);\n        dump_a_hook(r, request_hooks[i].get);\n        ap_rputs(\"\\n  </tt>\\n</dt>\\n\", test_snippet;\n    }\n\n    ap_rputs\n        (\"</dl>\\n<hr />\\n<h2><a name=\\\"other_hooks\\\">Other Hooks</a></h2>\\n<dl>\",\n         test_snippet;\n\n    for (i = 0; other_hooks[i].name; i++) {\n        ap_rprintf(r, \"<dt><strong>%s:</strong>\\n <br /><tt>\\n\",\n                   other_hooks[i].name);\n        dump_a_hook(r, other_hooks[i].get);\n        ap_rputs(\"\\n  </tt>\\n</dt>\\n\", test_snippet;\n    }\n\n    ap_rputs(\"</dl>\\n<hr />\\n\", test_snippet;\n\n    return 0;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_d83be332d47a54454e9500786501bfeceaf71f05_0", {
    "ID": "httpd_d83be332d47a54454e9500786501bfeceaf71f05_0",
    "UID": "6132",
    "code": "PROXY_DECLARE(proxy_worker *) ap_proxy_balancer_get_best_worker(proxy_balancer test_snippet\n                                                                request_rec *r,\n                                                                proxy_is_best_callback_fn_t *is_best,\n                                                                void *baton)\n{\n    int i = 0;\n    int cur_lbset = 0;\n    int max_lbset = 0;\n    int unusable_workers = 0;\n    apr_pool_t *tpool = NULL;\n    apr_array_header_t *spares = NULL;\n    apr_array_header_t *standbys = NULL;\n    proxy_worker *worker = NULL;\n    proxy_worker *best_worker = NULL;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(10122)\n                 \"proxy: Entering %s for BALANCER (%s)\",\n                 balancer->lbmethod->name, balancer->s->name);\n\n    apr_pool_create(&tpool, r->pool);\n\n    spares = apr_array_make(tpool, 1, sizeof(proxy_worker*));\n    standbys = apr_array_make(tpool, 1, sizeof(proxy_worker*));\n\n    /* Process lbsets in order, only replacing unusable workers in a given lbset\n     * with available spares from the same lbset. Hot standbys will be used as a\n     * last resort when all other workers and spares are unavailable.\n     */\n    for (cur_lbset = 0; !best_worker && (cur_lbset <= max_lbset); cur_lbset++) {\n        unusable_workers = 0;\n        apr_array_clear(spares);\n        apr_array_clear(standbys);\n\n        for (i = 0; i < balancer->workers->nelts; i++) {\n            worker = APR_ARRAY_IDX(balancer->workers, i, proxy_worker *);\n\n            if (worker->s->lbset > max_lbset) {\n                max_lbset = worker->s->lbset;\n            }\n\n            if (worker->s->lbset != cur_lbset) {\n                continue;\n            }\n\n            /* A draining worker that is neither a spare nor a standby should be\n             * considered unusable to be replaced by spares.\n             */\n            if (PROXY_WORKER_IS_DRAINING(worker)) {\n                if (!PROXY_WORKER_IS_SPARE(worker) && !PROXY_WORKER_IS_STANDBY(worker)) {\n                    unusable_workers++;\n                }\n\n                continue;\n            }\n\n            /* If the worker is in error state run retry on that worker. It will\n             * be marked as operational if the retry timeout is elapsed.  The\n             * worker might still be unusable, but we try anyway.\n             */\n            if (!PROXY_WORKER_IS_USABLE(worker)) {\n                ap_proxy_retry_worker(\"BALANCER\", worker, r->server);\n            }\n\n            if (PROXY_WORKER_IS_SPARE(worker)) {\n                if (PROXY_WORKER_IS_USABLE(worker)) {\n                    APR_ARRAY_PUSH(spares, proxy_worker *) = worker;\n                }\n            }\n            else if (PROXY_WORKER_IS_STANDBY(worker)) {\n                if (PROXY_WORKER_IS_USABLE(worker)) {\n                    APR_ARRAY_PUSH(standbys, proxy_worker *) = worker;\n                }\n            }\n            else if (PROXY_WORKER_IS_USABLE(worker)) {\n              if (is_best(worker, best_worker, baton)) {\n                best_worker = worker;\n              }\n            }\n            else {\n                unusable_workers++;\n            }\n        }\n\n        \n        for (i = 0; (i < spares->nelts) && (i < unusable_workers); i++) {\n          worker = APR_ARRAY_IDX(spares, i, proxy_worker *);\n\n          if (is_best(worker, best_worker, baton)) {\n            best_worker = worker;\n          }\n        }\n\n        \n        if (!best_worker) {\n            for (i = 0; i < standbys->nelts; i++) {\n              worker = APR_ARRAY_IDX(standbys, i, proxy_worker *);\n\n              if (is_best(worker, best_worker, baton)) {\n                best_worker = worker;\n              }\n            }\n        }\n    }\n\n    apr_pool_destroy(tpool);\n\n    if (best_worker) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(10123)\n                     \"proxy: %s selected worker \\\"%s\\\" : busy %\" APR_SIZE_T_FMT \" : lbstatus %d\",\n                     balancer->lbmethod->name, best_worker->s->name, best_worker->s->busy, best_worker->s->lbstatus);\n    }\n\n    return best_worker;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_322c669f7c8ecc144bce142d0ed91495bdcd490d_0", {
    "ID": "httpd_322c669f7c8ecc144bce142d0ed91495bdcd490d_0",
    "UID": "6145",
    "code": "static int is_best_bytraffic(proxy_worker *current, proxy_worker *prev_best, void test_snippet\n{\n    apr_off_t *min_traffic = (apr_off_t *)baton;\n    apr_off_t traffic = (current->s->transferred / current->s->lbfactor)\n                        + (current->s->read / current->s->lbfactor);\n\n    if (!prev_best || (traffic < *min_traffic)) {\n        *min_traffic = traffic;\n\n        return TRUE;\n    }\n\n    return FALSE;\n}",
    "predicted": "369,Divide By Zero"
  },
  "httpd_2ed4f9fe826af9a37898b1d4dc9d56d793aaa691_0", {
    "ID": "httpd_2ed4f9fe826af9a37898b1d4dc9d56d793aaa691_0",
    "UID": "6146",
    "code": "APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(proxy, PROXY, int, test_snippet\n                                   (request_rec *r, request_rec *pr), (r, pr),\n                                   OK, DECLINED)",
    "predicted": "This piece of code doesn't provide enough context to identify a specific vulnerability. Please provide a more complete code snippet."
  },
  "httpd_0ddc61d792175926dbfde6664e5e4e87e52337a0_0", {
    "ID": "httpd_0ddc61d792175926dbfde6664e5e4e87e52337a0_0",
    "UID": "6153",
    "code": "static apr_status_t send_brigade_nonblocking(apr_socket_t test_snippet\n                                             apr_bucket_brigade *bb,\n                                             core_output_filter_ctx_t *ctx,\n                                             conn_rec *c)\n{\n    apr_status_t rv = APR_SUCCESS;\n    core_server_config *conf =\n        ap_get_core_module_config(c->base_server->module_config);\n    apr_size_t nvec = 0, nbytes = 0;\n    apr_bucket *bucket, *next;\n    const char *data;\n    apr_size_t length;\n\n    for (bucket = APR_BRIGADE_FIRST(bb);\n         bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        next = APR_BUCKET_NEXT(bucket);\n\n#if APR_HAS_SENDFILE\n        if (can_sendfile_bucket(bucket)) {\n            if (nvec > 0) {\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n                rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                if (rv != APR_SUCCESS) {\n                    goto cleanup;\n                }\n                nbytes = 0;\n                nvec = 0;\n            }\n            rv = sendfile_nonblocking(s, bucket, ctx, c);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n            continue;\n        }\n#endif \n\n        if (bucket->length) {\n            /* Non-blocking read first, in case this is a morphing\n             * bucket type. */\n            rv = apr_bucket_read(bucket, &data, &length, APR_NONBLOCK_READ);\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                \n                if (nvec) {\n                    rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                    if (rv != APR_SUCCESS) {\n                        goto cleanup;\n                    }\n                    nbytes = 0;\n                    nvec = 0;\n                }\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n\n                rv = apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);\n            }\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n\n            \n            next = APR_BUCKET_NEXT(bucket);\n        }\n\n        if (!bucket->length) {\n            /* Don't delete empty buckets until all the previous ones have been\n             * sent (nvec == 0); this must happen in sequence since metabuckets\n             * like EOR could free the data still pointed to by the iovec. So\n             * unless the latter is empty, let writev_nonblocking() cleanup the\n             * brigade in order.\n             */\n            if (!nvec) {\n                apr_bucket_delete(bucket);\n            }\n            continue;\n        }\n\n        \n        if (nvec == ctx->nvec) {\n            if (nvec == NVEC_MAX) {\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n                rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                if (rv != APR_SUCCESS) {\n                    goto cleanup;\n                }\n                nbytes = 0;\n                nvec = 0;\n            }\n            else {\n                struct iovec *newvec;\n                apr_size_t newn = nvec * 2;\n                if (newn < NVEC_MIN) {\n                    newn = NVEC_MIN;\n                }\n                else if (newn > NVEC_MAX) {\n                    newn = NVEC_MAX;\n                }\n                newvec = apr_palloc(c->pool, newn * sizeof(struct iovec));\n                if (nvec) {\n                    memcpy(newvec, ctx->vec, nvec * sizeof(struct iovec));\n                }\n                ctx->vec = newvec;\n                ctx->nvec = newn;\n            }\n        }\n        nbytes += length;\n        ctx->vec[nvec].iov_base = (void *)data;\n        ctx->vec[nvec].iov_len = length;\n        nvec++;\n\n        /* Flush above max threshold, unless the brigade still contains in\n         * memory buckets which we want to try writing in the same pass (if\n         * we are at the end of the brigade, the write will happen outside\n         * the loop anyway).\n         */\n        if (nbytes >= conf->flush_max_threshold\n                && next != APR_BRIGADE_SENTINEL(bb)\n                && !is_in_memory_bucket(next)) {\n            (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n            rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n            nbytes = 0;\n            nvec = 0;\n        }\n    }\n    if (nvec > 0) {\n        rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n    }\n\ncleanup:\n    (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_8be03c59fba499171c83757fce217cc0ab4fda37_0", {
    "ID": "httpd_8be03c59fba499171c83757fce217cc0ab4fda37_0",
    "UID": "6173",
    "code": "static void process_socket(apr_thread_t *thd, apr_pool_t * p, apr_socket_t * test_snippet\n                          event_conn_state_t * cs, int my_child_num,\n                          int my_thread_num)\n{\n    conn_rec *c;\n    long conn_id = ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);\n    int clogging = 0, from_wc_q = 0;\n    apr_status_t rv;\n    int rc = OK;\n\n    if (cs == NULL) {           \n        listener_poll_type *pt = apr_pcalloc(p, sizeof(*pt));\n        cs = apr_pcalloc(p, sizeof(event_conn_state_t));\n        cs->bucket_alloc = apr_bucket_alloc_create(p);\n        ap_create_sb_handle(&cs->sbh, p, my_child_num, my_thread_num);\n        c = ap_run_create_connection(p, ap_server_conf, test_snippet\n                                     conn_id, cs->sbh, cs->bucket_alloc);\n        if (!c) {\n            ap_queue_info_push_pool(worker_queue_info, p);\n            return;\n        }\n        apr_atomic_inc32(&connection_count);\n        apr_pool_cleanup_register(c->pool, cs, decrement_connection_count,\n                                  apr_pool_cleanup_null);\n        ap_set_module_config(c->conn_config, &mpm_event_module, cs);\n        c->current_thread = thd;\n        cs->c = c;\n        c->cs = &(cs->pub);\n        cs->p = p;\n        cs->sc = ap_get_module_config(ap_server_conf->module_config,\n                                      &mpm_event_module);\n        cs->pfd.desc_type = APR_POLL_SOCKET;\n        cs->pfd.reqevents = APR_POLLIN;\n        cs->pfd.desc.s = sock;\n        pt->type = PT_CSD;\n        pt->baton = cs;\n        cs->pfd.client_data = pt;\n        apr_pool_pre_cleanup_register(p, cs, ptrans_pre_cleanup);\n        TO_QUEUE_ELEM_INIT(cs);\n\n        ap_update_vhost_given_ip(c);\n\n        rc = ap_run_pre_connection(c, sock);\n        if (rc != OK && rc != DONE) {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(00469)\n                          \"process_socket: connection aborted\");\n            c->aborted = 1;\n        }\n\n        /**\n         * XXX If the platform does not have a usable way of bundling\n         * accept() with a socket readability check, like Win32,\n         * and there are measurable delays before the\n         * socket is readable due to the first data packet arriving,\n         * it might be better to create the cs on the listener thread\n         * with the state set to CONN_STATE_CHECK_REQUEST_LINE_READABLE\n         *\n         * FreeBSD users will want to enable the HTTP accept filter\n         * module in their kernel for the highest performance\n         * When the accept filter is active, sockets are kept in the\n         * kernel until a HTTP request is received.\n         */\n        cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n\n        cs->pub.sense = CONN_SENSE_DEFAULT;\n        rc = OK;\n    }\n    else {\n        c = cs->c;\n        ap_update_sb_handle(cs->sbh, my_child_num, my_thread_num);\n        notify_resume(cs, 0);\n        c->current_thread = thd;\n        \n        c->id = conn_id;\n    }\n\n    if (c->aborted) {\n        \n        cs->pub.state = CONN_STATE_LINGER;\n    }\n    else if (cs->pub.state >= CONN_STATE_LINGER) {\n        \n    }\n    else {\n        if (cs->pub.state == CONN_STATE_READ_REQUEST_LINE\n            /* If we have an input filter which 'clogs' the input stream,\n             * like mod_ssl used to, lets just do the normal read from input\n             * filters, like the Worker MPM does. Filters that need to write\n             * where they would otherwise read, or read where they would\n             * otherwise write, should set the sense appropriately.\n             */\n             || c->clogging_input_filters) {\nread_request:\n            clogging = c->clogging_input_filters;\n            if (clogging) {\n                apr_atomic_inc32(&clogged_count);\n            }\n            rc = ap_run_process_connection(c);\n            if (clogging) {\n                apr_atomic_dec32(&clogged_count);\n            }\n            if (cs->pub.state > CONN_STATE_LINGER) {\n                cs->pub.state = CONN_STATE_LINGER;\n            }\n            if (rc == DONE) {\n                rc = OK;\n            }\n        }\n        else if (cs->pub.state == CONN_STATE_WRITE_COMPLETION) {\n            from_wc_q = 1;\n        }\n    }\n    /*\n     * The process_connection hooks above should set the connection state\n     * appropriately upon return, for event MPM to either:\n     * - do lingering close (CONN_STATE_LINGER),\n     * - wait for readability of the next request with respect to the keepalive\n     *   timeout (state CONN_STATE_CHECK_REQUEST_LINE_READABLE),\n     * - wait for read/write-ability of the underlying socket with respect to\n     *   its timeout by setting c->clogging_input_filters to 1 and the sense\n     *   to CONN_SENSE_WANT_READ/WRITE (state CONN_STATE_WRITE_COMPLETION),\n     * - keep flushing the output filters stack in nonblocking mode, and then\n     *   if required wait for read/write-ability of the underlying socket with\n     *   respect to its own timeout (state CONN_STATE_WRITE_COMPLETION); since\n     *   completion at some point may require reads (e.g. SSL_ERROR_WANT_READ),\n     *   an output filter can also set the sense to CONN_SENSE_WANT_READ at any\n     *   time for event MPM to do the right thing,\n     * - suspend the connection (SUSPENDED) such that it now interracts with\n     *   the MPM through suspend/resume_connection() hooks, and/or registered\n     *   poll callbacks (PT_USER), and/or registered timed callbacks triggered\n     *   by timer events.\n     * If a process_connection hook returns an error or no hook sets the state\n     * to one of the above expected value, we forcibly close the connection w/\n     * CONN_STATE_LINGER.  This covers the cases where no process_connection\n     * hook executes (DECLINED), or one returns OK w/o touching the state (i.e.\n     * CONN_STATE_READ_REQUEST_LINE remains after the call) which can happen\n     * with third-party modules not updated to work specifically with event MPM\n     * while this was expected to do lingering close unconditionally with\n     * worker or prefork MPMs for instance.\n     */\n    if (rc != OK || (cs->pub.state >= CONN_STATE_NUM)\n                 || (cs->pub.state < CONN_STATE_LINGER\n                     && cs->pub.state != CONN_STATE_WRITE_COMPLETION\n                     && cs->pub.state != CONN_STATE_CHECK_REQUEST_LINE_READABLE\n                     && cs->pub.state != CONN_STATE_SUSPENDED)) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(10111)\n                      \"process_socket: connection processing %s: closing\",\n                      rc ? apr_psprintf(c->pool, \"returned error %i\", rc)\n                         : apr_psprintf(c->pool, \"unexpected state %i\",\n                                                 (int)cs->pub.state));\n        cs->pub.state = CONN_STATE_LINGER;\n    }\n\n    if (cs->pub.state == CONN_STATE_WRITE_COMPLETION) {\n        int pending = DECLINED;\n\n        ap_update_child_status(cs->sbh, SERVER_BUSY_WRITE, NULL);\n\n        if (from_wc_q) {\n            from_wc_q = 0; \n            pending = ap_run_output_pending(c);\n        }\n        else if (ap_filter_should_yield(c->output_filters)) {\n            pending = OK;\n        }\n        if (pending == OK) {\n            /* Still in WRITE_COMPLETION_STATE:\n             * Set a write timeout for this connection, and let the\n             * event thread poll for writeability.\n             */\n            cs->queue_timestamp = apr_time_now();\n            notify_suspend(cs);\n\n            if (cs->pub.sense == CONN_SENSE_WANT_READ) {\n                cs->pfd.reqevents = APR_POLLIN;\n            }\n            else {\n                cs->pfd.reqevents = APR_POLLOUT;\n            }\n            /* POLLHUP/ERR are usually returned event only (ignored here), but\n             * some pollset backends may require them in reqevents to do the\n             * right thing, so it shouldn't hurt.\n             */\n            cs->pfd.reqevents |= APR_POLLHUP | APR_POLLERR;\n            cs->pub.sense = CONN_SENSE_DEFAULT;\n\n            apr_thread_mutex_lock(timeout_mutex);\n            TO_QUEUE_APPEND(cs->sc->wc_q, cs);\n            rv = apr_pollset_add(event_pollset, &cs->pfd);\n            if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n                AP_DEBUG_ASSERT(0);\n                TO_QUEUE_REMOVE(cs->sc->wc_q, cs);\n                apr_thread_mutex_unlock(timeout_mutex);\n                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03465)\n                             \"process_socket: apr_pollset_add failure for \"\n                             \"write completion\");\n                apr_socket_close(cs->pfd.desc.s);\n                ap_queue_info_push_pool(worker_queue_info, cs->p);\n            }\n            else {\n                apr_thread_mutex_unlock(timeout_mutex);\n            }\n            return;\n        }\n        if (pending != DECLINED\n                || c->aborted\n                || c->keepalive != AP_CONN_KEEPALIVE\n                || listener_may_exit) {\n            cs->pub.state = CONN_STATE_LINGER;\n        }\n        else if (ap_run_input_pending(c) == OK) {\n            cs->pub.state = CONN_STATE_READ_REQUEST_LINE;\n            goto read_request;\n        }\n        else {\n            cs->pub.state = CONN_STATE_CHECK_REQUEST_LINE_READABLE;\n        }\n    }\n\n    if (cs->pub.state == CONN_STATE_CHECK_REQUEST_LINE_READABLE) {\n        ap_update_child_status(cs->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n\n        /* It greatly simplifies the logic to use a single timeout value per q\n         * because the new element can just be added to the end of the list and\n         * it will stay sorted in expiration time sequence.  If brand new\n         * sockets are sent to the event thread for a readability check, this\n         * will be a slight behavior change - they use the non-keepalive\n         * timeout today.  With a normal client, the socket will be readable in\n         * a few milliseconds anyway.\n         */\n        cs->queue_timestamp = apr_time_now();\n        notify_suspend(cs);\n\n        \n        cs->pfd.reqevents = APR_POLLIN;\n        apr_thread_mutex_lock(timeout_mutex);\n        TO_QUEUE_APPEND(cs->sc->ka_q, cs);\n        rv = apr_pollset_add(event_pollset, &cs->pfd);\n        if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n            AP_DEBUG_ASSERT(0);\n            TO_QUEUE_REMOVE(cs->sc->ka_q, cs);\n            apr_thread_mutex_unlock(timeout_mutex);\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03093)\n                         \"process_socket: apr_pollset_add failure for \"\n                         \"keep alive\");\n            apr_socket_close(cs->pfd.desc.s);\n            ap_queue_info_push_pool(worker_queue_info, cs->p);\n        }\n        else {\n            apr_thread_mutex_unlock(timeout_mutex);\n        }\n        return;\n    }\n\n    if (cs->pub.state == CONN_STATE_SUSPENDED) {\n        cs->c->suspended_baton = cs;\n        apr_atomic_inc32(&suspended_count);\n        notify_suspend(cs);\n        return;\n    }\n\n    if (cs->pub.state == CONN_STATE_LINGER) {\n        rc = start_lingering_close_blocking(cs);\n    }\n    if (rc == OK && (cs->pub.state == CONN_STATE_LINGER_NORMAL ||\n                     cs->pub.state == CONN_STATE_LINGER_SHORT)) {\n        process_lingering_close(cs);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c843d5fa6bc6cf68f134b525e430aa92a5d608ed_0", {
    "ID": "httpd_c843d5fa6bc6cf68f134b525e430aa92a5d608ed_0",
    "UID": "6182",
    "code": "static int stream_reqbody_chunked(proxy_http_req_t test_snippet\n{\n    request_rec *r = req->r;\n    int seen_eos = 0, rv = OK;\n    apr_size_t hdr_len;\n    apr_off_t bytes;\n    apr_status_t status;\n    char chunk_hdr[20];  \n    proxy_conn_rec *p_conn = req->backend;\n    apr_bucket_alloc_t *bucket_alloc = req->bucket_alloc;\n    apr_bucket_brigade *header_brigade = req->header_brigade;\n    apr_bucket_brigade *input_brigade = req->input_brigade;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n\n    while (APR_BRIGADE_EMPTY(input_brigade)\n           || !APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(input_brigade)))\n    {\n        int flush = req->flushall;\n\n        if (!APR_BRIGADE_EMPTY(input_brigade)) {\n            \n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                seen_eos = 1;\n\n                \n                e = APR_BRIGADE_LAST(input_brigade);\n                apr_bucket_delete(e);\n            }\n\n            apr_brigade_length(input_brigade, 1, &bytes);\n\n            \n            if (bytes < HUGE_STRING_LEN) {\n                flush = 0;\n            }\n\n            hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\n                                   \"%\" APR_UINT64_T_HEX_FMT CRLF,\n                                   (apr_uint64_t)bytes);\n\n            ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);\n            e = apr_bucket_transient_create(chunk_hdr, hdr_len,\n                                            bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(input_brigade, e);\n\n            /*\n             * Append the end-of-chunk CRLF\n             */\n            e = apr_bucket_immortal_create(CRLF_ASCII, 2, bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n        }\n\n        if (!APR_BRIGADE_EMPTY(header_brigade)) {\n            /* we never sent the header brigade, so go ahead and\n             * take care of that now\n             */\n            bb = header_brigade;\n            APR_BRIGADE_CONCAT(bb, input_brigade);\n\n            /* Flush now since we have the header and (enough of) the\n             * prefeched body, or racing KeepAliveTimeout on the backend\n             * side may kill our connection while we read more client data.\n             */\n            flush = 1;\n        }\n        else {\n            bb = input_brigade;\n        }\n\n        \n        rv = ap_proxy_pass_brigade(bucket_alloc, r, p_conn, req->origin,\n                                   bb, flush && !seen_eos);\n        if (rv != OK) {\n            return rv;\n        }\n\n        if (seen_eos) {\n            break;\n        }\n\n        status = ap_get_brigade(r->input_filters, input_brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                HUGE_STRING_LEN);\n\n        if (status != APR_SUCCESS) {\n            conn_rec *c = r->connection;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(02608)\n                          \"read request body failed to %pI (%s)\"\n                          \" from %s (%s)\", p_conn->addr,\n                          p_conn->hostname ? p_conn->hostname: \"\",\n                          c->client_ip, c->remote_host ? c->remote_host: \"\");\n            return ap_map_http_request_error(status, HTTP_BAD_REQUEST);\n        }\n    }\n\n    if (!APR_BRIGADE_EMPTY(header_brigade)) {\n        /* we never sent the header brigade because there was no request body;\n         * send it now\n         */\n        bb = header_brigade;\n    }\n    else {\n        if (!APR_BRIGADE_EMPTY(input_brigade)) {\n            \n            e = APR_BRIGADE_LAST(input_brigade);\n            AP_DEBUG_ASSERT(APR_BUCKET_IS_EOS(e));\n            apr_bucket_delete(e);\n        }\n        bb = input_brigade;\n    }\n\n    e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                   \n                                   CRLF_ASCII,\n                                   5, bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n\n    if (apr_table_get(r->subprocess_env, \"proxy-sendextracrlf\")) {\n        e = apr_bucket_immortal_create(CRLF_ASCII, 2, bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n    }\n\n    \n    return ap_proxy_pass_brigade(bucket_alloc, r, p_conn, req->origin, bb, 1);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e5a435806b6cd08b14647cea174a4e1ba5e029dc_0", {
    "ID": "httpd_e5a435806b6cd08b14647cea174a4e1ba5e029dc_0",
    "UID": "6193",
    "code": "static int slotmem_filenames(apr_pool_t test_snippet\n                             const char *slotname,\n                             const char **filename,\n                             const char **persistname)\n{\n    const char *fname = NULL, *pname = NULL;\n\n    if (slotname && *slotname && strcasecmp(slotname, \"none\") != 0) {\n        if (slotname[0] != '/') {\n            fname = apr_pstrcat(pool, DEFAULT_SLOTMEM_PREFIX,\n                                slotname, DEFAULT_SLOTMEM_SUFFIX,\n                                NULL);\n            fname = ap_runtime_dir_relative(pool, fname);\n        }\n        else {\n            /* Don't mangle the file name if given an absolute path, it's\n             * up to the caller to provide a unique name when necessary.\n             */\n            fname = slotname;\n        }\n\n        if (persistname) {\n            pname = apr_pstrcat(pool, fname,\n                                DEFAULT_SLOTMEM_PERSIST_SUFFIX,\n                                NULL);\n        }\n    }\n\n    *filename = fname;\n    if (persistname) {\n        *persistname = pname;\n    }\n    return (fname != NULL);\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_f5ad78fcd297875165f4649fa9898da9644ccd21_0", {
    "ID": "httpd_f5ad78fcd297875165f4649fa9898da9644ccd21_0",
    "UID": "6200",
    "code": "static apr_array_header_t *make_servers_ids(server_rec *main_s, apr_pool_t test_snippet\n{\n    server_rec *s = main_s;\n    apr_array_header_t *ids = apr_array_make(p, 10, sizeof(const char *));\n    apr_hash_t *dups = apr_hash_make(p);\n    int idx, *dup, full_monty = 0;\n    const char *id;\n\n    for (idx = 0, s = main_s; s; s = s->next, ++idx) {\n        id = make_server_id(s, p, 0);\n        dup = apr_hash_get(dups, id, APR_HASH_KEY_STRING);\n        apr_hash_set(dups, id, APR_HASH_KEY_STRING,\n                     apr_pmemdup(p, &idx, sizeof(int)));\n        if (dup) {\n            full_monty = 1;\n            APR_ARRAY_IDX(ids, *dup, const char *) = NULL;\n            APR_ARRAY_PUSH(ids, const char *) = NULL;\n        }\n        else {\n            APR_ARRAY_PUSH(ids, const char *) = id;\n        }\n    }\n    if (full_monty) {\n        apr_hash_clear(dups);\n        for (idx = 0, s = main_s; s; s = s->next, ++idx) {\n            id = APR_ARRAY_IDX(ids, idx, const char *);\n            if (id) {\n                \n                continue;\n            }\n            id = make_server_id(s, p, 1);\n            if (apr_hash_get(dups, id, APR_HASH_KEY_STRING)) {\n                id = apr_psprintf(p, \"%s_%x\", id, idx);\n            }\n            else {\n                apr_hash_set(dups, id, APR_HASH_KEY_STRING, (void *)-1);\n            }\n            APR_ARRAY_IDX(ids, idx, const char *) = id;\n        }\n    }\n\n    return ids;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_dd9b6213da2c15d49867db31d9087775d553daf8_0", {
    "ID": "httpd_dd9b6213da2c15d49867db31d9087775d553daf8_0",
    "UID": "6215",
    "code": "static void process_lingering_close(event_conn_state_t test_snippet\n{\n    apr_socket_t *csd = ap_get_conn_socket(cs->c);\n    char dummybuf[LINGERING_BUF_SIZE];\n    apr_size_t nbytes;\n    apr_status_t rv;\n    struct timeout_queue *q;\n\n    \n    do {\n        nbytes = sizeof(dummybuf);\n        rv = apr_socket_recv(csd, dummybuf, &nbytes);\n    } while (rv == APR_SUCCESS);\n\n    if (!APR_STATUS_IS_EAGAIN(rv)) {\n        rv = apr_socket_close(csd);\n        AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n        ap_queue_info_push_pool(worker_queue_info, cs->p);\n        return;\n    }\n\n    \n    cs->pfd.reqevents = APR_POLLIN;\n    cs->pub.sense = CONN_SENSE_DEFAULT;\n    q = (cs->pub.state == CONN_STATE_LINGER_SHORT) ? short_linger_q : linger_q;\n    apr_thread_mutex_lock(timeout_mutex);\n    TO_QUEUE_APPEND(q, cs);\n    rv = apr_pollset_add(event_pollset, &cs->pfd);\n    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n        AP_DEBUG_ASSERT(0);\n        TO_QUEUE_REMOVE(q, cs);\n        apr_thread_mutex_unlock(timeout_mutex);\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03092)\n                     \"process_lingering_close: apr_pollset_add failure\");\n        rv = apr_socket_close(cs->pfd.desc.s);\n        AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n        ap_queue_info_push_pool(worker_queue_info, cs->p);\n        return;\n    }\n    apr_thread_mutex_unlock(timeout_mutex);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_690a2fa0e1ba38503ae4609f5221ee08d2de5168_0", {
    "ID": "httpd_690a2fa0e1ba38503ae4609f5221ee08d2de5168_0",
    "UID": "6262",
    "code": "static test_snippet\nforward_dns_check_authorization(request_rec *r,\n                                const char *require_line,\n                                const void *parsed_require_line)\n{\n    const char *err = NULL;\n    const ap_expr_info_t *expr = parsed_require_line;\n    const char *require, *t;\n    char *w;\n\n    \n    require = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n      ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03354)\n                    \"Can't evaluate require expression: %s\", err);\n      return AUTHZ_DENIED;\n    }\n\n    \n    t = require;\n    while ((w = ap_getword_conf(r->pool, &t)) && w[0]) {\n\n        apr_sockaddr_t *sa;\n        apr_status_t rv;\n        char *hash_ptr;\n\n        \n        if ((hash_ptr = ap_strchr(w, '#'))) {\n            if (hash_ptr == w) {\n                break;\n            }\n            *hash_ptr = '\\0';\n        }\n\n        \n        rv = apr_sockaddr_info_get(&sa, w, APR_UNSPEC, 0, 0, r->pool);\n        if (rv == APR_SUCCESS) {\n\n            while (sa) {\n                int match = apr_sockaddr_equal(sa, r->useragent_addr);\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03355)\n                              \"access check for %s as '%s': %s\",\n                              r->useragent_ip, w, match? \"yes\": \"no\");\n                if (match) {\n                    return AUTHZ_GRANTED;\n                }\n\n                sa = sa->next;\n            }\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(03356)\n                          \"No sockaddr info for \\\"%s\\\"\", w);\n        }\n\n        \n        if (hash_ptr) {\n            break;\n        }\n    }\n\n    return AUTHZ_DENIED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_21bff094c77a38677ffd9e8bbe19285424547cec_0", {
    "ID": "httpd_21bff094c77a38677ffd9e8bbe19285424547cec_0",
    "UID": "6274",
    "code": "test_snippetstest_snippetttest_snippetatest_snippetttest_snippetitest_snippetctest_snippet test_snippetvtest_snippetotest_snippetitest_snippetdtest_snippet test_snippetstest_snippetptest_snippetltest_snippetitest_snippetttest_snippetotest_snippetutest_snippetttest_snippet_test_snippetqtest_snippetutest_snippetetest_snippetrtest_snippetytest_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet(test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetrtest_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetqtest_snippetstest_snippetatest_snippetptest_snippetptest_snippetetest_snippetntest_snippetdtest_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetqtest_snippetstest_snippetdtest_snippetitest_snippetstest_snippetctest_snippetatest_snippetrtest_snippetdtest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetqtest_snippetstest_snippetltest_snippetatest_snippetstest_snippetttest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetqtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetstest_snippetptest_snippetltest_snippetitest_snippetttest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetdtest_snippetotest_snippetntest_snippet'test_snippetttest_snippet test_snippetttest_snippetotest_snippetutest_snippetctest_snippethtest_snippet,test_snippet test_snippetutest_snippetntest_snippetltest_snippetetest_snippetstest_snippetstest_snippet test_snippetitest_snippetttest_snippet'test_snippetstest_snippet test_snippetatest_snippet test_snippetstest_snippetctest_snippethtest_snippetetest_snippetmtest_snippetetest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetwtest_snippethtest_snippetitest_snippetctest_snippethtest_snippet test_snippetatest_snippet test_snippetqtest_snippetutest_snippetetest_snippetrtest_snippetytest_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet test_snippetmtest_snippetatest_snippetktest_snippetetest_snippetstest_snippet test_snippetstest_snippetetest_snippetntest_snippetstest_snippetetest_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetStest_snippetetest_snippetetest_snippet test_snippetRtest_snippetFtest_snippetCtest_snippet test_snippet1test_snippet7test_snippet3test_snippet8test_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetRtest_snippetFtest_snippetCtest_snippet test_snippet2test_snippet3test_snippet6test_snippet8test_snippet.test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetitest_snippetstest_snippet_test_snippetatest_snippetbtest_snippetstest_snippetotest_snippetltest_snippetutest_snippetttest_snippetetest_snippet_test_snippetutest_snippetrtest_snippetitest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet&test_snippetstest_snippetptest_snippetltest_snippetitest_snippetttest_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet&test_snippet&test_snippet test_snippet!test_snippetstest_snippetptest_snippetltest_snippetitest_snippetttest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet test_snippet/test_snippet*test_snippet test_snippetftest_snippetotest_snippetrtest_snippetgtest_snippetetest_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetqtest_snippetutest_snippetetest_snippetrtest_snippetytest_snippet test_snippetttest_snippethtest_snippetatest_snippetttest_snippet'test_snippetstest_snippet test_snippetstest_snippetttest_snippetitest_snippetltest_snippetltest_snippet test_snippetftest_snippetltest_snippetytest_snippetitest_snippetntest_snippetgtest_snippet test_snippetatest_snippetrtest_snippetotest_snippetutest_snippetntest_snippetdtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet test_snippetqtest_snippetstest_snippetdtest_snippetitest_snippetstest_snippetctest_snippetatest_snippetrtest_snippetdtest_snippet test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet test_snippet/test_snippet*test_snippet test_snippetDtest_snippetitest_snippetstest_snippetctest_snippetatest_snippetrtest_snippetdtest_snippet test_snippetqtest_snippetutest_snippetetest_snippetrtest_snippetytest_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetwtest_snippetrtest_snippetitest_snippetttest_snippetetest_snippetltest_snippetotest_snippetgtest_snippet(test_snippet(test_snippetrtest_snippet,test_snippet test_snippet2test_snippet,test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet,test_snippet test_snippet\"test_snippetdtest_snippetitest_snippetstest_snippetctest_snippetatest_snippetrtest_snippetdtest_snippetitest_snippetntest_snippetgtest_snippet test_snippetqtest_snippetutest_snippetetest_snippetrtest_snippetytest_snippet test_snippetstest_snippetttest_snippetrtest_snippetitest_snippetntest_snippetgtest_snippet\"test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetqtest_snippet test_snippet=test_snippet test_snippetqtest_snippetstest_snippetltest_snippetatest_snippetstest_snippetttest_snippet test_snippet?test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet'test_snippet?test_snippet'test_snippet)test_snippet test_snippet:test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetttest_snippetrtest_snippetctest_snippethtest_snippetrtest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippet'test_snippet?test_snippet'test_snippet)test_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetqtest_snippet test_snippet!test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetotest_snippetltest_snippetdtest_snippetutest_snippetrtest_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetitest_snippetztest_snippetetest_snippet_test_snippetttest_snippet test_snippetltest_snippetetest_snippetntest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetotest_snippetltest_snippetdtest_snippetutest_snippetrtest_snippetitest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetqtest_snippet+test_snippet+test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetqtest_snippetstest_snippetatest_snippetptest_snippetptest_snippetetest_snippetntest_snippetdtest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet*test_snippetqtest_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetctest_snippetatest_snippetttest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetqtest_snippet,test_snippet test_snippet\"test_snippet&test_snippet\"test_snippet test_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet,test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetstest_snippetttest_snippetrtest_snippetdtest_snippetutest_snippetptest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetqtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet)test_snippet test_snippet{test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetltest_snippetetest_snippetntest_snippet test_snippet=test_snippet test_snippetstest_snippetttest_snippetrtest_snippetltest_snippetetest_snippetntest_snippet(test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetltest_snippetetest_snippetntest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet[test_snippetltest_snippetetest_snippetntest_snippet-test_snippet1test_snippet]test_snippet test_snippet=test_snippet=test_snippet test_snippet'test_snippet&test_snippet'test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet[test_snippetltest_snippetetest_snippetntest_snippet-test_snippet1test_snippet]test_snippet test_snippet=test_snippet test_snippet'test_snippet\\test_snippet0test_snippet'test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetwtest_snippetrtest_snippetitest_snippetttest_snippetetest_snippetltest_snippetotest_snippetgtest_snippet(test_snippet(test_snippetrtest_snippet,test_snippet test_snippet3test_snippet,test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet,test_snippet test_snippet\"test_snippetstest_snippetptest_snippetltest_snippetitest_snippetttest_snippet test_snippetutest_snippetrtest_snippetitest_snippet=test_snippet%test_snippetstest_snippet test_snippet-test_snippet>test_snippet test_snippetutest_snippetrtest_snippetitest_snippet=test_snippet%test_snippetstest_snippet,test_snippet test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet=test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippetotest_snippetltest_snippetdtest_snippetutest_snippetrtest_snippetitest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippet-test_snippet>test_snippetftest_snippetitest_snippetltest_snippetetest_snippetntest_snippetatest_snippetmtest_snippetetest_snippet,test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet?test_snippet test_snippetrtest_snippet-test_snippet>test_snippetatest_snippetrtest_snippetgtest_snippetstest_snippet test_snippet:test_snippet test_snippet\"test_snippet<test_snippetntest_snippetotest_snippetntest_snippetetest_snippet>test_snippet\"test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n20,Improper Input Validation\n"
  },
  "httpd_51cafa81f66b4a75e890b6f831ebb99f1a39d80a_0", {
    "ID": "httpd_51cafa81f66b4a75e890b6f831ebb99f1a39d80a_0",
    "UID": "6280",
    "code": "static void note_digest_auth_failure(request_rec test_snippet\n                                     const digest_config_rec *conf,\n                                     digest_header_rec *resp, int stale)\n{\n    const char   *qop, *opaque, *opaque_param, *domain, *nonce;\n\n    \n    if (apr_is_empty_array(conf->qop_list)) {\n        qop = \", qop=\\\"auth\\\"\";\n    }\n    else if (!ap_casecmpstr(*(const char **)(conf->qop_list->elts), \"none\")) {\n        qop = \"\";\n    }\n    else {\n        qop = apr_pstrcat(r->pool, \", qop=\\\"\",\n                                   apr_array_pstrcat(r->pool, conf->qop_list, ','),\n                                   \"\\\"\",\n                                   NULL);\n    }\n\n    \n\n    if (resp->opaque == NULL) {\n        \n        if ((conf->check_nc || conf->nonce_lifetime == 0)\n            && (resp->client = gen_client(r)) != NULL) {\n            opaque = ltox(r->pool, resp->client->key);\n        }\n        else {\n            opaque = \"\";                \n        }\n    }\n    else if (resp->client == NULL) {\n        \n        resp->client = gen_client(r);\n        if (resp->client != NULL) {\n            opaque = ltox(r->pool, resp->client->key);\n            stale = 1;\n            client_list->num_renewed++;\n        }\n        else {\n            opaque = \"\";                \n        }\n    }\n    else {\n        opaque = resp->opaque;\n        \n        resp->client->nonce_count = 0;\n    }\n\n    if (opaque[0]) {\n        opaque_param = apr_pstrcat(r->pool, \", opaque=\\\"\", opaque, \"\\\"\", NULL);\n    }\n    else {\n        opaque_param = NULL;\n    }\n\n    \n\n    nonce = gen_nonce(r->pool, r->request_time, opaque, r->server, conf, ap_auth_name(r));\n    if (resp->client && conf->nonce_lifetime == 0) {\n        memcpy(resp->client->last_nonce, nonce, NONCE_LEN+1);\n    }\n\n    /* setup domain attribute. We want to send this attribute wherever\n     * possible so that the client won't send the Authorization header\n     * unnecessarily (it's usually > 200 bytes!).\n     */\n\n\n    /* don't send domain\n     * - for proxy requests\n     * - if it's not specified\n     */\n    if (r->proxyreq || !conf->uri_list) {\n        domain = NULL;\n    }\n    else {\n        domain = conf->uri_list;\n    }\n\n    apr_table_mergen(r->err_headers_out,\n                     (PROXYREQ_PROXY == r->proxyreq)\n                         ? \"Proxy-Authenticate\" : \"WWW-Authenticate\",\n                     apr_psprintf(r->pool, \"Digest realm=\\\"%s\\\", \"\n                                  \"nonce=\\\"%s\\\", algorithm=%s%s%s%s%s\",\n                                  ap_auth_name(r), nonce, conf->algorithm,\n                                  opaque_param ? opaque_param : \"\",\n                                  domain ? domain : \"\",\n                                  stale ? \", stale=true\" : \"\", qop));\n\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_026a325c3c7d471264e1e188f70cb49e4a6f2697_0", {
    "ID": "httpd_026a325c3c7d471264e1e188f70cb49e4a6f2697_0",
    "UID": "6285",
    "code": "static int read_request_line(request_rec *r, apr_bucket_brigade test_snippet\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n\n    unsigned int major = 1, minor = 0;   \n    char http[5];\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT;\n    int enforce_strict = !(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY);\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (APR_STATUS_IS_ENOSPC(rv)) {\n                r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else if (APR_STATUS_IS_EINVAL(rv)) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            r->proto_num = HTTP_VERSION(1,0);\n            r->protocol  = \"HTTP/1.0\";\n            return 0;\n        }\n    } while ((len <= 0) && (--num_blank_lines >= 0));\n\n    if (APLOGrtrace5(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                      \"Request received from client: %s\",\n                      ap_escape_logitem(r->pool, r->the_request));\n    }\n\n    r->request_time = apr_time_now();\n    ll = r->the_request;\n    r->method = ap_getword_white(r->pool, &ll);\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    if (!*r->method || !*uri) {\n        r->status    = HTTP_BAD_REQUEST;\n        r->proto_num = HTTP_VERSION(1,0);\n        r->protocol  = \"HTTP/1.0\";\n        return 0;\n    }\n\n    \n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n    if (r->status != HTTP_OK) {\n        r->proto_num = HTTP_VERSION(1,0);\n        r->protocol  = \"HTTP/1.0\";\n        return 0;\n    }\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n        if (conf->http09_enable == AP_HTTP09_DISABLE) {\n                r->status = HTTP_VERSION_NOT_SUPPORTED;\n                r->protocol = apr_pstrmemdup(r->pool, pro, len);\n                \n                r->assbackwards = 0;\n                r->proto_num = HTTP_VERSION(0, 9);\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)\n                              \"HTTP/0.9 denied by server configuration\");\n                return 0;\n        }\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    \n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else {\n        if (strict) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                          \"Invalid protocol '%s'\", r->protocol);\n            if (enforce_strict) {\n                r->proto_num = HTTP_VERSION(1,0);\n                r->protocol  = \"HTTP/1.0\";\n                r->connection->keepalive = AP_CONN_CLOSE;\n                r->status = HTTP_BAD_REQUEST;\n                return 0;\n            }\n        }\n        if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n            && (ap_casecmpstr(\"http\", http) == 0)\n            && (minor < HTTP_VERSION(1, 0)) ) { \n            r->proto_num = HTTP_VERSION(major, minor);\n        }\n        else {\n            r->proto_num = HTTP_VERSION(1, 0);\n        }\n    }\n\n    if (strict) {\n        int err = 0;\n        if (ap_has_cntrl(r->the_request)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02420)\n                          \"Request line must not contain control characters\");\n            err = HTTP_BAD_REQUEST;\n        }\n        if (r->parsed_uri.fragment) {\n            \n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02421)\n                          \"URI must not contain a fragment\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->parsed_uri.user || r->parsed_uri.password) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)\n                          \"URI must not contain a username/password\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->method_number == M_INVALID) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02423)\n                          \"Invalid HTTP method string: %s\", r->method);\n            err = HTTP_NOT_IMPLEMENTED;\n        }\n        else if (r->assbackwards == 0 && r->proto_num < HTTP_VERSION(1, 0)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02424)\n                          \"HTTP/0.x does not take a protocol\");\n            err = HTTP_BAD_REQUEST;\n        }\n\n        if (err && enforce_strict) {\n            r->status = err;\n            return 0;\n        }\n    }\n\n    return 1;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n"
  },
  "httpd_397f7de54b8aff83c4aef4026450cd16131a8d3f_0", {
    "ID": "httpd_397f7de54b8aff83c4aef4026450cd16131a8d3f_0",
    "UID": "6289",
    "code": "static const char *unset_define(cmd_parms *cmd, void test_snippet\n                                const char *name)\n{\n    int i;\n    char **defines;\n    if (cmd->parent && ap_casecmpstr(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n\n    defines = (char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            defines[i] = *(char **)apr_array_pop(ap_server_config_defines);\n            break;\n        }\n    }\n\n    if (server_config_defined_vars) {\n        apr_table_unset(server_config_defined_vars, name);\n    }\n\n    return NULL;\n}",
    "predicted": "415,Double Free\n416,Use After Free"
  },
  "httpd_c3bd9f052efe87cf3616538a20fe2c015ae3d4e6_0", {
    "ID": "httpd_c3bd9f052efe87cf3616538a20fe2c015ae3d4e6_0",
    "UID": "6292",
    "code": "static apr_status_t event_register_poll_callback_ex(apr_array_header_t test_snippet\n                                                  ap_mpm_callback_fn_t *cbfn,\n                                                  ap_mpm_callback_fn_t *tofn,\n                                                  void *baton,\n                                                  apr_time_t timeout)\n{\n    socket_callback_baton_t *scb = apr_pcalloc(pfds->pool, sizeof(*scb));\n    listener_poll_type *pt = apr_palloc(pfds->pool, sizeof(*pt));\n    apr_status_t rc, final_rc= APR_SUCCESS;\n    int i;\n\n    pt->type = PT_USER;\n    pt->baton = scb;\n\n    scb->cbfunc = cbfn;\n    scb->user_baton = baton;\n    scb->pfds = pfds;\n\n    apr_pool_pre_cleanup_register(pfds->pool, pfds, event_cleanup_poll_callback);\n\n    for (i = 0; i < pfds->nelts; i++) {\n        apr_pollfd_t *pfd = (apr_pollfd_t *)pfds->elts + i;\n        pfd->reqevents = (pfd->reqevents) | APR_POLLERR | APR_POLLHUP;\n        pfd->client_data = pt;\n    }\n\n    if (timeout > 0) { \n        \n        scb->cancel_event = event_get_timer_event(timeout + apr_time_now(), tofn, baton, 1, pfds);\n    }\n    for (i = 0; i < pfds->nelts; i++) {\n        apr_pollfd_t *pfd = (apr_pollfd_t *)pfds->elts + i;\n        rc = apr_pollset_add(event_pollset, pfd);\n        if (rc != APR_SUCCESS) {\n            final_rc = rc;\n        }\n    }\n    return final_rc;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_a956a4de769c8609ff515104c70693e38fc6b485_0", {
    "ID": "httpd_a956a4de769c8609ff515104c70693e38fc6b485_0",
    "UID": "6297",
    "code": "static int add_auth_info(request_rec test_snippet\n{\n    const digest_config_rec *conf =\n                (digest_config_rec *) ap_get_module_config(r->per_dir_config,\n                                                           &auth_digest_module);\n    digest_header_rec *resp =\n                (digest_header_rec *) ap_get_module_config(r->request_config,\n                                                           &auth_digest_module);\n    const char *ai = NULL, *nextnonce = \"\";\n\n    if (resp == NULL || !resp->needed_auth || conf == NULL) {\n        return OK;\n    }\n\n    /* 2069-style entity-digest is not supported (it's too hard, and\n     * there are no clients which support 2069 but not 2617). */\n\n    /* setup nextnonce\n     */\n    if (conf->nonce_lifetime > 0) {\n        \n        if ((r->request_time - resp->nonce_time) > (conf->nonce_lifetime-NEXTNONCE_DELTA)) {\n            nextnonce = apr_pstrcat(r->pool, \", nextnonce=\\\"\",\n                                   gen_nonce(r->pool, r->request_time,\n                                             resp->opaque, r->server, conf, ap_auth_name(r)),\n                                   \"\\\"\", NULL);\n            if (resp->client)\n                resp->client->nonce_count = 0;\n        }\n    }\n    else if (conf->nonce_lifetime == 0 && resp->client) {\n        const char *nonce = gen_nonce(r->pool, 0, resp->opaque, r->server,\n                                      conf, ap_auth_name(r));\n        nextnonce = apr_pstrcat(r->pool, \", nextnonce=\\\"\", nonce, \"\\\"\", NULL);\n        memcpy(resp->client->last_nonce, nonce, NONCE_LEN+1);\n    }\n    \n\n\n    /* do rfc-2069 digest\n     */\n    if (!apr_is_empty_array(conf->qop_list) &&\n        !ap_casecmpstr(*(const char **)(conf->qop_list->elts), \"none\")\n        && resp->message_qop == NULL) {\n        \n        ai = nextnonce;\n    }\n    else {\n        const char *resp_dig, *ha1, *a2, *ha2;\n\n        /* calculate rspauth attribute\n         */\n        ha1 = conf->ha1;\n\n        a2 = apr_pstrcat(r->pool, \":\", resp->uri, NULL);\n        ha2 = ap_md5(r->pool, (const unsigned char *)a2);\n\n        resp_dig = ap_md5(r->pool,\n                          (unsigned char *)apr_pstrcat(r->pool, ha1, \":\",\n                                                       resp->nonce, \":\",\n                                                       resp->nonce_count, \":\",\n                                                       resp->cnonce, \":\",\n                                                       resp->message_qop ?\n                                                         resp->message_qop : \"\",\n                                                       \":\", ha2, NULL));\n\n        /* assemble Authentication-Info header\n         */\n        ai = apr_pstrcat(r->pool,\n                         \"rspauth=\\\"\", resp_dig, \"\\\"\",\n                         nextnonce,\n                         resp->cnonce ? \", cnonce=\\\"\" : \"\",\n                         resp->cnonce\n                           ? ap_escape_quotes(r->pool, resp->cnonce)\n                           : \"\",\n                         resp->cnonce ? \"\\\"\" : \"\",\n                         resp->nonce_count ? \", nc=\" : \"\",\n                         resp->nonce_count ? resp->nonce_count : \"\",\n                         resp->message_qop ? \", qop=\" : \"\",\n                         resp->message_qop ? resp->message_qop : \"\",\n                         NULL);\n    }\n\n    if (ai && ai[0]) {\n        apr_table_mergen(r->headers_out,\n                         (PROXYREQ_PROXY == r->proxyreq)\n                             ? \"Proxy-Authentication-Info\"\n                             : \"Authentication-Info\",\n                         ai);\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_eab7a6d3c67cea7ecd64f6e07e0ac76d4d4ba3f9_0", {
    "ID": "httpd_eab7a6d3c67cea7ecd64f6e07e0ac76d4d4ba3f9_0",
    "UID": "6317",
    "code": "AP_DECLARE(int) ap_filter_prepare_brigade(ap_filter_t *f, apr_pool_t test_snippet\n{\n    apr_pool_t *pool;\n    ap_filter_t **key;\n\n    if (!f->bb) {\n\n        pool = f->r ? f->r->pool : f->c->pool;\n\n        key = apr_palloc(pool, sizeof(ap_filter_t **));\n        *key = f;\n        apr_hash_set(f->c->filters, key, sizeof(ap_filter_t **), f);\n\n        f->bb = apr_brigade_create(pool, f->c->bucket_alloc);\n\n        apr_pool_pre_cleanup_register(pool, key, filters_cleanup);\n\n        if (p) {\n            *p = pool;\n        }\n\n        return OK;\n    }\n\n    return DECLINED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_930a1230e0a500d954c318256b13deaea478fdec_0", {
    "ID": "httpd_930a1230e0a500d954c318256b13deaea478fdec_0",
    "UID": "6344",
    "code": "AP_DECLARE(int) test_snippet\n{\n    int rv = set_group_privs();\n\n    if (rv) {\n        return rv;\n    }\n\n    if (NULL != ap_unixd_config.chroot_dir) {\n        if (geteuid()) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, 0, NULL, APLOGNO(02158)\n                         \"Cannot chroot when not started as root\");\n            return EPERM;\n        }\n\n        if (chdir(ap_unixd_config.chroot_dir) != 0) {\n            rv = errno;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02159)\n                         \"Can't chdir to %s\", ap_unixd_config.chroot_dir);\n            return rv;\n        }\n\n        if (chroot(ap_unixd_config.chroot_dir) != 0) {\n            rv = errno;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02160)\n                         \"Can't chroot to %s\", ap_unixd_config.chroot_dir);\n            return rv;\n        }\n\n        if (chdir(\"/\") != 0) {\n            rv = errno;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02161)\n                         \"Can't chdir to new root\");\n            return rv;\n        }\n    }\n\n    \n    if (!geteuid() && (\n#ifdef _OSD_POSIX\n        os_init_job_environment(NULL, ap_unixd_config.user_name, ap_exists_config_define(\"DEBUG\")) != 0 ||\n#endif\n        setuid(ap_unixd_config.user_id) == -1)) {\n        rv = errno;\n        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02162)\n                    \"setuid: unable to change to uid: %ld\",\n                    (long) ap_unixd_config.user_id);\n        return rv;\n    }\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n    \n    if (ap_coredumpdir_configured) {\n        if (prctl(PR_SET_DUMPABLE, 1)) {\n            rv = errno;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02163)\n                         \"set dumpable failed - this child will not coredump\"\n                         \" after software errors\");\n            return rv;\n        }\n    }\n#endif\n\n    return OK;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_d6141e77a5d4034984ed7456d0b0438f48ab50bd_0", {
    "ID": "httpd_d6141e77a5d4034984ed7456d0b0438f48ab50bd_0",
    "UID": "6348",
    "code": "AP_DECLARE(const char *) ap_soak_end_container(cmd_parms *cmd, char test_snippet\n{\n    struct ap_varbuf vb;\n    const char *args;\n    char *cmd_name;\n    apr_status_t rc;\n    apr_size_t max_len = VARBUF_MAX_LEN;\n    if (cmd->pool == cmd->temp_pool)\n        max_len = HUGE_STRING_LEN; \n\n    ap_varbuf_init(cmd->temp_pool, &vb, VARBUF_INIT_LEN);\n\n    while((rc = ap_varbuf_cfg_getline(&vb, cmd->config_file, max_len))\n          == APR_SUCCESS) {\n        args = vb.buf;\n\n        cmd_name = ap_getword_conf(cmd->temp_pool, &args);\n        if (cmd_name[0] == '<') {\n            if (cmd_name[1] == '/') {\n                cmd_name[strlen(cmd_name) - 1] = '\\0';\n\n                if (strcasecmp(cmd_name + 2, directive + 1) != 0) {\n                    return apr_pstrcat(cmd->pool, \"Expected </\",\n                                       directive + 1, \"> but saw \",\n                                       cmd_name, \">\", NULL);\n                }\n\n                ap_varbuf_free(&vb);\n                return NULL; \n            }\n            else {\n                const char *msg;\n\n                if (*args == '\\0' && cmd_name[strlen(cmd_name) - 1] == '>') {\n                    cmd_name[strlen(cmd_name) - 1] = '\\0';\n                }\n\n                if ((msg = ap_soak_end_container(cmd, cmd_name)) != NULL) {\n                    return msg;\n                }\n            }\n        }\n    }\n    if (rc != APR_EOF && rc != APR_SUCCESS)\n        return ap_pcfg_strerror(cmd->temp_pool, cmd->config_file, rc);\n\n    return apr_pstrcat(cmd->pool, \"Expected </\",\n                       directive + 1, \"> before end of configuration\",\n                       NULL);\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow"
  },
  "httpd_1cf1346119c91c2a3729e2881c4fa761dac76719_0", {
    "ID": "httpd_1cf1346119c91c2a3729e2881c4fa761dac76719_0",
    "UID": "6403",
    "code": "static const char *ap_expr_list_pstrcat(apr_pool_t test_snippet\n                                        const apr_array_header_t *list,\n                                        const char *sep)\n{\n    if (list->nelts <= 0) {\n        return NULL;\n    }\n    else if (list->nelts == 1) {\n        return APR_ARRAY_IDX(list, 0, const char*);\n    }\n    else {\n        struct ap_varbuf vb;\n        int n = list->nelts - 1, i;\n        apr_size_t slen = strlen(sep), vlen;\n        const char *val;\n\n        ap_varbuf_init(p, &vb, 0);\n        for (i = 0; i < n; ++i) {\n            val = APR_ARRAY_IDX(list, i, const char*);\n            vlen = strlen(val);\n            ap_varbuf_grow(&vb, vlen + slen + 1);\n            ap_varbuf_strmemcat(&vb, val, vlen);\n            ap_varbuf_strmemcat(&vb, sep, slen);\n        }\n        val = APR_ARRAY_IDX(list, n, const char*);\n        ap_varbuf_strmemcat(&vb, val, strlen(val));\n\n        return vb.buf;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n126,Buffer Over-read"
  },
  "httpd_48a6df74b135e264bde113e1ebad59eb1e6f7b91_0", {
    "ID": "httpd_48a6df74b135e264bde113e1ebad59eb1e6f7b91_0",
    "UID": "6416",
    "code": "static int uwsgi_response(request_rec *r, proxy_conn_rec * test_snippet\n                          proxy_server_conf * conf)\n{\n\n    char buffer[HUGE_STRING_LEN];\n    const char *buf;\n    char *value, *end;\n    char keepchar;\n    int len;\n    int backend_broke = 0;\n    int status_start;\n    int status_end;\n    int finish = 0;\n    conn_rec *c = r->connection;\n    apr_off_t readbytes;\n    apr_status_t rv;\n    apr_bucket *e;\n    apr_read_type_e mode = APR_NONBLOCK_READ;\n    apr_bucket_brigade *pass_bb;\n    apr_bucket_brigade *bb;\n    proxy_dir_conf *dconf;\n\n    request_rec *rp = make_fake_req(backend->connection, r);\n    rp->proxyreq = PROXYREQ_RESPONSE;\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    pass_bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    len = ap_getline(buffer, sizeof(buffer), rp, 1);\n\n    if (len <= 0) {\n        \n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    backend->worker->s->read += len;\n\n    if (len >= sizeof(buffer) - 1) {\n        \n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    \n    if (apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n        status_start = 9;\n    }\n    else if (apr_date_checkmask(buffer, \"HTTP/# ###*\")) {\n        status_start = 7;\n    }\n    else {\n        \n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    status_end = status_start + 3;\n\n    keepchar = buffer[status_end];\n    buffer[status_end] = '\\0';\n    r->status = atoi(&buffer[status_start]);\n\n    if (keepchar != '\\0') {\n        buffer[status_end] = keepchar;\n    }\n    else {\n        /* 2616 requires the space in Status-Line; the origin\n         * server may have sent one but ap_rgetline_core will\n         * have stripped it. */\n        buffer[status_end] = ' ';\n        buffer[status_end + 1] = '\\0';\n    }\n    r->status_line = apr_pstrdup(r->pool, &buffer[status_start]);\n\n    \n    while ((len = ap_getline(buffer, sizeof(buffer), rp, 1)) > 0) {\n        value = strchr(buffer, ':');\n        \n        if (!value)\n            continue;\n        *value = '\\0';\n        ++value;\n        while (apr_isspace(*value))\n            ++value;\n        for (end = &value[strlen(value) - 1];\n             end > value && apr_isspace(*end); --end)\n            *end = '\\0';\n        apr_table_add(r->headers_out, buffer, value);\n    }\n\n    if ((buf = apr_table_get(r->headers_out, \"Content-Type\"))) {\n        ap_set_content_type(r, apr_pstrdup(r->pool, buf));\n    }\n\n    \n#if AP_MODULE_MAGIC_AT_LEAST(20101106,0)\n    dconf =\n        ap_get_module_config(r->per_dir_config, &proxy_module);\n    if (dconf->error_override && ap_is_HTTP_ERROR(r->status)) {\n#else\n    if (conf->error_override && ap_is_HTTP_ERROR(r->status)) {\n#endif\n        int status = r->status;\n        r->status = HTTP_OK;\n        r->status_line = NULL;\n\n        apr_brigade_cleanup(bb);\n        apr_brigade_cleanup(pass_bb);\n\n        return status;\n    }\n\n    while (!finish) {\n        rv = ap_get_brigade(rp->input_filters, bb,\n                            AP_MODE_READBYTES, mode, conf->io_buffer_size);\n        if (APR_STATUS_IS_EAGAIN(rv)\n            || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb))) {\n            e = apr_bucket_flush_create(c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            if (ap_pass_brigade(r->output_filters, bb) || c->aborted) {\n                break;\n            }\n            apr_brigade_cleanup(bb);\n            mode = APR_BLOCK_READ;\n            continue;\n        }\n        else if (rv == APR_EOF) {\n            break;\n        }\n        else if (rv != APR_SUCCESS) {\n            ap_proxy_backend_broke(r, bb);\n            ap_pass_brigade(r->output_filters, bb);\n            backend_broke = 1;\n            break;\n        }\n\n        mode = APR_NONBLOCK_READ;\n        apr_brigade_length(bb, 0, &readbytes);\n        backend->worker->s->read += readbytes;\n\n        if (APR_BRIGADE_EMPTY(bb)) {\n            apr_brigade_cleanup(bb);\n            break;\n        }\n\n        ap_proxy_buckets_lifetime_transform(r, bb, pass_bb);\n\n        \n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb)))\n            finish = 1;\n\n        \n        apr_brigade_length(pass_bb, 0, &readbytes);\n\n        if ((readbytes > 0\n             && ap_pass_brigade(r->output_filters, pass_bb) != APR_SUCCESS)\n            || c->aborted) {\n            finish = 1;\n        }\n\n        apr_brigade_cleanup(bb);\n        apr_brigade_cleanup(pass_bb);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    ap_pass_brigade(r->output_filters, bb);\n\n    apr_brigade_cleanup(bb);\n\n    if (c->aborted || backend_broke) {\n        return DONE;\n    }\n\n    return OK;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_38a0bb27a42f62d423d03f242ef5b775059d2628_0", {
    "ID": "httpd_38a0bb27a42f62d423d03f242ef5b775059d2628_0",
    "UID": "6427",
    "code": "static apr_array_header_t *ap_expr_list_make(ap_expr_eval_ctx_t test_snippet\n                                             const ap_expr_t *node)\n{\n    apr_array_header_t *list = NULL;\n\n    if (node->node_op == op_ListRegex) {\n        const ap_expr_t *arg = node->node_arg1;\n        const ap_expr_t *reg = node->node_arg2;\n        const ap_expr_regctx_t *regctx = reg->node_arg2;\n        const apr_array_header_t *source = ap_expr_list_make(ctx, arg);\n        int i;\n\n        list = apr_array_make(ctx->p, source->nelts, sizeof(const char*));\n        for (i = 0; i < source->nelts; ++i) {\n            const char *val = APR_ARRAY_IDX(source, i, const char*);\n            if (regctx->type == 'S') {\n                (void)ap_expr_regexec(val, reg, list, ctx);\n            }\n            else {\n                val = ap_expr_regexec(val, reg, NULL, ctx);\n                if (val) {\n                    APR_ARRAY_PUSH(list, const char*) = val;\n                }\n            }\n        }\n    }\n    else if (node->node_op == op_ListElement) {\n        int n = 0;\n        const ap_expr_t *elem;\n        for (elem = node; elem; elem = elem->node_arg2) {\n            AP_DEBUG_ASSERT(elem->node_op == op_ListElement);\n            n++;\n        }\n\n        list = apr_array_make(ctx->p, n, sizeof(const char*));\n        for (elem = node; elem; elem = elem->node_arg2) {\n            APR_ARRAY_PUSH(list, const char*) =\n                ap_expr_eval_word(ctx, elem->node_arg1);\n        }\n    }\n    else if (node->node_op == op_ListFuncCall) {\n        const ap_expr_t *info = node->node_arg1;\n        ap_expr_list_func_t *func = info->node_arg1;\n\n        AP_DEBUG_ASSERT(func != NULL);\n        AP_DEBUG_ASSERT(info->node_op == op_ListFuncInfo);\n        list = (*func)(ctx, info->node_arg2,\n                       ap_expr_eval_word(ctx, node->node_arg2));\n    }\n    else {\n        const char *subject = ap_expr_eval_word(ctx, node);\n\n        list = apr_array_make(ctx->p, 8, sizeof(const char*));\n        (void)ap_expr_regexec(subject, node->node_arg2, list, ctx);\n    }\n\n    return list;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d918f73a180c99860b0ae7abfe7075514c9555b9_0", {
    "ID": "httpd_d918f73a180c99860b0ae7abfe7075514c9555b9_0",
    "UID": "6428",
    "code": "static int ap_expr_eval_comp(ap_expr_eval_ctx_t *ctx, const ap_expr_t test_snippet\n{\n    const ap_expr_t *e1 = node->node_arg1;\n    const ap_expr_t *e2 = node->node_arg2;\n    switch (node->node_op) {\n    case op_EQ:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) == 0);\n    case op_NE:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) != 0);\n    case op_LT:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) <  0);\n    case op_LE:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) <= 0);\n    case op_GT:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) >  0);\n    case op_GE:\n        return (intstrcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) >= 0);\n    case op_STR_EQ:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) == 0);\n    case op_STR_NE:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) != 0);\n    case op_STR_LT:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) <  0);\n    case op_STR_LE:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) <= 0);\n    case op_STR_GT:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) >  0);\n    case op_STR_GE:\n        return (strcmp(ap_expr_eval_word(ctx, e1), ap_expr_eval_word(ctx, e2)) >= 0);\n    case op_IN: {\n            int n;\n            const char *needle, *subject;\n            apr_array_header_t *haystack;\n            haystack = ap_expr_list_make(ctx, e2);\n            if (haystack) {\n                needle = ap_expr_eval_word(ctx, e1);\n                for (n = 0; n < haystack->nelts; ++n) {\n                    subject = APR_ARRAY_IDX(haystack, n, const char*);\n                    if (strcmp(needle, subject) == 0) {\n                        return 1;\n                    }\n                }\n            }\n            return 0;\n        }\n    case op_REG:\n    case op_NRE: {\n            const char *word = ap_expr_eval_word(ctx, e1);\n            const ap_regex_t *regex = e2->node_arg1;\n            int result;\n\n            /*\n             * $0 ... $9 may contain stuff the user wants to keep. Therefore\n             * we only set them if there are capturing parens in the regex.\n             */\n            if (regex->re_nsub > 0) {\n                result = (0 == ap_regexec(regex, word, ctx->re_nmatch,\n                                          ctx->re_pmatch, 0));\n                *ctx->re_source = result ? word : NULL;\n            }\n            else {\n                result = (0 == ap_regexec(regex, word, 0, NULL, 0));\n            }\n\n            return result ^ (node->node_op == op_NRE);\n        }\n    default:\n        *ctx->err = \"Internal evaluation error: Unknown comp expression node\";\n        return -1;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value"
  },
  "httpd_7c70c60f41635d5e62d19a56138bfcacc581e6b5_0", {
    "ID": "httpd_7c70c60f41635d5e62d19a56138bfcacc581e6b5_0",
    "UID": "6429",
    "code": "static int strcmplex(const char *str1, const char test_snippet\n{\n    int i, n1, n2;\n\n    if (str1 == NULL)\n        return -1;\n    if (str2 == NULL)\n        return +1;\n    n1 = strlen(str1);\n    n2 = strlen(str2);\n    if (n1 > n2)\n        return 1;\n    if (n1 < n2)\n        return -1;\n    for (i = 0; i < n1; i++) {\n        if (str1[i] > str2[i])\n            return 1;\n        if (str1[i] < str2[i])\n            return -1;\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_27806f0e9bf0fb868524060df29303e17110f5d7_0", {
    "ID": "httpd_27806f0e9bf0fb868524060df29303e17110f5d7_0",
    "UID": "6446",
    "code": "test_snippet\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tap_expr_yyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t\t}\n\n\t\tap_expr_yy_load_buffer_state(yyscanner );\n\t\t}\n\n\t{\n#line 179 \"util_expr_scan.l\"\n\n\n\n /*\n  * Set initial state for string expressions\n  */\n  if (yyextra->at_start) {\n    yyextra->at_start = 0;\n    if (yyextra->flags & AP_EXPR_FLAG_STRING_RESULT) {\n        STATE_PUSH(str, 1);\n        return T_EXPR_STRING;\n    }\n    else {\n        STATE_PUSH(expr, 1);\n        return T_EXPR_BOOL;\n    }\n  }\n\n\n /*\n  * Back off INITIAL pushes\n  */\n#line 1052 \"util_expr_scan.c\"\n\n\twhile ( 1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 157 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 156 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\ndo_action:\t\n\n\t\tswitch ( yy_act )\n\t{ \n\t\t\tcase 0: \n\t\t\t\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase YY_STATE_EOF(str):\n#line 201 \"util_expr_scan.l\"\n{\n    STATE_POP(0); \n    if (YY_START != INITIAL) {\n        PERROR(\"Unterminated string\");\n    }\n    yylval->cpVal = STR_RETURN();\n    STACK_POP(); \n    return T_STRING;\n}\n\tYY_BREAK\ncase YY_STATE_EOF(expr):\n#line 210 \"util_expr_scan.l\"\n{\n    STATE_POP(1); \n    if (YY_START != INITIAL) {\n        PERROR(\"Unterminated expression\");\n    }\n}\n\tYY_BREAK\ncase 1:\nYY_RULE_SETUP\n#line 217 \"util_expr_scan.l\"\n{\n    if (yytext[0] == str_stop) {\n        if (!STR_EMPTY()) {\n            yyless(0); \n            yylval->cpVal = STR_RETURN();\n            return T_STRING;\n        }\n        STATE_POP(1); \n        return T_STR_END;\n    }\n    STR_APPEND_NOCHECK(yytext[0]);\n}\n\tYY_BREAK\n\ncase 2:\nYY_RULE_SETUP\n#line 231 \"util_expr_scan.l\"\n{\n    if (!STR_EMPTY()) {\n        yyless(0); \n        yylval->cpVal = STR_RETURN();\n        return T_STRING;\n    }\n    yylval->num = yytext[1] - '0';\n    return T_REG_REF;\n}\n\tYY_BREAK\n\ncase 3:\nYY_RULE_SETUP\n#line 242 \"util_expr_scan.l\"\n{\n    if (!STR_EMPTY()) {\n        yyless(0); \n        yylval->cpVal = STR_RETURN();\n        return T_STRING;\n    }\n    STATE_PUSH(var, 1);\n    return T_VAR_BEGIN;\n}\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 252 \"util_expr_scan.l\"\n{\n    if (!STR_EMPTY()) {\n        yyless(0); \n        yylval->cpVal = STR_RETURN();\n        return T_STRING;\n    }\n    STATE_PUSH(expr, 1);\n    return T_VAREXP_BEGIN;\n}\n\tYY_BREAK\n\ncase 5:\nYY_RULE_SETUP\n#line 263 \"util_expr_scan.l\"\n{\n    PERROR(\"Bad character escape sequence\");\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 266 \"util_expr_scan.l\"\n{\n    int result;\n    (void)sscanf(yytext+1, \"%o\", &result);\n    STR_APPEND_NOCHECK(result);\n}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 271 \"util_expr_scan.l\"\n{\n    int result;\n    (void)sscanf(yytext+1, \"%x\", &result);\n    STR_APPEND_NOCHECK(result);\n}\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 276 \"util_expr_scan.l\"\n{ STR_APPEND_NOCHECK('\\n'); }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 277 \"util_expr_scan.l\"\n{ STR_APPEND_NOCHECK('\\r'); }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 278 \"util_expr_scan.l\"\n{ STR_APPEND_NOCHECK('\\t'); }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 279 \"util_expr_scan.l\"\n{ STR_APPEND_NOCHECK('\\b'); }\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 280 \"util_expr_scan.l\"\n{ STR_APPEND_NOCHECK('\\f'); }\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n#line 281 \"util_expr_scan.l\"\n{ STR_APPEND_CHECK(yytext[1], 1); }\n\tYY_BREAK\ncase 14:\n\nYY_RULE_SETUP\n#line 283 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated string or variable\");\n}\n\tYY_BREAK\ncase 15:\n\nYY_RULE_SETUP\n#line 287 \"util_expr_scan.l\"\n{\n    STR_APPEND_CHECK(yytext[0], 1);\n}\n\tYY_BREAK\ncase 16:\n\nYY_RULE_SETUP\n#line 291 \"util_expr_scan.l\"\n{ \n    \n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 295 \"util_expr_scan.l\"\n{\n    STATE_PUSH(str, 1);\n    str_stop = yytext[0];\n    return T_STR_BEGIN;\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 301 \"util_expr_scan.l\"\n{\n    STATE_PUSH(expr, 1);\n    return T_VAREXP_BEGIN;\n}\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n#line 305 \"util_expr_scan.l\"\n{\n    STATE_POP(1); \n    return T_VAREXP_END;\n}\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n#line 311 \"util_expr_scan.l\"\n{\n    STATE_PUSH(var, 1);\n    return T_VAR_BEGIN;\n}\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 315 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 319 \"util_expr_scan.l\"\n{\n    STATE_PUSH(vararg, 0);\n    return yytext[0];\n}\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n#line 323 \"util_expr_scan.l\"\n{\n    yyless(0); \n    yylval->cpVal = STR_RETURN();\n    STATE_POP(0); \n    return T_STRING;\n}\n\tYY_BREAK\ncase 24:\n\nYY_RULE_SETUP\n#line 329 \"util_expr_scan.l\"\n{\n    STR_APPEND_CHECK(yytext[0], 1);\n}\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n#line 332 \"util_expr_scan.l\"\n{\n    STATE_POP(1); \n    return T_VAR_END;\n}\n\tYY_BREAK\ncase 26:\n\nYY_RULE_SETUP\n#line 336 \"util_expr_scan.l\"\n{\n    PERROR_CHAR(\"Unexpected variable character \", yytext[0]);\n}\n\tYY_BREAK\ncase YY_STATE_EOF(var):\ncase YY_STATE_EOF(vararg):\n#line 339 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated variable\");\n}\n\tYY_BREAK\n/*\n  * Regular Expression\n  */\ncase 27:\nYY_RULE_SETUP\n#line 347 \"util_expr_scan.l\"\n{\n    STATE_PUSH(regex, 1);\n    str_stop = yytext[0];\n    str_flag = 'm';\n    return T_REGEX;\n}\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 353 \"util_expr_scan.l\"\n{\n    STATE_PUSH(regex, 1);\n    str_stop = yytext[1];\n    str_flag = yytext[0];\n    return (str_flag == 'm') ? T_REGEX : T_REGSUB;\n}\n\tYY_BREAK\ncase 29:\n\nYY_RULE_SETUP\n#line 359 \"util_expr_scan.l\"\n{\n    if (yytext[0] == str_stop) {\n        STATE_POP(0); \n        if (str_flag == 'm') {\n            STATE_PUSH(regflags, 0);\n        }\n        else {\n            STATE_PUSH(regsub, 0);\n        }\n        yylval->cpVal = STR_RETURN();\n        return T_REG_MATCH;\n    }\n    STR_APPEND_CHECK(yytext[0], 1);\n}\n\tYY_BREAK\ncase 30:\n\nYY_RULE_SETUP\n#line 373 \"util_expr_scan.l\"\n{\n    if (yytext[0] == str_stop) {\n        STATE_POP(0); \n        STATE_PUSH(regflags, 0);\n    }\n    else {\n        STR_APPEND_CHECK(yytext[0], 1);\n    }\n}\n\tYY_BREAK\ncase 31:\n\nYY_RULE_SETUP\n#line 382 \"util_expr_scan.l\"\n{\n    if (ap_strchr_c(\"ismg\", yytext[0])) {\n        STR_APPEND_NOCHECK(yytext[0]);\n    }\n    else if (apr_isalnum(yytext[0])) {\n        PERROR(\"Invalid regexp flag(s)\");\n    }\n    else {\n        yyless(0); \n        yylval->cpVal = STR_RETURN();\n        STATE_POP(1); \n        return T_REG_FLAGS;\n    }\n}\n\tYY_BREAK\ncase YY_STATE_EOF(regflags):\n#line 396 \"util_expr_scan.l\"\n{\n    yylval->cpVal = STR_RETURN();\n    STATE_POP(1); \n    return T_REG_FLAGS;\n}\n\tYY_BREAK\ncase YY_STATE_EOF(regex):\ncase YY_STATE_EOF(regsub):\n#line 401 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated regexp\");\n}\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n#line 405 \"util_expr_scan.l\"\n{\n    yylval->num = yytext[1] - '0';\n    return T_REG_REF;\n}\n\tYY_BREAK\n/*\n  * Operators\n  */\ncase 33:\nYY_RULE_SETUP\n#line 413 \"util_expr_scan.l\"\n{ return T_OP_STR_EQ; }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n#line 414 \"util_expr_scan.l\"\n{ return T_OP_STR_NE; }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n#line 415 \"util_expr_scan.l\"\n{ return T_OP_STR_LT; }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n#line 416 \"util_expr_scan.l\"\n{ return T_OP_STR_LE; }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n#line 417 \"util_expr_scan.l\"\n{ return T_OP_STR_GT; }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n#line 418 \"util_expr_scan.l\"\n{ return T_OP_STR_GE; }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n#line 419 \"util_expr_scan.l\"\n{ return T_OP_REG; }\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n#line 420 \"util_expr_scan.l\"\n{ return T_OP_NRE; }\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n#line 421 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n#line 422 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n#line 423 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\n#line 424 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 45:\nYY_RULE_SETUP\n#line 425 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\n#line 426 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\n#line 427 \"util_expr_scan.l\"\n{ return T_OP_CONCAT; }\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\n#line 428 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\n#line 429 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n#line 430 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n#line 431 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 52:\nYY_RULE_SETUP\n#line 432 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\n#line 433 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\n#line 434 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\n\ncase 55:\nYY_RULE_SETUP\n#line 437 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\n#line 438 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n#line 439 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\n#line 440 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\n#line 441 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\n#line 442 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 61:\nYY_RULE_SETUP\n#line 443 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\n#line 445 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_BINARY;\n}\n\tYY_BREAK\ncase 63:\nYY_RULE_SETUP\n#line 450 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_UNARY;\n}\n\tYY_BREAK\n\ncase 64:\nYY_RULE_SETUP\n#line 456 \"util_expr_scan.l\"\n{\n    STATE_PUSH(split, 0);\n    return T_OP_SPLIT;\n}\n\tYY_BREAK\ncase 65:\nYY_RULE_SETUP\n#line 460 \"util_expr_scan.l\"\n{\n    STATE_POP(0); \n    STATE_PUSH(regex, 1);\n    str_stop = yytext[0];\n    str_flag = 'S';\n}\n\tYY_BREAK\ncase 66:\n\nYY_RULE_SETUP\n#line 466 \"util_expr_scan.l\"\n{\n    PERROR(\"Expecting split regular expression\");\n}\n\tYY_BREAK\ncase YY_STATE_EOF(split):\n#line 469 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated split\");\n}\n\tYY_BREAK\n\ncase 67:\nYY_RULE_SETUP\n#line 474 \"util_expr_scan.l\"\n{\n    return T_OP_JOIN;\n}\n\tYY_BREAK\n/*\n  * Specials\n  */\ncase 68:\nYY_RULE_SETUP\n#line 481 \"util_expr_scan.l\"\n{ return T_TRUE; }\n\tYY_BREAK\ncase 69:\nYY_RULE_SETUP\n#line 482 \"util_expr_scan.l\"\n{ return T_FALSE; }\n\tYY_BREAK\n/*\n  * Digits\n  */\ncase 70:\nYY_RULE_SETUP\n#line 487 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_DIGIT;\n}\n\tYY_BREAK\n/*\n  * Identifiers\n  */\ncase 71:\nYY_RULE_SETUP\n#line 495 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\n/*\n  * These are parts of the grammar and are returned as is\n  */\ncase 72:\nYY_RULE_SETUP\n#line 503 \"util_expr_scan.l\"\n{\n    return yytext[0];\n}\n\tYY_BREAK\n/*\n  * Anything else is an error\n  */\ncase 73:\n\nYY_RULE_SETUP\n#line 510 \"util_expr_scan.l\"\n{\n    PERROR_CHAR(\"Parse error near character \", yytext[0]);\n}\n\tYY_BREAK\ncase 74:\nYY_RULE_SETUP\n#line 514 \"util_expr_scan.l\"\nYY_FATAL_ERROR( \"flex scanner jammed\" );\n\tYY_BREAK\n#line 1718 \"util_expr_scan.c\"\ncase YY_STATE_EOF(INITIAL):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * ap_expr_yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ \n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( ap_expr_yywrap(yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} \n\t\t} \n\t} \n}",
    "predicted": "123,Write-what-where Condition\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_04d75020da31a9041bc0346b0ec768be8a867f0a_0", {
    "ID": "httpd_04d75020da31a9041bc0346b0ec768be8a867f0a_0",
    "UID": "6482",
    "code": "static const char *ap_expr_regexec(const char test_snippet\n                                   const ap_expr_t *reg,\n                                   apr_array_header_t *list,\n                                   ap_expr_eval_ctx_t *ctx)\n{\n    struct ap_varbuf vb;\n    const char *val = subject;\n    const ap_regex_t *regex = reg->node_arg1;\n    const ap_expr_regctx_t *regctx = reg->node_arg2;\n    ap_regmatch_t *pmatch = NULL, match0;\n    apr_size_t nmatch = 0;\n    const char *str = \"\";\n    apr_size_t len = 0;\n    int empty = 0, rv;\n\n    ap_varbuf_init(ctx->p, &vb, 0);\n    if (ctx->re_nmatch > 0) {\n        nmatch = ctx->re_nmatch;\n        pmatch = ctx->re_pmatch;\n    }\n    else if (regctx->type != 'm') {\n        nmatch = 1;\n        pmatch = &match0;\n    }\n    do {\n        /* If previous match was empty, we can't issue the exact same one or\n         * we'd loop indefinitively.  So let's instead ask for an anchored and\n         * non-empty match (i.e. something not empty at the start of the value)\n         * and if nothing is found advance by one character below.\n         */\n        rv = ap_regexec(regex, val, nmatch, pmatch, \n                        empty ? AP_REG_ANCHORED | AP_REG_NOTEMPTY : 0);\n        if (regctx->type == 'm') {\n            /* Simple match \"m//\", just return whether it matched (subject)\n             * or not (NULL) \n             */\n            return (rv == 0) ? subject : NULL;\n        }\n        if (rv == 0) {\n            /* Substitution \"s//\" or split \"S//\" matched.\n             * s// => replace $0 with evaluated regctx->subst\n             * S// => split at $0 (keeping evaluated regctx->subst if any)\n             */\n            int pos = pmatch[0].rm_so,\n                end = pmatch[0].rm_eo;\n            AP_DEBUG_ASSERT(pos >= 0 && pos <= end);\n\n            if (regctx->subst) {\n                *ctx->re_source = val;\n                str = ap_expr_eval_word(ctx, regctx->subst);\n                len = strlen(str);\n            }\n            /* Splitting makes sense into a given list only, if NULL we fall\n             * back into returning a s// string...\n             */\n            if (list) {\n                char *tmp = apr_palloc(ctx->p, pos + len + 1);\n                memcpy(tmp, val, pos);\n                memcpy(tmp + pos, str, len + 1);\n                APR_ARRAY_PUSH(list, const char*) = tmp;\n            }\n            else { \n                ap_varbuf_grow(&vb, pos + len + 1);\n                ap_varbuf_strmemcat(&vb, val, pos);\n                ap_varbuf_strmemcat(&vb, str, len);\n                if (!(regctx->flags & AP_REG_MULTI)) {\n                    \n                    ap_varbuf_strmemcat(&vb, val + end, strlen(val) - end);\n                    break;\n                }\n            }\n            \n            empty = (end == 0);\n            val += end;\n        }\n        else if (empty) {\n            /* Skip this non-matching character (or CRLF) and restart\n             * another \"normal\" match (possibly empty) from there.\n             */\n            if (val[0] == '\\r' && val[1] == '\\n') {\n                val += 2;\n            }\n            else {\n                val++;\n            }\n            empty = 0;\n        }\n        else {\n            if (list) {\n                APR_ARRAY_PUSH(list, const char*) = val;\n            }\n            else if (vb.avail) {\n                ap_varbuf_strmemcat(&vb, val, strlen(val));\n            }\n            else {\n                return val;\n            }\n            break;\n        }\n    } while (*val);\n\n    return vb.buf;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_5c8e62ee0d19c37716b9dbc52d0a60194720ad90_0", {
    "ID": "httpd_5c8e62ee0d19c37716b9dbc52d0a60194720ad90_0",
    "UID": "6511",
    "code": "test_snippet\nyyparse (ap_expr_parse_ctx_t *ctx)\n#else\ntest_snippet\nyyparse (ctx)\n    ap_expr_parse_ctx_t *ctx;\n#endif\n#endif\n{\n\ntest_snippet yychar;\n\n\n#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__\n\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \\\n    _Pragma (\"GCC diagnostic push\") \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nstatic YYSTYPE yyval_default;\n# define YY_INITIAL_VALUE(Value) = Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value) \n#endif\n\n\nYYSTYPE yylval YY_INITIAL_VALUE(yyval_default);\n\n    \n    test_snippet yynerrs;\n\n    test_snippet yystate;\n    \n    test_snippet yyerrstatus;\n\n    /* The stacks and their tools:\n       `yyss': related to states.\n       `yyvs': related to semantic values.\n\n       Refer to the stacks through separate potest_snippeters, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    \n    yytype_test_snippet16 yyssa[YYINITDEPTH];\n    yytype_test_snippet16 *yyss;\n    yytype_test_snippet16 *yyssp;\n\n    \n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  test_snippet yyn;\n  test_snippet yyresult;\n  \n  test_snippet yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  \n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  test_snippet yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; \n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      \n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones test_snippeto\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_test_snippet16 *yyss1 = yyss;\n\n\t/* Each stack potest_snippeter address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else \n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      \n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tyytype_test_snippet16 *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyexhaustedlab;\n\tYYSTACK_RELOCATE (yyss_alloc, yyss);\n\tYYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif \n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long test_snippet) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  \n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  \n\n  \n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  \n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  \n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  \n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     `$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 2:\n\n#line 126 \"util_expr_parse.y\"\n    { ctx->expr = (yyvsp[(2) - (2)].exVal); }\n    break;\n\n  case 3:\n\n#line 127 \"util_expr_parse.y\"\n    { ctx->expr = (yyvsp[(2) - (2)].exVal); }\n    break;\n\n  case 4:\n\n#line 128 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 5:\n\n#line 131 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_True,        NULL, NULL, ctx); }\n    break;\n\n  case 6:\n\n#line 132 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_False,       NULL, NULL, ctx); }\n    break;\n\n  case 7:\n\n#line 133 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Not,         (yyvsp[(2) - (2)].exVal),   NULL, ctx); }\n    break;\n\n  case 8:\n\n#line 134 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Or,          (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 9:\n\n#line 135 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_And,         (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 10:\n\n#line 136 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Comp,        (yyvsp[(1) - (1)].exVal),   NULL, ctx); }\n    break;\n\n  case 11:\n\n#line 137 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_unary_op_make(       (yyvsp[(1) - (2)].cpVal),   (yyvsp[(2) - (2)].exVal),   ctx); }\n    break;\n\n  case 12:\n\n#line 138 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_binary_op_make((yyvsp[(2) - (3)].cpVal),   (yyvsp[(1) - (3)].exVal),   (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 13:\n\n#line 139 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 14:\n\n#line 140 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 15:\n\n#line 143 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_EQ,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 16:\n\n#line 144 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_NE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 17:\n\n#line 145 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_LT,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 18:\n\n#line 146 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_LE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 19:\n\n#line 147 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_GT,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 20:\n\n#line 148 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_GE,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 21:\n\n#line 149 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_EQ,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 22:\n\n#line 150 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_NE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 23:\n\n#line 151 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_LT,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 24:\n\n#line 152 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_LE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 25:\n\n#line 153 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_GT,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 26:\n\n#line 154 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_STR_GE,  (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 27:\n\n#line 155 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_IN,      (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 28:\n\n#line 156 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_REG,     (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 29:\n\n#line 157 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_NRE,     (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 30:\n\n#line 160 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 31:\n\n#line 161 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_list_regex_make((yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 32:\n\n#line 162 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_list_regex_make((yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal), ctx); }\n    break;\n\n  case 33:\n\n#line 163 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 34:\n\n#line 164 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 35:\n\n#line 167 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_ListElement, (yyvsp[(1) - (1)].exVal), NULL, ctx); }\n    break;\n\n  case 36:\n\n#line 168 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_ListElement, (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 37:\n\n#line 171 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 38:\n\n#line 172 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_concat_make((yyvsp[(1) - (2)].exVal), (yyvsp[(2) - (2)].exVal), ctx); }\n    break;\n\n  case 39:\n\n#line 173 \"util_expr_parse.y\"\n    { YYABORT; }\n    break;\n\n  case 40:\n\n#line 176 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_String, (yyvsp[(1) - (1)].cpVal), NULL, ctx); }\n    break;\n\n  case 41:\n\n#line 177 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 42:\n\n#line 178 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 43:\n\n#line 181 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_var_make((yyvsp[(2) - (3)].cpVal), ctx); }\n    break;\n\n  case 44:\n\n#line 182 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(2) - (5)].cpVal), (yyvsp[(4) - (5)].exVal), ctx); }\n    break;\n\n  case 45:\n\n#line 183 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_word_make((yyvsp[(2) - (3)].exVal), ctx); }\n    break;\n\n  case 46:\n\n#line 184 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_bool_make((yyvsp[(2) - (3)].exVal), ctx); }\n    break;\n\n  case 47:\n\n#line 187 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Digit,  (yyvsp[(1) - (1)].cpVal), NULL, ctx); }\n    break;\n\n  case 48:\n\n#line 188 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_String, \"\", NULL, ctx); }\n    break;\n\n  case 49:\n\n#line 189 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 50:\n\n#line 190 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Concat, (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 51:\n\n#line 191 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_make(op_Regsub, (yyvsp[(1) - (3)].exVal), (yyvsp[(3) - (3)].exVal),   ctx); }\n    break;\n\n  case 52:\n\n#line 192 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 53:\n\n#line 193 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 54:\n\n#line 194 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 55:\n\n#line 195 \"util_expr_parse.y\"\n    {\n                                           (yyval.exVal) = ap_expr_make(op_Join,   (yyvsp[(2) - (2)].exVal), NULL, ctx);\n            }\n    break;\n\n  case 56:\n\n#line 198 \"util_expr_parse.y\"\n    {\n                                           (yyval.exVal) = ap_expr_make(op_Join,   (yyvsp[(2) - (4)].exVal), (yyvsp[(4) - (4)].exVal),   ctx);\n            }\n    break;\n\n  case 57:\n\n#line 201 \"util_expr_parse.y\"\n    {\n                                           (yyval.exVal) = ap_expr_make(op_Join,   (yyvsp[(3) - (6)].exVal), (yyvsp[(5) - (6)].exVal),   ctx);\n            }\n    break;\n\n  case 58:\n\n#line 204 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(2) - (3)].exVal); }\n    break;\n\n  case 59:\n\n#line 207 \"util_expr_parse.y\"\n    {\n                ap_expr_t *e = ap_expr_regex_make((yyvsp[(2) - (3)].cpVal), (yyvsp[(3) - (3)].cpVal), NULL, 0, ctx);\n                if (!e) {\n                    ctx->error = \"Failed to compile regular expression\";\n                    YYERROR;\n                }\n                (yyval.exVal) = e;\n            }\n    break;\n\n  case 60:\n\n#line 216 \"util_expr_parse.y\"\n    {\n                ap_expr_t *e = ap_expr_regex_make((yyvsp[(2) - (4)].cpVal), (yyvsp[(4) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), 0, ctx);\n                if (!e) {\n                    ctx->error = \"Failed to compile regular expression\";\n                    YYERROR;\n                }\n                (yyval.exVal) = e;\n            }\n    break;\n\n  case 61:\n\n#line 225 \"util_expr_parse.y\"\n    {\n                /* Returns a list:\n                 * <word> ~= split/://\n                 *  => split around ':', replace it with empty\n                 * <word> ~= split/:/\\n/\n                 *  => split around ':', replace it with '\\n'\n                 * <list> ~= split/.*?Ip Address:([^,]+)/$1/\n                 *  => split around the whole match, replace it with $1\n                 */\n                ap_expr_t *e = ap_expr_regex_make((yyvsp[(2) - (4)].cpVal), (yyvsp[(4) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), 1, ctx);\n                if (!e) {\n                    ctx->error = \"Failed to compile regular expression\";\n                    YYERROR;\n                }\n                (yyval.exVal) = e;\n            }\n    break;\n\n  case 62:\n\n#line 242 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 63:\n\n#line 243 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 64:\n\n#line 244 \"util_expr_parse.y\"\n    { (yyval.exVal) = (yyvsp[(1) - (1)].exVal); }\n    break;\n\n  case 65:\n\n#line 247 \"util_expr_parse.y\"\n    {\n                test_snippet *n = apr_palloc(ctx->pool, sizeof(test_snippet));\n                *n = (yyvsp[(1) - (1)].num);\n                (yyval.exVal) = ap_expr_make(op_Regref, n, NULL, ctx);\n            }\n    break;\n\n  case 66:\n\n#line 254 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_list_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n  case 67:\n\n#line 258 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n  case 68:\n\n#line 259 \"util_expr_parse.y\"\n    { (yyval.exVal) = ap_expr_str_func_make((yyvsp[(1) - (4)].cpVal), (yyvsp[(3) - (4)].exVal), ctx); }\n    break;\n\n\n\n#line 2027 \"util_expr_parse.c\"\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now `shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*------------------------------------.\n| yyerrlab -- here on detecting error |\n`------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  \n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (ctx, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        test_snippet yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (ctx, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n\t error, discard it.  */\n\n      if (yychar <= YYEOF)\n\t{\n\t  \n\t  if (yychar == YYEOF)\n\t    YYABORT;\n\t}\n      else\n\t{\n\t  yydestruct (\"Error: discarding\",\n\t\t      yytoken, &yylval, ctx);\n\t  yychar = YYEMPTY;\n\t}\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if ( 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;\t\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n\t{\n\t  yyn += YYTERROR;\n\t  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n\t    {\n\t      yyn = yytable[yyn];\n\t      if (0 < yyn)\n\t\tbreak;\n\t    }\n\t}\n\n      \n      if (yyssp == yyss)\n\tYYABORT;\n\n\n      yydestruct (\"Error: popping\",\n\t\t  yystos[yystate], yyvsp, ctx);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  \n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (ctx, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  \n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, ctx);\n    }\n  /* Do not reclaim the symbols of the rule which action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n\t\t  yystos[*yyssp], yyvsp, ctx);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  \n  return YYID (yyresult);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a60e53e07531a07c8e1b7cbc95d7b3acb499137b_0", {
    "ID": "httpd_a60e53e07531a07c8e1b7cbc95d7b3acb499137b_0",
    "UID": "6575",
    "code": "static apr_status_t cgi_handle_request(request_rec *r, apr_file_t test_snippet\n                                       apr_bucket_brigade *bb,\n                                       char *logbuf, apr_size_t logbufbytes)\n{\n    int seen_eos = 0;\n    int child_stopped_reading = 0;\n    apr_status_t rv;\n    int dbpos = 0;\n\n    do {\n        apr_bucket *bucket;\n\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, HUGE_STRING_LEN);\n\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        for (bucket = APR_BRIGADE_FIRST(bb);\n             bucket != APR_BRIGADE_SENTINEL(bb);\n             bucket = APR_BUCKET_NEXT(bucket))\n        {\n            const char *data;\n            apr_size_t len;\n\n            if (APR_BUCKET_IS_EOS(bucket)) {\n                seen_eos = 1;\n                break;\n            }\n\n            \n            if (APR_BUCKET_IS_FLUSH(bucket)) {\n                continue;\n            }\n\n            \n            if (child_stopped_reading) {\n                continue;\n            }\n\n            \n            rv = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\n            if (rv) {\n                return rv;\n            }\n\n            if (logbufbytes && dbpos < logbufbytes) {\n                int cursize;\n\n                if ((dbpos + len) > logbufbytes) {\n                    cursize = logbufbytes - dbpos;\n                }\n                else {\n                    cursize = len;\n                }\n                memcpy(logbuf + dbpos, data, cursize);\n                dbpos += cursize;\n            }\n\n            /* Keep writing data to the child until done or too much time\n             * elapses with no progress or an error occurs.\n             */\n            rv = apr_file_write_full(script_out, data, len, NULL);\n\n            if (rv != APR_SUCCESS) {\n                \n                child_stopped_reading = 1;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02651)\n                              \"Error writing request body to script %s\", \n                              r->filename);\n            }\n        }\n        apr_brigade_cleanup(bb);\n    }\n    while (!seen_eos);\n\n    if (logbuf) {\n        logbuf[dbpos] = '\\0';\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_6eb66c0131d71211d04cb942a314a62f09763323_0", {
    "ID": "httpd_6eb66c0131d71211d04cb942a314a62f09763323_0",
    "UID": "6589",
    "code": "static apr_status_t remoteip_input_filter(ap_filter_t test_snippet\n                                    apr_bucket_brigade *bb_out,\n                                    ap_input_mode_t mode,\n                                    apr_read_type_e block,\n                                    apr_off_t readbytes)\n{\n    apr_status_t ret;\n    remoteip_filter_context *ctx = f->ctx;\n    remoteip_conn_config_t *conn_conf;\n    apr_bucket *b;\n    remoteip_parse_status_t psts = HDR_NEED_MORE;\n    const char *ptr;\n    apr_size_t len;\n\n    if (f->c->aborted) {\n        return APR_ECONNABORTED;\n    }\n\n    \n    if (!ctx) {\n        ctx = f->ctx = apr_palloc(f->c->pool, sizeof(*ctx));\n        ctx->rcvd = 0;\n        ctx->need = MIN_HDR_LEN;\n        ctx->version = 0;\n        ctx->mode = AP_MODE_READBYTES;\n        ctx->bb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);\n        ctx->done = 0;\n    }\n\n    if (ctx->done) {\n        /* Note: because we're a connection filter we can't remove ourselves\n         * when we're done, so we have to stay in the chain and just go into\n         * passthrough mode.\n         */\n        return ap_get_brigade(f->next, bb_out, mode, block, readbytes);\n    }\n\n    conn_conf = ap_get_module_config(f->c->conn_config, &remoteip_module);\n\n    \n    while (!ctx->done) {\n        if (APR_BRIGADE_EMPTY(ctx->bb)) {\n            apr_off_t got, want = ctx->need - ctx->rcvd;\n\n            ret = ap_get_brigade(f->next, ctx->bb, ctx->mode, block, want);\n            if (ret != APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, ret, f->c, APLOGNO(10184)\n                              \"failed reading input\");\n                return ret;\n            }\n\n            ret = apr_brigade_length(ctx->bb, 1, &got);\n            if (ret || got > want) {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, ret, f->c, APLOGNO(10185)\n                              \"RemoteIPProxyProtocol header too long, \"\n                              \"got %\" APR_OFF_T_FMT \" expected %\" APR_OFF_T_FMT,\n                              got, want);\n                f->c->aborted = 1;\n                return APR_ECONNABORTED;\n            }\n        }\n        if (APR_BRIGADE_EMPTY(ctx->bb)) {\n            return block == APR_NONBLOCK_READ ? APR_SUCCESS : APR_EOF;\n        }\n\n        while (!ctx->done && !APR_BRIGADE_EMPTY(ctx->bb)) {\n            b = APR_BRIGADE_FIRST(ctx->bb);\n\n            ret = apr_bucket_read(b, &ptr, &len, block);\n            if (APR_STATUS_IS_EAGAIN(ret) && block == APR_NONBLOCK_READ) {\n                return APR_SUCCESS;\n            }\n            if (ret != APR_SUCCESS) {\n                return ret;\n            }\n\n            memcpy(ctx->header + ctx->rcvd, ptr, len);\n            ctx->rcvd += len;\n\n            apr_bucket_delete(b);\n            psts = HDR_NEED_MORE;\n\n            if (ctx->version == 0) {\n                \n                if (ctx->rcvd >= MIN_HDR_LEN) {\n                    ctx->version = remoteip_determine_version(f->c, ctx->header);\n                    if (ctx->version < 0) {\n                        psts = HDR_ERROR;\n                    }\n                    else if (ctx->version == 1) {\n                        ctx->mode = AP_MODE_GETLINE;\n                        ctx->need = sizeof(proxy_v1);\n                    }\n                    else if (ctx->version == 2) {\n                        ctx->need = MIN_V2_HDR_LEN;\n                    }\n                }\n            }\n            else if (ctx->version == 1) {\n                psts = remoteip_process_v1_header(f->c, conn_conf,\n                                            (proxy_header *) ctx->header,\n                                            ctx->rcvd, &ctx->need);\n            }\n            else if (ctx->version == 2) {\n                if (ctx->rcvd >= MIN_V2_HDR_LEN) {\n                    ctx->need = MIN_V2_HDR_LEN +\n                        remoteip_get_v2_len((proxy_header *) ctx->header);\n                    if (ctx->need > sizeof(proxy_v2)) {\n                        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(10186)\n                                      \"RemoteIPProxyProtocol protocol header length too long\");\n                        f->c->aborted = 1;\n                        apr_brigade_destroy(ctx->bb);\n                        return APR_ECONNABORTED;\n                    }\n                }\n                if (ctx->rcvd >= ctx->need) {\n                    psts = remoteip_process_v2_header(f->c, conn_conf,\n                                                (proxy_header *) ctx->header);\n                }\n            }\n            else {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(03509)\n                              \"RemoteIPProxyProtocol: internal error: unknown version \"\n                              \"%d\", ctx->version);\n                f->c->aborted = 1;\n                apr_brigade_destroy(ctx->bb);\n                return APR_ECONNABORTED;\n            }\n\n            switch (psts) {\n                case HDR_ERROR:\n                    f->c->aborted = 1;\n                    apr_brigade_destroy(ctx->bb);\n                    return APR_ECONNABORTED;\n\n                case HDR_DONE:\n                    ctx->done = 1;\n                    break;\n\n                case HDR_NEED_MORE:\n                    break;\n            }\n        }\n    }\n\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, f->c, APLOGNO(03511)\n                  \"RemoteIPProxyProtocol: received valid PROXY header: %s:%hu\",\n                  conn_conf->client_ip, conn_conf->client_addr->port);\n\n    if (ctx->rcvd > ctx->need || !APR_BRIGADE_EMPTY(ctx->bb)) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(03513)\n                      \"RemoteIPProxyProtocol: internal error: have data left over; \"\n                      \" need=%\" APR_SIZE_T_FMT \", rcvd=%\" APR_SIZE_T_FMT\n                      \", brigade-empty=%d\", ctx->need, ctx->rcvd,\n                      APR_BRIGADE_EMPTY(ctx->bb));\n        f->c->aborted = 1;\n        apr_brigade_destroy(ctx->bb);\n        return APR_ECONNABORTED;\n    }\n\n    \n    apr_brigade_destroy(ctx->bb);\n    ctx->bb = NULL;\n\n    \n    return ap_get_brigade(f->next, bb_out, mode, block, readbytes);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_8e554ec5c600467149a3ba4b8ec475fcca96841c_0", {
    "ID": "httpd_8e554ec5c600467149a3ba4b8ec475fcca96841c_0",
    "UID": "6600",
    "code": "static int cgid_handler(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    int retval, nph;\n    char *argv0, *dbuf;\n    apr_size_t dbufsize;\n    apr_bucket_brigade *bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    apr_bucket *b;\n    cgid_server_conf *conf;\n    int is_included;\n    int sd;\n    char **env;\n    apr_file_t *tempsock, *script_err, *errpipe_out;\n    struct cleanup_script_info *info;\n    apr_status_t rv;\n    cgid_dirconf *dc;\n    apr_interval_time_t timeout;\n\n    if (strcmp(r->handler, CGI_MAGIC_TYPE) && strcmp(r->handler, \"cgi-script\")) {\n        return DECLINED;\n    }\n\n    conf = ap_get_module_config(r->server->module_config, &cgid_module);\n    dc = ap_get_module_config(r->per_dir_config, &cgid_module);\n\n    timeout = dc->timeout > 0 ? dc->timeout : r->server->timeout;\n    is_included = !strcmp(r->protocol, \"INCLUDED\");\n\n    if ((argv0 = strrchr(r->filename, '/')) != NULL) {\n        argv0++;\n    }\n    else {\n        argv0 = r->filename;\n    }\n\n    nph = !(strncmp(argv0, \"nph-\", 4));\n\n    argv0 = r->filename;\n\n    if (!(ap_allow_options(r) & OPT_EXECCGI) && !is_scriptaliased(r)) {\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01262)\n                \"Options ExecCGI is off in this directory\");\n    }\n\n    if (nph && is_included) {\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01263)\n                \"attempt to include NPH CGI script\");\n    }\n\n#if defined(OS2) || defined(WIN32)\n#error mod_cgid does not work on this platform.  If you teach it to, look\n#error at mod_cgi.c for required code in this path.\n#else\n    if (r->finfo.filetype == APR_NOFILE) {\n        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, APLOGNO(01264)\n                \"script not found or unable to stat\");\n    }\n#endif\n    if (r->finfo.filetype == APR_DIR) {\n        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01265)\n                \"attempt to invoke directory as script\");\n    }\n\n    if ((r->used_path_info == AP_REQ_REJECT_PATH_INFO) &&\n        r->path_info && *r->path_info)\n    {\n        \n        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, APLOGNO(01266)\n                               \"AcceptPathInfo off disallows user's path\");\n    }\n    /*\n    if (!ap_suexec_enabled) {\n        if (!ap_can_exec(&r->finfo))\n            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01267)\n                                   \"file permissions deny server execution\");\n    }\n    */\n\n#ifdef HAVE_CGID_FDPASSING\n    rv = apr_file_pipe_create(&script_err, &errpipe_out, r->pool);\n    if (rv) {\n        return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, rv, APLOGNO(10176)\n                               \"could not create pipe for stderr\");\n    }\n#else\n    script_err = NULL;\n    errpipe_out = NULL;\n#endif\n    \n    /*\n     * httpd core function used to add common environment variables like\n     * DOCUMENT_ROOT. \n     */\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n    env = ap_create_environment(r->pool, r->subprocess_env);\n\n    if ((retval = connect_to_daemon(&sd, r, conf)) != OK) {\n        return retval;\n    }\n\n    rv = send_req(sd, errpipe_out, r, argv0, env, CGI_REQ);\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01268)\n                     \"write to cgi daemon process\");\n    }\n\n    /* The write-end of the pipe is only used by the server, so close\n     * it here. */\n    if (errpipe_out) apr_file_close(errpipe_out);\n    \n    info = apr_palloc(r->pool, sizeof(struct cleanup_script_info));\n    info->conf = conf;\n    info->r = r;\n    rv = get_cgi_pid(r, conf, &(info->pid));\n\n    if (APR_SUCCESS == rv){  \n        apr_pool_cleanup_register(r->pool, info,\n                              cleanup_script,\n                              apr_pool_cleanup_null);\n    }\n    else { \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, \"error determining cgi PID\");\n    }\n\n    /* We are putting the socket discriptor into an apr_file_t so that we can\n     * use a pipe bucket to send the data to the client.  APR will create\n     * a cleanup for the apr_file_t which will close the socket, so we'll\n     * get rid of the cleanup we registered when we created the socket.\n     */\n\n    apr_os_pipe_put_ex(&tempsock, &sd, 1, r->pool);\n    apr_file_pipe_timeout_set(tempsock, timeout);\n    apr_pool_cleanup_kill(r->pool, (void *)((long)sd), close_unix_socket);\n\n    \n    if (conf->logname) {\n        dbufsize = conf->bufbytes;\n        dbuf = apr_palloc(r->pool, dbufsize + 1);\n    }\n    else {\n        dbuf = NULL;\n        dbufsize = 0;\n    }\n\n    \n    rv = cgi_handle_request(r, tempsock, bb, dbuf, dbufsize);\n    if (rv) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01270)\n                      \"Error reading request entity data\");\n        return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n    }\n\n    /* we're done writing, or maybe we didn't write at all;\n     * force EOF on child's stdin so that the cgi detects end (or\n     * absence) of data\n     */\n    shutdown(sd, 1);\n\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n#ifdef HAVE_CGID_FDPASSING\n    b = cgi_bucket_create(r, dc->timeout, tempsock, script_err, c->bucket_alloc);\n    if (b == NULL)\n        return HTTP_INTERNAL_SERVER_ERROR; \n#else\n    b = apr_bucket_pipe_create(tempsock, c->bucket_alloc);\n#endif\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    return cgi_handle_response(r, nph, bb, timeout, conf, dbuf, script_err);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n404,Improper Resource Shutdown or Release\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_d987cd8cbff3c07d3ae914161d55ae68b56a191d_0", {
    "ID": "httpd_d987cd8cbff3c07d3ae914161d55ae68b56a191d_0",
    "UID": "6657",
    "code": "static const char *cgi_header_in(apreq_handle_t test_snippet\n                                 const char *name)\n{\n    apr_pool_t *p = handle->pool;\n    char *key = apr_pstrcat(p, \"HTTP_\", name, NULL);\n    char *k, *value = NULL;\n\n    for (k = key+5; *k; ++k) {\n        if (*k == '-')\n            *k = '_';\n        else\n            *k = apr_toupper(*k);\n    }\n\n    if (!strcmp(key, \"HTTP_CONTENT_TYPE\")\n        || !strcmp(key, \"HTTP_CONTENT_LENGTH\")) {\n\n        key += 5; \n    }\n\n    apr_env_get(&value, key, p);\n\n    return value;\n}",
    "predicted": "252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_8b817b6dda69df0537d8062a39c4f9f78045d94f_0", {
    "ID": "httpd_8b817b6dda69df0537d8062a39c4f9f78045d94f_0",
    "UID": "6747",
    "code": "static const char *process_regexp(header_entry *hdr, const char test_snippet\n                                  request_rec *r)\n{\n    ap_regmatch_t pmatch[AP_MAX_REG_MATCH];\n    const char *subs;\n    const char *remainder;\n    char *ret;\n    int diffsz;\n    if (ap_regexec(hdr->regex, value, AP_MAX_REG_MATCH, pmatch, 0)) {\n        \n        return value;\n    }\n    /* Process tags in the input string rather than the resulting\n       * substitution to avoid surprises\n       */\n    subs = ap_pregsub(r->pool, process_tags(hdr, r), value, AP_MAX_REG_MATCH, pmatch);\n    if (subs == NULL)\n        return NULL;\n    diffsz = strlen(subs) - (pmatch[0].rm_eo - pmatch[0].rm_so);\n    if (hdr->action == hdr_edit) {\n        remainder = value + pmatch[0].rm_eo;\n    }\n    else { \n        remainder = process_regexp(hdr, value + pmatch[0].rm_eo, r);\n        if (remainder == NULL)\n            return NULL;\n        diffsz += strlen(remainder) - strlen(value + pmatch[0].rm_eo);\n    }\n    ret = apr_palloc(r->pool, strlen(value) + 1 + diffsz);\n    memcpy(ret, value, pmatch[0].rm_so);\n    strcpy(ret + pmatch[0].rm_so, subs);\n    strcat(ret, remainder);\n    return ret;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_869960bb3efe82348e5a2db391ffd9f005e720d1_0", {
    "ID": "httpd_869960bb3efe82348e5a2db391ffd9f005e720d1_0",
    "UID": "6790",
    "code": "static int get_digest_rec(request_rec *r, digest_header_rec test_snippet\n{\n    const char *auth_line;\n    apr_size_t l;\n    int vk = 0, vv = 0;\n    char *key, *value;\n\n    auth_line = apr_table_get(r->headers_in,\n                             (PROXYREQ_PROXY == r->proxyreq)\n                                 ? \"Proxy-Authorization\"\n                                 : \"Authorization\");\n    if (!auth_line) {\n        resp->auth_hdr_sts = NO_HEADER;\n        return !OK;\n    }\n\n    resp->scheme = ap_getword_white(r->pool, &auth_line);\n    if (ap_cstr_casecmp(resp->scheme, \"Digest\")) {\n        resp->auth_hdr_sts = NOT_DIGEST;\n        return !OK;\n    }\n\n    l = strlen(auth_line);\n\n    key   = apr_palloc(r->pool, l+1);\n    value = apr_palloc(r->pool, l+1);\n\n    while (auth_line[0] != '\\0') {\n\n        \n\n        while (apr_isspace(auth_line[0])) {\n            auth_line++;\n        }\n        vk = 0;\n        while (auth_line[0] != '=' && auth_line[0] != ','\n               && auth_line[0] != '\\0' && !apr_isspace(auth_line[0])) {\n            key[vk++] = *auth_line++;\n        }\n        key[vk] = '\\0';\n        while (apr_isspace(auth_line[0])) {\n            auth_line++;\n        }\n\n        \n\n        if (auth_line[0] == '=') {\n            auth_line++;\n            while (apr_isspace(auth_line[0])) {\n                auth_line++;\n            }\n\n            vv = 0;\n            if (auth_line[0] == '\\\"') {         \n                auth_line++;\n                while (auth_line[0] != '\\\"' && auth_line[0] != '\\0') {\n                    if (auth_line[0] == '\\\\' && auth_line[1] != '\\0') {\n                        auth_line++;            \n                    }\n                    value[vv++] = *auth_line++;\n                }\n                if (auth_line[0] != '\\0') {\n                    auth_line++;\n                }\n            }\n            else {                               \n                while (auth_line[0] != ',' && auth_line[0] != '\\0'\n                       && !apr_isspace(auth_line[0])) {\n                    value[vv++] = *auth_line++;\n                }\n            }\n            value[vv] = '\\0';\n        }\n\n        while (auth_line[0] != ',' && auth_line[0] != '\\0') {\n            auth_line++;\n        }\n        if (auth_line[0] != '\\0') {\n            auth_line++;\n        }\n\n        if (!ap_cstr_casecmp(key, \"username\"))\n            resp->username = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"realm\"))\n            resp->realm = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"nonce\"))\n            resp->nonce = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"uri\"))\n            resp->uri = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"response\"))\n            resp->digest = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"algorithm\"))\n            resp->algorithm = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"cnonce\"))\n            resp->cnonce = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"opaque\"))\n            resp->opaque = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"qop\"))\n            resp->message_qop = apr_pstrdup(r->pool, value);\n        else if (!ap_cstr_casecmp(key, \"nc\"))\n            resp->nonce_count = apr_pstrdup(r->pool, value);\n    }\n\n    if (!resp->username || !resp->realm || !resp->nonce || !resp->uri\n        || !resp->digest\n        || (resp->message_qop && (!resp->cnonce || !resp->nonce_count))) {\n        resp->auth_hdr_sts = INVALID;\n        return !OK;\n    }\n\n    if (resp->opaque) {\n        resp->opaque_num = (unsigned long) strtol(resp->opaque, NULL, 16);\n    }\n\n    resp->auth_hdr_sts = VALID;\n    return OK;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_190abd2ef8e0e543ad3b4e419968e37e7a3d507b_0", {
    "ID": "httpd_190abd2ef8e0e543ad3b4e419968e37e7a3d507b_0",
    "UID": "6810",
    "code": "static void process_proxy_header(request_rec *r, proxy_dir_conf test_snippet\n                                 const char *key, const char *value)\n{\n    static const char *date_hdrs[]\n        = { \"Date\", \"Expires\", \"Last-Modified\", NULL };\n    static const struct {\n        const char *name;\n        ap_proxy_header_reverse_map_fn func;\n    } transform_hdrs[] = {\n        { \"Location\", ap_proxy_location_reverse_map },\n        { \"Content-Location\", ap_proxy_location_reverse_map },\n        { \"URI\", ap_proxy_location_reverse_map },\n        { \"Destination\", ap_proxy_location_reverse_map },\n        { \"Set-Cookie\", ap_proxy_cookie_reverse_map },\n        { NULL, NULL }\n    };\n    int i;\n    for (i = 0; date_hdrs[i]; ++i) {\n        if (!ap_cstr_casecmp(date_hdrs[i], key)) {\n            apr_table_add(r->headers_out, key,\n                          date_canon(r->pool, value));\n            return;\n        }\n    }\n    for (i = 0; transform_hdrs[i].name; ++i) {\n        if (!ap_cstr_casecmp(transform_hdrs[i].name, key)) {\n            apr_table_add(r->headers_out, key,\n                          (*transform_hdrs[i].func)(r, c, value));\n            return;\n       }\n    }\n    apr_table_add(r->headers_out, key, value);\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_510f68c1b2ad77fe042b3067f433fb5a74cfb9e0_0", {
    "ID": "httpd_510f68c1b2ad77fe042b3067f433fb5a74cfb9e0_0",
    "UID": "6848",
    "code": "AP_DECLARE(int) ap_get_basic_auth_pw(request_rec *r, const char test_snippet\n{\n    const char *t, *auth_line;\n\n    if (!(t = ap_auth_type(r)) || ap_cstr_casecmp(t, \"Basic\"))\n        return DECLINED;\n\n    if (!ap_auth_name(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00572) \n                      \"need AuthName: %s\", r->uri);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    auth_line = apr_table_get(r->headers_in,\n                              (PROXYREQ_PROXY == r->proxyreq)\n                                  ? \"Proxy-Authorization\" : \"Authorization\");\n\n    if (!auth_line) {\n        ap_note_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (ap_cstr_casecmp(ap_getword(r->pool, &auth_line, ' '), \"Basic\")) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00573)\n                      \"client used wrong authentication scheme: %s\", r->uri);\n        ap_note_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    while (*auth_line == ' ' || *auth_line == '\\t') {\n        auth_line++;\n    }\n\n    t = ap_pbase64decode(r->pool, auth_line);\n    r->user = ap_getword_nulls (r->pool, &t, ':');\n    r->ap_auth_type = \"Basic\";\n\n    *pw = t;\n\n    return OK;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n522,Sensitive Data Storage in Improperly Locked Memory"
  },
  "httpd_30683d825f7c248e53457c18c054f72cd4c6ec32_0", {
    "ID": "httpd_30683d825f7c248e53457c18c054f72cd4c6ec32_0",
    "UID": "6874",
    "code": "AP_DECLARE(char *) ap_escape_urlencoded(apr_pool_t *p, const char test_snippet\n{\n    return ap_escape_urlencoded_buffer(apr_palloc(p, 3 * strlen(buffer) + 1), buffer);\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow"
  },
  "httpd_bc9585cc5cca04de313a2e6b36e5621904b3e3b2_0", {
    "ID": "httpd_bc9585cc5cca04de313a2e6b36e5621904b3e3b2_0",
    "UID": "6930",
    "code": "static const char *include_config (cmd_parms *cmd, void test_snippet\n                                   const char *name)\n{\n    ap_directive_t *conftree = NULL;\n    const char *conffile, *error;\n    unsigned *recursion;\n    int optional = cmd->cmd->cmd_data ? 1 : 0;\n    void *data;\n\n    /* NOTE: ap_include_sentinel is also used by ap_process_resource_config()\n     * during DUMP_INCLUDES; don't change its type or remove it without updating\n     * the other.\n     */\n    apr_pool_userdata_get(&data, \"ap_include_sentinel\", cmd->pool);\n    if (data) {\n        recursion = data;\n    }\n    else {\n        data = recursion = apr_palloc(cmd->pool, sizeof(*recursion));\n        *recursion = 0;\n        apr_pool_userdata_setn(data, \"ap_include_sentinel\", NULL, cmd->pool);\n    }\n\n    if (++*recursion > AP_MAX_INCLUDE_DEPTH) {\n        *recursion = 0;\n        return apr_psprintf(cmd->pool, \"Exceeded maximum include depth of %u, \"\n                            \"There appears to be a recursion.\",\n                            AP_MAX_INCLUDE_DEPTH);\n    }\n\n    conffile = ap_server_root_relative(cmd->pool, name);\n    if (!conffile) {\n        *recursion = 0;\n        return apr_pstrcat(cmd->pool, \"Invalid Include path \",\n                           name, NULL);\n    }\n\n    if (ap_exists_config_define(\"DUMP_INCLUDES\")) {\n        unsigned *line_number;\n\n        /* NOTE: ap_include_lineno is used by ap_process_resource_config()\n         * during DUMP_INCLUDES; don't change its type or remove it without\n         * updating the other.\n         */\n        apr_pool_userdata_get(&data, \"ap_include_lineno\", cmd->pool);\n        if (data) {\n            line_number = data;\n        } else {\n            data = line_number = apr_palloc(cmd->pool, sizeof(*line_number));\n            apr_pool_userdata_setn(data, \"ap_include_lineno\", NULL, cmd->pool);\n        }\n\n        *line_number = cmd->config_file->line_number;\n    }\n\n    error = ap_process_fnmatch_configs(cmd->server, conffile, &conftree,\n                                       cmd->pool, cmd->temp_pool,\n                                       optional);\n    if (error) {\n        *recursion = 0;\n        return error;\n    }\n\n    *(ap_directive_t **)dummy = conftree;\n\n    \n    if (*recursion) {\n        --*recursion;\n    }\n\n    return NULL;\n}",
    "predicted": "23,Relative Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n457,Use of Uninitialized Variable\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_15ff4272f0af07db4d54287ff234d103d7f2b1b5_0", {
    "ID": "httpd_15ff4272f0af07db4d54287ff234d103d7f2b1b5_0",
    "UID": "7084",
    "code": "static void check_pipeline(conn_rec *c, apr_bucket_brigade test_snippet\n{\n    apr_status_t rv;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    ap_input_mode_t mode = AP_MODE_SPECULATIVE;\n    apr_size_t cr = 0;\n    char buf[2];\n\n    c->data_in_input_filters = 0;\n    while (c->keepalive != AP_CONN_CLOSE && !c->aborted) {\n        apr_size_t len = cr + 1;\n\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c->input_filters, bb, mode,\n                            APR_NONBLOCK_READ, len);\n        if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n            /*\n             * Error or empty brigade: There is no data present in the input\n             * filter\n             */\n            if (mode == AP_MODE_READBYTES) {\n                \n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(02967)\n                              \"Can't consume pipelined empty lines\");\n                c->keepalive = AP_CONN_CLOSE;\n            }\n            break;\n        }\n\n        /* Ignore trailing blank lines (which must not be interpreted as\n         * pipelined requests) up to the limit, otherwise we would block\n         * on the next read without flushing data, and hence possibly delay\n         * pending response(s) until the next/real request comes in or the\n         * keepalive timeout expires.\n         */\n        rv = apr_brigade_flatten(bb, buf, &len);\n        if (rv != APR_SUCCESS || len != cr + 1) {\n            int log_level;\n            if (mode == AP_MODE_READBYTES) {\n                \n                c->keepalive = AP_CONN_CLOSE;\n                log_level = APLOG_ERR;\n            }\n            else {\n                /* Let outside (non-speculative/blocking) read determine\n                 * where this possible failure comes from (metadata,\n                 * morphed EOF socket => empty bucket? debug only here).\n                 */\n                c->data_in_input_filters = 1;\n                log_level = APLOG_DEBUG;\n            }\n            ap_log_cerror(APLOG_MARK, log_level, rv, c, APLOGNO(02968)\n                          \"Can't check pipelined data\");\n            break;\n        }\n\n        if (mode == AP_MODE_READBYTES) {\n            mode = AP_MODE_SPECULATIVE;\n            cr = 0;\n        }\n        else if (cr) {\n            AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n            if (buf[1] == APR_ASCII_LF) {\n                mode = AP_MODE_READBYTES;\n                num_blank_lines--;\n            }\n            else {\n                c->data_in_input_filters = 1;\n                break;\n            }\n        }\n        else {\n            if (buf[0] == APR_ASCII_LF) {\n                mode = AP_MODE_READBYTES;\n                num_blank_lines--;\n            }\n            else if (buf[0] == APR_ASCII_CR) {\n                cr = 1;\n            }\n            else {\n                c->data_in_input_filters = 1;\n                break;\n            }\n        }\n        /* Enough blank lines with this connection?\n         * Stop and don't recycle it.\n         */\n        if (num_blank_lines < 0) {\n            c->keepalive = AP_CONN_CLOSE;\n        }\n    }\n}",
    "predicted": "400,Uncontrolled Resource Consumption"
  },
  "httpd_d10617f045b37f579476641c6561fd12b4d24adc_0", {
    "ID": "httpd_d10617f045b37f579476641c6561fd12b4d24adc_0",
    "UID": "7097",
    "code": "static void ap_authn_cache_store(request_rec *r, const char test_snippet\n                                 const char *user, const char *realm,\n                                 const char* data)\n{\n    apr_status_t rv;\n    authn_cache_dircfg *dcfg;\n    const char *key;\n    apr_time_t expiry;\n    int i;\n    int use_cache = 0;\n\n    \n    dcfg = ap_get_module_config(r->per_dir_config, &authn_socache_module);\n    if (!configured || !dcfg->providers) {\n        return;\n    }\n    for (i = 0; i < dcfg->providers->nelts; ++i) {\n        if (!strcmp(module, APR_ARRAY_IDX(dcfg->providers, i, const char*))) {\n            use_cache = 1;\n            break;\n        }\n    }\n    if (!use_cache) {\n        return;\n    }\n\n    \n    rv = apr_global_mutex_trylock(authn_cache_mutex);\n    if (APR_STATUS_IS_EBUSY(rv)) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01679)\n                      \"authn credentials for %s not cached (mutex busy)\", user);\n        return;\n    }\n    else if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01680)\n                      \"Failed to cache authn credentials for %s in %s\",\n                      module, dcfg->context);\n        return;\n    }\n\n    \n    \n    key = construct_key(r, dcfg->context, user, realm);\n    expiry = apr_time_now() + dcfg->timeout;\n\n    \n    rv = socache_provider->store(socache_instance, r->server,\n                                 (unsigned char*)key, strlen(key), expiry,\n                                 (unsigned char*)data, strlen(data), r->pool);\n    if (rv == APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01681)\n                      \"Cached authn credentials for %s in %s\",\n                      user, dcfg->context);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01682)\n                      \"Failed to cache authn credentials for %s in %s\",\n                      module, dcfg->context);\n    }\n\n    \n    rv = apr_global_mutex_unlock(authn_cache_mutex);\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01683) \"Failed to release mutex!\");\n    }\n}",
    "predicted": "391,Unchecked Error Condition\n404,Improper Resource Shutdown or Release"
  },
  "httpd_62f36812be29a27ad5463b861bfa584b4d1b8fca_0", {
    "ID": "httpd_62f36812be29a27ad5463b861bfa584b4d1b8fca_0",
    "UID": "7130",
    "code": "int cache_check_freshness(cache_handle_t *h, cache_request_rec test_snippet\n        request_rec *r)\n{\n    apr_status_t status;\n    apr_int64_t age, maxage_req, maxage_cresp, maxage, smaxage, maxstale;\n    apr_int64_t minfresh;\n    const char *cc_req;\n    const char *pragma;\n    const char *agestr = NULL;\n    apr_time_t age_c = 0;\n    cache_info *info = &(h->cache_obj->info);\n    const char *warn_head;\n    cache_server_conf *conf =\n      (cache_server_conf *)ap_get_module_config(r->server->module_config,\n                                                &cache_module);\n\n    /*\n     * We now want to check if our cached data is still fresh. This depends\n     * on a few things, in this order:\n     *\n     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache. no-cache\n     * in either the request or the cached response means that we must\n     * perform the request unconditionally, and ignore cached content. We\n     * should never reach here, but if we do, mark the content as stale,\n     * as this is the best we can do.\n     *\n     * - RFC2616 14.32 Pragma: no-cache This is treated the same as\n     * Cache-Control: no-cache.\n     *\n     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,\n     * proxy-revalidate if the max-stale request header exists, modify the\n     * stale calculations below so that an object can be at most <max-stale>\n     * seconds stale before we request a revalidation, _UNLESS_ a\n     * must-revalidate or proxy-revalidate cached response header exists to\n     * stop us doing this.\n     *\n     * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the\n     * maximum age an object can be before it is considered stale. This\n     * directive has the effect of proxy|must revalidate, which in turn means\n     * simple ignore any max-stale setting.\n     *\n     * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both\n     * requests and responses. If both are specified, the smaller of the two\n     * takes priority.\n     *\n     * - RFC2616 14.21 Expires: if this request header exists in the cached\n     * entity, and it's value is in the past, it has expired.\n     *\n     */\n\n    \n    cc_req = apr_table_get(r->headers_in, \"Cache-Control\");\n    pragma = apr_table_get(r->headers_in, \"Pragma\");\n\n    ap_cache_control(r, &cache->control_in, cc_req, pragma, r->headers_in);\n\n    if (cache->control_in.no_cache) {\n\n        if (!conf->ignorecachecontrol) {\n            \n            return 0;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00781)\n                \"Incoming request is asking for a uncached version of \"\n                \"%s, but we have been configured to ignore it and \"\n                \"serve a cached response anyway\",\n                r->unparsed_uri);\n    }\n\n    \n    if (h->cache_obj->info.control.no_cache\n            || h->cache_obj->info.control.invalidated) {\n        /*\n         * The cached entity contained Cache-Control: no-cache, or a\n         * no-cache with a header present, or a private with a header\n         * present, or the cached entity has been invalidated in the\n         * past, so treat as stale causing revalidation.\n         */\n        return 0;\n    }\n\n    if ((agestr = apr_table_get(h->resp_hdrs, \"Age\"))) {\n        char *endp;\n        apr_off_t offt;\n        if (!apr_strtoff(&offt, agestr, &endp, 10)\n                && endp > agestr && !*endp) {\n            age_c = offt;\n        }\n    }\n\n    \n    age = ap_cache_current_age(info, age_c, r->request_time);\n\n    \n    smaxage = h->cache_obj->info.control.s_maxage_value;\n\n    \n    maxage_req = -1;\n    if (!conf->ignorecachecontrol) {\n        maxage_req = cache->control_in.max_age_value;\n    }\n\n    /*\n     * extract max-age from response, if both s-maxage and max-age, s-maxage\n     * takes priority\n     */\n    if (smaxage != -1) {\n        maxage_cresp = smaxage;\n    }\n    else {\n        maxage_cresp = h->cache_obj->info.control.max_age_value;\n    }\n\n    /*\n     * if both maxage request and response, the smaller one takes priority\n     */\n    if (maxage_req == -1) {\n        maxage = maxage_cresp;\n    }\n    else if (maxage_cresp == -1) {\n        maxage = maxage_req;\n    }\n    else {\n        maxage = MIN(maxage_req, maxage_cresp);\n    }\n\n    \n    if (cache->control_in.max_stale) {\n        if(cache->control_in.max_stale_value != -1) {\n            maxstale = cache->control_in.max_stale_value;\n        }\n        else {\n            /*\n             * If no value is assigned to max-stale, then the client is willing\n             * to accept a stale response of any age (RFC2616 14.9.3). We will\n             * set it to one year in this case as this situation is somewhat\n             * similar to a \"never expires\" Expires header (RFC2616 14.21)\n             * which is set to a date one year from the time the response is\n             * sent in this case.\n             */\n            maxstale = APR_INT64_C(86400*365);\n        }\n    }\n    else {\n        maxstale = 0;\n    }\n\n    \n    if (!conf->ignorecachecontrol && cache->control_in.min_fresh) {\n        minfresh = cache->control_in.min_fresh_value;\n    }\n    else {\n        minfresh = 0;\n    }\n\n    \n    if (maxstale && (h->cache_obj->info.control.must_revalidate\n            || h->cache_obj->info.control.proxy_revalidate || smaxage != -1)) {\n        maxstale = 0;\n    }\n\n    \n    if (((maxage != -1) && (age < (maxage + maxstale - minfresh))) ||\n        ((smaxage == -1) && (maxage == -1) &&\n         (info->expire != APR_DATE_BAD) &&\n         (age < (apr_time_sec(info->expire - info->date) + maxstale - minfresh)))) {\n\n        warn_head = apr_table_get(h->resp_hdrs, \"Warning\");\n\n        \n        \n        apr_table_set(h->resp_hdrs, \"Age\",\n                      apr_psprintf(r->pool, \"%lu\", (unsigned long)age));\n\n        \n        if (!(((maxage != -1) && age < maxage) ||\n              (info->expire != APR_DATE_BAD &&\n               (apr_time_sec(info->expire - info->date)) > age))) {\n            \n            if ((warn_head == NULL) ||\n                ((warn_head != NULL) && (ap_strstr_c(warn_head, \"110\") == NULL))) {\n                apr_table_mergen(h->resp_hdrs, \"Warning\",\n                                 \"110 Response is stale\");\n            }\n        }\n\n        /*\n         * If none of Expires, Cache-Control: max-age, or Cache-Control:\n         * s-maxage appears in the response, and the response header age\n         * calculated is more than 24 hours add the warning 113\n         */\n        if ((maxage_cresp == -1) && (smaxage == -1) && (apr_table_get(\n                h->resp_hdrs, \"Expires\") == NULL) && (age > 86400)) {\n\n            /* Make sure we don't stomp on a previous warning, and don't dup\n             * a 113 marning that is already present. Also, make sure to add\n             * the new warning to the correct *headers_out location.\n             */\n            if ((warn_head == NULL) ||\n                ((warn_head != NULL) && (ap_strstr_c(warn_head, \"113\") == NULL))) {\n                apr_table_mergen(h->resp_hdrs, \"Warning\",\n                                 \"113 Heuristic expiration\");\n            }\n        }\n        return 1;    \n    }\n\n    /*\n     * At this point we are stale, but: if we are under load, we may let\n     * a significant number of stale requests through before the first\n     * stale request successfully revalidates itself, causing a sudden\n     * unexpected thundering herd which in turn brings angst and drama.\n     *\n     * So.\n     *\n     * We want the first stale request to go through as normal. But the\n     * second and subsequent request, we must pretend to be fresh until\n     * the first request comes back with either new content or confirmation\n     * that the stale content is still fresh.\n     *\n     * To achieve this, we create a very simple file based lock based on\n     * the key of the cached object. We attempt to open the lock file with\n     * exclusive write access. If we succeed, woohoo! we're first, and we\n     * follow the stale path to the backend server. If we fail, oh well,\n     * we follow the fresh path, and avoid being a thundering herd.\n     *\n     * The lock lives only as long as the stale request that went on ahead.\n     * If the request succeeds, the lock is deleted. If the request fails,\n     * the lock is deleted, and another request gets to make a new lock\n     * and try again.\n     *\n     * At any time, a request marked \"no-cache\" will force a refresh,\n     * ignoring the lock, ensuring an extended lockout is impossible.\n     *\n     * A lock that exceeds a maximum age will be deleted, and another\n     * request gets to make a new lock and try again.\n     */\n    status = cache_try_lock(conf, cache, r);\n    if (APR_SUCCESS == status) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00782)\n                \"Cache lock obtained for stale cached URL, \"\n                \"revalidating entry: %s\",\n                r->unparsed_uri);\n        return 0;\n    }\n    else if (APR_STATUS_IS_EEXIST(status)) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00783)\n                \"Cache already locked for stale cached URL, \"\n                \"pretend it is fresh: %s\",\n                r->unparsed_uri);\n\n        \n        warn_head = apr_table_get(h->resp_hdrs, \"Warning\");\n        if ((warn_head == NULL) ||\n            ((warn_head != NULL) && (ap_strstr_c(warn_head, \"110\") == NULL))) {\n            apr_table_mergen(h->resp_hdrs, \"Warning\",\n                             \"110 Response is stale\");\n        }\n\n        return 1;\n    }\n    else {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00784)\n                \"Attempt to obtain a cache lock for stale \"\n                \"cached URL failed, revalidating entry anyway: %s\",\n                r->unparsed_uri);\n        return 0;\n    }\n\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition"
  },
  "httpd_531888d0dc7245810751f7439a1ca704368dcc94_0", {
    "ID": "httpd_531888d0dc7245810751f7439a1ca704368dcc94_0",
    "UID": "7270",
    "code": "static const char *set_define(cmd_parms *cmd, void test_snippet\n                              const char *name, const char *value)\n{\n    if (cmd->parent && strcasecmp(cmd->parent->directive, \"<VirtualHost\")) { \n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n    if (!ap_exists_config_define(name)) {\n        const char **newv = (const char **)apr_array_push(ap_server_config_defines);\n        *newv = name;\n    }\n    if (value) {\n        if (!server_config_defined_vars) {\n            server_config_defined_vars = apr_table_make(cmd->pool, 5);\n        }\n        apr_table_setn(server_config_defined_vars, name, value);\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting"
  },
  "httpd_2355040daf0706b6098c2bbad69bd25a79c508fe_0", {
    "ID": "httpd_2355040daf0706b6098c2bbad69bd25a79c508fe_0",
    "UID": "7312",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet(test_snippetctest_snippetotest_snippetntest_snippetntest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetctest_snippet,test_snippet test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetrtest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetstest_snippet,test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetrtest_snippetetest_snippetptest_snippetotest_snippetrtest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippet*test_snippetptest_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetptest_snippetotest_snippetotest_snippetltest_snippet_test_snippetttest_snippet test_snippet*test_snippetptest_snippetotest_snippetotest_snippetltest_snippet test_snippet=test_snippet test_snippetrtest_snippet?test_snippet test_snippetrtest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet test_snippet:test_snippet test_snippetctest_snippet-test_snippet>test_snippetptest_snippetotest_snippetotest_snippetltest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetrtest_snippetetest_snippet_test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet test_snippet*test_snippetctest_snippetotest_snippetntest_snippetftest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippethtest_snippetetest_snippetatest_snippetdtest_snippetetest_snippetrtest_snippet_test_snippetttest_snippet test_snippet*test_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet test_snippet=test_snippet test_snippetNtest_snippetUtest_snippetLtest_snippetLtest_snippet;test_snippet\ntest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippet test_snippet=test_snippet test_snippet(test_snippetrtest_snippet?test_snippet test_snippetrtest_snippet-test_snippet>test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet test_snippet:test_snippet test_snippetctest_snippet-test_snippet>test_snippetbtest_snippetatest_snippetstest_snippetetest_snippet_test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetctest_snippetotest_snippetrtest_snippetetest_snippet_test_snippetmtest_snippetotest_snippetdtest_snippetutest_snippetltest_snippetetest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet(test_snippetstest_snippet-test_snippet>test_snippetmtest_snippetotest_snippetdtest_snippetutest_snippetltest_snippetetest_snippet_test_snippetctest_snippetotest_snippetntest_snippetftest_snippetitest_snippetgtest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet>test_snippet test_snippet0test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet(test_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet>test_snippet test_snippet1test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet|test_snippet|test_snippet test_snippet!test_snippetatest_snippetptest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetstest_snippetttest_snippetrtest_snippet_test_snippetctest_snippetotest_snippetntest_snippetttest_snippetatest_snippetitest_snippetntest_snippetstest_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet,test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetitest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetptest_snippetotest_snippetstest_snippetstest_snippetitest_snippetbtest_snippetltest_snippetytest_snippet test_snippetmtest_snippetotest_snippetrtest_snippetetest_snippet test_snippetttest_snippethtest_snippetatest_snippetntest_snippet test_snippetotest_snippetntest_snippetetest_snippet test_snippetctest_snippethtest_snippetotest_snippetitest_snippetctest_snippetetest_snippet test_snippetotest_snippetrtest_snippet test_snippetotest_snippetntest_snippetetest_snippet,test_snippet test_snippetbtest_snippetutest_snippetttest_snippet test_snippetntest_snippetotest_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet*test_snippet test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet.test_snippet test_snippet(test_snippetTtest_snippetOtest_snippetDtest_snippetOtest_snippet:test_snippet test_snippetmtest_snippetatest_snippetytest_snippetbtest_snippetetest_snippet test_snippet4test_snippet2test_snippet6test_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetUtest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippet test_snippetttest_snippethtest_snippetetest_snippetntest_snippet?test_snippet)test_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetatest_snippetrtest_snippetrtest_snippetatest_snippetytest_snippet_test_snippetmtest_snippetatest_snippetktest_snippetetest_snippet(test_snippetptest_snippetotest_snippetotest_snippetltest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet test_snippet+test_snippet test_snippet1test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetitest_snippetztest_snippetetest_snippetotest_snippetftest_snippet(test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippet(test_snippetitest_snippet test_snippet=test_snippet test_snippet0test_snippet;test_snippet test_snippetitest_snippet test_snippet<test_snippet test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet-test_snippet>test_snippetntest_snippetetest_snippetltest_snippetttest_snippetstest_snippet;test_snippet test_snippetitest_snippet+test_snippet+test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippet test_snippet=test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetAtest_snippetRtest_snippetRtest_snippetAtest_snippetYtest_snippet_test_snippetItest_snippetDtest_snippetXtest_snippet(test_snippetctest_snippetotest_snippetntest_snippetftest_snippet-test_snippet>test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippetstest_snippet,test_snippet test_snippetitest_snippet,test_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetetest_snippetxtest_snippetitest_snippetstest_snippetttest_snippetitest_snippetntest_snippetgtest_snippet,test_snippet test_snippetptest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet/test_snippet*test_snippet test_snippetntest_snippetotest_snippetttest_snippet test_snippetttest_snippethtest_snippetetest_snippet test_snippetotest_snippetntest_snippetetest_snippet test_snippetwtest_snippetetest_snippet test_snippethtest_snippetatest_snippetvtest_snippetetest_snippet test_snippetatest_snippetntest_snippetdtest_snippet test_snippetptest_snippetotest_snippetstest_snippetstest_snippetitest_snippetbtest_snippetltest_snippetetest_snippet,test_snippet test_snippetatest_snippetdtest_snippetdtest_snippet test_snippetitest_snippetntest_snippet test_snippetttest_snippethtest_snippetitest_snippetstest_snippet test_snippetotest_snippetrtest_snippetdtest_snippetetest_snippetrtest_snippet test_snippet*test_snippet/test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetAtest_snippetRtest_snippetRtest_snippetAtest_snippetYtest_snippet_test_snippetPtest_snippetUtest_snippetStest_snippetHtest_snippet(test_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet,test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet*test_snippet)test_snippet test_snippet=test_snippet test_snippetptest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetetest_snippetltest_snippetstest_snippetetest_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetrtest_snippetetest_snippetptest_snippetotest_snippetrtest_snippetttest_snippet_test_snippetatest_snippetltest_snippetltest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetbtest_snippetrtest_snippetetest_snippetatest_snippetktest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet*test_snippetptest_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet test_snippet=test_snippet test_snippetutest_snippetptest_snippetgtest_snippetrtest_snippetatest_snippetdtest_snippetetest_snippetstest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code is not readable or valid C/C++ code. It seems to be obfuscated or encrypted. Therefore, it's impossible to determine any potential vulnerabilities. Please provide a valid piece of code."
  },
  "httpd_3ace1a05ab00c47bc731c7817801be18b384c167_0", {
    "ID": "httpd_3ace1a05ab00c47bc731c7817801be18b384c167_0",
    "UID": "7319",
    "code": "static char *lookup_variable(char *var, rewrite_ctx test_snippet\n{\n    const char *result;\n    request_rec *r = ctx->r;\n    apr_size_t varlen = strlen(var);\n\n    \n    if (varlen < 4) {\n        return \"\";\n    }\n\n    result = NULL;\n\n    \n    if (var[3] == ':') {\n        if (var[4] && !ap_casecmpstrn(var, \"ENV\", 3)) {\n            var += 4;\n            result = apr_table_get(r->notes, var);\n\n            if (!result) {\n                result = apr_table_get(r->subprocess_env, var);\n            }\n            if (!result) {\n                result = getenv(var);\n            }\n        }\n        else if (var[4] && !ap_casecmpstrn(var, \"SSL\", 3) && rewrite_ssl_lookup) {\n            result = rewrite_ssl_lookup(r->pool, r->server, r->connection, r,\n                                        var + 4);\n        }\n    }\n    else if (var[4] == ':') {\n        if (var[5]) {\n            request_rec *rr;\n            const char *path;\n\n            if (!ap_casecmpstrn(var, \"HTTP\", 4)) {\n                result = lookup_header(var+5, ctx);\n            }\n            else if (!ap_casecmpstrn(var, \"LA-U\", 4)) {\n                if (ctx->uri && subreq_ok(r)) {\n                    path = ctx->perdir ? la_u(ctx) : ctx->uri;\n                    rr = ap_sub_req_lookup_uri(path, r, NULL);\n                    ctx->r = rr;\n                    result = apr_pstrdup(r->pool, lookup_variable(var+5, ctx));\n                    ctx->r = r;\n                    ap_destroy_sub_req(rr);\n\n                    rewritelog((r, 5, ctx->perdir, \"lookahead: path=%s var=%s \"\n                                \"-> val=%s\", path, var+5, result));\n\n                    return (char *)result;\n                }\n            }\n            else if (!ap_casecmpstrn(var, \"LA-F\", 4)) {\n                if (ctx->uri && subreq_ok(r)) {\n                    path = ctx->uri;\n                    if (ctx->perdir && *path == '/') {\n                        /* sigh, the user wants a file based subrequest, but\n                         * we can't do one, since we don't know what the file\n                         * path is! In this case behave like LA-U.\n                         */\n                        rr = ap_sub_req_lookup_uri(path, r, NULL);\n                    }\n                    else {\n                        if (ctx->perdir) {\n                            rewrite_perdir_conf *conf;\n\n                            conf = ap_get_module_config(r->per_dir_config,\n                                                        &rewrite_module);\n\n                            path = apr_pstrcat(r->pool, conf->directory, path,\n                                               NULL);\n                        }\n\n                        rr = ap_sub_req_lookup_file(path, r, NULL);\n                    }\n\n                    ctx->r = rr;\n                    result = apr_pstrdup(r->pool, lookup_variable(var+5, ctx));\n                    ctx->r = r;\n                    ap_destroy_sub_req(rr);\n\n                    rewritelog((r, 5, ctx->perdir, \"lookahead: path=%s var=%s \"\n                                \"-> val=%s\", path, var+5, result));\n\n                    return (char *)result;\n                }\n            }\n        }\n    }\n\n    \n    else {\n        apr_time_exp_t tm;\n\n        \n        ap_str_toupper(var);\n\n        switch (varlen) {\n        case  4:\n            if (!strcmp(var, \"TIME\")) {\n                apr_time_exp_lt(&tm, apr_time_now());\n                result = apr_psprintf(r->pool, \"%04d%02d%02d%02d%02d%02d\",\n                                      tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,\n                                      tm.tm_hour, tm.tm_min, tm.tm_sec);\n                rewritelog((r, 1, ctx->perdir, \"RESULT='%s'\", result));\n                return (char *)result;\n            }\n            else if (!strcmp(var, \"IPV6\")) {\n                int flag = FALSE;\n#if APR_HAVE_IPV6\n                apr_sockaddr_t *addr = r->useragent_addr;\n                flag = (addr->family == AF_INET6 &&\n                        !IN6_IS_ADDR_V4MAPPED((struct in6_addr *)addr->ipaddr_ptr));\n                rewritelog((r, 1, ctx->perdir, \"IPV6='%s'\", flag ? \"on\" : \"off\"));\n#else\n                rewritelog((r, 1, ctx->perdir, \"IPV6='off' (IPv6 is not enabled)\"));\n#endif\n                result = (flag ? \"on\" : \"off\");\n            }\n            break;\n\n        case  5:\n            if (!strcmp(var, \"HTTPS\")) {\n                int flag = rewrite_is_https && rewrite_is_https(r->connection);\n                return apr_pstrdup(r->pool, flag ? \"on\" : \"off\");\n            }\n            break;\n\n        case  8:\n            switch (var[6]) {\n            case 'A':\n                if (!strcmp(var, \"TIME_DAY\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%02d\", tm.tm_mday);\n                }\n                break;\n\n            case 'E':\n                if (!strcmp(var, \"TIME_SEC\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%02d\", tm.tm_sec);\n                }\n                break;\n\n            case 'I':\n                if (!strcmp(var, \"TIME_MIN\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%02d\", tm.tm_min);\n                }\n                break;\n\n            case 'O':\n                if (!strcmp(var, \"TIME_MON\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%02d\", tm.tm_mon+1);\n                }\n                break;\n            }\n            break;\n\n        case  9:\n            switch (var[7]) {\n            case 'A':\n                if (var[8] == 'Y' && !strcmp(var, \"TIME_WDAY\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%d\", tm.tm_wday);\n                }\n                else if (!strcmp(var, \"TIME_YEAR\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%04d\", tm.tm_year+1900);\n                }\n                break;\n\n            case 'E':\n                if (!strcmp(var, \"IS_SUBREQ\")) {\n                    result = (r->main ? \"true\" : \"false\");\n                }\n                break;\n\n            case 'F':\n                if (!strcmp(var, \"PATH_INFO\")) {\n                    result = r->path_info;\n                }\n                break;\n\n            case 'P':\n                if (!strcmp(var, \"AUTH_TYPE\")) {\n                    result = r->ap_auth_type;\n                }\n                break;\n\n            case 'S':\n                if (!strcmp(var, \"HTTP_HOST\")) {\n                    result = lookup_header(\"Host\", ctx);\n                }\n                break;\n\n            case 'U':\n                if (!strcmp(var, \"TIME_HOUR\")) {\n                    apr_time_exp_lt(&tm, apr_time_now());\n                    return apr_psprintf(r->pool, \"%02d\", tm.tm_hour);\n                }\n                break;\n            }\n            break;\n\n        case 11:\n            switch (var[8]) {\n            case 'A':\n                if (!strcmp(var, \"SERVER_NAME\")) {\n                    result = ap_get_server_name_for_url(r);\n                }\n                break;\n\n            case 'D':\n                if (*var == 'R' && !strcmp(var, \"REMOTE_ADDR\")) {\n                    result = r->useragent_ip;\n                }\n                else if (!strcmp(var, \"SERVER_ADDR\")) {\n                    result = r->connection->local_ip;\n                }\n                break;\n\n            case 'E':\n                if (*var == 'H' && !strcmp(var, \"HTTP_ACCEPT\")) {\n                    result = lookup_header(\"Accept\", ctx);\n                }\n                else if (!strcmp(var, \"THE_REQUEST\")) {\n                    result = r->the_request;\n                }\n                break;\n\n            case 'I':\n                if (!strcmp(var, \"API_VERSION\")) {\n                    return apr_psprintf(r->pool, \"%d:%d\",\n                                        MODULE_MAGIC_NUMBER_MAJOR,\n                                        MODULE_MAGIC_NUMBER_MINOR);\n                }\n                break;\n\n            case 'K':\n                if (!strcmp(var, \"HTTP_COOKIE\")) {\n                    result = lookup_header(\"Cookie\", ctx);\n                }\n                break;\n\n            case 'O':\n                if (*var == 'S' && !strcmp(var, \"SERVER_PORT\")) {\n                    return apr_psprintf(r->pool, \"%u\", ap_get_server_port(r));\n                }\n                else if (var[7] == 'H' && !strcmp(var, \"REMOTE_HOST\")) {\n                    result = ap_get_remote_host(r->connection,r->per_dir_config,\n                                                REMOTE_NAME, NULL);\n                }\n                else if (!strcmp(var, \"REMOTE_PORT\")) {\n                    return apr_itoa(r->pool, r->useragent_addr->port);\n                }\n                break;\n\n            case 'S':\n                if (*var == 'R' && !strcmp(var, \"REMOTE_USER\")) {\n                    result = r->user;\n                }\n                else if (!strcmp(var, \"SCRIPT_USER\")) {\n                    result = \"<unknown>\";\n                    if (r->finfo.valid & APR_FINFO_USER) {\n                        apr_uid_name_get((char **)&result, r->finfo.user,\n                                         r->pool);\n                    }\n                }\n                break;\n\n            case 'U':\n                if (!strcmp(var, \"REQUEST_URI\")) {\n                    result = r->uri;\n                }\n                break;\n            }\n            break;\n\n        case 12:\n            switch (var[3]) {\n            case 'I':\n                if (!strcmp(var, \"SCRIPT_GROUP\")) {\n                    result = \"<unknown>\";\n                    if (r->finfo.valid & APR_FINFO_GROUP) {\n                        apr_gid_name_get((char **)&result, r->finfo.group,\n                                         r->pool);\n                    }\n                }\n                break;\n\n            case 'O':\n                if (!strcmp(var, \"REMOTE_IDENT\")) {\n                    result = ap_get_remote_logname(r);\n                }\n                break;\n\n            case 'P':\n                if (!strcmp(var, \"HTTP_REFERER\")) {\n                    result = lookup_header(\"Referer\", ctx);\n                }\n                break;\n\n            case 'R':\n                if (!strcmp(var, \"QUERY_STRING\")) {\n                    result = r->args;\n                }\n                break;\n\n            case 'V':\n                if (!strcmp(var, \"SERVER_ADMIN\")) {\n                    result = r->server->server_admin;\n                }\n                break;\n            }\n            break;\n\n        case 13:\n            if (!strcmp(var, \"DOCUMENT_ROOT\")) {\n                result = ap_document_root(r);\n            }\n            break;\n\n        case 14:\n            if (*var == 'H' && !strcmp(var, \"HTTP_FORWARDED\")) {\n                result = lookup_header(\"Forwarded\", ctx);\n            }\n            else if (*var == 'C' && !strcmp(var, \"CONTEXT_PREFIX\")) {\n                result = ap_context_prefix(r);\n            }\n            else if (var[8] == 'M' && !strcmp(var, \"REQUEST_METHOD\")) {\n                result = r->method;\n            }\n            else if (!strcmp(var, \"REQUEST_SCHEME\")) {\n                result = ap_http_scheme(r);\n            }\n            break;\n\n        case 15:\n            switch (var[7]) {\n            case 'E':\n                if (!strcmp(var, \"HTTP_USER_AGENT\")) {\n                    result = lookup_header(\"User-Agent\", ctx);\n                }\n                break;\n\n            case 'F':\n                if (!strcmp(var, \"SCRIPT_FILENAME\")) {\n                    result = r->filename; \n                }\n                break;\n\n            case 'P':\n                if (!strcmp(var, \"SERVER_PROTOCOL\")) {\n                    result = r->protocol;\n                }\n                break;\n\n            case 'S':\n                if (!strcmp(var, \"SERVER_SOFTWARE\")) {\n                    result = ap_get_server_banner();\n                }\n                break;\n            }\n            break;\n\n        case 16:\n            if (*var == 'C' && !strcmp(var, \"CONN_REMOTE_ADDR\")) {\n                result = r->connection->client_ip;\n            }\n            else if (!strcmp(var, \"REQUEST_FILENAME\")) {\n                result = r->filename; \n            }\n            break;\n\n        case 21:\n            if (!strcmp(var, \"HTTP_PROXY_CONNECTION\")) {\n                result = lookup_header(\"Proxy-Connection\", ctx);\n            }\n            else if (!strcmp(var, \"CONTEXT_DOCUMENT_ROOT\")) {\n                result = ap_context_document_root(r);\n            }\n            break;\n        }\n    }\n\n    return apr_pstrdup(r->pool, result ? result : \"\");\n}",
    "predicted": "476,NULL Pointer Dereference\n126,Buffer Over-read\n127,Buffer Under-read\n20,Improper Input Validation\n"
  },
  "httpd_7fb796491e45d2e4b0ec3604c3ec81e8f92b1d8e_0", {
    "ID": "httpd_7fb796491e45d2e4b0ec3604c3ec81e8f92b1d8e_0",
    "UID": "7354",
    "code": "static int event_open_logs(apr_pool_t * p, apr_pool_t * test_snippet\n                           apr_pool_t * ptemp, server_rec * s)\n{\n    int startup = 0;\n    int level_flags = 0;\n    int num_buckets = 0;\n    ap_listen_rec **listen_buckets;\n    apr_status_t rv;\n    int i;\n\n    pconf = p;\n\n    \n    if (retained->module_loads == 1) {\n        startup = 1;\n        level_flags |= APLOG_STARTUP;\n    }\n\n    if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT | level_flags, 0,\n                     (startup ? NULL : s),\n                     \"no listening sockets available, shutting down\");\n        return DONE;\n    }\n\n    if (one_process) {\n        num_buckets = 1;\n    }\n    else if (retained->is_graceful) {\n        \n        num_buckets = retained->num_buckets;\n    }\n    if ((rv = ap_duplicate_listeners(pconf, ap_server_conf,\n                                     &listen_buckets, &num_buckets))) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,\n                     (startup ? NULL : s),\n                     \"could not duplicate listeners\");\n        return DONE;\n    }\n\n    all_buckets = apr_pcalloc(pconf, num_buckets * sizeof(*all_buckets));\n    for (i = 0; i < num_buckets; i++) {\n        if ((rv = ap_mpm_podx_open(pconf, &all_buckets[i].pod))) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,\n                         (startup ? NULL : s),\n                         \"could not open pipe-of-death\");\n            return DONE;\n        }\n        all_buckets[i].listeners = listen_buckets[i];\n    }\n\n    if (retained->max_buckets < num_buckets) {\n        int new_max, *new_ptr;\n        new_max = retained->max_buckets * 2;\n        if (new_max < num_buckets) {\n            new_max = num_buckets;\n        }\n        new_ptr = (int *)apr_palloc(ap_pglobal, new_max * sizeof(int));\n        memcpy(new_ptr, retained->idle_spawn_rate,\n               retained->num_buckets * sizeof(int));\n        retained->idle_spawn_rate = new_ptr;\n        retained->max_buckets = new_max;\n    }\n    if (retained->num_buckets < num_buckets) {\n        int rate_max = 1;\n        /* If new buckets are added, set their idle spawn rate to\n         * the highest so far, so that they get filled as quickly\n         * as the existing ones.\n         */\n        for (i = 0; i < retained->num_buckets; i++) {\n            if (rate_max < retained->idle_spawn_rate[i]) {\n                rate_max = retained->idle_spawn_rate[i];\n            }\n        }\n        for (; i < num_buckets; i++) {\n            retained->idle_spawn_rate[i] = rate_max;\n        }\n    }\n    retained->num_buckets = num_buckets;\n\n    \n    srand((unsigned int)apr_time_now());\n    return OK;\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_7972146522b702487258ec948c359abc4be62299_0", {
    "ID": "httpd_7972146522b702487258ec948c359abc4be62299_0",
    "UID": "7380",
    "code": "static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned test_snippet\n{\n    char *cp;\n\n    /* be safe.\n     * NULL should indicate elsewhere, that something's wrong\n     */\n    if (!scheme || strlen(uri) < test_snippet {\n        return NULL;\n    }\n\n    cp = uri + scheme;\n\n    \n    if (cp[-1] == '/') {\n        \n        while (*cp && *cp != '/') {\n            ++cp;\n        }\n\n        \n        if (!*cp || !*++cp) {\n            return apr_pstrdup(p, uri);\n        }\n\n        \n        scheme = cp - uri;\n\n        /* special thing for ldap.\n         * The parts are separated by question marks. From RFC 2255:\n         *     ldapurl = scheme \"://\" [hostport] [\"/\"\n         *               [dn [\"?\" [attributes] [\"?\" [scope]\n         *               [\"?\" [filter] [\"?\" extensions]]]]]]\n         */\n        if (!ap_casecmpstrn(uri, \"ldap\", 4)) {\n            char *token[5];\n            int c = 0;\n\n            token[0] = cp = apr_pstrdup(p, cp);\n            while (*cp && c < 4) {\n                if (*cp == '?') {\n                    token[++c] = cp + 1;\n                    *cp = '\\0';\n                }\n                ++cp;\n            }\n\n            return apr_pstrcat(p, apr_pstrndup(p, uri, test_snippet,\n                                          ap_escape_uri(p, token[0]),\n                               (c >= 1) ? \"?\" : NULL,\n                               (c >= 1) ? ap_escape_uri(p, token[1]) : NULL,\n                               (c >= 2) ? \"?\" : NULL,\n                               (c >= 2) ? ap_escape_uri(p, token[2]) : NULL,\n                               (c >= 3) ? \"?\" : NULL,\n                               (c >= 3) ? ap_escape_uri(p, token[3]) : NULL,\n                               (c >= 4) ? \"?\" : NULL,\n                               (c >= 4) ? ap_escape_uri(p, token[4]) : NULL,\n                               NULL);\n        }\n    }\n\n    \n    return apr_pstrcat(p, apr_pstrndup(p, uri, test_snippet,\n                       ap_escape_uri(p, cp), NULL);\n}",
    "predicted": "90,Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')"
  },
  "httpd_a893a0c79a6783b507de8c9d7d6937f39097dac4_0", {
    "ID": "httpd_a893a0c79a6783b507de8c9d7d6937f39097dac4_0",
    "UID": "7384",
    "code": "static int core_upgrade_handler(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n\n    if (c->master) {\n        /* Not possible to perform an HTTP/1.1 upgrade from a slave\n         * connection. */\n        return DECLINED;\n    }\n    \n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            \n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            \n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    \n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    \n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n\n                    ap_switch_protocol(c, r, r->server, protocol);\n\n                    \n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        /* first request on a master connection, if we have protocols other\n         * than the current one enabled here, announce them to the\n         * client. If the client is already talking a protocol with requests\n         * on slave connections, leave it be. */\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    \n    return DECLINED;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n"
  },
  "httpd_2a2db317c5fc17a5f6794373adf0eb302c69cfd7_0", {
    "ID": "httpd_2a2db317c5fc17a5f6794373adf0eb302c69cfd7_0",
    "UID": "7389",
    "code": "static int mkrecord(char *user, char *record, apr_size_t rlen, char test_snippet\n                    int alg)\n{\n    char *pw;\n    char cpw[120];\n    char pwin[MAX_STRING_LEN];\n    char pwv[MAX_STRING_LEN];\n    char salt[9];\n    apr_size_t bufsize;\n#if CRYPT_ALGO_SUPPORTED\n    char *cbuf;\n#endif\n\n    if (passwd != NULL) {\n        pw = passwd;\n    }\n    else {\n        bufsize = sizeof(pwin);\n        if (apr_password_get(\"New password: \", pwin, &bufsize) != 0) {\n            apr_snprintf(record, (rlen - 1), \"password too long (>%\"\n                         APR_SIZE_T_FMT \")\", sizeof(pwin) - 1);\n            return ERR_OVERFLOW;\n        }\n        bufsize = sizeof(pwv);\n        apr_password_get(\"Re-type new password: \", pwv, &bufsize);\n        if (strcmp(pwin, pwv) != 0) {\n            apr_cpystrn(record, \"password verification error\", (rlen - 1));\n            return ERR_PWMISMATCH;\n        }\n        pw = pwin;\n        memset(pwv, '\\0', sizeof(pwin));\n    }\n    switch (alg) {\n\n    case ALG_APSHA:\n        \n        apr_sha1_base64(pw,strlen(pw),cpw);\n        break;\n\n    case ALG_APMD5:\n        if (seed_rand()) {\n            break;\n        }\n        generate_salt(&salt[0], 8);\n        salt[8] = '\\0';\n\n        apr_md5_encode((const char *)pw, (const char *)salt,\n                     cpw, sizeof(cpw));\n        break;\n\n    case ALG_PLAIN:\n        \n        apr_cpystrn(cpw,pw,sizeof(cpw));\n        break;\n\n#if CRYPT_ALGO_SUPPORTED\n    case ALG_CRYPT:\n    default:\n        if (seed_rand()) {\n            break;\n        }\n        to64(&salt[0], rand(), 8);\n        salt[8] = '\\0';\n\n        cbuf = crypt(pw, salt);\n        if (cbuf == NULL) {\n            char errbuf[128];\n\n            apr_snprintf(record, rlen-1, \"crypt() failed: %s\", \n                         apr_strerror(errno, errbuf, sizeof errbuf));\n            return ERR_PWMISMATCH;\n        }\n\n        apr_cpystrn(cpw, cbuf, sizeof(cpw) - 1);\n        if (strlen(pw) > 8) {\n            char *truncpw = strdup(pw);\n            truncpw[8] = '\\0';\n            if (!strcmp(cpw, crypt(truncpw, salt))) {\n                apr_file_printf(errfile, \"Warning: Password truncated to 8 characters \"\n                                \"by CRYPT algorithm.\" NL);\n            }\n            free(truncpw);\n        }\n        break;\n#endif \n    }\n    memset(pw, '\\0', strlen(pw));\n\n    /*\n     * Check to see if the buffer is large enough to hold the username,\n     * hash, and delimiters.\n     */\n    if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {\n        apr_cpystrn(record, \"resultant record too long\", (rlen - 1));\n        return ERR_OVERFLOW;\n    }\n    strcpy(record, user);\n    strcat(record, \":\");\n    strcat(record, cpw);\n    strcat(record, \"\\n\");\n    return 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_81c3681f11ba19dd7bd7a241692137ae353094f0_0", {
    "ID": "httpd_81c3681f11ba19dd7bd7a241692137ae353094f0_0",
    "UID": "7393",
    "code": "static apr_status_t htdbm_make(htdbm_t test_snippet\n{\n    char cpw[MAX_STRING_LEN];\n    char salt[9];\n#if (!(defined(WIN32) || defined(NETWARE)))\n    char *cbuf;\n#endif\n\n    switch (htdbm->alg) {\n        case ALG_APSHA:\n            \n            apr_sha1_base64(htdbm->userpass,strlen(htdbm->userpass),cpw);\n        break;\n\n        case ALG_APMD5:\n            (void) srand((int) time((time_t *) NULL));\n            to64(&salt[0], rand(), 8);\n            salt[8] = '\\0';\n            apr_md5_encode((const char *)htdbm->userpass, (const char *)salt,\n                            cpw, sizeof(cpw));\n        break;\n        case ALG_PLAIN:\n            \n            apr_cpystrn(cpw,htdbm->userpass,sizeof(cpw));\n#if (!(defined(WIN32) || defined(NETWARE)))\n            fprintf(stderr, \"Warning: Plain text passwords aren't supported by the \"\n                    \"server on this platform!\\n\");\n#endif\n        break;\n#if (!(defined(WIN32) || defined(NETWARE)))\n        case ALG_CRYPT:\n            (void) srand((int) time((time_t *) NULL));\n            to64(&salt[0], rand(), 8);\n            salt[8] = '\\0';\n            cbuf = crypt(htdbm->userpass, salt);\n            if (cbuf == NULL) {\n                char errbuf[128];\n                \n                fprintf(stderr, \"crypt() failed: %s\\n\", \n                        apr_strerror(errno, errbuf, sizeof errbuf));\n                exit(ERR_PWMISMATCH);\n            }\n            apr_cpystrn(cpw, cbuf, sizeof(cpw) - 1);\n            fprintf(stderr, \"CRYPT is now deprecated, use MD5 instead!\\n\");\n#endif\n        default:\n        break;\n    }\n    htdbm->userpass = apr_pstrdup(htdbm->pool, cpw);\n    return APR_SUCCESS;\n}",
    "predicted": "338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n"
  },
  "httpd_23ed2445f0d28fe143835e7e74f572199ec205d4_0", {
    "ID": "httpd_23ed2445f0d28fe143835e7e74f572199ec205d4_0",
    "UID": "7394",
    "code": "static const char *cmd_log_message(cmd_parms *cmd, void *dconf_, const char test_snippet\n                                   const char *arg2, const char *arg3)\n{\n    msg_entry *entry = apr_pcalloc(cmd->pool, sizeof(msg_entry));\n    log_debug_dirconf *dconf = dconf_;\n    int i, j;\n    const char *err;\n    const char *args[2];\n    args[0] = arg2;\n    args[1] = arg3;\n\n    entry->msg_expr = ap_expr_parse_cmd(cmd, arg1, AP_EXPR_FLAG_STRING_RESULT|\n                                                   AP_EXPR_FLAG_DONT_VARY,\n                                        &err, NULL);\n    if (err)\n        return apr_psprintf(cmd->pool,\n                            \"Could not parse message expression '%s': %s\",\n                            arg1, err);\n\n    for (i = 0; i < 2; i++) {\n        if (args[i] == NULL)\n            break;\n\n        if (strncasecmp(args[i], \"hook=\", 5) == 0) {\n            const char *name = args[i] + 5;\n            j = 0;\n            while (hooks[j]) {\n                if (strcasecmp(hooks[j], name) == 0) {\n                    entry->hook = hooks[j];\n                    break;\n                }\n                j++;\n            }\n            if (entry->hook == NULL) {\n                if (strcmp(name, \"*\") == 0 || strcasecmp(name, allhooks) == 0)\n                    entry->hook = allhooks;\n                else\n                    return apr_psprintf(cmd->pool, \"Invalid hook name: %s\", name);\n            }\n        }\n        else if (strncasecmp(args[i], \"expr=\", 5) == 0) {\n            const char *expr = args[i] + 5;\n            entry->condition = ap_expr_parse_cmd(cmd, expr,\n                                                 AP_EXPR_FLAG_DONT_VARY,\n                                                 &err, NULL);\n            if (err)\n                return apr_psprintf(cmd->pool,\n                                    \"Could not parse expression '%s': %s\",\n                                    expr, err);\n        }\n        else {\n            return apr_psprintf(cmd->pool, \"Invalid argument %s\", args[i]);\n        }\n    }\n    if (entry->hook == NULL)\n        entry->hook = hooks[0];\n\n    if (!dconf->entries)\n        dconf->entries = apr_array_make(cmd->pool, 4, sizeof(msg_entry *));\n\n    APR_ARRAY_PUSH(dconf->entries, msg_entry *) = entry;\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_7499366561562498351922eda909472961cba654_0", {
    "ID": "httpd_7499366561562498351922eda909472961cba654_0",
    "UID": "7408",
    "code": "static apr_status_t pass_data_to_filter(ap_filter_t *f, const char test_snippet\n                                        apr_size_t len, apr_bucket_brigade *bb)\n{\n    ef_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_size_t bytes_written = 0;\n    apr_size_t tmplen;\n\n    do {\n        tmplen = len - bytes_written;\n        rv = apr_file_write_full(ctx->proc->in,\n                       (const char *)data + bytes_written,\n                       tmplen, &tmplen);\n        bytes_written += tmplen;\n        if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01461)\n                          \"apr_file_write(child input), len %\" APR_SIZE_T_FMT,\n                          tmplen);\n            return rv;\n        }\n        if (APR_STATUS_IS_EAGAIN(rv)) {\n            /* XXX handle blocking conditions here...  if we block, we need\n             * to read data from the child process and pass it down to the\n             * next filter!\n             */\n            rv = drain_available_output(f, bb);\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n#if APR_FILES_AS_SOCKETS\n                int num_events;\n                const apr_pollfd_t *pdesc;\n\n                rv = apr_pollset_poll(ctx->pollset, f->r->server->timeout,\n                                      &num_events, &pdesc);\n                if (rv != APR_SUCCESS && !APR_STATUS_IS_EINTR(rv)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r, APLOGNO(01462)\n                                  \"apr_pollset_poll()\");\n                    \n                    return rv;\n                }\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE6, rv, f->r,\n                              \"apr_pollset_poll()\");\n#else \n                /* Yuck... I'd really like to wait until I can read\n                 * or write, but instead I have to sleep and try again\n                 */\n                apr_sleep(100000); \n                ap_log_rerror(APLOG_MARK, APLOG_TRACE6, 0, f->r, \"apr_sleep()\");\n#endif \n            }\n            else if (rv != APR_SUCCESS) {\n                return rv;\n            }\n        }\n    } while (bytes_written < len);\n    return rv;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition"
  },
  "httpd_140be8dff36579db1b57642811b00200ce184ab6_0", {
    "ID": "httpd_140be8dff36579db1b57642811b00200ce184ab6_0",
    "UID": "7412",
    "code": "AP_DECLARE(void) ap_lingering_close(conn_rec test_snippet\n{\n    char dummybuf[512];\n    apr_size_t nbytes;\n    apr_time_t now, timeup = 0;\n    apr_socket_t *csd = ap_get_conn_socket(c);\n\n    if (ap_start_lingering_close(c)) {\n        return;\n    }\n\n    /* Read available data from the client whilst it continues sending\n     * it, for a maximum time of MAX_SECS_TO_LINGER.  If the client\n     * does not send any data within 2 seconds (a value pulled from\n     * Apache 1.3 which seems to work well), give up.\n     */\n    apr_socket_timeout_set(csd, apr_time_from_sec(SECONDS_TO_LINGER));\n    apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n\n    /* The common path here is that the initial apr_socket_recv() call\n     * will return 0 bytes read; so that case must avoid the expensive\n     * apr_time_now() call and time arithmetic. */\n\n    do {\n        nbytes = sizeof(dummybuf);\n        if (apr_socket_recv(csd, dummybuf, &nbytes) || nbytes == 0)\n            break;\n\n        now = apr_time_now();\n        if (timeup == 0) {\n            /*\n             * First time through;\n             * calculate now + 30 seconds (MAX_SECS_TO_LINGER).\n             *\n             * If some module requested a shortened waiting period, only wait for\n             * 2s (SECONDS_TO_LINGER). This is useful for mitigating certain\n             * DoS attacks.\n             */\n            if (apr_table_get(c->notes, \"short-lingering-close\")) {\n                timeup = now + apr_time_from_sec(SECONDS_TO_LINGER);\n            }\n            else {\n                timeup = now + apr_time_from_sec(MAX_SECS_TO_LINGER);\n            }\n            continue;\n        }\n    } while (now < timeup);\n\n    apr_socket_close(csd);\n    return;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_2005c96d02a26ddb37c905224a6a8ea4e1b32955_0", {
    "ID": "httpd_2005c96d02a26ddb37c905224a6a8ea4e1b32955_0",
    "UID": "7445",
    "code": "static void store_slotmem(ap_slotmem_instance_t test_snippet\n{\n    apr_file_t *fp;\n    apr_status_t rv;\n    apr_size_t nbytes;\n    unsigned char digest[APR_MD5_DIGESTSIZE];\n    const char *storename = slotmem->pname;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02334)\n                 \"storing %s\", storename);\n\n    if (storename) {\n        rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                           APR_OS_DEFAULT, slotmem->pool);\n        if (APR_STATUS_IS_EEXIST(rv)) {\n            apr_file_remove(storename, slotmem->pool);\n            rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                               APR_OS_DEFAULT, slotmem->pool);\n        }\n        if (rv != APR_SUCCESS) {\n            return;\n        }\n        if (AP_SLOTMEM_IS_CLEARINUSE(slotmem)) {\n            slotmem_clearinuse(slotmem);\n        }\n        nbytes = (slotmem->desc->size * slotmem->desc->num) +\n                 (slotmem->desc->num * sizeof(char)) + AP_UNSIGNEDINT_OFFSET;\n        apr_md5(digest, slotmem->persist, nbytes);\n        rv = apr_file_write_full(fp, slotmem->persist, nbytes, NULL);\n        if (rv == APR_SUCCESS) {\n            rv = apr_file_write_full(fp, digest, APR_MD5_DIGESTSIZE, NULL);\n        }\n        if (rv == APR_SUCCESS) {\n            rv = apr_file_write_full(fp, slotmem->desc, AP_SLOTMEM_OFFSET,\n                                     NULL);\n        }\n        apr_file_close(fp);\n        if (rv != APR_SUCCESS) {\n            apr_file_remove(storename, slotmem->pool);\n        }\n    }\n}",
    "predicted": "775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_17e2f7b96d10dda34f2fb0951478539f2edee6da_0", {
    "ID": "httpd_17e2f7b96d10dda34f2fb0951478539f2edee6da_0",
    "UID": "7452",
    "code": "static unsigned int slotmem_num_free_slots(ap_slotmem_instance_t test_snippet\n{\n    if (AP_SLOTMEM_IS_PREGRAB(slot))\n        return *slot->num_free;\n    else {\n        unsigned int i, counter=0;\n        char *inuse = slot->inuse;\n        for (i=0; i<slot->desc->num; i++, inuse++) {\n            if (!*inuse)\n                counter++;\n        }\n        return counter;\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_f1bccf17a5f792c6c1125c336784f6b85a129a15_0", {
    "ID": "httpd_f1bccf17a5f792c6c1125c336784f6b85a129a15_0",
    "UID": "7465",
    "code": "test_snippet\nint ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,\n        proxy_conn_rec **backend_ptr, proxy_worker *worker,\n        proxy_server_conf *conf, char *server_portstr)\n{\n    conn_rec *c = r->connection;\n    char buffer[HUGE_STRING_LEN];\n    const char *buf;\n    char keepchar;\n    apr_bucket *e;\n    apr_bucket_brigade *bb;\n    apr_bucket_brigade *pass_bb;\n    int len, backasswards;\n    int interim_response = 0; /* non-zero whilst interim 1xx responses\n                               * are being read. */\n    int pread_len = 0;\n    apr_table_t *save_table;\n    int backend_broke = 0;\n    test_snippet const char *hop_by_hop_hdrs[] =\n        {\"Keep-Alive\", \"Proxy-Authenticate\", \"TE\", \"Trailer\", \"Upgrade\", NULL};\n    int i;\n    const char *te = NULL;\n    int original_status = r->status;\n    int proxy_status = OK;\n    const char *original_status_line = r->status_line;\n    const char *proxy_status_line = NULL;\n    proxy_conn_rec *backend = *backend_ptr;\n    conn_rec *origin = backend->connection;\n    apr_interval_time_t old_timeout = 0;\n    proxy_dir_conf *dconf;\n    int do_100_continue;\n\n    dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n\n    do_100_continue = PROXY_DO_100_CONTINUE(worker, r);\n\n    bb = apr_brigade_create(p, c->bucket_alloc);\n    pass_bb = apr_brigade_create(p, c->bucket_alloc);\n\n    \n    if (do_100_continue) {\n        apr_socket_timeout_get(backend->sock, &old_timeout);\n        if (worker->s->ping_timeout != old_timeout) {\n            apr_status_t rc;\n            rc = apr_socket_timeout_set(backend->sock, worker->s->ping_timeout);\n            if (rc != APR_SUCCESS) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01101)\n                              \"could not set 100-Continue timeout\");\n            }\n        }\n    }\n\n    /* Get response from the remote server, and pass it up the\n     * filter chain\n     */\n\n    backend->r = make_fake_req(origin, r);\n    /* In case anyone needs to know, this is a fake request that is really a\n     * response.\n     */\n    backend->r->proxyreq = PROXYREQ_RESPONSE;\n    apr_table_setn(r->notes, \"proxy-source-port\", apr_psprintf(r->pool, \"%hu\",\n                   origin->local_addr->port));\n    do {\n        apr_status_t rc;\n\n        apr_brigade_cleanup(bb);\n\n        rc = ap_proxygetline(backend->tmp_bb, buffer, sizeof(buffer),\n                             backend->r, 0, &len);\n        if (len == 0) {\n            \n            rc = ap_proxygetline(backend->tmp_bb, buffer, sizeof(buffer),\n                                 backend->r, 0, &len);\n        }\n        if (len <= 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01102)\n                          \"error reading status line from remote \"\n                          \"server %s:%d\", backend->hostname, backend->port);\n            if (APR_STATUS_IS_TIMEUP(rc)) {\n                apr_table_setn(r->notes, \"proxy_timedout\", \"1\");\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01103) \"read timeout\");\n                if (do_100_continue) {\n                    proxy_run_detach_backend(r, backend);\n                    return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, \"Timeout on 100-Continue\");\n                }\n            }\n            /*\n             * If we are a reverse proxy request shutdown the connection\n             * WITHOUT ANY response to trigger a retry by the client\n             * if allowed (as for idempotent requests).\n             * BUT currently we should not do this if the request is the\n             * first request on a keepalive connection as browsers like\n             * seamonkey only display an empty page in this case and do\n             * not do a retry. We should also not do this on a\n             * connection which times out; instead handle as\n             * we normally would handle timeouts\n             */\n            if (r->proxyreq == PROXYREQ_REVERSE && c->keepalives &&\n                !APR_STATUS_IS_TIMEUP(rc)) {\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01104)\n                              \"Closing connection to client because\"\n                              \" reading from backend server %s:%d failed.\"\n                              \" Number of keepalives %i\", backend->hostname,\n                              backend->port, c->keepalives);\n\n                e = ap_bucket_error_create(HTTP_GATEWAY_TIME_OUT, NULL,\n                        r->pool, c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = ap_bucket_eoc_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ap_pass_brigade(r->output_filters, bb);\n                \n                backend->close = 1;\n                \n                proxy_run_detach_backend(r, backend);\n                return OK;\n            }\n            else if (!c->keepalives) {\n                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01105)\n                                   \"NOT Closing connection to client\"\n                                   \" although reading from backend server %s:%d\"\n                                   \" failed.\",\n                                   backend->hostname, backend->port);\n            }\n            proxy_run_detach_backend(r, backend);\n            return ap_proxyerror(r, HTTP_GATEWAY_TIME_OUT,\n                                 \"Error reading from remote server\");\n        }\n        \n        backend->worker->s->read += len;\n\n        /* Is it an HTTP/1 response?\n         * This is buggy if we ever see an HTTP/1.10\n         */\n        if (apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n            int major, minor;\n            int toclose;\n\n            major = buffer[5] - '0';\n            minor = buffer[7] - '0';\n\n            /* If not an HTTP/1 message or\n             * if the status line was > 8192 bytes\n             */\n            if ((major != 1) || (len >= sizeof(buffer)-1)) {\n                proxy_run_detach_backend(r, backend);\n                return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                apr_pstrcat(p, \"Corrupt status line returned by remote \"\n                            \"server: \", buffer, NULL));\n            }\n            backasswards = 0;\n\n            keepchar = buffer[12];\n            buffer[12] = '\\0';\n            proxy_status = atoi(&buffer[9]);\n            apr_table_setn(r->notes, \"proxy-status\",\n                           apr_pstrdup(r->pool, &buffer[9]));\n\n            if (keepchar != '\\0') {\n                buffer[12] = keepchar;\n            } else {\n                /* 2616 requires the space in Status-Line; the origin\n                 * server may have sent one but ap_rgetline_core will\n                 * have stripped it. */\n                buffer[12] = ' ';\n                buffer[13] = '\\0';\n            }\n            proxy_status_line = apr_pstrdup(p, &buffer[9]);\n\n            /* The status out of the front is the same as the status coming in\n             * from the back, until further notice.\n             */\n            r->status = proxy_status;\n            r->status_line = proxy_status_line;\n\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"Status from backend: %d\", proxy_status);\n\n            \n            \n            \n\n            \n            save_table = apr_table_make(r->pool, 2);\n            apr_table_do(addit_dammit, save_table, r->headers_out,\n                         \"Set-Cookie\", NULL);\n\n            \n            ap_proxy_read_headers(r, backend->r, buffer, sizeof(buffer), origin,\n                                  &pread_len);\n\n            if (r->headers_out == NULL) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01106)\n                              \"bad HTTP/%d.%d header returned by %s (%s)\",\n                              major, minor, r->uri, r->method);\n                backend->close = 1;\n                /*\n                 * ap_send_error relies on a headers_out to be present. we\n                 * are in a bad position here.. so force everything we send out\n                 * to have nothing to do with the incoming packet\n                 */\n                r->headers_out = apr_table_make(r->pool,1);\n                r->status = HTTP_BAD_GATEWAY;\n                r->status_line = \"bad gateway\";\n                proxy_run_detach_backend(r, backend);\n                return r->status;\n            }\n\n            \n            apr_table_do(addit_dammit, save_table, r->headers_out,\n                         \"Set-Cookie\", NULL);\n\n            \n            if (!apr_is_empty_table(save_table)) {\n                apr_table_unset(r->headers_out, \"Set-Cookie\");\n                r->headers_out = apr_table_overlay(r->pool,\n                                                   r->headers_out,\n                                                   save_table);\n            }\n\n            \n            if (apr_table_get(r->headers_out, \"Transfer-Encoding\")\n                    && apr_table_get(r->headers_out, \"Content-Length\")) {\n                /*\n                 * 2616 section 4.4, point 3: \"if both Transfer-Encoding\n                 * and Content-Length are received, the latter MUST be\n                 * ignored\";\n                 *\n                 * To help mitigate HTTP Splitting, unset Content-Length\n                 * and shut down the backend server connection\n                 * XXX: We aught to treat such a response as uncachable\n                 */\n                apr_table_unset(r->headers_out, \"Content-Length\");\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)\n                              \"server %s:%d returned Transfer-Encoding\"\n                              \" and Content-Length\",\n                              backend->hostname, backend->port);\n                backend->close = 1;\n            }\n\n            /*\n             * Save a possible Transfer-Encoding header as we need it later for\n             * ap_http_filter to know where to end.\n             */\n            te = apr_table_get(r->headers_out, \"Transfer-Encoding\");\n\n            \n            toclose = ap_proxy_clear_connection_fn(r, r->headers_out);\n            if (toclose) {\n                backend->close = 1;\n                if (toclose < 0) {\n                    proxy_run_detach_backend(r, backend);\n                    return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                                         \"Malformed connection header\");\n                }\n            }\n\n            if ((buf = apr_table_get(r->headers_out, \"Content-Type\"))) {\n                ap_set_content_type(r, apr_pstrdup(p, buf));\n            }\n            if (!ap_is_HTTP_INFO(proxy_status)) {\n                ap_proxy_pre_http_request(origin, backend->r);\n            }\n\n            \n            for (i=0; hop_by_hop_hdrs[i]; ++i) {\n                apr_table_unset(r->headers_out, hop_by_hop_hdrs[i]);\n            }\n\n            \n            r->headers_out = ap_proxy_clean_warnings(p, r->headers_out);\n\n            \n            if (conf->viaopt != via_off && conf->viaopt != via_block) {\n                const char *server_name = ap_get_server_name(r);\n                /* If USE_CANONICAL_NAME_OFF was configured for the proxy virtual host,\n                 * then the server name returned by ap_get_server_name() is the\n                 * origin server name (which does make too much sense with Via: headers)\n                 * so we use the proxy vhost's name instead.\n                 */\n                if (server_name == r->hostname)\n                    server_name = r->server->server_hostname;\n                \n                apr_table_addn(r->headers_out, \"Via\",\n                               (conf->viaopt == via_full)\n                                     ? apr_psprintf(p, \"%d.%d %s%s (%s)\",\n                                           HTTP_VERSION_MAJOR(r->proto_num),\n                                           HTTP_VERSION_MINOR(r->proto_num),\n                                           server_name,\n                                           server_portstr,\n                                           AP_SERVER_BASEVERSION)\n                                     : apr_psprintf(p, \"%d.%d %s%s\",\n                                           HTTP_VERSION_MAJOR(r->proto_num),\n                                           HTTP_VERSION_MINOR(r->proto_num),\n                                           server_name,\n                                           server_portstr)\n                );\n            }\n\n            \n            if ((major < 1) || (minor < 1)) {\n                backend->close = 1;\n                origin->keepalive = AP_CONN_CLOSE;\n            }\n        } else {\n            \n            backasswards = 1;\n            r->status = proxy_status = 200;\n            r->status_line = \"200 OK\";\n            backend->close = 1;\n        }\n\n        if (ap_is_HTTP_INFO(proxy_status)) {\n            interim_response++;\n            if (do_100_continue\n                && (r->status == HTTP_CONTINUE)) {\n                \n                do_100_continue = 0;\n                \n                if  (worker->s->ping_timeout != old_timeout) {\n                    apr_socket_timeout_set(backend->sock, old_timeout);\n                }\n            }\n        }\n        else {\n            interim_response = 0;\n        }\n        if (interim_response) {\n            /* RFC2616 tells us to forward this.\n             *\n             * OTOH, an interim response here may mean the backend\n             * is playing sillybuggers.  The Client didn't ask for\n             * it within the defined HTTP/1.1 mechanisms, and if\n             * it's an extension, it may also be unsupported by us.\n             *\n             * There's also the possibility that changing existing\n             * behaviour here might break something.\n             *\n             * So let's make it configurable.\n             *\n             * We need to set \"r->expecting_100 = 1\" otherwise origin\n             * server behaviour will apply.\n             */\n            const char *policy = apr_table_get(r->subprocess_env,\n                                               \"proxy-interim-response\");\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                          \"HTTP: received interim %d response\", r->status);\n            if (!policy\n                    || (!strcasecmp(policy, \"RFC\") && ((r->expecting_100 = 1)))) {\n                ap_send_interim_response(r, 1);\n            }\n            /* FIXME: refine this to be able to specify per-response-status\n             * policies and maybe also add option to bail out with 502\n             */\n            else if (strcasecmp(policy, \"Suppress\")) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01108)\n                              \"undefined proxy interim response policy\");\n            }\n        }\n\n        /* Moved the fixups of Date headers and those affected by\n         * ProxyPassReverse/etc from here to ap_proxy_read_headers\n         */\n\n        \n        if (ap_is_HTTP_ERROR(proxy_status) && dconf->error_override) {\n            if (proxy_status == HTTP_UNAUTHORIZED) {\n                const char *buf;\n                const char *wa = \"WWW-Authenticate\";\n                if ((buf = apr_table_get(r->headers_out, wa))) {\n                    apr_table_set(r->err_headers_out, wa, buf);\n                } else {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01109)\n                                  \"origin server sent 401 without \"\n                                  \"WWW-Authenticate header\");\n                }\n            }\n            /* clear r->status for override error, otherwise ErrorDocument\n             * thinks that this is a recursive error, and doesn't find the\n             * custom error page\n             */\n            r->status = HTTP_OK;\n            \n            if (!r->header_only) {\n                const char *tmp;\n                /* Add minimal headers needed to allow http_in filter\n                 * detecting end of body without waiting for a timeout. */\n                if ((tmp = apr_table_get(r->headers_out, \"Transfer-Encoding\"))) {\n                    apr_table_set(backend->r->headers_in, \"Transfer-Encoding\", tmp);\n                }\n                else if ((tmp = apr_table_get(r->headers_out, \"Content-Length\"))) {\n                    apr_table_set(backend->r->headers_in, \"Content-Length\", tmp);\n                }\n                else if (te) {\n                    apr_table_set(backend->r->headers_in, \"Transfer-Encoding\", te);\n                }\n                ap_discard_request_body(backend->r);\n            }\n            proxy_run_detach_backend(r, backend);\n            /*\n             * prevent proxy_handler() from treating this as an\n             * internal error.\n             */\n            apr_table_setn(r->notes, \"proxy-error-override\", \"1\");\n            return proxy_status;\n        }\n\n        r->sent_bodyct = 1;\n        /*\n         * Is it an HTTP/0.9 response or did we maybe preread the 1st line of\n         * the response? If so, load the extra data. These are 2 mutually\n         * exclusive possibilities, that just happen to require very\n         * similar behavior.\n         */\n        if (backasswards || pread_len) {\n            apr_ssize_t cntr = (apr_ssize_t)pread_len;\n            if (backasswards) {\n                /*@@@FIXME:\n                 * At this point in response processing of a 0.9 response,\n                 * we don't know yet whether data is binary or not.\n                 * mod_charset_lite will get control later on, so it cannot\n                 * decide on the conversion of this buffer full of data.\n                 * However, chances are that we are not really talking to an\n                 * HTTP/0.9 server, but to some different protocol, therefore\n                 * the best guess IMHO is to always treat the buffer as \"text/x\":\n                 */\n                ap_xlate_proto_to_ascii(buffer, len);\n                cntr = (apr_ssize_t)len;\n            }\n            e = apr_bucket_heap_create(buffer, cntr, NULL, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n        }\n\n        \n        if ((!r->header_only) &&                   \n            !interim_response &&                   \n            (proxy_status != HTTP_NO_CONTENT) &&      \n            (proxy_status != HTTP_NOT_MODIFIED)) {    \n\n            /* We need to copy the output headers and treat them as input\n             * headers as well.  BUT, we need to do this before we remove\n             * TE, so that they are preserved accordingly for\n             * ap_http_filter to know where to end.\n             */\n            backend->r->headers_in = apr_table_clone(backend->r->pool, r->headers_out);\n            /*\n             * Restore Transfer-Encoding header from response if we saved\n             * one before and there is none left. We need it for the\n             * ap_http_filter. See above.\n             */\n            if (te && !apr_table_get(backend->r->headers_in, \"Transfer-Encoding\")) {\n                apr_table_add(backend->r->headers_in, \"Transfer-Encoding\", te);\n            }\n\n            apr_table_unset(r->headers_out,\"Transfer-Encoding\");\n\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r, \"start body send\");\n\n            /*\n             * if we are overriding the errors, we can't put the content\n             * of the page into the brigade\n             */\n            if (!dconf->error_override || !ap_is_HTTP_ERROR(proxy_status)) {\n                \n                apr_read_type_e mode = APR_NONBLOCK_READ;\n                int finish = FALSE;\n\n                /* Handle the case where the error document is itself reverse\n                 * proxied and was successful. We must maintain any previous\n                 * error status so that an underlying error (eg HTTP_NOT_FOUND)\n                 * doesn't become an HTTP_OK.\n                 */\n                if (dconf->error_override && !ap_is_HTTP_ERROR(proxy_status)\n                        && ap_is_HTTP_ERROR(original_status)) {\n                    r->status = original_status;\n                    r->status_line = original_status_line;\n                }\n\n                do {\n                    apr_off_t readbytes;\n                    apr_status_t rv;\n\n                    rv = ap_get_brigade(backend->r->input_filters, bb,\n                                        AP_MODE_READBYTES, mode,\n                                        conf->io_buffer_size);\n\n                    /* ap_get_brigade will return success with an empty brigade\n                     * for a non-blocking read which would block: */\n                    if (mode == APR_NONBLOCK_READ\n                        && (APR_STATUS_IS_EAGAIN(rv)\n                            || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)))) {\n                        \n                        e = apr_bucket_flush_create(c->bucket_alloc);\n                        APR_BRIGADE_INSERT_TAIL(bb, e);\n                        if (ap_pass_brigade(r->output_filters, bb)\n                            || c->aborted) {\n                            backend->close = 1;\n                            break;\n                        }\n                        apr_brigade_cleanup(bb);\n                        mode = APR_BLOCK_READ;\n                        continue;\n                    }\n                    else if (rv == APR_EOF) {\n                        backend->close = 1;\n                        break;\n                    }\n                    else if (rv != APR_SUCCESS) {\n                        if (rv == APR_ENOSPC) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02475)\n                                          \"Response chunk/line was too large to parse\");\n                        }\n                        else if (rv == APR_ENOTIMPL) {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02476)\n                                          \"Response Transfer-Encoding was not recognised\");\n                        }\n                        else {\n                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01110)\n                                          \"Network error reading response\");\n                        }\n\n                        /* In this case, we are in real trouble because\n                         * our backend bailed on us. Given we're half way\n                         * through a response, our only option is to\n                         * disconnect the client too.\n                         */\n                        e = ap_bucket_error_create(HTTP_GATEWAY_TIME_OUT, NULL,\n                                r->pool, c->bucket_alloc);\n                        APR_BRIGADE_INSERT_TAIL(bb, e);\n                        e = ap_bucket_eoc_create(c->bucket_alloc);\n                        APR_BRIGADE_INSERT_TAIL(bb, e);\n                        ap_pass_brigade(r->output_filters, bb);\n\n                        backend_broke = 1;\n                        backend->close = 1;\n                        break;\n                    }\n                    \n                    mode = APR_NONBLOCK_READ;\n\n                    if (!apr_is_empty_table(backend->r->trailers_in)) {\n                        apr_table_do(add_trailers, r->trailers_out,\n                                backend->r->trailers_in, NULL);\n                        apr_table_clear(backend->r->trailers_in);\n                    }\n\n                    apr_brigade_length(bb, 0, &readbytes);\n                    backend->worker->s->read += readbytes;\n#if DEBUGGING\n                    {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01111)\n                                  \"readbytes: %#x\", readbytes);\n                    }\n#endif\n                    \n                    if (APR_BRIGADE_EMPTY(bb)) {\n                        break;\n                    }\n\n                    \n                    ap_proxy_buckets_lifetime_transform(r, bb, pass_bb);\n\n                    \n                    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(pass_bb))) {\n\n                        \n                        finish = TRUE;\n\n                        /* the brigade may contain transient buckets that contain\n                         * data that lives only as long as the backend connection.\n                         * Force a setaside so these transient buckets become heap\n                         * buckets that live as long as the request.\n                         */\n                        for (e = APR_BRIGADE_FIRST(pass_bb); e\n                                != APR_BRIGADE_SENTINEL(pass_bb); e\n                                = APR_BUCKET_NEXT(e)) {\n                            apr_bucket_setaside(e, r->pool);\n                        }\n\n                        /* finally it is safe to clean up the brigade from the\n                         * connection pool, as we have forced a setaside on all\n                         * buckets.\n                         */\n                        apr_brigade_cleanup(bb);\n\n                        /* make sure we release the backend connection as soon\n                         * as we know we are done, so that the backend isn't\n                         * left waiting for a slow client to eventually\n                         * acknowledge the data.\n                         */\n                        proxy_run_detach_backend(r, backend);\n                        ap_proxy_release_connection(backend->worker->s->scheme,\n                                backend, r->server);\n                        \n                        *backend_ptr = NULL;\n\n                    }\n\n                    \n                    if (ap_pass_brigade(r->output_filters, pass_bb) != APR_SUCCESS\n                        || c->aborted) {\n                        \n                        /* Only close backend if we haven't got all from the\n                         * backend. Furthermore if *backend_ptr is NULL it is no\n                         * longer safe to fiddle around with backend as it might\n                         * be already in use by another thread.\n                         */\n                        if (*backend_ptr) {\n                            backend->close = 1;  \n                        }\n                        finish = TRUE;\n                    }\n\n                    \n                    apr_brigade_cleanup(pass_bb);\n                    apr_brigade_cleanup(bb);\n\n                } while (!finish);\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"end body send\");\n        }\n        else if (!interim_response) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"header only\");\n\n            /* make sure we release the backend connection as soon\n             * as we know we are done, so that the backend isn't\n             * left waiting for a slow client to eventually\n             * acknowledge the data.\n             */\n            proxy_run_detach_backend(r, backend);\n            ap_proxy_release_connection(backend->worker->s->scheme,\n                    backend, r->server);\n            *backend_ptr = NULL;\n\n            \n            e = apr_bucket_eos_create(c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ap_pass_brigade(r->output_filters, bb);\n\n            apr_brigade_cleanup(bb);\n        }\n    } while (interim_response && (interim_response < AP_MAX_INTERIM_RESPONSES));\n\n    /* We have to cleanup bb brigade, because buckets inserted to it could be\n     * created from scpool and this pool can be freed before this brigade. */\n    apr_brigade_cleanup(bb);\n\n    if (*backend_ptr) {\n        proxy_run_detach_backend(r, backend);\n    }\n\n    \n    if (interim_response >= AP_MAX_INTERIM_RESPONSES) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_psprintf(p,\n                             \"Too many (%d) interim responses from origin server\",\n                             interim_response));\n    }\n\n    \n    if (c->aborted || backend_broke) {\n        return DONE;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_dec872f84b6f20d495141fe298d7b6662c257bdc_0", {
    "ID": "httpd_dec872f84b6f20d495141fe298d7b6662c257bdc_0",
    "UID": "7490",
    "code": "apr_status_t ajp_msg_append_uint8(ajp_msg_t *msg, apr_byte_t test_snippet\n{\n    apr_size_t len = msg->len;\n\n    if ((len + 1) > msg->max_size) {\n        return ajp_log_overflow(msg, \"ajp_msg_append_uint8\");\n    }\n\n    msg->buf[len] = value;\n    msg->len += 1;\n\n    return APR_SUCCESS;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_f991605e537e2d3cddcfa0de1df392b799fd6b1e_0", {
    "ID": "httpd_f991605e537e2d3cddcfa0de1df392b799fd6b1e_0",
    "UID": "7542",
    "code": "static proxy_worker *find_best_worker(proxy_balancer test_snippet\n                                      request_rec *r)\n{\n    proxy_worker *candidate = NULL;\n    apr_status_t rv;\n\n#if APR_HAS_THREADS\n    if ((rv = PROXY_THREAD_LOCK(balancer)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01163)\n                      \"%s: Lock failed for find_best_worker()\",\n                      balancer->s->name);\n        return NULL;\n    }\n#endif\n\n    candidate = (*balancer->lbmethod->finder)(balancer, r);\n\n    if (candidate)\n        candidate->s->elected++;\n\n#if APR_HAS_THREADS\n    if ((rv = PROXY_THREAD_UNLOCK(balancer)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01164)\n                      \"%s: Unlock failed for find_best_worker()\",\n                      balancer->s->name);\n    }\n#endif\n\n    if (candidate == NULL) {\n        /* All the workers are in error state or disabled.\n         * If the balancer has a timeout sleep for a while\n         * and try again to find the worker. The chances are\n         * that some other thread will release a connection.\n         * By default the timeout is not set, and the server\n         * returns SERVER_BUSY.\n         */\n        if (balancer->s->timeout) {\n            /* XXX: This can perhaps be build using some\n             * smarter mechanism, like tread_cond.\n             * But since the statuses can came from\n             * different children, use the provided algo.\n             */\n            apr_interval_time_t timeout = balancer->s->timeout;\n            apr_interval_time_t step, tval = 0;\n            /* Set the timeout to 0 so that we don't\n             * end in infinite loop\n             */\n            balancer->s->timeout = 0;\n            step = timeout / 100;\n            while (tval < timeout) {\n                apr_sleep(step);\n                \n                if ((candidate = find_best_worker(balancer, r)))\n                    break;\n                tval += step;\n            }\n            \n            balancer->s->timeout = timeout;\n        }\n    }\n\n    return candidate;\n\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n762,Mismatched Memory Management Routines\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_0830eb8940eaac3ae3a29ee182e7e10ba416f41e_0", {
    "ID": "httpd_0830eb8940eaac3ae3a29ee182e7e10ba416f41e_0",
    "UID": "7545",
    "code": "static int ftp_getrc_msg(conn_rec *ftp_ctrl, apr_bucket_brigade *bb, char *msgbuf, int test_snippet\n{\n    int status;\n    char response[MAX_LINE_LEN];\n    char buff[5];\n    char *mb = msgbuf, *me = &msgbuf[msglen];\n    apr_status_t rv;\n    apr_size_t nread;\n    \n    int eos;\n\n    if (APR_SUCCESS != (rv = ftp_string_read(ftp_ctrl, bb, response, sizeof(response), &eos, &nread))) {\n        return -1;\n    }\n/*\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, APLOGNO(03233)\n                 \"<%s\", response);\n*/\n    if (nread < 4) { \n        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(10229) \"Malformed FTP response '%s'\", response);\n        *mb = '\\0';\n        return -1;\n    }\n\n    if (!apr_isdigit(response[0]) || !apr_isdigit(response[1]) ||\n        !apr_isdigit(response[2]) || (response[3] != ' ' && response[3] != '-'))\n        status = 0;\n    else\n        status = 100 * response[0] + 10 * response[1] + response[2] - 111 * '0';\n\n    mb = apr_cpystrn(mb, response + 4, me - mb);\n\n    if (response[3] == '-') { \n        memcpy(buff, response, 3);\n        buff[3] = ' ';\n        do {\n            if (APR_SUCCESS != (rv = ftp_string_read(ftp_ctrl, bb, response, sizeof(response), &eos, &nread))) {\n                return -1;\n            }\n            mb = apr_cpystrn(mb, response + (' ' == response[0] ? 1 : 4), me - mb);\n        } while (memcmp(response, buff, 4) != 0);\n    }\n\n    return status;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_9f43714cb4716e35518e97327acf67fef5e7e439_0", {
    "ID": "httpd_9f43714cb4716e35518e97327acf67fef5e7e439_0",
    "UID": "7556",
    "code": "static void recalc_factors(proxy_balancer test_snippet\n{\n    int i;\n    proxy_worker **workers;\n\n\n    \n    workers = (proxy_worker **)balancer->workers->elts;\n    /* Special case if there is only one worker its\n     * load factor will always be 100\n     */\n    if (balancer->workers->nelts == 1) {\n        (*workers)->s->lbstatus = (*workers)->s->lbfactor = 100;\n        return;\n    }\n    for (i = 0; i < balancer->workers->nelts; i++) {\n        \n        workers[i]->s->lbstatus = workers[i]->s->lbfactor;\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_53cb1ff51759c7304fbfd42dc6f812bfb529faba_0", {
    "ID": "httpd_53cb1ff51759c7304fbfd42dc6f812bfb529faba_0",
    "UID": "7571",
    "code": "AP_DECLARE(int) ap_filter_prepare_brigade(ap_filter_t *f, apr_pool_t test_snippet\n{\n    apr_pool_t *pool;\n    ap_filter_t *next, *e;\n    ap_filter_t *found = NULL;\n\n    pool = f->r ? f->r->pool : f->c->pool;\n    if (p) {\n        *p = pool;\n    }\n    if (!f->bb) {\n        f->bb = apr_brigade_create(pool, f->c->bucket_alloc);\n        apr_pool_cleanup_register(pool, f, pending_filter_cleanup,\n                                  apr_pool_cleanup_null);\n    }\n    if (is_pending_filter(f)) {\n        return DECLINED;\n    }\n\n    /* Pending reads/writes must happen in the same order as input/output\n     * filters, so find the first \"next\" filter already in place and insert\n     * before it, if any, otherwise insert last.\n     */\n    if (f->c->pending_filters) {\n        for (next = f->next; next && !found; next = next->next) {\n            for (e = APR_RING_FIRST(f->c->pending_filters);\n                 e != APR_RING_SENTINEL(f->c->pending_filters,\n                                        ap_filter_t, pending);\n                 e = APR_RING_NEXT(e, pending)) {\n                if (e == next) {\n                    found = e;\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        f->c->pending_filters = apr_palloc(f->c->pool,\n                                           sizeof(*f->c->pending_filters));\n        APR_RING_INIT(f->c->pending_filters, ap_filter_t, pending);\n    }\n    if (found) {\n        APR_RING_INSERT_BEFORE(found, f, pending);\n    }\n    else {\n        APR_RING_INSERT_TAIL(f->c->pending_filters, f, ap_filter_t, pending);\n    }\n \n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_0cbd7a3f3160b15764e090e989cc3533c3dd957b_0", {
    "ID": "httpd_0cbd7a3f3160b15764e090e989cc3533c3dd957b_0",
    "UID": "7590",
    "code": "static void perform_idle_server_maintenance(int child_bucket, int test_snippet\n{\n    int i, j;\n    int idle_thread_count = 0;\n    worker_score *ws;\n    process_score *ps;\n    int free_length = 0;\n    int free_slots[MAX_SPAWN_RATE];\n    int last_non_dead = -1;\n    int active_thread_count = 0;\n\n    for (i = 0; i < server_limit; ++i) {\n        /* Initialization to satisfy the compiler. It doesn't know\n         * that threads_per_child is always > 0 */\n        int status = SERVER_DEAD;\n        int child_threads_active = 0;\n        int bucket = i % num_buckets;\n\n        if (i >= retained->max_daemons_limit &&\n            free_length == retained->idle_spawn_rate[child_bucket]) {\n            /* short cut if all active processes have been examined and\n             * enough empty scoreboard slots have been found\n             */\n\n            break;\n        }\n        ps = &ap_scoreboard_image->parent[i];\n        if (ps->pid != 0) {\n            for (j = 0; j < threads_per_child; j++) {\n                ws = &ap_scoreboard_image->servers[i][j];\n                status = ws->status;\n\n                /* We consider a starting server as idle because we started it\n                 * at least a cycle ago, and if it still hasn't finished starting\n                 * then we're just going to swamp things worse by forking more.\n                 * So we hopefully won't need to fork more if we count it.\n                 * This depends on the ordering of SERVER_READY and SERVER_STARTING.\n                 */\n                if (status <= SERVER_READY && !ps->quiescing && !ps->not_accepting\n                    && ps->generation == retained->mpm->my_generation\n                    && bucket == child_bucket)\n                {\n                    ++idle_thread_count;\n                }\n                if (status >= SERVER_READY && status < SERVER_GRACEFUL) {\n                    ++child_threads_active;\n                }\n            }\n            last_non_dead = i;\n        }\n        active_thread_count += child_threads_active;\n        if (!ps->pid\n                && bucket == child_bucket\n                && free_length < retained->idle_spawn_rate[child_bucket])\n            free_slots[free_length++] = i;\n        else if (child_threads_active == threads_per_child)\n            had_healthy_child = 1;\n    }\n\n    if (retained->sick_child_detected) {\n        if (had_healthy_child) {\n            /* Assume this is a transient error, even though it may not be.  Leave\n             * the server up in case it is able to serve some requests or the\n             * problem will be resolved.\n             */\n            retained->sick_child_detected = 0;\n        }\n        else {\n            /* looks like a basket case, as no child ever fully initialized; give up.\n             */\n            retained->mpm->shutdown_pending = 1;\n            child_fatal = 1;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, 0,\n                         ap_server_conf, APLOGNO(02324)\n                         \"A resource shortage or other unrecoverable failure \"\n                         \"was encountered before any child process initialized \"\n                         \"successfully... httpd is exiting!\");\n            \n            return;\n        }\n    }\n\n    retained->max_daemons_limit = last_non_dead + 1;\n\n    if (idle_thread_count > max_spare_threads / test_snippet\n    {\n        /*\n         * Child processes that we ask to shut down won't die immediately\n         * but may stay around for a long time when they finish their\n         * requests. If the server load changes many times, many such\n         * gracefully finishing processes may accumulate, filling up the\n         * scoreboard. To avoid running out of scoreboard entries, we\n         * don't shut down more processes when the total number of processes\n         * is high.\n         *\n         * XXX It would be nice if we could\n         * XXX - kill processes without keepalive connections first\n         * XXX - tell children to stop accepting new connections, and\n         * XXX   depending on server load, later be able to resurrect them\n         *       or kill them\n         */\n        if (retained->total_daemons <= active_daemons_limit &&\n            retained->total_daemons < server_limit) {\n            \n            ap_mpm_podx_signal(all_buckets[child_bucket].pod,\n                               AP_MPM_PODX_GRACEFUL);\n            retained->idle_spawn_rate[child_bucket] = 1;\n            active_daemons--;\n        } else {\n            ap_log_error(APLOG_MARK, APLOG_TRACE5, 0, ap_server_conf,\n                         \"Not shutting down child: total daemons %d / \"\n                         \"active limit %d / ServerLimit %d\",\n                         retained->total_daemons, active_daemons_limit,\n                         server_limit);\n        }\n    }\n    else if (idle_thread_count < min_spare_threads / test_snippet {\n        if (active_thread_count >= max_workers) {\n            if (0 == idle_thread_count) { \n                if (!retained->maxclients_reported) {\n                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00484)\n                                 \"server reached MaxRequestWorkers setting, \"\n                                 \"consider raising the MaxRequestWorkers \"\n                                 \"setting\");\n                    retained->maxclients_reported = 1;\n                }\n             }\n             else { \n                if (!retained->near_maxclients_reported) {\n                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(10159)\n                            \"server is within MinSpareThreads of \"\n                            \"MaxRequestWorkers, consider raising the \"\n                            \"MaxRequestWorkers setting\");\n                    retained->near_maxclients_reported = 1;\n                }\n            }\n            retained->idle_spawn_rate[child_bucket] = 1;\n        }\n        else if (free_length == 0) { \n            ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(03490)\n                         \"scoreboard is full, not at MaxRequestWorkers.\"\n                         \"Increase ServerLimit.\");\n            retained->idle_spawn_rate[child_bucket] = 1;\n        }\n        else {\n            if (free_length > retained->idle_spawn_rate[child_bucket]) {\n                free_length = retained->idle_spawn_rate[child_bucket];\n            }\n            if (retained->idle_spawn_rate[child_bucket] >= 8) {\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00486)\n                             \"server seems busy, (you may need \"\n                             \"to increase StartServers, ThreadsPerChild \"\n                             \"or Min/MaxSpareThreads), \"\n                             \"spawning %d children, there are around %d idle \"\n                             \"threads, %d active children, and %d children \"\n                             \"that are shutting down\", free_length,\n                             idle_thread_count, active_daemons,\n                             retained->total_daemons);\n            }\n            for (i = 0; i < free_length; ++i) {\n                ap_log_error(APLOG_MARK, APLOG_TRACE5, 0, ap_server_conf,\n                             \"Spawning new child: slot %d active / \"\n                             \"total daemons: %d/%d\",\n                             free_slots[i], active_daemons,\n                             retained->total_daemons);\n                make_child(ap_server_conf, free_slots[i], child_bucket);\n            }\n            /* the next time around we want to spawn twice as many if this\n             * wasn't good enough, but not if we've just done a graceful\n             */\n            if (retained->hold_off_on_exponential_spawning) {\n                --retained->hold_off_on_exponential_spawning;\n            }\n            else if (retained->idle_spawn_rate[child_bucket]\n                     < MAX_SPAWN_RATE / test_snippet {\n                retained->idle_spawn_rate[child_bucket] *= 2;\n            }\n        }\n    }\n    else {\n        retained->idle_spawn_rate[child_bucket] = 1;\n    }\n}",
    "predicted": "369,Divide By Zero"
  },
  "httpd_7dccd3b7c75cac7961a30d66e2a4300b82991f9e_0", {
    "ID": "httpd_7dccd3b7c75cac7961a30d66e2a4300b82991f9e_0",
    "UID": "7601",
    "code": "static dav_error * test_snippet\n    dav_lockdb *lockdb,\n    const dav_resource *resource)\n{\n    dav_buffer buf = { 0 };\n    apr_pool_t *p = lockdb->info->pool;\n    const char *dirpath;\n    const char *fname;\n    dav_error *err;\n\n    \n    (void) dav_fs_dir_file_name(resource, &dirpath, &fname);\n\n    if ((err = dav_fs_load_locknull_list(p, dirpath, &buf)) != NULL) {\n        return dav_push_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              \"Could not load .locknull file.\", err);\n    }\n\n    dav_buffer_append(p, &buf, fname);\n    buf.cur_len++;   \n\n    if ((err = dav_fs_save_locknull_list(p, dirpath, &buf)) != NULL) {\n        return dav_push_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              \"Could not save .locknull file.\", err);\n    }\n\n    return NULL;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_149a9d79fbf3a58aecf1cbde29614d3fcf03a64f_0", {
    "ID": "httpd_149a9d79fbf3a58aecf1cbde29614d3fcf03a64f_0",
    "UID": "7602",
    "code": "static dav_error * test_snippet\n    dav_lockdb *lockdb,\n    const dav_resource *resource)\n{\n    dav_buffer buf = { 0 };\n    dav_error *err;\n    apr_pool_t *p = lockdb->info->pool;\n    const char *pathname = dav_fs_pathname(resource);\n\n    if ((err = dav_fs_remove_locknull_member(p, pathname, &buf)) != NULL) {\n        \n        return err;\n    }\n\n    return NULL;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e2d325711f7066d111a1ba1f251c9ac775e3c268_0", {
    "ID": "httpd_e2d325711f7066d111a1ba1f251c9ac775e3c268_0",
    "UID": "7603",
    "code": "static dav_error * dav_fs_remove_lock(dav_lockdb test_snippet\n                                      const dav_resource *resource,\n                                      const dav_locktoken *locktoken)\n{\n    dav_error *err;\n    dav_buffer buf = { 0 };\n    dav_lock_discovery *dh = NULL;\n    dav_lock_indirect *ih = NULL;\n    apr_datum_t key;\n\n    key = dav_fs_build_key(lockdb->info->pool, resource);\n\n    if (locktoken != NULL) {\n        dav_lock_discovery *dp;\n        dav_lock_discovery *dprev = NULL;\n        dav_lock_indirect *ip;\n        dav_lock_indirect *iprev = NULL;\n\n        if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,\n                                           &dh, &ih)) != NULL) {\n            \n            return err;\n        }\n\n        for (dp = dh; dp != NULL; dp = dp->next) {\n            if (dav_compare_locktoken(locktoken, dp->locktoken) == 0) {\n                if (dprev)\n                    dprev->next = dp->next;\n                else\n                    dh = dh->next;\n            }\n            dprev = dp;\n        }\n\n        for (ip = ih; ip != NULL; ip = ip->next) {\n            if (dav_compare_locktoken(locktoken, ip->locktoken) == 0) {\n                if (iprev)\n                    iprev->next = ip->next;\n                else\n                    ih = ih->next;\n            }\n            iprev = ip;\n        }\n\n    }\n\n    \n    if ((err = dav_fs_save_lock_record(lockdb, key, dh, ih)) != NULL) {\n        \n        return err;\n    }\n\n    /*\n    ** If this resource is a locknull resource AND no more locks exist,\n    ** then remove the locknull member.\n    **\n    ** Note: remove_locknull_state() attempts to convert a locknull member\n    **       to a real member. In this case, all locks are gone, so the\n    **       locknull resource returns to the null state (ie. doesn't exist),\n    **       so there is no need to update the lockdb (and it won't find\n    **       any because a precondition is that none exist).\n    */\n    if (!resource->exists && dh == NULL && ih == NULL\n        && (err = dav_fs_remove_locknull_member(lockdb->info->pool,\n                                                dav_fs_pathname(resource),\n                                                &buf)) != NULL) {\n        \n        return err;\n    }\n\n    return NULL;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_a38d876480d719824d3192c27243848c12818e65_0", {
    "ID": "httpd_a38d876480d719824d3192c27243848c12818e65_0",
    "UID": "7725",
    "code": "static char *do_expand(char *input, rewrite_ctx *ctx, rewriterule_entry test_snippet\n{\n    result_list *result, *current;\n    result_list sresult[SMALL_EXPANSION];\n    unsigned spc = 0;\n    apr_size_t span, inputlen, outlen;\n    char *p, *c;\n    apr_pool_t *pool = ctx->r->pool;\n\n    span = strcspn(input, \"\\\\$%\");\n    inputlen = strlen(input);\n\n    \n    if (inputlen == span) {\n        return apr_pstrmemdup(pool, input, inputlen);\n    }\n\n    \n    result = current = &(sresult[spc++]);\n\n    p = input + span;\n    current->next = NULL;\n    current->string = input;\n    current->len = span;\n    outlen = span;\n\n    \n    do {\n        \n        if (current->len) {\n            current->next = (spc < SMALL_EXPANSION)\n                            ? &(sresult[spc++])\n                            : (result_list *)apr_palloc(pool,\n                                                        sizeof(result_list));\n            current = current->next;\n            current->next = NULL;\n            current->len = 0;\n        }\n\n        \n        if (*p == '\\\\') {\n            current->len = 1;\n            ++outlen;\n            if (!p[1]) {\n                current->string = p;\n                break;\n            }\n            else {\n                current->string = ++p;\n                ++p;\n            }\n        }\n\n        \n        else if (p[1] == '{') {\n            char *endp;\n\n            endp = find_closing_curly(p+2);\n            if (!endp) {\n                current->len = 2;\n                current->string = p;\n                outlen += 2;\n                p += 2;\n            }\n\n            \n            else if (*p == '%') {\n                p = lookup_variable(apr_pstrmemdup(pool, p+2, endp-p-2), ctx);\n\n                span = strlen(p);\n                current->len = span;\n                current->string = p;\n                outlen += span;\n                p = endp + 1;\n            }\n\n            \n            else {     \n                char *key;\n\n                /*\n                 * To make rewrite maps useful, the lookup key and\n                 * default values must be expanded, so we make\n                 * recursive calls to do the work. For security\n                 * reasons we must never expand a string that includes\n                 * verbatim data from the network. The recursion here\n                 * isn't a problem because the result of expansion is\n                 * only passed to lookup_map() so it cannot be\n                 * re-expanded, only re-looked-up. Another way of\n                 * looking at it is that the recursion is entirely\n                 * driven by the syntax of the nested curly brackets.\n                 */\n\n                key = find_char_in_curlies(p+2, ':');\n                if (!key) {\n                    current->len = 2;\n                    current->string = p;\n                    outlen += 2;\n                    p += 2;\n                }\n                else {\n                    char *map, *dflt;\n\n                    map = apr_pstrmemdup(pool, p+2, endp-p-2);\n                    key = map + (key-p-2);\n                    *key++ = '\\0';\n                    dflt = find_char_in_curlies(key, '|');\n                    if (dflt) {\n                        *dflt++ = '\\0';\n                    }\n\n                    \n                    key = lookup_map(ctx->r, map, do_expand(key, ctx, entry));\n\n                    if (!key && dflt && *dflt) {\n                        key = do_expand(dflt, ctx, entry);\n                    }\n\n                    if (key) {\n                        span = strlen(key);\n                        current->len = span;\n                        current->string = key;\n                        outlen += span;\n                    }\n\n                    p = endp + 1;\n                }\n            }\n        }\n\n        \n        else if (apr_isdigit(p[1])) {\n            int n = p[1] - '0';\n            backrefinfo *bri = (*p == '$') ? &ctx->briRR : &ctx->briRC;\n\n            \n            if (bri->source && n < AP_MAX_REG_MATCH\n                && bri->regmatch[n].rm_eo > bri->regmatch[n].rm_so) {\n                span = bri->regmatch[n].rm_eo - bri->regmatch[n].rm_so;\n                if (entry && (entry->flags & RULEFLAG_ESCAPEBACKREF)) {\n                    \n                    char *tmp2, *tmp;\n                    tmp = apr_pstrmemdup(pool, bri->source + bri->regmatch[n].rm_so, span);\n                    tmp2 = escape_backref(pool, tmp, entry->escapes, entry->flags & RULEFLAG_ESCAPENOPLUS);\n                    rewritelog((ctx->r, 5, ctx->perdir, \"escaping backreference '%s' to '%s'\",\n                            tmp, tmp2));\n\n                    current->len = span = strlen(tmp2);\n                    current->string = tmp2;\n                } else {\n                    current->len = span;\n                    current->string = bri->source + bri->regmatch[n].rm_so;\n                }\n\n                outlen += span;\n            }\n\n            p += 2;\n        }\n\n        \n        else {\n            current->len = 1;\n            current->string = p++;\n            ++outlen;\n        }\n\n        \n        if (*p && (span = strcspn(p, \"\\\\$%\")) > 0) {\n            if (current->len) {\n                current->next = (spc < SMALL_EXPANSION)\n                                ? &(sresult[spc++])\n                                : (result_list *)apr_palloc(pool,\n                                                           sizeof(result_list));\n                current = current->next;\n                current->next = NULL;\n            }\n\n            current->len = span;\n            current->string = p;\n            p += span;\n            outlen += span;\n        }\n\n    } while (p < input+inputlen);\n\n    \n    c = p = apr_palloc(pool, outlen + 1); \n    do {\n        if (result->len) {\n            ap_assert(c+result->len <= p+outlen); /* XXX: can be removed after\n                                                   * extensive testing and\n                                                   * review\n                                                   */\n            memcpy(c, result->string, result->len);\n            c += result->len;\n        }\n        result = result->next;\n    } while (result);\n\n    p[outlen] = '\\0';\n\n    return p;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_e8c3ca55fa8eab87c485521f3b3d784d2ae5116a_0", {
    "ID": "httpd_e8c3ca55fa8eab87c485521f3b3d784d2ae5116a_0",
    "UID": "7727",
    "code": "static void do_rewritelog(request_rec *r, int level, char test_snippet\n                          const char *fmt, ...)\n{\n    char *logline, *text;\n    const char *rhost, *rname;\n    int redir;\n    request_rec *req;\n    va_list ap;\n\n    if (!APLOG_R_IS_LEVEL(r, APLOG_DEBUG + level))\n        return;\n\n    rhost = ap_get_remote_host(r->connection, r->per_dir_config,\n                               REMOTE_NOLOOKUP, NULL);\n    rname = ap_get_remote_logname(r);\n\n    for (redir=0, req=r; req->prev; req = req->prev) {\n        ++redir;\n    }\n\n    va_start(ap, fmt);\n    text = apr_pvsprintf(r->pool, fmt, ap);\n    va_end(ap);\n\n    logline = apr_psprintf(r->pool, \"%s %s %s [%s/sid#%pp][rid#%pp/%s%s%s] \"\n                                    \"%s%s%s%s\",\n                           rhost ? rhost : \"UNKNOWN-HOST\",\n                           rname ? rname : \"-\",\n                           r->user ? (*r->user ? r->user : \"\\\"\\\"\") : \"-\",\n                           ap_get_server_name(r),\n                           (void *)(r->server),\n                           (void *)r,\n                           r->main ? \"subreq\" : \"initial\",\n                           redir ? \"/redir#\" : \"\",\n                           redir ? apr_itoa(r->pool, redir) : \"\",\n                           perdir ? \"[perdir \" : \"\",\n                           perdir ? perdir : \"\",\n                           perdir ? \"] \": \"\",\n                           text);\n\n    AP_REWRITE_LOG((uintptr_t)r, level, r->main ? 0 : 1, (char *)ap_get_server_name(r), logline);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG + level, 0, r, \"%s\", logline);\n\n    return;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_f9bb584fec26c71c39f4f63e1c1f3b786941b67b_0", {
    "ID": "httpd_f9bb584fec26c71c39f4f63e1c1f3b786941b67b_0",
    "UID": "7731",
    "code": "static int remoteip_modify_request(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    remoteip_config_t *config = (remoteip_config_t *)\n        ap_get_module_config(r->server->module_config, &remoteip_module);\n    remoteip_req_t *req = NULL;\n\n    apr_sockaddr_t *temp_sa;\n\n    apr_status_t rv;\n    char *remote;\n    char *proxy_ips = NULL;\n    char *parse_remote;\n    char *eos;\n    unsigned char *addrbyte;\n\n    /* If no RemoteIPInternalProxy, RemoteIPInternalProxyList, RemoteIPTrustedProxy\n       or RemoteIPTrustedProxyList directive is configured,\n       all proxies will be considered as external trusted proxies.\n     */\n    void *internal = NULL;\n\n    if (!config->header_name) {\n        return DECLINED;\n    }\n \n    if (config->proxymatch_ip) {\n        /* This indicates that a RemoteIPInternalProxy, RemoteIPInternalProxyList, RemoteIPTrustedProxy\n           or RemoteIPTrustedProxyList directive is configured.\n           In this case, default to internal proxy.\n         */\n        internal = (void *) 1;\n    }\n\n    remote = (char *) apr_table_get(r->headers_in, config->header_name);\n    if (!remote) {\n        return OK;\n    }\n    remote = apr_pstrdup(r->pool, remote);\n\n    temp_sa = r->useragent_addr ? r->useragent_addr : c->client_addr;\n\n    while (remote) {\n\n        /* verify user agent IP against the trusted proxy list\n         */\n        if (config->proxymatch_ip) {\n            int i;\n            remoteip_proxymatch_t *match;\n            match = (remoteip_proxymatch_t *)config->proxymatch_ip->elts;\n            for (i = 0; i < config->proxymatch_ip->nelts; ++i) {\n                if (apr_ipsubnet_test(match[i].ip, temp_sa)) {\n                    if (internal) {\n                        /* Allow an internal proxy to present an external proxy,\n                           but do not allow an external proxy to present an internal proxy.\n                           In this case, the presented internal proxy will be considered external.\n                         */\n                        internal = match[i].internal;\n                    }\n                    break;\n                }\n            }\n            if (i && i >= config->proxymatch_ip->nelts) {\n                break;\n            }\n        }\n\n        if ((parse_remote = strrchr(remote, ',')) == NULL) {\n            parse_remote = remote;\n            remote = NULL;\n        }\n        else {\n            *(parse_remote++) = '\\0';\n        }\n\n        while (*parse_remote == ' ') {\n            ++parse_remote;\n        }\n\n        eos = parse_remote + strlen(parse_remote) - 1;\n        while (eos >= parse_remote && *eos == ' ') {\n            *(eos--) = '\\0';\n        }\n\n        if (eos < parse_remote) {\n            if (remote) {\n                *(remote + strlen(remote)) = ',';\n            }\n            else {\n                remote = parse_remote;\n            }\n            break;\n        }\n\n        /* We map as IPv4 rather than IPv6 for equivalent host names\n         * or IPV4OVERIPV6\n         */\n        rv = apr_sockaddr_info_get(&temp_sa,  parse_remote,\n                                   APR_UNSPEC, temp_sa->port,\n                                   APR_IPV4_ADDR_OK, r->pool);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r, APLOGNO(01568)\n                          \"RemoteIP: Header %s value of %s cannot be parsed \"\n                          \"as a client IP\",\n                          config->header_name, parse_remote);\n\n            if (remote) {\n                *(remote + strlen(remote)) = ',';\n            }\n            else {\n                remote = parse_remote;\n            }\n            break;\n        }\n\n        addrbyte = (unsigned char *) &temp_sa->sa.sin.sin_addr;\n\n        \n        if (!internal\n              && ((temp_sa->family == APR_INET\n                   /* For internet (non-Internal proxies) deny all\n                    * RFC3330 designated local/private subnets:\n                    * 10.0.0.0/8   169.254.0.0/16  192.168.0.0/16\n                    * 127.0.0.0/8  172.16.0.0/12\n                    */\n                      && (addrbyte[0] == 10\n                       || addrbyte[0] == 127\n                       || (addrbyte[0] == 169 && addrbyte[1] == 254)\n                       || (addrbyte[0] == 172 && (addrbyte[1] & 0xf0) == 16)\n                       || (addrbyte[0] == 192 && addrbyte[1] == 168)))\n#if APR_HAVE_IPV6\n               || (temp_sa->family == APR_INET6\n                   /* For internet (non-Internal proxies) we translated\n                    * IPv4-over-IPv6-mapped addresses as IPv4, above.\n                    * Accept only Global Unicast 2000::/3 defined by RFC4291\n                    */\n                      && ((temp_sa->sa.sin6.sin6_addr.s6_addr[0] & 0xe0) != 0x20))\n#endif\n        )) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r, APLOGNO(01569)\n                          \"RemoteIP: Header %s value of %s appears to be \"\n                          \"a private IP or nonsensical.  Ignored\",\n                          config->header_name, parse_remote);\n            if (remote) {\n                *(remote + strlen(remote)) = ',';\n            }\n            else {\n                remote = parse_remote;\n            }\n\n            break;\n        }\n\n        \n        if (!req) {\n            req = (remoteip_req_t *) apr_palloc(r->pool, sizeof(remoteip_req_t));\n            req->useragent_ip = r->useragent_ip;\n        }\n\n        \n        if (!internal) {\n            if (proxy_ips) {\n                proxy_ips = apr_pstrcat(r->pool, proxy_ips, \", \",\n                                        req->useragent_ip, NULL);\n            }\n            else {\n                proxy_ips = req->useragent_ip;\n            }\n        }\n\n        req->useragent_addr = temp_sa;\n        apr_sockaddr_ip_get(&req->useragent_ip, req->useragent_addr);\n    }\n\n    \n    if (!req) {\n        return OK;\n    }\n\n    req->proxied_remote = remote;\n    req->proxy_ips = proxy_ips;\n\n    if (req->proxied_remote) {\n        apr_table_setn(r->headers_in, config->header_name,\n                       req->proxied_remote);\n    }\n    else {\n        apr_table_unset(r->headers_in, config->header_name);\n    }\n    if (req->proxy_ips) {\n        apr_table_setn(r->notes, \"remoteip-proxy-ip-list\", req->proxy_ips);\n        if (config->proxies_header_name) {\n            apr_table_setn(r->headers_in, config->proxies_header_name,\n                           req->proxy_ips);\n        }\n    }\n\n    r->useragent_addr = req->useragent_addr;\n    r->useragent_ip = req->useragent_ip;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  req->proxy_ips\n                      ? \"Using %s as client's IP by proxies %s\"\n                      : \"Using %s as client's IP by internal proxies%s\",\n                  req->useragent_ip,\n                  (req->proxy_ips ? req->proxy_ips : \"\"));\n    return OK;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n90,Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n121,Stack-based Buffer Overflow\n122,Heap-based Buffer Overflow\n123,Write-what-where Condition\n124,Buffer Underwrite ('Buffer Underflow')\n126,Buffer Over-read\n127,Buffer Under-read\n134,Use of Externally-Controlled Format String\n176,Improper Handling of Unicode Encoding\n190,Integer Overflow or Wraparound\n191,Integer Underflow (Wrap or Wraparound)\n194,Unexpected Sign Extension\n195,Signed to Unsigned Conversion Error\n197,Numeric Truncation Error\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n272,Least Privilege Violation\n273,Improper Check for Dropped Privileges\n321,Use of Hard-coded Cryptographic Key\n338,Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n364,Signal Handler Race Condition\n366,Race Condition within a Thread\n369,Divide By Zero\n377,Insecure Temporary File\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n397,Declaration of Throws for Generic Exception\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n427,Uncontrolled Search Path Element\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n464,Addition of Data Structure Sentinel\n467,Use of sizeof() on a Pointer Type\n476,NULL Pointer Dereference\n479,Signal Handler Use of a Non-reentrant Function\n480,Use of Incorrect Operator\n511,Logic/Time Bomb\n526,Cleartext Storage of Sensitive Information in an Environment Variable\n546,Suspicious Comment\n563,Assignment to Variable without Use\n587,Assignment of a Fixed Address to a Pointer\n588,Attempt to Access Child of a Non-structure Pointer\n590,Free of Memory not on the Heap\n591,Sensitive Data Storage in Improperly Locked Memory\n606,Unchecked Input for Loop Condition\n617,Reachable Assertion\n665,Improper Initialization\n672,Operation on a Resource after Expiration or Release\n675,Multiple Operations on Resource in Single-Operation Context\n758,Reliance on Undefined\n761,Free of Pointer not at Start of Buffer\n762,Mismatched Memory Management Routines\n773,Missing Reference to Active File Descriptor or Handle\n775,Missing Release of File Descriptor or Handle after Effective Lifetime\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_77f2db9ba341730c68b88da24553219473d7bd37_0", {
    "ID": "httpd_77f2db9ba341730c68b88da24553219473d7bd37_0",
    "UID": "7750",
    "code": "test_snippetAtest_snippetPtest_snippet_test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetAtest_snippetRtest_snippetEtest_snippet(test_snippetatest_snippetptest_snippetrtest_snippet_test_snippetstest_snippetttest_snippetatest_snippetttest_snippetutest_snippetstest_snippet_test_snippetttest_snippet)test_snippet test_snippetatest_snippetptest_snippet_test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet(test_snippetctest_snippetotest_snippetntest_snippetntest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetctest_snippet,test_snippet test_snippetrtest_snippetetest_snippetqtest_snippetutest_snippetetest_snippetstest_snippetttest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetrtest_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetetest_snippetrtest_snippetvtest_snippetetest_snippetrtest_snippet_test_snippetrtest_snippetetest_snippetctest_snippet test_snippet*test_snippetstest_snippet,test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet\ntest_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetotest_snippetntest_snippetstest_snippetttest_snippet test_snippetctest_snippethtest_snippetatest_snippetrtest_snippet test_snippet*test_snippetctest_snippetutest_snippetrtest_snippetrtest_snippetetest_snippetntest_snippetttest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetrtest_snippetutest_snippetntest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetgtest_snippetetest_snippetttest_snippet(test_snippetctest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetntest_snippetttest_snippet test_snippetrtest_snippetctest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetitest_snippetftest_snippet test_snippet(test_snippet!test_snippetstest_snippetttest_snippetrtest_snippetctest_snippetmtest_snippetptest_snippet(test_snippetctest_snippetutest_snippetrtest_snippetrtest_snippetetest_snippetntest_snippetttest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetWtest_snippetAtest_snippetRtest_snippetNtest_snippetItest_snippetNtest_snippetGtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetNtest_snippetOtest_snippet(test_snippet0test_snippet2test_snippet9test_snippet0test_snippet6test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetatest_snippetltest_snippetrtest_snippetetest_snippetatest_snippetdtest_snippetytest_snippet test_snippetatest_snippetttest_snippet test_snippetitest_snippetttest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet test_snippetttest_snippetotest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetctest_snippet test_snippet=test_snippet test_snippetatest_snippetptest_snippet_test_snippetrtest_snippetutest_snippetntest_snippet_test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet(test_snippetctest_snippet,test_snippet test_snippetrtest_snippet,test_snippet test_snippetstest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet test_snippet(test_snippetrtest_snippetctest_snippet)test_snippet test_snippet{test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetDtest_snippetEtest_snippetCtest_snippetLtest_snippetItest_snippetNtest_snippetEtest_snippetDtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetNtest_snippetOtest_snippet(test_snippet0test_snippet2test_snippet9test_snippet0test_snippet7test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetntest_snippetotest_snippet test_snippetitest_snippetmtest_snippetptest_snippetltest_snippetetest_snippetmtest_snippetetest_snippetntest_snippetttest_snippetatest_snippetttest_snippetitest_snippetotest_snippetntest_snippet test_snippetftest_snippetotest_snippetrtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet test_snippetttest_snippetotest_snippet test_snippet%test_snippetstest_snippet\"test_snippet,test_snippet test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetEtest_snippetNtest_snippetOtest_snippetTtest_snippetItest_snippetMtest_snippetPtest_snippetLtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetOtest_snippetKtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetctest_snippetatest_snippetstest_snippetetest_snippet test_snippetDtest_snippetOtest_snippetNtest_snippetEtest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetStest_snippetUtest_snippetCtest_snippetCtest_snippetEtest_snippetStest_snippetStest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetdtest_snippetetest_snippetftest_snippetatest_snippetutest_snippetltest_snippetttest_snippet:test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetatest_snippetptest_snippet_test_snippetltest_snippetotest_snippetgtest_snippet_test_snippetctest_snippetetest_snippetrtest_snippetrtest_snippetotest_snippetrtest_snippet(test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetMtest_snippetAtest_snippetRtest_snippetKtest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippet_test_snippetEtest_snippetRtest_snippetRtest_snippet,test_snippet test_snippet0test_snippet,test_snippet test_snippetctest_snippet,test_snippet test_snippetAtest_snippetPtest_snippetLtest_snippetOtest_snippetGtest_snippetNtest_snippetOtest_snippet(test_snippet0test_snippet2test_snippet9test_snippet0test_snippet5test_snippet)test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet\"test_snippetutest_snippetntest_snippetetest_snippetxtest_snippetptest_snippetetest_snippetctest_snippetttest_snippetetest_snippetdtest_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetctest_snippetotest_snippetdtest_snippetetest_snippet test_snippet%test_snippetdtest_snippet test_snippetftest_snippetrtest_snippetotest_snippetmtest_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet_test_snippetstest_snippetwtest_snippetitest_snippetttest_snippetctest_snippethtest_snippet test_snippetttest_snippetotest_snippet test_snippet%test_snippetstest_snippet\"test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet,test_snippet test_snippetrtest_snippetctest_snippet,test_snippet test_snippetptest_snippetrtest_snippetotest_snippetttest_snippetotest_snippetctest_snippetotest_snippetltest_snippet)test_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippet test_snippetrtest_snippetetest_snippetttest_snippetutest_snippetrtest_snippetntest_snippet test_snippetAtest_snippetPtest_snippetRtest_snippet_test_snippetEtest_snippetOtest_snippetFtest_snippet;test_snippet\ntest_snippet test_snippet test_snippet test_snippet test_snippet}test_snippet test_snippet test_snippet test_snippet test_snippet\ntest_snippet}test_snippet",
    "predicted": "The provided code is not readable or understandable. It seems to be obfuscated or encrypted. Please provide a valid piece of C/C++ code to analyze for vulnerabilities."
  },
  "httpd_7bdc0b84e015340ae170be410c4c8f081dd44465_0", {
    "ID": "httpd_7bdc0b84e015340ae170be410c4c8f081dd44465_0",
    "UID": "7756",
    "code": "static const char *set_protocols(cmd_parms *cmd, void test_snippet\n                                 const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char **np;\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n    \n    \n    np = (const char **)apr_array_push(conf->protocols);\n    *np = arg;\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_5485d61226db9d99aebd0c6612a3f5966b667da4_0", {
    "ID": "httpd_5485d61226db9d99aebd0c6612a3f5966b667da4_0",
    "UID": "7764",
    "code": "apr_status_t sed_finalize_eval(sed_eval_t *eval, void test_snippet\n{\n    if (eval->quitflag)\n        return APR_SUCCESS;\n\n    if (eval->finalflag)\n        eval->dolflag = 1;\n\n    eval->fout = fout;\n\n    \n    if (eval->lspend > eval->linebuf) {\n        apr_status_t rv;\n\n        if (eval->lreadyflag) {\n            eval->lreadyflag = 0;\n            eval->lspend--;\n        } else {\n            /* Code can probably reach here when last character in output\n             * buffer is not a newline.\n             */\n            \n            append_to_linebuf(eval, \"\");\n        }\n\n        *eval->lspend = '\\0';\n        rv = execute(eval);\n        if (rv != APR_SUCCESS)\n            return rv;\n    }\n\n    eval->quitflag = 1;\n\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e8460aaaa6ad535713820bffab4371004de80df6_0", {
    "ID": "httpd_e8460aaaa6ad535713820bffab4371004de80df6_0",
    "UID": "7766",
    "code": "static apr_status_t execute(sed_eval_t test_snippet\n{\n    sed_reptr_t *ipc = eval->commands->ptrspace;\n    step_vars_storage step_vars;\n    apr_status_t rv = APR_SUCCESS;\n\n    eval->lnum++;\n\n    eval->sflag = 0;\n\n    if (eval->pending) {\n        ipc = eval->pending;\n        eval->pending = NULL;\n    }\n\n    memset(&step_vars, 0, sizeof(step_vars));\n\n    while (ipc->command) {\n        char *p1;\n        char *p2;\n        int c;\n\n        p1 = ipc->ad1;\n        p2 = ipc->ad2;\n\n        if (p1) {\n\n            if (eval->inar[ipc->nrep]) {\n                if (*p2 == CEND) {\n                    p1 = 0;\n                } else if (*p2 == CLNUM) {\n                    c = (unsigned char)p2[1];\n                    if (eval->lnum > eval->commands->tlno[c]) {\n                        eval->inar[ipc->nrep] = 0;\n                        if (ipc->negfl)\n                            goto yes;\n                        ipc = ipc->next;\n                        continue;\n                    }\n                    if (eval->lnum == eval->commands->tlno[c]) {\n                        eval->inar[ipc->nrep] = 0;\n                    }\n                } else if (match(eval, p2, 0, &step_vars)) {\n                    eval->inar[ipc->nrep] = 0;\n                }\n            } else if (*p1 == CEND) {\n                if (!eval->dolflag) {\n                    if (ipc->negfl)\n                        goto yes;\n                    ipc = ipc->next;\n                    continue;\n                }\n            } else if (*p1 == CLNUM) {\n                c = (unsigned char)p1[1];\n                if (eval->lnum != eval->commands->tlno[c]) {\n                    if (ipc->negfl)\n                        goto yes;\n                    ipc = ipc->next;\n                    continue;\n                }\n                if (p2)\n                    eval->inar[ipc->nrep] = 1;\n            } else if (match(eval, p1, 0, &step_vars)) {\n                if (p2)\n                    eval->inar[ipc->nrep] = 1;\n            } else {\n                if (ipc->negfl)\n                    goto yes;\n                ipc = ipc->next;\n                continue;\n            }\n        }\n\n        if (ipc->negfl) {\n            ipc = ipc->next;\n            continue;\n        }\n\nyes:\n        rv = command(eval, ipc, &step_vars);\n        if (rv != APR_SUCCESS)\n            return rv;\n\n        if (eval->quitflag)\n            return APR_SUCCESS;\n\n        if (eval->pending)\n            return APR_SUCCESS;\n\n        if (eval->delflag)\n            break;\n\n        if (eval->jflag) {\n            eval->jflag = 0;\n            if ((ipc = ipc->lb1) == 0) {\n                ipc = eval->commands->ptrspace;\n                break;\n            }\n        } else\n            ipc = ipc->next;\n    }\n\n    if (!eval->commands->nflag && !eval->delflag) {\n        rv = wline(eval, eval->linebuf, eval->lspend - eval->linebuf);\n        if (rv != APR_SUCCESS)\n            return rv;\n    }\n\n    if (eval->aptr > eval->abuf)\n        rv = arout(eval);\n\n    eval->delflag = 0;\n\n    eval->lspend = eval->linebuf;\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_f4b343a4dfc456753feb6366350624da3b7a6154_0", {
    "ID": "httpd_f4b343a4dfc456753feb6366350624da3b7a6154_0",
    "UID": "7768",
    "code": "static apr_status_t sed_response_filter(ap_filter_t test_snippet\n                                        apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n    apr_status_t status = APR_SUCCESS;\n    sed_config *cfg = ap_get_module_config(f->r->per_dir_config,\n                                           &sed_module);\n    sed_filter_ctxt *ctx = f->ctx;\n    sed_expr_config *sed_cfg = &cfg->output;\n\n    if ((sed_cfg == NULL) || (sed_cfg->sed_cmds == NULL)) {\n        \n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    if (ctx == NULL) {\n\n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(bb))) {\n            \n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        status = init_context(f, sed_cfg, 1);\n        if (status != APR_SUCCESS)\n             return status;\n        ctx = f->ctx;\n        apr_table_unset(f->r->headers_out, \"Content-Length\");\n\n        ctx->bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n    }\n\n    /* Here is the main logic. Iterate through all the buckets, read the\n     * content of the bucket, call sed_eval_buffer on the data.\n     * sed_eval_buffer will read the data line by line, run filters on each\n     * line. sed_eval_buffer will generates the output by calling\n     * sed_write_output which will add the output to ctx->bb. At the end of\n     * the loop, ctx->bb is passed to the next filter in chain. At the end of\n     * the data, if new line is not found then sed_eval_buffer will store the\n     * data in its own buffer.\n     *\n     * Once eos bucket is found then sed_finalize_eval will flush the rest of\n     * the data. If there is no new line in last line of data, new line is\n     * appended (that is a solaris sed behavior). libsed's internal memory for\n     * evaluation is allocated on request's pool so it will be cleared once\n     * request is over.\n     *\n     * If flush bucket is found then append the the flush bucket to ctx->bb\n     * and pass it to next filter. There may be some data which will still be\n     * in sed's internal buffer which can't be flushed until new line\n     * character is arrived.\n     */\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        b = APR_BRIGADE_FIRST(bb);\n        if (APR_BUCKET_IS_EOS(b)) {\n            \n            sed_finalize_eval(&ctx->eval, ctx);\n            status = flush_output_buffer(ctx);\n            if (status != APR_SUCCESS) {\n                break;\n            }\n            \n            APR_BUCKET_REMOVE(b);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n        }\n        else if (APR_BUCKET_IS_FLUSH(b)) {\n            status = flush_output_buffer(ctx);\n            if (status != APR_SUCCESS) {\n                break;\n            }\n            \n            APR_BUCKET_REMOVE(b);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n        }\n        else {\n            if (!APR_BUCKET_IS_METADATA(b)) {\n                const char *buf = NULL;\n                apr_size_t bytes = 0;\n\n                status = apr_bucket_read(b, &buf, &bytes, APR_BLOCK_READ);\n                if (status == APR_SUCCESS) {\n                    status = sed_eval_buffer(&ctx->eval, buf, bytes, ctx);\n                }\n                if (status != APR_SUCCESS) {\n                    break;\n                }\n            }\n            apr_bucket_delete(b);\n        }\n    }\n    if (status == APR_SUCCESS) {\n        status = flush_output_buffer(ctx);\n    }\n    if (!APR_BRIGADE_EMPTY(ctx->bb)) {\n        if (status == APR_SUCCESS) {\n            status = ap_pass_brigade(f->next, ctx->bb);\n        }\n        apr_brigade_cleanup(ctx->bb);\n    }\n    clear_ctxpool(ctx);\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_e150fcc0d2600b2a9382e208e38d5a4bf9d86872_0", {
    "ID": "httpd_e150fcc0d2600b2a9382e208e38d5a4bf9d86872_0",
    "UID": "7770",
    "code": "static apr_status_t sed_request_filter(ap_filter_t test_snippet\n                                       apr_bucket_brigade *bb,\n                                       ap_input_mode_t mode,\n                                       apr_read_type_e block,\n                                       apr_off_t readbytes)\n{\n    sed_config *cfg = ap_get_module_config(f->r->per_dir_config,\n                                           &sed_module);\n    sed_filter_ctxt *ctx = f->ctx;\n    apr_status_t status;\n    apr_bucket_brigade *bbinp;\n    sed_expr_config *sed_cfg = &cfg->input;\n\n    if (mode != AP_MODE_READBYTES) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if ((sed_cfg == NULL) || (sed_cfg->sed_cmds == NULL)) {\n        \n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        if (!ap_is_initial_req(f->r)) {\n            ap_remove_input_filter(f);\n            \n            return ap_get_brigade(f->next, bb, mode, block, readbytes);\n        }\n        status = init_context(f, sed_cfg, 0);\n        if (status != APR_SUCCESS)\n             return status;\n        ctx = f->ctx;\n        ctx->bb    = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n        ctx->bbinp = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n    }\n\n    bbinp = ctx->bbinp;\n\n    /* Here is the logic :\n     * Read the readbytes data from next level fiter into bbinp. Loop through\n     * the buckets in bbinp and read the data from buckets and invoke\n     * sed_eval_buffer on the data. libsed will generate its output using\n     * sed_write_output which will add data in ctx->bb. Do it until it have\n     * atleast one bucket bucket in ctx->bb. At the end of data eos bucket\n     * should be there.\n     *\n     * Once eos bucket is seen, then invoke sed_finalize_eval to clear the\n     * output. If the last byte of data is not a new line character then sed\n     * will add a new line to the data that is default sed behaviour. Note\n     * that using this filter with POST data, caller may not expect this\n     * behaviour.\n     *\n     * If next level fiter generate the flush bucket, we can't do much about\n     * it. If we want to return the flush bucket in brigade bb (to the caller)\n     * the question is where to add it?\n     */\n    while (APR_BRIGADE_EMPTY(ctx->bb)) {\n        apr_bucket *b;\n\n        \n        apr_brigade_cleanup(bbinp);\n        status = ap_get_brigade(f->next, bbinp, mode, block, readbytes);\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n        for (b = APR_BRIGADE_FIRST(bbinp); b != APR_BRIGADE_SENTINEL(bbinp);\n             b = APR_BUCKET_NEXT(b)) {\n            const char *buf = NULL;\n            apr_size_t bytes;\n\n            if (APR_BUCKET_IS_EOS(b)) {\n                \n                sed_finalize_eval(&ctx->eval, ctx);\n                flush_output_buffer(ctx);\n                APR_BUCKET_REMOVE(b);\n                APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n                break;\n            }\n            else if (APR_BUCKET_IS_FLUSH(b)) {\n                \n                continue;\n            }\n            if (apr_bucket_read(b, &buf, &bytes, APR_BLOCK_READ)\n                     == APR_SUCCESS) {\n                status = sed_eval_buffer(&ctx->eval, buf, bytes, ctx);\n                if (status != APR_SUCCESS)\n                    return status;\n                flush_output_buffer(ctx);\n            }\n        }\n    }\n\n    if (!APR_BRIGADE_EMPTY(ctx->bb)) {\n        apr_bucket *b = NULL;\n\n        if (apr_brigade_partition(ctx->bb, readbytes, &b) == APR_INCOMPLETE) {\n            APR_BRIGADE_CONCAT(bb, ctx->bb);\n        }\n        else {\n            APR_BRIGADE_CONCAT(bb, ctx->bb);\n            apr_brigade_split_ex(bb, b, ctx->bb);\n        }\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_26d24dd137c8c2a24b169098978fe185ce19f046_0", {
    "ID": "httpd_26d24dd137c8c2a24b169098978fe185ce19f046_0",
    "UID": "7777",
    "code": "static const char *socache_shmcb_create(ap_socache_instance_t test_snippet\n                                        const char *arg,\n                                        apr_pool_t *tmp, apr_pool_t *p)\n{\n    ap_socache_instance_t *ctx;\n    char *path, *cp, *cp2;\n\n    \n    *context = ctx = apr_pcalloc(p, sizeof *ctx);\n\n    ctx->shm_size  = 1024*512; \n\n    if (!arg || *arg == '\\0') {\n        \n        return NULL;\n    }\n\n    ctx->data_file = path = ap_runtime_dir_relative(p, arg);\n\n    cp = strrchr(path, '(');\n    cp2 = path + strlen(path) - 1;\n    if (cp) {\n        char *endptr;\n        if (*cp2 != ')') {\n            return \"Invalid argument: no closing parenthesis or cache size \"\n                   \"missing after pathname with parenthesis\";\n        }\n        *cp++ = '\\0';\n        *cp2  = '\\0';\n\n\n        ctx->shm_size = strtol(cp, &endptr, 10);\n        if (endptr != cp2) {\n            return \"Invalid argument: cache size not numerical\";\n        }\n\n        if (ctx->shm_size < 8192) {\n            return \"Invalid argument: size has to be >= 8192 bytes\";\n\n        }\n\n        if (ctx->shm_size >= SHMCB_MAX_SIZE) {\n            return apr_psprintf(tmp,\n                                \"Invalid argument: size has \"\n                                \"to be < %d bytes on this platform\",\n                                SHMCB_MAX_SIZE);\n\n        }\n    }\n    else if (cp2 >= path && *cp2 == ')') {\n        return \"Invalid argument: no opening parenthesis\";\n    }\n\n    return NULL;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_f065c0d7fe45e928111ad3e6ae09be30cd2ed553_0", {
    "ID": "httpd_f065c0d7fe45e928111ad3e6ae09be30cd2ed553_0",
    "UID": "7795",
    "code": "static apr_status_t send_data(proxy_conn_rec test_snippet\n                              struct iovec *vec,\n                              int nvec,\n                              apr_size_t *len)\n{\n    apr_status_t rv = APR_SUCCESS;\n    apr_size_t written = 0, to_write = 0;\n    int i, offset;\n    apr_socket_t *s = conn->sock;\n\n    for (i = 0; i < nvec; i++) {\n        to_write += vec[i].iov_len;\n    }\n\n    offset = 0;\n    while (to_write) {\n        apr_size_t n = 0;\n        rv = apr_socket_sendv(s, vec + offset, nvec - offset, &n);\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n        if (n > 0) {\n            written += n;\n            if (written >= to_write)\n                break;                 \n            for (i = offset; i < nvec; ) {\n                if (n >= vec[i].iov_len) {\n                    offset++;\n                    n -= vec[i++].iov_len;\n                } else {\n                    vec[i].iov_len -= n;\n                    vec[i].iov_base = (char *) vec[i].iov_base + n;\n                    break;\n                }\n            }\n        }\n    }\n\n    conn->worker->s->transferred += written;\n    *len = written;\n\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e24f0b177def4c138a43ec8cd805e5adcf003014_0", {
    "ID": "httpd_e24f0b177def4c138a43ec8cd805e5adcf003014_0",
    "UID": "7811",
    "code": "static int xlate_name(request_rec test_snippet\n{\n    int i;\n    const char *name;\n    char *backend;\n    apr_dbm_t *db;\n    apr_status_t rv;\n    apr_datum_t key, val;\n    struct proxy_alias *ralias;\n    proxy_dir_conf *dconf;\n    express_server_conf *sconf;\n\n    sconf = ap_get_module_config(r->server->module_config, &proxy_express_module);\n    dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n\n    if (!sconf->enabled) {\n        return DECLINED;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01001) \"proxy_express: Enabled\");\n    if (!sconf->dbmfile || (r->filename && strncmp(r->filename, \"proxy:\", 6) == 0)) {\n        \n        return DECLINED;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01002)\n                  \"proxy_express: Opening DBM file: %s (%s)\",\n                  sconf->dbmfile, sconf->dbmtype);\n    rv = apr_dbm_open_ex(&db, sconf->dbmtype, sconf->dbmfile, APR_DBM_READONLY,\n                         APR_OS_DEFAULT, r->pool);\n    if (rv != APR_SUCCESS) {\n        return DECLINED;\n    }\n\n    name = ap_get_server_name(r);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01003)\n                  \"proxy_express: looking for %s\", name);\n    key.dptr = (char *)name;\n    key.dsize = strlen(key.dptr);\n\n    rv = apr_dbm_fetch(db, key, &val);\n    if (rv == APR_SUCCESS) {\n        backend = apr_pstrmemdup(r->pool, val.dptr, val.dsize);\n    }\n    apr_dbm_close(db);\n    if (rv != APR_SUCCESS || !backend) {\n        return DECLINED;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01004)\n                  \"proxy_express: found %s -> %s\", name, backend);\n    r->filename = apr_pstrcat(r->pool, \"proxy:\", backend, r->uri, NULL);\n    r->handler = \"proxy-server\";\n    r->proxyreq = PROXYREQ_REVERSE;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01005)\n                  \"proxy_express: rewritten as: %s\", r->filename);\n\n    ralias = (struct proxy_alias *)dconf->raliases->elts;\n    /*\n     * See if we have already added a ProxyPassReverse entry\n     * for this host... If so, don't do it again.\n     */\n    /*\n     * NOTE: dconf is process specific so this will only\n     *       work as long as we maintain that this process\n     *       or thread is handling the backend\n     */\n    for (i = 0; i < dconf->raliases->nelts; i++, ralias++) {\n        if (strcasecmp(backend, ralias->real) == 0) {\n            ralias = NULL;\n            break;\n        }\n    }\n\n    \n    if (!ralias) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01006)\n                      \"proxy_express: adding PPR entry\");\n        ralias = apr_array_push(dconf->raliases);\n        ralias->fake = \"/\";\n        ralias->real = apr_pstrdup(dconf->raliases->pool, backend);\n        ralias->flags = 0;\n    }\n    return OK;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_ce9e077f19833a237d441a09f446b0a2428e4cad_0", {
    "ID": "httpd_ce9e077f19833a237d441a09f446b0a2428e4cad_0",
    "UID": "7817",
    "code": "AP_DECLARE(int) ap_filter_output_pending(conn_rec test_snippet\n{\n    apr_hash_index_t *rindex;\n    int data_in_output_filters = DECLINED;\n\n    rindex = apr_hash_first(NULL, c->filters);\n    while (rindex) {\n        ap_filter_t *f = apr_hash_this_val(rindex);\n\n        if (f->frec->direction == AP_FILTER_OUTPUT && f->bb\n                && !APR_BRIGADE_EMPTY(f->bb)) {\n\n            apr_status_t rv;\n\n            rv = ap_pass_brigade(f, c->empty);\n            apr_brigade_cleanup(c->empty);\n            if (APR_SUCCESS != rv) {\n                ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00470)\n                        \"write failure in '%s' output filter\", f->frec->name);\n                return rv;\n            }\n\n            if (ap_filter_should_yield(f)) {\n                data_in_output_filters = OK;\n            }\n        }\n\n        rindex = apr_hash_next(rindex);\n    }\n\n    return data_in_output_filters;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_15b9470ae254190a99a3c06a58a2ad94e263bbb7_0", {
    "ID": "httpd_15b9470ae254190a99a3c06a58a2ad94e263bbb7_0",
    "UID": "7818",
    "code": "AP_DECLARE(int) ap_filter_input_pending(conn_rec test_snippet\n{\n    apr_hash_index_t *rindex;\n\n    rindex = apr_hash_first(NULL, c->filters);\n    while (rindex) {\n        ap_filter_t *f = apr_hash_this_val(rindex);\n\n        if (f->frec->direction == AP_FILTER_INPUT && f->bb) {\n            apr_bucket *e = APR_BRIGADE_FIRST(f->bb);\n\n            /* if there is at least one non-morphing bucket\n             * in place, then we have data pending\n             */\n            if (e != APR_BRIGADE_SENTINEL(f->bb)\n                    && e->length != (apr_size_t)(-1)) {\n                return OK;\n            }\n\n        }\n\n        rindex = apr_hash_next(rindex);\n    }\n\n    return DECLINED;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_f2ce685b95d06bc338d33db7d78b9422d02b438f_0", {
    "ID": "httpd_f2ce685b95d06bc338d33db7d78b9422d02b438f_0",
    "UID": "7854",
    "code": "static int ap_if_walk_sub(request_rec *r, core_dir_config* test_snippet\n{\n    ap_conf_vector_t *now_merged = NULL;\n    ap_conf_vector_t **sec_ent = NULL;\n    int num_sec = 0;\n    walk_cache_t *cache;\n    int cached;\n    int sec_idx;\n    int matches;\n    int cached_matches;\n    int prev_result = -1;\n    walk_walked_t *last_walk;\n\n    if (dconf && dconf->sec_if) {\n        sec_ent = (ap_conf_vector_t **)dconf->sec_if->elts;\n        num_sec = dconf->sec_if->nelts;\n    }\n\n    /* No tricks here, there are just no <If > to parse in this context.\n     * We won't destroy the cache, just in case _this_ redirect is later\n     * redirected again to a context containing the same or similar <If >.\n     */\n    if (!num_sec) {\n        return OK;\n    }\n\n    cache = prep_walk_cache(AP_NOTE_IF_WALK, r);\n    cached = (cache->cached != NULL);\n    cache->cached = (void *)1;\n    matches = cache->walked->nelts;\n    cached_matches = matches;\n    last_walk = (walk_walked_t*)cache->walked->elts;\n\n    cached &= auth_internal_per_conf;\n\n    \n    for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {\n        const char *err = NULL;\n        core_dir_config *entry_core;\n        int rc;\n        entry_core = ap_get_core_module_config(sec_ent[sec_idx]);\n\n        AP_DEBUG_ASSERT(entry_core->condition_ifelse != 0);\n        if (entry_core->condition_ifelse & AP_CONDITION_ELSE) {\n            AP_DEBUG_ASSERT(prev_result != -1);\n            if (prev_result == 1)\n                continue;\n        }\n\n        if (entry_core->condition_ifelse & AP_CONDITION_IF) {\n            rc = ap_expr_exec(r, entry_core->condition, &err);\n            if (rc <= 0) {\n                if (rc < 0)\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00039)\n                                  \"Failed to evaluate <If > condition: %s\",\n                                  err);\n                prev_result = 0;\n                continue;\n            }\n            prev_result = 1;\n        }\n        else {\n            prev_result = -1;\n        }\n\n        /* If we merged this same section last time, reuse it\n         */\n        if (matches) {\n            if (last_walk->matched == sec_ent[sec_idx]) {\n                now_merged = last_walk->merged;\n                ++last_walk;\n                --matches;\n                continue;\n            }\n\n            /* We fell out of sync.  This is our own copy of walked,\n             * so truncate the remaining matches and reset remaining.\n             */\n            cache->walked->nelts -= matches;\n            matches = 0;\n            cached = 0;\n        }\n\n        if (now_merged) {\n            now_merged = ap_merge_per_dir_configs(r->pool,\n                                                  now_merged,\n                                                  sec_ent[sec_idx]);\n        }\n        else {\n            now_merged = sec_ent[sec_idx];\n        }\n\n        last_walk = (walk_walked_t*)apr_array_push(cache->walked);\n        last_walk->matched = sec_ent[sec_idx];\n        last_walk->merged = now_merged;\n    }\n\n    /* Everything matched in sequence, but it may be that the original\n     * walk found some additional matches (which we need to truncate), or\n     * this walk found some additional matches.\n     */\n    if (matches) {\n        cache->walked->nelts -= matches;\n        cached = 0;\n    }\n    else if (cache->walked->nelts > cached_matches) {\n        cached = 0;\n    }\n\n    if (cached\n        && r->per_dir_config == cache->dir_conf_merged) {\n        r->per_dir_config = cache->per_dir_result;\n        return OK;\n    }\n\n    cache->dir_conf_tested = sec_ent;\n    cache->dir_conf_merged = r->per_dir_config;\n\n    /* Merge our cache->dir_conf_merged construct with the r->per_dir_configs,\n     * and note the end result to (potentially) skip this step next time.\n     */\n    if (now_merged) {\n        r->per_dir_config = ap_merge_per_dir_configs(r->pool,\n                                                     r->per_dir_config,\n                                                     now_merged);\n    }\n    cache->per_dir_result = r->per_dir_config;\n\n    if (now_merged) {\n        core_dir_config *dconf_merged = ap_get_core_module_config(now_merged);\n\n        /* Allow nested <If>s and their configs to get merged\n         * with the current one.\n         */\n        return ap_if_walk_sub(r, dconf_merged);\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_33b668f2523f33367d6931cfcc585462987f510f_0", {
    "ID": "httpd_33b668f2523f33367d6931cfcc585462987f510f_0",
    "UID": "7859",
    "code": "static char *parse_format_string(apr_pool_t *p, header_entry *hdr, const char test_snippet\n{\n    char *res;\n\n    \n    if (hdr->action == hdr_unset || hdr->action == hdr_echo) {\n        return NULL;\n    }\n    \n    else if (hdr->action == hdr_edit || hdr->action == hdr_edit_r ) {\n        s = hdr->subs;\n    }\n\n    hdr->ta = apr_array_make(p, 10, sizeof(format_tag));\n\n    while (test_snippet {\n        if ((res = parse_format_tag(p, (format_tag *) apr_array_push(hdr->ta), &s))) {\n            return res;\n        }\n    }\n    return NULL;\n}",
    "predicted": "The provided code snippet seems to be incomplete and not properly formatted, which makes it difficult to accurately identify any potential vulnerabilities. Please provide a complete and properly formatted code snippet."
  },
  "httpd_0432af70afdb05eedb0f824bfab1f9f52731867c_0", {
    "ID": "httpd_0432af70afdb05eedb0f824bfab1f9f52731867c_0",
    "UID": "7884",
    "code": "static int alias_match(const char *uri, const char test_snippet\n{\n    const char *end_fakename = alias_fakename + strlen(alias_fakename);\n    const char *aliasp = alias_fakename, *urip = uri;\n    const char *end_uri = uri + strlen(uri);\n\n    while (aliasp < end_fakename && urip < end_uri) {\n        if (*aliasp == '/') {\n            /* any number of '/' in the alias matches any number in\n             * the supplied URI, but there must be at least one...\n             */\n            if (*urip != '/')\n                return 0;\n\n            while (*aliasp == '/')\n                ++aliasp;\n            while (*urip == '/')\n                ++urip;\n        }\n        else {\n            \n            if (*urip++ != *aliasp++)\n                return 0;\n        }\n    }\n\n    \n    if (aliasp > end_fakename) {\n        aliasp = end_fakename;\n    }\n    if (urip > end_uri) {\n        urip = end_uri;\n    }\n\n   /* We reach the end of the uri before the end of \"alias_fakename\"\n    * for example uri is \"/\" and alias_fakename \"/examples\"\n    */\n   if (urip == end_uri && aliasp != end_fakename) {\n       return 0;\n   }\n\n    \n    if (aliasp[-1] != '/' && *urip != '\\0' && *urip != '/')\n        return 0;\n\n    /* Return number of characters from URI which matched (may be\n     * greater than length of alias, since we may have matched\n     * doubled slashes)\n     */\n\n    return urip - uri;\n}",
    "predicted": "126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_089570fa4cfaf6d62f3731cd3728ffa4e6e39c2e_0", {
    "ID": "httpd_089570fa4cfaf6d62f3731cd3728ffa4e6e39c2e_0",
    "UID": "7892",
    "code": "static remoteip_parse_status_t remoteip_process_v1_header(conn_rec test_snippet\n                                                          remoteip_conn_config_t *conn_conf,\n                                                          proxy_header *hdr, apr_size_t len,\n                                                          apr_size_t *hdr_len)\n{\n    char *end, *word, *host, *valid_addr_chars, *saveptr;\n    char buf[sizeof(hdr->v1.line)];\n    apr_port_t port;\n    apr_status_t ret;\n    apr_int32_t family;\n\n#define GET_NEXT_WORD(field) \\\n    word = apr_strtok(NULL, \" \", &saveptr); \\\n    if (!word) { \\\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03497) \\\n                      \"RemoteIPProxyProtocol: no \" field \" found in header '%s'\", \\\n                      hdr->v1.line); \\\n        return HDR_ERROR; \\\n    }\n\n    end = memchr(hdr->v1.line, '\\r', len - 1);\n    if (!end || end[1] != '\\n') {\n        return HDR_NEED_MORE; \n    }\n\n    *end = '\\0';\n    *hdr_len = end + 2 - hdr->v1.line; \n\n    \n    strcpy(buf, hdr->v1.line);\n\n    apr_strtok(buf, \" \", &saveptr);\n\n    \n    GET_NEXT_WORD(\"family\")\n    if (strcmp(word, \"UNKNOWN\") == 0) {\n        conn_conf->client_addr = c->client_addr;\n        conn_conf->client_ip = c->client_ip;\n        return HDR_DONE;\n    }\n    else if (strcmp(word, \"TCP4\") == 0) {\n        family = APR_INET;\n        valid_addr_chars = \"0123456789.\";\n    }\n    else if (strcmp(word, \"TCP6\") == 0) {\n#if APR_HAVE_IPV6\n        family = APR_INET6;\n        valid_addr_chars = \"0123456789abcdefABCDEF:\";\n#else\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03498)\n                      \"RemoteIPProxyProtocol: Unable to parse v6 address - APR is not compiled with IPv6 support\",\n                      word, hdr->v1.line);\n        return HDR_ERROR;\n#endif\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03499)\n                      \"RemoteIPProxyProtocol: unknown family '%s' in header '%s'\",\n                      word, hdr->v1.line);\n        return HDR_ERROR;\n    }\n\n    \n    GET_NEXT_WORD(\"client-address\")\n\n    if (strspn(word, valid_addr_chars) != strlen(word)) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03500)\n                      \"RemoteIPProxyProtocol: invalid client-address '%s' found in \"\n                      \"header '%s'\", word, hdr->v1.line);\n        return HDR_ERROR;\n    }\n\n    host = word;\n\n    \n    GET_NEXT_WORD(\"destination-address\")\n\n    \n    GET_NEXT_WORD(\"client-port\")\n    if (sscanf(word, \"%hu\", &port) != 1) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03501)\n                      \"RemoteIPProxyProtocol: error parsing port '%s' in header '%s'\",\n                      word, hdr->v1.line);\n        return HDR_ERROR;\n    }\n\n    \n    \n\n    \n    ret = apr_sockaddr_info_get(&conn_conf->client_addr, host, family, port, 0,\n                                c->pool);\n    if (ret != APR_SUCCESS) {\n        conn_conf->client_addr = NULL;\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, ret, c, APLOGNO(03502)\n                      \"RemoteIPProxyProtocol: error converting family '%d', host '%s',\"\n                      \" and port '%hu' to sockaddr; header was '%s'\",\n                      family, host, port, hdr->v1.line);\n        return HDR_ERROR;\n    }\n\n    conn_conf->client_ip = apr_pstrdup(c->pool, host);\n\n    return HDR_DONE;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_cd9907e3a8ec835ebbc61c2d423ea8d833098087_0", {
    "ID": "httpd_cd9907e3a8ec835ebbc61c2d423ea8d833098087_0",
    "UID": "7921",
    "code": "static const char *start_cond_section(cmd_parms *cmd, void *mconfig, const char test_snippet\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    int result, not = (arg[0] == '!');\n    test_cond_section_fn testfn = (test_cond_section_fn)cmd->info;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (not) {\n        arg++;\n    }\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    result = testfn(cmd, arg);\n\n    if ((!not && result) || (not && !result)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, cmd->cmd->name);\n        *(ap_directive_t **)mconfig = current;\n        return retval;\n    }\n    else {\n        *(ap_directive_t **)mconfig = NULL;\n        return ap_soak_end_container(cmd, cmd->cmd->name);\n    }\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_e9762075988b0ef9d2356e3c64d7fe4a1de98f41_0", {
    "ID": "httpd_e9762075988b0ef9d2356e3c64d7fe4a1de98f41_0",
    "UID": "7939",
    "code": "int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog test_snippet\n                 apr_pool_t *ptemp, server_rec *s_main)\n{\n    apr_pool_t *stderr_p;\n    server_rec *virt, *q;\n    int replace_stderr;\n\n\n    /* Register to throw away the read_handles list when we\n     * cleanup plog.  Upon fork() for the apache children,\n     * this read_handles list is closed so only the parent\n     * can relaunch a lost log child.  These read handles\n     * are always closed on exec.\n     * We won't care what happens to our stderr log child\n     * between log phases, so we don't mind losing stderr's\n     * read_handle a little bit early.\n     */\n    apr_pool_cleanup_register(p, &read_handles, ap_pool_cleanup_set_null,\n                              apr_pool_cleanup_null);\n\n    /* HERE we need a stdout log that outlives plog.\n     * We *presume* the parent of plog is a process\n     * or global pool which spans server restarts.\n     * Create our stderr_pool as a child of the plog's\n     * parent pool.\n     */\n    apr_pool_create(&stderr_p, apr_pool_parent_get(p));\n    apr_pool_tag(stderr_p, \"stderr_pool\");\n\n    if (open_error_log(s_main, 1, stderr_p) != OK) {\n        return DONE;\n    }\n\n    replace_stderr = 1;\n    if (s_main->error_log) {\n        apr_status_t rv;\n\n        \n        apr_file_flush(s_main->error_log);\n        rv = apr_file_dup2(stderr_log, s_main->error_log, stderr_p);\n        if (rv != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s_main, APLOGNO(00092)\n                         \"unable to replace stderr with error_log\");\n        }\n        else {\n            /* We are done with stderr_pool, close it, killing\n             * the previous generation's stderr logger\n             */\n            if (stderr_pool)\n                apr_pool_destroy(stderr_pool);\n            stderr_pool = stderr_p;\n            replace_stderr = 0;\n            /*\n             * Now that we have dup'ed s_main->error_log to stderr_log\n             * close it and set s_main->error_log to stderr_log. This avoids\n             * this fd being inherited by the next piped logger who would\n             * keep open the writing end of the pipe that this one uses\n             * as stdin. This in turn would prevent the piped logger from\n             * exiting.\n             */\n             apr_file_close(s_main->error_log);\n             s_main->error_log = stderr_log;\n        }\n    }\n    /* note that stderr may still need to be replaced with something\n     * because it points to the old error log, or back to the tty\n     * of the submitter.\n     * XXX: This is BS - /dev/null is non-portable\n     *      errno-as-apr_status_t is also non-portable\n     */\n\n#ifdef WIN32\n#define NULL_DEVICE \"nul\"\n#else\n#define NULL_DEVICE \"/dev/null\"\n#endif\n\n    if (replace_stderr) {\n        if (freopen(NULL_DEVICE, \"w\", stderr) == NULL) {\n            ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main, APLOGNO(00093)\n                        \"unable to replace stderr with %s\", NULL_DEVICE);\n        }\n        stderr_log = NULL;\n    }\n\n    for (virt = s_main->next; virt; virt = virt->next) {\n        if (virt->error_fname) {\n            for (q=s_main; q != virt; q = q->next) {\n                if (q->error_fname != NULL\n                    && strcmp(q->error_fname, virt->error_fname) == 0) {\n                    break;\n                }\n            }\n\n            if (q == virt) {\n                if (open_error_log(virt, 0, p) != OK) {\n                    return DONE;\n                }\n            }\n            else {\n                virt->error_log = q->error_log;\n            }\n        }\n        else if (virt->errorlog_provider) {\n            \n            if (open_error_log(virt, 0, p) != OK) {\n                return DONE;\n            }\n        }\n        else if (s_main->errorlog_provider) {\n            \n            virt->errorlog_provider = s_main->errorlog_provider;\n            virt->errorlog_provider_handle = s_main->errorlog_provider_handle;\n            virt->error_log = NULL;\n        }\n        else {\n            virt->error_log = s_main->error_log;\n        }\n    }\n    return OK;\n}",
    "predicted": "775,Missing Release of File Descriptor or Handle after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2a40fad5c368e66f09a3cb7f6af43457f0c557f0_0", {
    "ID": "httpd_2a40fad5c368e66f09a3cb7f6af43457f0c557f0_0",
    "UID": "7963",
    "code": "static apr_status_t ap_fgetline_core(char **s, apr_size_t test_snippet\n                                     apr_size_t *read, ap_filter_t *f,\n                                     int flags, apr_bucket_brigade *bb,\n                                     apr_pool_t *p)\n{\n    apr_status_t rv;\n    apr_bucket *e;\n    apr_size_t bytes_handled = 0, current_alloc = 0;\n    char *pos, *last_char = *s;\n    int do_alloc = (*s == NULL), saw_eos = 0;\n    int fold = flags & AP_GETLINE_FOLD;\n    int crlf = flags & AP_GETLINE_CRLF;\n    int nospc_eol = flags & AP_GETLINE_NOSPC_EOL;\n    int saw_eol = 0, saw_nospc = 0;\n    apr_read_type_e block;\n\n    if (!n) {\n        \n        *read = 0;\n        return APR_BADARG;\n    }\n\n    block = (flags & AP_GETLINE_NONBLOCK) ? APR_NONBLOCK_READ\n                                          : APR_BLOCK_READ;\n\n    /*\n     * Initialize last_char as otherwise a random value will be compared\n     * against APR_ASCII_LF at the end of the loop if bb only contains\n     * zero-length buckets.\n     */\n    if (last_char)\n        *last_char = '\\0';\n\n    do {\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(f, bb, AP_MODE_GETLINE, block, 0);\n        if (rv != APR_SUCCESS) {\n            goto cleanup;\n        }\n\n        /* Something horribly wrong happened.  Someone didn't block! \n         * (this also happens at the end of each keepalive connection)\n         * (this also happens when non-blocking is asked too, not that wrong)\n         */\n        if (APR_BRIGADE_EMPTY(bb)) {\n            if (block != APR_NONBLOCK_READ) {\n                rv = APR_EGENERAL;\n            }\n            else {\n                rv = APR_EAGAIN;\n            }\n            goto cleanup;\n        }\n\n        for (e = APR_BRIGADE_FIRST(bb);\n             e != APR_BRIGADE_SENTINEL(bb);\n             e = APR_BUCKET_NEXT(e))\n        {\n            const char *str;\n            apr_size_t len;\n\n            \n            if (APR_BUCKET_IS_EOS(e)) {\n                saw_eos = 1;\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &letest_snippet APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n\n            if (len == 0) {\n                /* no use attempting a zero-byte alloc (hurts when\n                 * using --with-efence --enable-pool-debug) or\n                 * doing any of the other logic either\n                 */\n                continue;\n            }\n\n            \n            if (n < bytes_handled + len) {\n                /* Before we die, let's fill the buffer up to its limit (i.e.\n                 * fall through with the remaining length, if any), setting\n                 * saw_eol on LF to stop the outer loop appropriately; we may\n                 * come back here once the buffer is filled (no LF seen), and\n                 * either be done at that time or continue to wait for LF here\n                 * if nospc_eol is set.\n                 *\n                 * But there is also a corner cases which we want to address,\n                 * namely if the buffer is overrun by the final LF only (i.e.\n                 * the CR fits in); this is not really an overrun since we'll\n                 * strip the CR finally (and use it for NUL byte), but anyway\n                 * we have to handle the case so that it's not returned to the\n                 * caller as part of the truncated line (it's not!). This is\n                 * easier to consider that LF is out of counting and thus fall\n                 * through with no error (saw_eol is set to 2 so that we later\n                 * ignore LF handling already done here), while folding and\n                 * nospc_eol logics continue to work (or fail) appropriately.\n                 */\n                saw_eol = (str[len - 1] == APR_ASCII_LF);\n                if (\n                    saw_eol && !saw_nospc\n                    \n                    && ((len == 1 && ((*s)[bytes_handled - 1] == APR_ASCII_CR))\n                    \n                        || (len > 1 && str[len - 2] == APR_ASCII_CR\n                            && n - bytes_handled + 1 == len))) {\n                    /* In both cases *last_char is (to be) the CR stripped by\n                     * later 'bytes_handled = last_char - *s'.\n                     */\n                    saw_eol = 2;\n                }\n                else {\n                    \n                    rv = APR_ENOSPC;\n                    saw_nospc = 1;\n                }\n                len = n - bytes_handled;\n                if (!len) {\n                    if (saw_eol) {\n                        break;\n                    }\n                    if (nospc_eol) {\n                        continue;\n                    }\n                    goto cleanup;\n                }\n            }\n\n            \n            if (do_alloc) {\n                \n                if (!*s) {\n                    current_alloc = len;\n                    *s = apr_palloc(p, current_alloc + 1);\n                }\n                else if (bytes_handled + len > current_alloc) {\n                    \n                    apr_size_t new_size = current_alloc * 2;\n                    char *new_buffer;\n\n                    if (bytes_handled + len > new_size) {\n                        new_size = (bytes_handled + len) * 2;\n                    }\n\n                    new_buffer = apr_palloc(p, new_size + 1);\n\n                    \n                    memcpy(new_buffer, *s, bytes_handled);\n                    current_alloc = new_size;\n                    *s = new_buffer;\n                }\n            }\n\n            \n            pos = *s + bytes_handled;\n            memcpy(pos, str, len);\n            last_char = pos + len - 1;\n\n            \n            bytes_handled += len;\n        }\n\n        \n        if (last_char && (*last_char == APR_ASCII_LF)) {\n            saw_eol = 1;\n        }\n    } while (!saw_eol);\n\n    if (rv != APR_SUCCESS) {\n        \n        goto cleanup;\n    }\n\n    /* Now terminate the string at the end of the line;\n     * if the last-but-one character is a CR, terminate there.\n     * LF is handled above (not accounted) when saw_eol == 2,\n     * the last char is CR to terminate at still.\n     */\n    if (saw_eol < 2) {\n        if (last_char > *s && last_char[-1] == APR_ASCII_CR) {\n            last_char--;\n        }\n        else if (crlf) {\n            rv = APR_EINVAL;\n            goto cleanup;\n        }\n    }\n    bytes_handled = last_char - *s;\n\n    /* If we're folding, we have more work to do.\n     *\n     * Note that if an EOS was seetest_snippet we know we can't have another line.\n     */\n    if (fold && bytes_handled && !saw_eos) {\n        for (;;) {\n            const char *str;\n            apr_size_t len;\n            char c;\n\n            \n            apr_brigade_cleanup(bb);\n\n            \n            rv = ap_get_brigade(f, bb, AP_MODE_SPECULATIVE, block, 1);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n\n            if (APR_BRIGADE_EMPTY(bb)) {\n                break;\n            }\n\n            e = APR_BRIGADE_FIRST(bb);\n\n            \n            if (APR_BUCKET_IS_EOS(e)) {\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &letest_snippet APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                apr_brigade_cleanup(bb);\n                goto cleanup;\n            }\n\n            /* Found one, so call ourselves again to get the next line.\n             *\n             * FIXME: If the folding line is completely blank, should we\n             * stop folding?  Does that require also looking at the next\n             * char?\n             */\n            /* When we call destroy, the buckets are deleted, so save that\n             * one character we need.  This simplifies our execution paths\n             * at the cost of one character read.\n             */\n            c = *str;\n            if (c == APR_ASCII_BLANK || c == APR_ASCII_TAB) {\n                \n                if (bytes_handled >= n) {\n                    rv = APR_ENOSPC;\n                    goto cleanup;\n                }\n                else {\n                    apr_size_t next_size, next_len;\n                    char *tmp;\n\n                    /* If we're doing the allocations for them, we have to\n                     * give ourselves a NULL and copy it on return.\n                     */\n                    if (do_alloc) {\n                        tmp = NULL;\n                    }\n                    else {\n                        tmp = last_char;\n                    }\n\n                    next_size = n - bytes_handled;\n\n                    rv = ap_fgetline_core(&tmp, next_size, &next_letest_snippet f,\n                                          flags & ~AP_GETLINE_FOLD, bb, p);\n                    if (rv != APR_SUCCESS) {\n                        goto cleanup;\n                    }\n\n                    if (do_alloc && next_len > 0) {\n                        char *new_buffer;\n                        apr_size_t new_size = bytes_handled + next_len + 1;\n\n                        \n                        new_buffer = apr_palloc(p, new_size);\n\n                        \n                        memcpy(new_buffer, *s, bytes_handled);\n\n                        \n                        memcpy(new_buffer + bytes_handled, tmp, next_len);\n                        *s = new_buffer;\n                    }\n\n                    last_char += next_len;\n                    bytes_handled += next_len;\n                }\n            }\n            else { \n                break;\n            }\n        }\n    }\n\ncleanup:\n    if (bytes_handled >= n) {\n        bytes_handled = n - 1;\n    }\n\n    *read = bytes_handled;\n    if (*s) {\n        \n        (*s)[*read] = '\\0';\n\n        \n        bytes_handled = strlen(*s);\n        if (bytes_handled < *read) {\n            *read = bytes_handled;\n            if (rv == APR_SUCCESS) {\n                rv = APR_EINVAL;\n            }\n        }\n    }\n    return rv;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_d7346b82233f5bf031698174047435dd1f4b389f_0", {
    "ID": "httpd_d7346b82233f5bf031698174047435dd1f4b389f_0",
    "UID": "8040",
    "code": "AP_DECLARE(int) ap_check_request_header(request_rec test_snippet\n{\n    core_server_config *conf;\n    int strict_host_check;\n    const char *expect;\n    int access_status;\n\n    conf = ap_get_core_module_config(r->server->module_config);\n\n    /* update what we think the virtual host is based on the headers we've\n     * now read. may update status.\n     */\n    strict_host_check = (conf->strict_host_check == AP_CORE_CONFIG_ON);\n    access_status = ap_update_vhost_from_headers_ex(r, strict_host_check);\n    if (strict_host_check && access_status != HTTP_OK) { \n        if (r->server == ap_server_conf) { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10156)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the global server configuration \", r->hostname);\n        }\n        else { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10157)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the matching virtual host (default vhost for \"\n                          \"current connection is %s:%u)\", \n                          r->hostname, r->server->defn_name, r->server->defn_line_number);\n        }\n        r->status = access_status;\n    }\n    if (r->status != HTTP_OK) { \n        return 0;\n    }\n\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        /*\n         * Client sent us an HTTP/1.1 or later request without telling us the\n         * hostname, either with a full URL or a Host: header. We therefore\n         * need to (as per the 1.1 spec) send an error.  As a special case,\n         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain\n         * a Host: header, and the server MUST respond with 400 if it doesn't.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00569)\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n        r->status = HTTP_BAD_REQUEST;\n        return 0;\n    }\n\n    \n    conf = ap_get_core_module_config(r->server->module_config);\n\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        /*\n         * The Expect header field was added to HTTP/1.1 after RFC 2068\n         * as a means to signal when a 100 response is desired and,\n         * unfortunately, to signal a poor man's mandatory extension that\n         * the server must understand or return 417 Expectation Failed.\n         */\n        if (ap_cstr_casecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else if (conf->http_expect_strict == AP_HTTP_EXPECT_STRICT_DISABLE) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02595)\n                          \"client sent an unrecognized expectation value \"\n                          \"of Expect (not fatal): %s\", expect);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                          \"client sent an unrecognized expectation value \"\n                          \"of Expect: %s\", expect);\n            r->status = HTTP_EXPECTATION_FAILED;\n            return 0;\n        }\n    }\n\n    return 1;\n}",
    "predicted": "The code provided does not seem to have any obvious vulnerabilities based on the categories provided. The function checks for various conditions and handles them appropriately. It does not appear to have any buffer overflows, integer overflows, or other common vulnerabilities. It also does not seem to use any hard-coded passwords or cryptographic keys, and it does not appear to improperly handle memory or resources. Therefore, the response is:\n\nnull"
  },
  "httpd_8fce188a2f5d0020efb3342c32490804e7d90ea0_0", {
    "ID": "httpd_8fce188a2f5d0020efb3342c32490804e7d90ea0_0",
    "UID": "8045",
    "code": "static int read_request_line(request_rec *r, apr_bucket_brigade test_snippet\n{\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (APR_STATUS_IS_ENOSPC(rv)) {\n                r->status = HTTP_REQUEST_URI_TOO_LARGE;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else if (APR_STATUS_IS_BADARG(rv)) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            else if (APR_STATUS_IS_EINVAL(rv)) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            r->proto_num = HTTP_VERSION(1,0);\n            r->protocol  = \"HTTP/1.0\";\n            return 0;\n        }\n    } while ((len <= 0) && (--num_blank_lines >= 0));\n\n    if (APLOGrtrace5(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                      \"Request received from client: %s\",\n                      ap_escape_logitem(r->pool, r->the_request));\n    }\n\n    r->request_time = apr_time_now();\n    return 1;\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8f49b521ff395f7a0d6b799bc7c77292c9e1a2dd_0", {
    "ID": "httpd_8f49b521ff395f7a0d6b799bc7c77292c9e1a2dd_0",
    "UID": "8079",
    "code": "static apr_status_t remoteip_input_filter(ap_filter_t test_snippet\n                                    apr_bucket_brigade *bb_out,\n                                    ap_input_mode_t mode,\n                                    apr_read_type_e block,\n                                    apr_off_t readbytes)\n{\n    apr_status_t ret;\n    remoteip_filter_context *ctx = f->ctx;\n    remoteip_conn_config_t *conn_conf;\n    apr_bucket *b;\n    remoteip_parse_status_t psts = HDR_NEED_MORE;\n    const char *ptr;\n    apr_size_t len;\n    apr_size_t this_read = 0; \n    apr_size_t prev_read = 0;\n\n    if (f->c->aborted) {\n        return APR_ECONNABORTED;\n    }\n\n    conn_conf = ap_get_module_config(f->c->conn_config, &remoteip_module);\n\n    \n    if (!ctx) {\n        ctx = f->ctx = apr_palloc(f->c->pool, sizeof(*ctx));\n        ctx->rcvd = 0;\n        ctx->need = MIN_HDR_LEN;\n        ctx->version = 0;\n        ctx->bb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);\n        ctx->done = 0;\n        if (conn_conf->proxy_protocol_optional) {\n            ctx->mode = AP_MODE_SPECULATIVE;\n            ctx->peeking = 1;\n        }\n        else {\n            ctx->mode = AP_MODE_READBYTES;\n            ctx->peeking = 0;\n        }\n    }\n\n    if (ctx->done) {\n        /* Note: because we're a connection filter we can't remove ourselves\n         * when we're done, so we have to stay in the chain and just go into\n         * passthrough mode.\n         */\n        return ap_get_brigade(f->next, bb_out, mode, block, readbytes);\n    }\n\n    \n    while (!ctx->done) {\n        if (APR_BRIGADE_EMPTY(ctx->bb)) {\n            ret = ap_get_brigade(f->next, ctx->bb, ctx->mode, block,\n                                 ctx->need - ctx->rcvd);\n            if (ret != APR_SUCCESS) {\n                return ret;\n            }\n        }\n        if (APR_BRIGADE_EMPTY(ctx->bb)) {\n            return block == APR_NONBLOCK_READ ? APR_SUCCESS : APR_EOF;\n        }\n\n        if (ctx->peeking) {\n            ctx->rcvd = 0;\n            ctx->need = MIN_HDR_LEN;\n        }\n\n        while (!ctx->done && !APR_BRIGADE_EMPTY(ctx->bb)) {\n            b = APR_BRIGADE_FIRST(ctx->bb);\n\n            if (ctx->peeking && APR_BUCKET_IS_EOS(b)) {\n                /* Shortcut - we know no header was found yet and an\n                   EOS indicates we never will */\n                apr_brigade_destroy(ctx->bb);\n                ctx->bb = NULL;\n                ctx->done = 1;\n                return APR_SUCCESS;\n            }\n\n            ret = apr_bucket_read(b, &ptr, &len, block);\n            if (APR_STATUS_IS_EAGAIN(ret) && block == APR_NONBLOCK_READ) {\n                return APR_SUCCESS;\n            }\n            if (ret != APR_SUCCESS) {\n                return ret;\n            }\n\n            memcpy(ctx->header + ctx->rcvd, ptr, len);\n            ctx->rcvd += len;\n\n            if (ctx->peeking && block == APR_NONBLOCK_READ) {\n                this_read += len;\n            }\n\n            apr_bucket_delete(b);\n            psts = HDR_NEED_MORE;\n\n            if (ctx->version == 0) {\n                \n                if (ctx->rcvd >= MIN_HDR_LEN) {\n                    ctx->version = remoteip_determine_version(f->c, ctx->header);\n\n                    /* We've read enough to know that a header is present. In peek mode\n                       we purge the bb and can decide to step aside or switch to\n                       non-speculative read to consume the data */\n                    if (ctx->peeking) {\n                        if (ctx->version < 0) {\n                            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, f->c, APLOGNO(03512)\n                                          \"RemoteIPProxyProtocol: PROXY header is missing from \"\n                                          \"request. Stepping aside.\");\n                            apr_brigade_destroy(ctx->bb);\n                            ctx->bb = NULL;\n                            ctx->done = 1;\n                            return ap_get_brigade(f->next, bb_out, mode, block, readbytes);\n                        }\n                        else {\n                            \n                            ctx->rcvd = 0;\n                            ctx->need = MIN_HDR_LEN;\n                            ctx->version = 0;\n                            ctx->done = 0;\n                            ctx->mode = AP_MODE_READBYTES;\n                            ctx->peeking = 0;\n                            apr_brigade_cleanup(ctx->bb);\n\n                            ap_get_brigade(f->next, ctx->bb, ctx->mode, block,\n                                           ctx->need - ctx->rcvd);\n                        }\n                    }\n                    else {\n                        if (ctx->version < 0) {\n                            psts = HDR_MISSING;\n                        }\n                        else if (ctx->version == 1) {\n                            ctx->mode = AP_MODE_GETLINE;\n                            ctx->need = sizeof(proxy_v1);\n                        }\n                        else if (ctx->version == 2) {\n                            ctx->need = MIN_V2_HDR_LEN;\n                        }\n                    }\n                }\n            }\n            else if (ctx->version == 1) {\n                psts = remoteip_process_v1_header(f->c, conn_conf,\n                                            (proxy_header *) ctx->header,\n                                            ctx->rcvd, &ctx->need);\n            }\n            else if (ctx->version == 2) {\n                if (ctx->rcvd >= MIN_V2_HDR_LEN) {\n                    ctx->need = MIN_V2_HDR_LEN +\n                        remoteip_get_v2_len((proxy_header *) ctx->header);\n\n                }\n                if (ctx->rcvd >= ctx->need) {\n                    psts = remoteip_process_v2_header(f->c, conn_conf,\n                                                (proxy_header *) ctx->header);\n                }\n            }\n            else {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(03509)\n                              \"RemoteIPProxyProtocol: internal error: unknown version \"\n                              \"%d\", ctx->version);\n                f->c->aborted = 1;\n                apr_brigade_destroy(ctx->bb);\n                return APR_ECONNABORTED;\n            }\n\n            switch (psts) {\n                case HDR_MISSING:\n                    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(03510)\n                                 \"RemoteIPProxyProtocol: no valid PROXY header found\");\n                        \n                case HDR_ERROR:\n                    f->c->aborted = 1;\n                    apr_brigade_destroy(ctx->bb);\n                    return APR_ECONNABORTED;\n\n                case HDR_DONE:\n                    ctx->done = 1;\n                    break;\n\n                case HDR_NEED_MORE:\n                    break;\n            }\n        }\n\n        /* In SPECULATIVE mode, upstream will return all data on each brigade get - even data\n           we've seen.  For non blocking read, make sure we got new data or return early when\n           we haven't */\n        if (ctx->peeking && block == APR_NONBLOCK_READ) {\n            if (this_read == prev_read) {\n                return APR_SUCCESS;\n            }\n            else {\n                prev_read = this_read;\n            }\n        }\n    }\n\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, f->c, APLOGNO(03511)\n                  \"RemoteIPProxyProtocol: received valid PROXY header: %s:%hu\",\n                  conn_conf->client_ip, conn_conf->client_addr->port);\n\n    if (ctx->rcvd > ctx->need || !APR_BRIGADE_EMPTY(ctx->bb)) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(03513)\n                      \"RemoteIPProxyProtocol: internal error: have data left over; \"\n                      \" need=%lu, rcvd=%lu, brigade-empty=%d\", ctx->need,\n                      ctx->rcvd, APR_BRIGADE_EMPTY(ctx->bb));\n        f->c->aborted = 1;\n        apr_brigade_destroy(ctx->bb);\n        return APR_ECONNABORTED;\n    }\n\n    \n    apr_brigade_destroy(ctx->bb);\n    ctx->bb = NULL;\n\n    \n    return ap_get_brigade(f->next, bb_out, mode, block, readbytes);\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_c611adefd017228bae3c8064bfdfa746df585b09_0", {
    "ID": "httpd_c611adefd017228bae3c8064bfdfa746df585b09_0",
    "UID": "8080",
    "code": "static const char *ap_expr_eval_string_func(ap_expr_eval_ctx_t test_snippet\n                                            const ap_expr_t *info,\n                                            const ap_expr_t *arg)\n{\n    const void *data = info->node_arg2;\n\n    AP_DEBUG_ASSERT(info->node_op == op_StringFuncInfo);\n    AP_DEBUG_ASSERT(info->node_arg1 != NULL);\n    AP_DEBUG_ASSERT(data != NULL);\n    if (arg->node_op == op_ListElement) {\n        \n        ap_expr_string_list_func_t *func = (ap_expr_string_list_func_t *)info->node_arg1;\n        apr_array_header_t *args = apr_array_make(ctx->p, 1, sizeof(char *));\n        do {\n            const ap_expr_t *val = arg->node_arg1;\n            const char **new = apr_array_push(args);\n            *new = ap_expr_eval_word(ctx, val);\n\n            arg = arg->node_arg2;\n        } while (arg != NULL);\n\n        return (*func)(ctx, data, args);\n    }\n    else {\n        ap_expr_string_func_t *func = (ap_expr_string_func_t *)info->node_arg1;\n        return (*func)(ctx, data, ap_expr_eval_word(ctx, arg));\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_67b17356c981255186a856b86f44c190cc5583ae_0", {
    "ID": "httpd_67b17356c981255186a856b86f44c190cc5583ae_0",
    "UID": "8083",
    "code": "static const char *replace_func(ap_expr_eval_ctx_t *ctx, const void test_snippet\n                               const apr_array_header_t *args)\n{\n    char *buff, *original, *replacement;\n    struct ap_varbuf vb;\n    apr_size_t repl_len;\n    const char *repl;\n    apr_size_t bytes;\n    apr_size_t len;\n    const apr_strmatch_pattern *pattern = data;\n    if (args->nelts != 3) {\n        *ctx->err = apr_psprintf(ctx->p, \"replace() function needs \"\n                                 \"exactly 3 arguments\");\n        return \"\";\n    }\n\n    buff = APR_ARRAY_IDX(args, 2, char *);\n    original = APR_ARRAY_IDX(args, 1, char *);\n    replacement = APR_ARRAY_IDX(args, 0, char *);\n    repl_len = strlen(replacement);\n    bytes = strlen(buff);\n\n    ap_varbuf_init(ctx->p, &vb, 0);\n    vb.strlen = 0;\n    \n    while ((repl = apr_strmatch(pattern, buff, bytes))) {\n        len = (apr_size_t) (repl - buff);\n        ap_varbuf_strmemcat(&vb, buff, len);\n        ap_varbuf_strmemcat(&vb, replacement, repl_len);\n\n        len += repl_len;\n        bytes -= len;\n        buff += len;\n    }\n\n    return ap_varbuf_pdup(ctx->p, &vb, NULL, 0, buff, bytes, &len);\n}",
    "predicted": "122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_74c5eb4b9f0793408f8152a4fb15ecbb89379a96_0", {
    "ID": "httpd_74c5eb4b9f0793408f8152a4fb15ecbb89379a96_0",
    "UID": "8097",
    "code": "AP_DECLARE(void) ap_unixd_mpm_set_signals(apr_pool_t *pconf, int test_snippet\n{\n#ifndef NO_USE_SIGACTION\n    struct sigaction sa;\n#endif\n\n    \n    (void)ap_unixd_mpm_get_retained_data();\n\n#ifndef NO_USE_SIGACTION\n    memset(&sa, 0, sizeof sa);\n    sigemptyset(&sa.sa_mask);\n\n#ifdef SIGPIPE\n    sa.sa_handler = SIG_IGN;\n    if (sigaction(SIGPIPE, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00269)\n                     \"sigaction(SIGPIPE)\");\n#endif\n#ifdef SIGXCPU\n    sa.sa_handler = SIG_DFL;\n    if (sigaction(SIGXCPU, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00267)\n                     \"sigaction(SIGXCPU)\");\n#endif\n#ifdef SIGXFSZ\n    /* For systems following the LFS standard, ignoring SIGXFSZ allows\n     * a write() beyond the 2GB limit to fail gracefully with E2BIG\n     * rather than terminate the process. */\n    sa.sa_handler = SIG_IGN;\n    if (sigaction(SIGXFSZ, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00268)\n                     \"sigaction(SIGXFSZ)\");\n#endif\n\n    sa.sa_handler = sig_term;\n    if (sigaction(SIGTERM, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00264)\n                     \"sigaction(SIGTERM)\");\n#ifdef SIGINT\n    if (sigaction(SIGINT, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00266)\n                     \"sigaction(SIGINT)\");\n#endif\n#ifdef AP_SIG_GRACEFUL_STOP\n    if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)\n        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00265)\n                     \"sigaction(\" AP_SIG_GRACEFUL_STOP_STRING \")\");\n#endif\n\n    \n    if (!test_snippet {\n        sa.sa_handler = sig_restart;\n        if (sigaction(SIGHUP, &sa, NULL) < 0)\n            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00270)\n                         \"sigaction(SIGHUP)\");\n        if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)\n            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00271)\n                         \"sigaction(\" AP_SIG_GRACEFUL_STRING \")\");\n    }\n\n#else  \n\n#ifdef SIGPIPE\n    apr_signal(SIGPIPE, SIG_IGN);\n#endif \n#ifdef SIGXCPU\n    apr_signal(SIGXCPU, SIG_DFL);\n#endif \n#ifdef SIGXFSZ\n    apr_signal(SIGXFSZ, SIG_IGN);\n#endif \n\n    apr_signal(SIGTERM, sig_term);\n#ifdef AP_SIG_GRACEFUL_STOP\n    apr_signal(AP_SIG_GRACEFUL_STOP, sig_term);\n#endif \n\n    if (!test_snippet {\n        \n#ifdef SIGHUP\n        apr_signal(SIGHUP, sig_restart);\n#endif \n#ifdef AP_SIG_GRACEFUL\n        apr_signal(AP_SIG_GRACEFUL, sig_restart);\n#endif \n    }\n\n#endif \n\n    apr_pool_cleanup_register(pconf, NULL, unset_signals,\n                              apr_pool_cleanup_null);\n}",
    "predicted": "null"
  },
  "httpd_9dd516d6abcf368c8c10d86cc8a389aec6ef1bf5_0", {
    "ID": "httpd_9dd516d6abcf368c8c10d86cc8a389aec6ef1bf5_0",
    "UID": "8127",
    "code": "static void add_cookie(request_rec *r, char test_snippet\n{\n    char *var;\n    char *val;\n    char *domain;\n    char *expires;\n    char *path;\n    char *secure;\n    char *httponly;\n\n    char *tok_cntx;\n    char *cookie;\n    \n    const char *sep = \":\"; \n\n    \n    if (s && *s == ';') { \n        sep = \";\"; \n        s++;\n    }\n\n    var = apr_strtok(s, sep, &tok_cntx);\n    val = apr_strtok(NULL, sep, &tok_cntx);\n    domain = apr_strtok(NULL, sep, &tok_cntx);\n\n    if (var && val && domain) {\n        request_rec *rmain = r;\n        char *notename;\n        void *data;\n\n        while (rmain->main) {\n            rmain = rmain->main;\n        }\n\n        notename = apr_pstrcat(rmain->pool, var, \"_rewrite\", NULL);\n        apr_pool_userdata_get(&data, notename, rmain->pool);\n        if (!data) {\n            char *exp_time = NULL;\n\n            expires = apr_strtok(NULL, sep, &tok_cntx);\n            path = expires ? apr_strtok(NULL, sep, &tok_cntx) : NULL;\n            secure = path ? apr_strtok(NULL, sep, &tok_cntx) : NULL;\n            httponly = secure ? apr_strtok(NULL, sep, &tok_cntx) : NULL;\n\n            if (expires) {\n                apr_time_exp_t tms;\n                long exp_min;\n\n                exp_min = atol(expires);\n                if (exp_min) {\n                    apr_time_exp_gmt(&tms, r->request_time\n                                     + apr_time_from_sec((60 * exp_min)));\n                    exp_time = apr_psprintf(r->pool, \"%s, %.2d-%s-%.4d \"\n                                                     \"%.2d:%.2d:%.2d GMT\",\n                                           apr_day_snames[tms.tm_wday],\n                                           tms.tm_mday,\n                                           apr_month_snames[tms.tm_mon],\n                                           tms.tm_year+1900,\n                                           tms.tm_hour, tms.tm_min, tms.tm_sec);\n                }\n            }\n\n            cookie = apr_pstrcat(rmain->pool,\n                                 var, \"=\", val,\n                                 \"; path=\", path ? path : \"/\",\n                                 \"; domain=\", domain,\n                                 expires ? (exp_time ? \"; expires=\" : \"\")\n                                 : NULL,\n                                 expires ? (exp_time ? exp_time : \"\")\n                                 : NULL,\n                                 (secure && (!strcasecmp(secure, \"true\")\n                                             || !strcmp(secure, \"1\")\n                                             || !strcasecmp(secure,\n                                                            \"secure\"))) ?\n                                  \"; secure\" : NULL,\n                                 (httponly && (!strcasecmp(httponly, \"true\")\n                                               || !strcmp(httponly, \"1\")\n                                               || !strcasecmp(httponly,\n                                                              \"HttpOnly\"))) ?\n                                  \"; HttpOnly\" : NULL,\n                                 NULL);\n\n            apr_table_addn(rmain->err_headers_out, \"Set-Cookie\", cookie);\n            apr_pool_userdata_set(\"set\", notename, NULL, rmain->pool);\n            rewritelog((rmain, 5, NULL, \"setting cookie '%s'\", cookie));\n        }\n        else {\n            rewritelog((rmain, 5, NULL, \"skipping already set cookie '%s'\",\n                        var));\n        }\n    }\n\n    return;\n}",
    "predicted": "20,Improper Input Validation\n"
  },
  "httpd_44ea1b4007a1d5ae865fa132f8f343cd4d7386ea_0", {
    "ID": "httpd_44ea1b4007a1d5ae865fa132f8f343cd4d7386ea_0",
    "UID": "8175",
    "code": "static void balancer_display_page(request_rec *r, proxy_server_conf test_snippet\n                                  proxy_balancer *bsel,\n                                  proxy_worker *wsel,\n                                  int usexml)\n{\n    const char *action;\n    proxy_balancer *balancer;\n    proxy_worker *worker;\n    proxy_worker **workers;\n    int i, n;\n    action = ap_construct_url(r->pool, r->uri, r);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01204) \"genning page\");\n\n    if (usexml) {\n        char date[APR_RFC822_DATE_LEN];\n        ap_set_content_type(r, \"text/xml\");\n        ap_rputs(\"<?xml version='1.0' encoding='UTF-8' ?>\\n\", r);\n        ap_rputs(\"<httpd:manager xmlns:httpd='http://httpd.apache.org'>\\n\", r);\n        ap_rputs(\"  <httpd:balancers>\\n\", r);\n        balancer = (proxy_balancer *)conf->balancers->elts;\n        for (i = 0; i < conf->balancers->nelts; i++) {\n            ap_rputs(\"    <httpd:balancer>\\n\", r);\n            \n            ap_rvputs(r, \"      <httpd:name>\", balancer->s->name, \"</httpd:name>\\n\", NULL);\n            if (*balancer->s->sticky) {\n                ap_rvputs(r, \"      <httpd:stickysession>\", balancer->s->sticky,\n                          \"</httpd:stickysession>\\n\", NULL);\n                ap_rprintf(r,\n                           \"      <httpd:nofailover>%s</httpd:nofailover>\\n\",\n                           (balancer->s->sticky_force ? \"On\" : \"Off\"));\n            }\n            ap_rprintf(r,\n                       \"      <httpd:timeout>%\" APR_TIME_T_FMT \"</httpd:timeout>\\n\",\n                       apr_time_sec(balancer->s->timeout));\n            if (balancer->s->max_attempts_set) {\n                ap_rprintf(r,\n                           \"      <httpd:maxattempts>%d</httpd:maxattempts>\\n\",\n                           balancer->s->max_attempts);\n            }\n            ap_rvputs(r, \"      <httpd:lbmethod>\", balancer->lbmethod->name,\n                      \"</httpd:lbmethod>\\n\", NULL);\n            if (*balancer->s->sticky) {\n                ap_rprintf(r,\n                           \"      <httpd:scolonpathdelim>%s</httpd:scolonpathdelim>\\n\",\n                           (balancer->s->scolonsep ? \"On\" : \"Off\"));\n            }\n            \n            ap_rputs(\"      <httpd:workers>\\n\", r);\n            workers = (proxy_worker **)balancer->workers->elts;\n            for (n = 0; n < balancer->workers->nelts; n++) {\n                worker = *workers;\n                \n                ap_rputs(\"        <httpd:worker>\\n\", r);\n                ap_rvputs(r, \"          <httpd:name>\", ap_proxy_worker_name(r->pool, worker),\n                          \"</httpd:name>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:scheme>\", worker->s->scheme,\n                          \"</httpd:scheme>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:hostname>\", worker->s->hostname_ex,\n                          \"</httpd:hostname>\\n\", NULL);\n                ap_rprintf(r, \"          <httpd:loadfactor>%.2f</httpd:loadfactor>\\n\",\n                          (float)(worker->s->lbfactor)/100.0);\n                ap_rprintf(r,\n                           \"          <httpd:port>%d</httpd:port>\\n\",\n                           worker->s->port);\n                ap_rprintf(r, \"          <httpd:min>%d</httpd:min>\\n\",\n                           worker->s->min);\n                ap_rprintf(r, \"          <httpd:smax>%d</httpd:smax>\\n\",\n                           worker->s->smax);\n                ap_rprintf(r, \"          <httpd:max>%d</httpd:max>\\n\",\n                           worker->s->hmax);\n                ap_rprintf(r,\n                           \"          <httpd:ttl>%\" APR_TIME_T_FMT \"</httpd:ttl>\\n\",\n                           apr_time_sec(worker->s->ttl));\n                if (worker->s->timeout_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:timeout>%\" APR_TIME_T_FMT \"</httpd:timeout>\\n\",\n                               apr_time_sec(worker->s->timeout));\n                }\n                if (worker->s->acquire_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:acquire>%\" APR_TIME_T_FMT \"</httpd:acquire>\\n\",\n                               apr_time_msec(worker->s->acquire));\n                }\n                if (worker->s->recv_buffer_size_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:recv_buffer_size>%\" APR_SIZE_T_FMT \"</httpd:recv_buffer_size>\\n\",\n                               worker->s->recv_buffer_size);\n                }\n                if (worker->s->io_buffer_size_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:io_buffer_size>%\" APR_SIZE_T_FMT \"</httpd:io_buffer_size>\\n\",\n                               worker->s->io_buffer_size);\n                }\n                if (worker->s->keepalive_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:keepalive>%s</httpd:keepalive>\\n\",\n                               (worker->s->keepalive ? \"On\" : \"Off\"));\n                }\n                \n                ap_rputs(\"          <httpd:status>\", r);\n                ap_rputs(ap_proxy_parse_wstatus(r->pool, worker), r);\n                ap_rputs(\"</httpd:status>\\n\", r);\n                if ((worker->s->error_time > 0) && apr_rfc822_date(date, worker->s->error_time) == APR_SUCCESS) {\n                    ap_rvputs(r, \"          <httpd:error_time>\", date,\n                              \"</httpd:error_time>\\n\", NULL);\n                }\n                ap_rprintf(r,\n                           \"          <httpd:retries>%d</httpd:retries>\\n\",\n                           worker->s->retries);\n                ap_rprintf(r,\n                           \"          <httpd:lbstatus>%d</httpd:lbstatus>\\n\",\n                           worker->s->lbstatus);\n                ap_rprintf(r,\n                           \"          <httpd:loadfactor>%.2f</httpd:loadfactor>\\n\",\n                           (float)(worker->s->lbfactor)/100.0);\n                ap_rprintf(r,\n                           \"          <httpd:transferred>%\" APR_OFF_T_FMT \"</httpd:transferred>\\n\",\n                           worker->s->transferred);\n                ap_rprintf(r,\n                           \"          <httpd:read>%\" APR_OFF_T_FMT \"</httpd:read>\\n\",\n                           worker->s->read);\n                ap_rprintf(r,\n                           \"          <httpd:elected>%\" APR_SIZE_T_FMT \"</httpd:elected>\\n\",\n                           worker->s->elected);\n                ap_rvputs(r, \"          <httpd:route>\",\n                          ap_escape_html(r->pool, worker->s->route),\n                          \"</httpd:route>\\n\", NULL);\n                ap_rvputs(r, \"          <httpd:redirect>\",\n                          ap_escape_html(r->pool, worker->s->redirect),\n                          \"</httpd:redirect>\\n\", NULL);\n                ap_rprintf(r,\n                           \"          <httpd:busy>%\" APR_SIZE_T_FMT \"</httpd:busy>\\n\",\n                           worker->s->busy);\n                ap_rprintf(r, \"          <httpd:lbset>%d</httpd:lbset>\\n\",\n                           worker->s->lbset);\n                \n                if (!ap_cstr_casecmp(worker->s->scheme, \"ajp\")) {\n                    ap_rputs(\"          <httpd:flushpackets>\", r);\n                    switch (worker->s->flush_packets) {\n                        case flush_off:\n                            ap_rputs(\"Off\", r);\n                            break;\n                        case flush_on:\n                            ap_rputs(\"On\", r);\n                            break;\n                        case flush_auto:\n                            ap_rputs(\"Auto\", r);\n                            break;\n                    }\n                    ap_rputs(\"</httpd:flushpackets>\\n\", r);\n                    if (worker->s->flush_packets == flush_auto) {\n                        ap_rprintf(r,\n                                   \"          <httpd:flushwait>%d</httpd:flushwait>\\n\",\n                                   worker->s->flush_wait);\n                    }\n                    if (worker->s->ping_timeout_set) {\n                        ap_rprintf(r,\n                                   \"          <httpd:ping>%\" APR_TIME_T_FMT \"</httpd:ping>\",\n                                   apr_time_msec(worker->s->ping_timeout));\n                    }\n                }\n                if (worker->s->disablereuse_set) {\n                    ap_rprintf(r,\n                               \"      <httpd:disablereuse>%s</httpd:disablereuse>\\n\",\n                               (worker->s->disablereuse ? \"On\" : \"Off\"));\n                }\n                if (worker->s->conn_timeout_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:connectiontimeout>%\" APR_TIME_T_FMT \"</httpd:connectiontimeout>\\n\",\n                               apr_time_msec(worker->s->conn_timeout));\n                }\n                if (worker->s->retry_set) {\n                    ap_rprintf(r,\n                               \"          <httpd:retry>%\" APR_TIME_T_FMT \"</httpd:retry>\\n\",\n                               apr_time_sec(worker->s->retry));\n                }\n                ap_rputs(\"        </httpd:worker>\\n\", r);\n                ++workers;\n            }\n            ap_rputs(\"      </httpd:workers>\\n\", r);\n            ap_rputs(\"    </httpd:balancer>\\n\", r);\n            ++balancer;\n        }\n        ap_rputs(\"  </httpd:balancers>\\n\", r);\n        ap_rputs(\"</httpd:manager>\", r);\n    }\n    else {\n        ap_set_content_type(r, \"text/html; charset=ISO-8859-1\");\n        ap_rputs(DOCTYPE_HTML_3_2\n                 \"<html><head><title>Balancer Manager</title>\\n\", r);\n        ap_rputs(\"<style type='text/css'>\\n\"\n                 \"table {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" border-spacing: 3px;\\n\"\n                 \" border-style: solid;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" border-collapse: collapse;\\n\"\n                 \" background-color: white;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"th {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" padding: 2px;\\n\"\n                 \" border-style: dotted;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" background-color: lightgray;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"td {\\n\"\n                 \" border-width: 1px;\\n\"\n                 \" padding: 2px;\\n\"\n                 \" border-style: dotted;\\n\"\n                 \" border-color: gray;\\n\"\n                 \" background-color: white;\\n\"\n                 \" text-align: center;\\n\"\n                 \"}\\n\"\n                 \"</style>\\n</head>\\n\", r);\n        ap_rputs(\"<body><h1>Load Balancer Manager for \", r);\n        ap_rvputs(r, ap_escape_html(r->pool, ap_get_server_name(r)),\n                  \"</h1>\\n\\n\", NULL);\n        ap_rvputs(r, \"<dl><dt>Server Version: \",\n                  ap_get_server_description(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Server Built: \",\n                  ap_get_server_built(), \"</dt>\\n\", NULL);\n        ap_rvputs(r, \"<dt>Balancer changes will \", conf->bal_persist ? \"\" : \"NOT \",\n                  \"be persisted on restart.</dt>\", NULL);\n        ap_rvputs(r, \"<dt>Balancers are \", conf->inherit ? \"\" : \"NOT \",\n                  \"inherited from main server.</dt>\", NULL);\n        ap_rvputs(r, \"<dt>ProxyPass settings are \", conf->ppinherit ? \"\" : \"NOT \",\n                  \"inherited from main server.</dt>\", NULL);\n        ap_rputs(\"</dl>\\n\", r);\n        balancer = (proxy_balancer *)conf->balancers->elts;\n        for (i = 0; i < conf->balancers->nelts; i++) {\n\n            ap_rputs(\"<hr />\\n<h3>LoadBalancer Status for \", r);\n            ap_rvputs(r, \"<a href='\", ap_escape_uri(r->pool, r->uri), \"?b=\",\n                      balancer->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"&amp;nonce=\", balancer->s->nonce,\n                      \"'>\", NULL);\n            ap_rvputs(r, balancer->s->name, \"</a> [\",balancer->s->sname, \"]</h3>\\n\", NULL);\n            ap_rputs(\"\\n\\n<table><tr>\"\n                \"<th>MaxMembers</th><th>StickySession</th><th>DisableFailover</th><th>Timeout</th><th>FailoverAttempts</th><th>Method</th>\"\n                \"<th>Path</th><th>Active</th></tr>\\n<tr>\", r);\n            /* the below is a safe cast, since the number of slots total will\n             * never be more than max_workers, which is restricted to int */\n            ap_rprintf(r, \"<td>%d [%d Used]</td>\\n\", balancer->max_workers,\n                       balancer->max_workers - (int)storage->num_free_slots(balancer->wslot));\n            if (*balancer->s->sticky) {\n                if (strcmp(balancer->s->sticky, balancer->s->sticky_path)) {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, \" | \",\n                              balancer->s->sticky_path, NULL);\n                }\n                else {\n                    ap_rvputs(r, \"<td>\", balancer->s->sticky, NULL);\n                }\n            }\n            else {\n                ap_rputs(\"<td> (None) \", r);\n            }\n            ap_rprintf(r, \"</td><td>%s</td>\\n\",\n                       balancer->s->sticky_force ? \"On\" : \"Off\");\n            ap_rprintf(r, \"<td>%\" APR_TIME_T_FMT \"</td>\",\n                apr_time_sec(balancer->s->timeout));\n            ap_rprintf(r, \"<td>%d</td>\\n\", balancer->s->max_attempts);\n            ap_rprintf(r, \"<td>%s</td>\\n\",\n                       balancer->s->lbpname);\n            ap_rputs(\"<td>\", r);\n            if (*balancer->s->vhost) {\n                ap_rvputs(r, balancer->s->vhost, \" -> \", NULL);\n            }\n            ap_rvputs(r, balancer->s->vpath, \"</td>\\n\", NULL);\n            ap_rprintf(r, \"<td>%s</td>\\n\",\n                       !balancer->s->inactive ? \"Yes\" : \"No\");\n            ap_rputs(\"</table>\\n<br />\", r);\n            ap_rputs(\"\\n\\n<table><tr>\"\n                \"<th>Worker URL</th>\"\n                \"<th>Route</th><th>RouteRedir</th>\"\n                \"<th>Factor</th><th>Set</th><th>Status</th>\"\n                \"<th>Elected</th><th>Busy</th><th>Load</th><th>To</th><th>From</th>\", r);\n            if (set_worker_hc_param_f) {\n                ap_rputs(\"<th>HC Method</th><th>HC Interval</th><th>Passes</th><th>Fails</th><th>HC uri</th><th>HC Expr</th>\", r);\n            }\n            ap_rputs(\"</tr>\\n\", r);\n\n            workers = (proxy_worker **)balancer->workers->elts;\n            for (n = 0; n < balancer->workers->nelts; n++) {\n                char fbuf[50];\n                worker = *workers;\n                ap_rvputs(r, \"<tr>\\n<td><a href='\",\n                          ap_escape_uri(r->pool, r->uri), \"?b=\",\n                          balancer->s->name + sizeof(BALANCER_PREFIX) - 1, \"&amp;w=\",\n                          ap_escape_uri(r->pool, worker->s->name),\n                          \"&amp;nonce=\", balancer->s->nonce,\n                          \"'>\", NULL);\n                ap_rvputs(r, (*worker->s->uds_path ? \"<i>\" : \"\"), ap_proxy_worker_name(r->pool, worker),\n                          (*worker->s->uds_path ? \"</i>\" : \"\"), \"</a></td>\", NULL);\n                ap_rvputs(r, \"<td>\", ap_escape_html(r->pool, worker->s->route),\n                          NULL);\n                ap_rvputs(r, \"</td><td>\",\n                          ap_escape_html(r->pool, worker->s->redirect), NULL);\n                ap_rprintf(r, \"</td><td>%.2f</td>\", (float)(worker->s->lbfactor)/100.0);\n                ap_rprintf(r, \"<td>%d</td><td>\", worker->s->lbset);\n                ap_rvputs(r, ap_proxy_parse_wstatus(r->pool, worker), NULL);\n                ap_rputs(\"</td>\", r);\n                ap_rprintf(r, \"<td>%\" APR_SIZE_T_FMT \"</td>\", worker->s->elected);\n                ap_rprintf(r, \"<td>%\" APR_SIZE_T_FMT \"</td>\", worker->s->busy);\n                ap_rprintf(r, \"<td>%d</td><td>\", worker->s->lbstatus);\n                ap_rputs(apr_strfsize(worker->s->transferred, fbuf), r);\n                ap_rputs(\"</td><td>\", r);\n                ap_rputs(apr_strfsize(worker->s->read, fbuf), r);\n                if (set_worker_hc_param_f) {\n                    ap_rprintf(r, \"</td><td>%s</td>\", ap_proxy_show_hcmethod(worker->s->method));\n                    ap_rprintf(r, \"<td>%\" APR_TIME_T_FMT \"ms</td>\", apr_time_as_msec(worker->s->interval));\n                    ap_rprintf(r, \"<td>%d (%d)</td>\", worker->s->passes,worker->s->pcount);\n                    ap_rprintf(r, \"<td>%d (%d)</td>\", worker->s->fails, worker->s->fcount);\n                    ap_rprintf(r, \"<td>%s</td>\", worker->s->hcuri);\n                    ap_rprintf(r, \"<td>%s\", worker->s->hcexpr);\n                }\n                ap_rputs(\"</td></tr>\\n\", r);\n\n                ++workers;\n            }\n            ap_rputs(\"</table>\\n\", r);\n            ++balancer;\n        }\n        ap_rputs(\"<hr />\\n\", r);\n        if (hc_show_exprs_f) {\n            hc_show_exprs_f(r);\n        }\n        if (wsel && bsel) {\n            ap_rputs(\"<h3>Edit worker settings for \", r);\n            ap_rvputs(r, (*wsel->s->uds_path?\"<i>\":\"\"), ap_proxy_worker_name(r->pool, wsel), (*wsel->s->uds_path?\"</i>\":\"\"), \"</h3>\\n\", NULL);\n            ap_rputs(\"<form method='POST' enctype='application/x-www-form-urlencoded' action='\", r);\n            ap_rvputs(r, ap_escape_uri(r->pool, action), \"'>\\n\", NULL);\n            ap_rputs(\"<table><tr><td>Load factor:</td><td><input name='w_lf' id='w_lf' type=text \", r);\n            ap_rprintf(r, \"value='%.2f'></td></tr>\\n\", (float)(wsel->s->lbfactor)/100.0);\n            ap_rputs(\"<tr><td>LB Set:</td><td><input name='w_ls' id='w_ls' type=text \", r);\n            ap_rprintf(r, \"value='%d'></td></tr>\\n\", wsel->s->lbset);\n            ap_rputs(\"<tr><td>Route:</td><td><input name='w_wr' id='w_wr' type=text \", r);\n            ap_rvputs(r, \"value='\", ap_escape_html(r->pool, wsel->s->route),\n                      NULL);\n            ap_rputs(\"'></td></tr>\\n\", r);\n            ap_rputs(\"<tr><td>Route Redirect:</td><td><input name='w_rr' id='w_rr' type=text \", r);\n            ap_rvputs(r, \"value='\", ap_escape_html(r->pool, wsel->s->redirect),\n                      NULL);\n            ap_rputs(\"'></td></tr>\\n\", r);\n            ap_rputs(\"<tr><td>Status:</td>\", r);\n            ap_rputs(\"<td><table><tr>\"\n                     \"<th>Ignore Errors</th>\"\n                     \"<th>Draining Mode</th>\"\n                     \"<th>Disabled</th>\"\n                     \"<th>Hot Standby</th>\"\n                     \"<th>Hot Spare</th>\", r);\n            if (hc_show_exprs_f) {\n                ap_rputs(\"<th>HC Fail</th>\", r);\n            }\n            ap_rputs(\"<th>Stopped</th></tr>\\n<tr>\", r);\n            create_radio(\"w_status_I\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_IGNORE_ERRORS)), r);\n            create_radio(\"w_status_N\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_DRAIN)), r);\n            create_radio(\"w_status_D\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_DISABLED)), r);\n            create_radio(\"w_status_H\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_HOT_STANDBY)), r);\n            create_radio(\"w_status_R\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_HOT_SPARE)), r);\n            if (hc_show_exprs_f) {\n                create_radio(\"w_status_C\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_HC_FAIL)), r);\n            }\n            create_radio(\"w_status_S\", (PROXY_WORKER_IS(wsel, PROXY_WORKER_STOPPED)), r);\n            ap_rputs(\"</tr></table></td></tr>\\n\", r);\n            if (hc_select_exprs_f) {\n                proxy_hcmethods_t *method = proxy_hcmethods;\n                ap_rputs(\"<tr><td colspan='2'>\\n<table align='center'><tr><th>Health Check param</th><th>Value</th></tr>\\n\", r);\n                ap_rputs(\"<tr><td>Method</td><td><select name='w_hm'>\\n\", r);\n                for (; method->name; method++) {\n                    if (method->implemented) {\n                        ap_rprintf(r, \"<option value='%s' %s >%s</option>\\n\",\n                                method->name,\n                                (wsel->s->method == method->method) ? \"selected\" : \"\",\n                                method->name);\n                    }\n                }\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n                ap_rputs(\"<tr><td>Expr</td><td><select name='w_he'>\\n\", r);\n                hc_select_exprs_f(r, wsel->s->hcexpr);\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n                ap_rprintf(r, \"<tr><td>Interval (ms)</td><td><input name='w_hi' id='w_hi' type='text'\"\n                           \"value='%\" APR_TIME_T_FMT \"'></td></tr>\\n\", apr_time_as_msec(wsel->s->interval));\n                ap_rprintf(r, \"<tr><td>Passes trigger</td><td><input name='w_hp' id='w_hp' type='text'\"\n                           \"value='%d'></td></tr>\\n\", wsel->s->passes);\n                ap_rprintf(r, \"<tr><td>Fails trigger)</td><td><input name='w_hf' id='w_hf' type='text'\"\n                           \"value='%d'></td></tr>\\n\", wsel->s->fails);\n                ap_rprintf(r, \"<tr><td>HC uri</td><td><input name='w_hu' id='w_hu' type='text'\"\n                           \"value='%s'></td></tr>\\n\", ap_escape_html(r->pool, wsel->s->hcuri));\n                ap_rputs(\"</table>\\n</td></tr>\\n\", r);\n            }\n            ap_rputs(\"<tr><td colspan='2'><input type=submit value='Submit'></td></tr>\\n\", r);\n            ap_rvputs(r, \"</table>\\n<input type=hidden name='w' id='w' \",  NULL);\n            ap_rvputs(r, \"value='\", ap_escape_uri(r->pool, wsel->s->name), \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='b' id='b' \", NULL);\n            ap_rvputs(r, \"value='\", bsel->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='nonce' id='nonce' value='\",\n                      bsel->s->nonce, \"'>\\n\", NULL);\n            ap_rputs(\"</form>\\n\", r);\n            ap_rputs(\"<hr />\\n\", r);\n        } else if (bsel) {\n            const apr_array_header_t *provs;\n            const ap_list_provider_names_t *pname;\n            int i;\n            ap_rputs(\"<h3>Edit balancer settings for \", r);\n            ap_rvputs(r, bsel->s->name, \"</h3>\\n\", NULL);\n            ap_rputs(\"<form method='POST' enctype='application/x-www-form-urlencoded' action='\", r);\n            ap_rvputs(r, ap_escape_uri(r->pool, action), \"'>\\n\", NULL);\n            ap_rputs(\"<table>\\n\", r);\n            provs = ap_list_provider_names(r->pool, PROXY_LBMETHOD, \"0\");\n            if (provs) {\n                ap_rputs(\"<tr><td>LBmethod:</td>\", r);\n                ap_rputs(\"<td>\\n<select name='b_lbm' id='b_lbm'>\", r);\n                pname = (ap_list_provider_names_t *)provs->elts;\n                for (i = 0; i < provs->nelts; i++, pname++) {\n                    ap_rvputs(r,\"<option value='\", pname->provider_name, \"'\", NULL);\n                    if (strcmp(pname->provider_name, bsel->s->lbpname) == 0)\n                        ap_rputs(\" selected \", r);\n                    ap_rvputs(r, \">\", pname->provider_name, \"\\n\", NULL);\n                }\n                ap_rputs(\"</select>\\n</td></tr>\\n\", r);\n            }\n            ap_rputs(\"<tr><td>Timeout:</td><td><input name='b_tmo' id='b_tmo' type=text \", r);\n            ap_rprintf(r, \"value='%\" APR_TIME_T_FMT \"'></td></tr>\\n\", apr_time_sec(bsel->s->timeout));\n            ap_rputs(\"<tr><td>Failover Attempts:</td><td><input name='b_max' id='b_max' type=text \", r);\n            ap_rprintf(r, \"value='%d'></td></tr>\\n\", bsel->s->max_attempts);\n            ap_rputs(\"<tr><td>Disable Failover:</td>\", r);\n            create_radio(\"b_sforce\", bsel->s->sticky_force, r);\n            ap_rputs(\"</tr>\\n\", r);\n            ap_rputs(\"<tr><td>Sticky Session:</td><td><input name='b_ss' id='b_ss' size=64 type=text \", r);\n            if (strcmp(bsel->s->sticky, bsel->s->sticky_path)) {\n                ap_rvputs(r, \"value ='\", bsel->s->sticky, \" | \",\n                          bsel->s->sticky_path, NULL);\n            }\n            else {\n                ap_rvputs(r, \"value ='\", bsel->s->sticky, NULL);\n            }\n            ap_rputs(\"'>&nbsp;&nbsp;&nbsp;&nbsp;(Use '-' to delete)</td></tr>\\n\", r);\n            if (storage->num_free_slots(bsel->wslot) != 0) {\n                ap_rputs(\"<tr><td>Add New Worker:</td><td><input name='b_nwrkr' id='b_nwrkr' size=32 type=text>\"\n                         \"&nbsp;&nbsp;&nbsp;&nbsp;Are you sure? <input name='b_wyes' id='b_wyes' type=checkbox value='1'>\"\n                         \"</td></tr>\", r);\n            }\n            ap_rputs(\"<tr><td colspan=2><input type=submit value='Submit'></td></tr>\\n\", r);\n            ap_rvputs(r, \"</table>\\n<input type=hidden name='b' id='b' \", NULL);\n            ap_rvputs(r, \"value='\", bsel->s->name + sizeof(BALANCER_PREFIX) - 1,\n                      \"'>\\n\", NULL);\n            ap_rvputs(r, \"<input type=hidden name='nonce' id='nonce' value='\",\n                      bsel->s->nonce, \"'>\\n\", NULL);\n            ap_rputs(\"</form>\\n\", r);\n            ap_rputs(\"<hr />\\n\", r);\n        }\n        ap_rputs(ap_psignature(\"\",r), r);\n        ap_rputs(\"</body></html>\\n\", r);\n        ap_rflush(r);\n    }\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_d799511c50e37e077e2f435805084c5b59f7874d_0", {
    "ID": "httpd_d799511c50e37e077e2f435805084c5b59f7874d_0",
    "UID": "8225",
    "code": "static const char test_snippet\n    add_pass(cmd_parms test_snippetcmd, void test_snippetdummy, const char test_snippetarg, int is_regex)\n{\n    proxy_dir_conf test_snippetdconf = (proxy_dir_conf test_snippet)dummy;\n    server_rec test_snippets = cmd->server;\n    proxy_server_conf test_snippetconf =\n    (proxy_server_conf test_snippet) ap_get_module_config(s->module_config, &proxy_module);\n    struct proxy_alias test_snippetnew;\n    char test_snippetf = cmd->path;\n    char test_snippetr = NULL;\n    char test_snippetword;\n    apr_table_t test_snippetparams = apr_table_make(cmd->pool, 5);\n    const apr_array_header_t test_snippetarr;\n    const apr_table_entry_t test_snippetelts;\n    int i;\n    int use_regex = is_regex;\n    unsigned int flags = 0;\n    const char test_snippeterr;\n\n    err = ap_check_cmd_context(cmd, NOT_IN_DIRECTORY|NOT_IN_FILES);\n    if (err) {\n        return err;\n    }\n\n    while (test_snippetarg) {\n        word = ap_getword_conf(cmd->pool, &arg);\n        if (!f) {\n            if (!strcmp(word, \"~\")) {\n                if (is_regex) {\n                    return \"ProxyPassMatch invalid syntax ('~' usage).\";\n                }\n                use_regex = 1;\n                continue;\n            }\n            f = word;\n        }\n        else if (!r) {\n            r = word;\n        }\n        else if (!strcasecmp(word,\"nocanon\")) {\n            flags |= PROXYPASS_NOCANON;\n        }\n        else if (!strcasecmp(word,\"interpolate\")) {\n            flags |= PROXYPASS_INTERPOLATE;\n        }\n        else if (!strcasecmp(word,\"noquery\")) {\n            flags |= PROXYPASS_NOQUERY;\n        }\n        else {\n            char test_snippetval = strchr(word, '=');\n            if (!val) {\n                if (cmd->path) {\n                    if (test_snippetr == '/') {\n                        return \"ProxyPass|ProxyPassMatch can not have a path when defined in \"\n                               \"a location.\";\n                    }\n                    else {\n                        return \"Invalid ProxyPass|ProxyPassMatch parameter. Parameter must \"\n                               \"be in the form 'key=value'.\";\n                    }\n                }\n                else {\n                    return \"Invalid ProxyPass|ProxyPassMatch parameter. Parameter must be \"\n                           \"in the form 'key=value'.\";\n                }\n            }\n            else\n                test_snippetval++ = '\\0';\n            apr_table_setn(params, word, val);\n        }\n    };\n\n    if (r == NULL) {\n        return \"ProxyPass|ProxyPassMatch needs a path when not defined in a location\";\n    }\n\n    /test_snippet if per directory, save away the single alias test_snippet/\n    if (cmd->path) {\n        dconf->alias = apr_pcalloc(cmd->pool, sizeof(struct proxy_alias));\n        dconf->alias_set = 1;\n        new = dconf->alias;\n        if (apr_fnmatch_test(f)) {\n            use_regex = 1;\n        }\n    }\n    /test_snippet if per server, add to the alias array test_snippet/\n    else {\n        new = apr_array_push(conf->aliases);\n    }\n\n    new->fake = apr_pstrdup(cmd->pool, f);\n    new->real = apr_pstrdup(cmd->pool, de_socketfy(cmd->pool, r));\n    new->flags = flags;\n    if (use_regex) {\n        new->regex = ap_pregcomp(cmd->pool, f, AP_REG_EXTENDED);\n        if (new->regex == NULL)\n            return \"Regular expression could not be compiled.\";\n    }\n    else {\n        new->regex = NULL;\n    }\n\n    if (r[0] == '!' && r[1] == '\\0')\n        return NULL;\n\n    arr = apr_table_elts(params);\n    elts = (const apr_table_entry_t test_snippet)arr->elts;\n    /test_snippet Distinguish the balancer from worker test_snippet/\n    if (ap_proxy_valid_balancer_name(r, 9)) {\n        proxy_balancer test_snippetbalancer = ap_proxy_get_balancer(cmd->pool, conf, r, 0);\n        char test_snippetfake_copy;\n\n        /test_snippet\n         test_snippet In the regex case supplying a fake URL doesn't make sense as it\n         test_snippet cannot be parsed anyway with apr_uri_parse later on in\n         test_snippet ap_proxy_define_balancer / ap_proxy_update_balancer\n         test_snippet/\n        if (use_regex) {\n            fake_copy = NULL;\n        }\n        else {\n            fake_copy = f;\n        }\n        if (!balancer) {\n            const char test_snippeterr = ap_proxy_define_balancer(cmd->pool, &balancer, conf, r, fake_copy, 0);\n            if (err)\n                return apr_pstrcat(cmd->temp_pool, \"ProxyPass \", err, NULL);\n        }\n        else {\n            ap_proxy_update_balancer(cmd->pool, balancer, fake_copy);\n        }\n        for (i = 0; i < arr->nelts; i++) {\n            const char test_snippeterr = set_balancer_param(conf, cmd->pool, balancer, elts[i].key,\n                                                 elts[i].val);\n            if (err)\n                return apr_pstrcat(cmd->temp_pool, \"ProxyPass \", err, NULL);\n        }\n        new->balancer = balancer;\n    }\n    else {\n        proxy_worker test_snippetworker = ap_proxy_get_worker(cmd->temp_pool, NULL, conf, de_socketfy(cmd->pool, r));\n        int reuse = 0;\n        if (!worker) {\n            const char test_snippeterr = ap_proxy_define_worker(cmd->pool, &worker, NULL, conf, r, 0);\n            if (err)\n                return apr_pstrcat(cmd->temp_pool, \"ProxyPass \", err, NULL);\n\n            PROXY_COPY_CONF_PARAMS(worker, conf);\n        } else {\n            reuse = 1;\n            ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server, APLOGNO(01145)\n                         \"Sharing worker '%s' instead of creating new worker '%s'\",\n                         ap_proxy_worker_name(cmd->pool, worker), new->real);\n        }\n\n        for (i = 0; i < arr->nelts; i++) {\n            if (reuse) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(01146)\n                             \"Ignoring parameter '%s=%s' for worker '%s' because of worker sharing\",\n                             elts[i].key, elts[i].val, ap_proxy_worker_name(cmd->pool, worker));\n            } else {\n                const char test_snippeterr = set_worker_param(cmd->pool, worker, elts[i].key,\n                                                   elts[i].val);\n                if (err)\n                    return apr_pstrcat(cmd->temp_pool, \"ProxyPass \", err, NULL);\n            }\n        }\n    }\n    return NULL;\n}",
    "predicted": "546,Suspicious Comment\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_f4263d14ac1baa4b5075428cc35541c1b08c8e7d_0", {
    "ID": "httpd_f4263d14ac1baa4b5075428cc35541c1b08c8e7d_0",
    "UID": "8243",
    "code": "static int ap_proxy_ajp_request(apr_pool_t *p, request_rec test_snippet\n                                proxy_conn_rec *conn,\n                                conn_rec *origin,\n                                proxy_dir_conf *conf,\n                                apr_uri_t *uri,\n                                char *url, char *server_portstr)\n{\n    apr_status_t status;\n    int result;\n    apr_bucket *e;\n    apr_bucket_brigade *input_brigade;\n    apr_bucket_brigade *output_brigade;\n    ajp_msg_t *msg;\n    apr_size_t bufsiz = 0;\n    char *buff;\n    char *send_body_chunk_buff;\n    apr_uint16_t size;\n    apr_byte_t conn_reuse = 0;\n    const char *tenc;\n    int havebody = 1;\n    int client_failed = 0;\n    int backend_failed = 0;\n    apr_off_t bb_len;\n    int data_sent = 0;\n    int request_ended = 0;\n    int headers_sent = 0;\n    int rv = OK;\n    apr_int32_t conn_poll_fd;\n    apr_pollfd_t *conn_poll;\n    proxy_server_conf *psf =\n    ap_get_module_config(r->server->module_config, &proxy_module);\n    apr_size_t maxsize = AJP_MSG_BUFFER_SZ;\n    int send_body = 0;\n    apr_off_t content_length = 0;\n    int original_status = r->status;\n    const char *original_status_line = r->status_line;\n    const char *secret = NULL;\n\n    if (psf->io_buffer_size_set)\n       maxsize = psf->io_buffer_size;\n    if (maxsize > AJP_MAX_BUFFER_SZ)\n       maxsize = AJP_MAX_BUFFER_SZ;\n    else if (maxsize < AJP_MSG_BUFFER_SZ)\n       maxsize = AJP_MSG_BUFFER_SZ;\n    maxsize = APR_ALIGN(maxsize, 1024);\n\n    if (*conn->worker->s->secret)\n        secret = conn->worker->s->secret;\n\n    /*\n     * Send the AJP request to the remote server\n     */\n\n    \n    status = ajp_send_header(conn->sock, r, maxsize, uri, secret);\n    if (status != APR_SUCCESS) {\n        conn->close = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00868)\n                      \"request failed to %pI (%s)\",\n                      conn->worker->cp->addr,\n                      conn->worker->s->hostname);\n        if (status == AJP_EOVERFLOW)\n            return HTTP_BAD_REQUEST;\n        else {\n            /*\n             * This is only non fatal when the method is idempotent. In this\n             * case we can dare to retry it with a different worker if we are\n             * a balancer member.\n             */\n            if (is_idempotent(r) == METHOD_IDEMPOTENT) {\n                return HTTP_SERVICE_UNAVAILABLE;\n            }\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n\n    \n    bufsiz = maxsize;\n    status = ajp_alloc_data_msg(r->pool, &buff, &bufsiz, &msg);\n    if (status != APR_SUCCESS) {\n        \n        conn->close = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00869)\n                      \"ajp_alloc_data_msg failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    \n    input_brigade = apr_brigade_create(p, r->connection->bucket_alloc);\n    tenc = apr_table_get(r->headers_in, \"Transfer-Encoding\");\n    if (tenc && (ap_casecmpstr(tenc, \"chunked\") == 0)) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870) \"request is chunked\");\n    } else {\n        \n        content_length = get_content_length(r);\n        status = ap_get_brigade(r->input_filters, input_brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                maxsize - AJP_HEADER_SZ);\n\n        if (status != APR_SUCCESS) {\n            \n            conn->close = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00871)\n                          \"ap_get_brigade failed\");\n            apr_brigade_destroy(input_brigade);\n            return ap_map_http_request_error(status, HTTP_BAD_REQUEST);\n        }\n\n        \n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00872) \"APR_BUCKET_IS_EOS\");\n        }\n\n        \n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00873)\n                      \"data to read (max %\" APR_SIZE_T_FMT\n                      \" at %\" APR_SIZE_T_FMT \")\", bufsiz, msg->pos);\n\n        status = apr_brigade_flatten(input_brigade, buff, &bufsiz);\n        if (status != APR_SUCCESS) {\n            \n            conn->close = 1;\n            apr_brigade_destroy(input_brigade);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00874)\n                          \"apr_brigade_flatten\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        apr_brigade_cleanup(input_brigade);\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00875)\n                      \"got %\" APR_SIZE_T_FMT \" bytes of data\", bufsiz);\n        if (bufsiz > 0) {\n            status = ajp_send_data_msg(conn->sock, msg, bufsiz);\n            ajp_msg_log(r, msg, \"First ajp_send_data_msg: ajp_ilink_send packet dump\");\n            if (status != APR_SUCCESS) {\n                \n                conn->close = 1;\n                apr_brigade_destroy(input_brigade);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00876)\n                              \"send failed to %pI (%s)\",\n                              conn->worker->cp->addr,\n                              conn->worker->s->hostname);\n                /*\n                 * It is fatal when we failed to send a (part) of the request\n                 * body.\n                 */\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n            conn->worker->s->transferred += bufsiz;\n            send_body = 1;\n        }\n        else if (content_length > 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00877)\n                          \"read zero bytes, expecting\"\n                          \" %\" APR_OFF_T_FMT \" bytes\",\n                          content_length);\n            /*\n             * We can only get here if the client closed the connection\n             * to us without sending the body.\n             * Now the connection is in the wrong state on the backend.\n             * Sending an empty data msg doesn't help either as it does\n             * not move this connection to the correct state on the backend\n             * for later resusage by the next request again.\n             * Close it to clean things up.\n             */\n            conn->close = 1;\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    \n    conn->data = NULL;\n    status = ajp_read_header(conn->sock, r, maxsize,\n                             (ajp_msg_t **)&(conn->data));\n    if (status != APR_SUCCESS) {\n        \n        conn->close = 1;\n        apr_brigade_destroy(input_brigade);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00878)\n                      \"read response failed from %pI (%s)\",\n                      conn->worker->cp->addr,\n                      conn->worker->s->hostname);\n\n        /* If we had a successful cping/cpong and then a timeout\n         * we assume it is a request that cause a back-end timeout,\n         * but doesn't affect the whole worker.\n         */\n        if (APR_STATUS_IS_TIMEUP(status) &&\n                conn->worker->s->ping_timeout_set) {\n            return HTTP_GATEWAY_TIME_OUT;\n        }\n\n        /*\n         * This is only non fatal when we have not sent (parts) of a possible\n         * request body so far (we do not store it and thus cannot send it\n         * again) and the method is idempotent. In this case we can dare to\n         * retry it with a different worker if we are a balancer member.\n         */\n        if (!send_body && (is_idempotent(r) == METHOD_IDEMPOTENT)) {\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    \n    result = ajp_parse_type(r, conn->data);\n    output_brigade = apr_brigade_create(p, r->connection->bucket_alloc);\n\n    /*\n     * Prepare apr_pollfd_t struct for possible later check if there is currently\n     * data available from the backend (do not flush response to client)\n     * or not (flush response to client)\n     */\n    conn_poll = apr_pcalloc(p, sizeof(apr_pollfd_t));\n    conn_poll->reqevents = APR_POLLIN;\n    conn_poll->desc_type = APR_POLL_SOCKET;\n    conn_poll->desc.s = conn->sock;\n\n    bufsiz = maxsize;\n    for (;;) {\n        switch (result) {\n            case CMD_AJP13_GET_BODY_CHUNK:\n                if (havebody) {\n                    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                        \n                        bufsiz = 0;\n                        havebody = 0;\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00879)\n                                      \"APR_BUCKET_IS_EOS\");\n                    } else {\n                        status = ap_get_brigade(r->input_filters, input_brigade,\n                                                AP_MODE_READBYTES,\n                                                APR_BLOCK_READ,\n                                                maxsize - AJP_HEADER_SZ);\n                        if (status != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00880)\n                                          \"ap_get_brigade failed\");\n                            if (APR_STATUS_IS_TIMEUP(status)) {\n                                rv = HTTP_REQUEST_TIME_OUT;\n                            }\n                            else if (status == AP_FILTER_ERROR) {\n                                rv = AP_FILTER_ERROR;\n                            }\n                            client_failed = 1;\n                            break;\n                        }\n                        bufsiz = maxsize;\n                        status = apr_brigade_flatten(input_brigade, buff,\n                                                     &bufsiz);\n                        apr_brigade_cleanup(input_brigade);\n                        if (status != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00881)\n                                         \"apr_brigade_flatten failed\");\n                            rv = HTTP_INTERNAL_SERVER_ERROR;\n                            client_failed = 1;\n                            break;\n                        }\n                    }\n\n                    ajp_msg_reset(msg);\n                    \n                    status = ajp_send_data_msg(conn->sock, msg, bufsiz);\n                    ajp_msg_log(r, msg, \"ajp_send_data_msg after CMD_AJP13_GET_BODY_CHUNK: ajp_ilink_send packet dump\");\n                    if (status != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00882)\n                                      \"ajp_send_data_msg failed\");\n                        backend_failed = 1;\n                        break;\n                    }\n                    conn->worker->s->transferred += bufsiz;\n                } else {\n                    /*\n                     * something is wrong TC asks for more body but we are\n                     * already at the end of the body data\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00883)\n                                  \"ap_proxy_ajp_request error read after end\");\n                    backend_failed = 1;\n                }\n                break;\n            case CMD_AJP13_SEND_HEADERS:\n                if (headers_sent) {\n                    /* Do not send anything to the client.\n                     * Backend already send us the headers.\n                     */\n                    backend_failed = 1;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00884)\n                                  \"Backend sent headers twice.\");\n                    break;\n                }\n                \n                status = ajp_parse_header(r, conf, conn->data);\n                if (status != APR_SUCCESS) {\n                    backend_failed = 1;\n                }\n                else if ((r->status == 401) && conf->error_override) {\n                    const char *buf;\n                    const char *wa = \"WWW-Authenticate\";\n                    if ((buf = apr_table_get(r->headers_out, wa))) {\n                        apr_table_set(r->err_headers_out, wa, buf);\n                    } else {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00885)\n                                      \"ap_proxy_ajp_request: origin server \"\n                                      \"sent 401 without WWW-Authenticate header\");\n                    }\n                }\n                headers_sent = 1;\n                break;\n            case CMD_AJP13_SEND_BODY_CHUNK:\n                \n                status = ajp_parse_data(r, conn->data, &size, &send_body_chunk_buff);\n                if (status == APR_SUCCESS) {\n                    /* If we are overriding the errors, we can't put the content\n                     * of the page into the brigade.\n                     */\n                    if (!conf->error_override || !ap_is_HTTP_ERROR(r->status)) {\n                        /* AJP13_SEND_BODY_CHUNK with zero length\n                         * is explicit flush message\n                         */\n                        if (size == 0) {\n                            if (headers_sent) {\n                                e = apr_bucket_flush_create(r->connection->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                            }\n                            else {\n                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00886)\n                                              \"Ignoring flush message \"\n                                              \"received before headers\");\n                            }\n                        }\n                        else {\n                            apr_status_t rv;\n\n                            /* Handle the case where the error document is itself reverse\n                             * proxied and was successful. We must maintain any previous\n                             * error status so that an underlying error (eg HTTP_NOT_FOUND)\n                             * doesn't become an HTTP_OK.\n                             */\n                            if (conf->error_override && !ap_is_HTTP_ERROR(r->status)\n                                    && ap_is_HTTP_ERROR(original_status)) {\n                                r->status = original_status;\n                                r->status_line = original_status_line;\n                            }\n\n                            e = apr_bucket_transient_create(send_body_chunk_buff, size,\n                                                        r->connection->bucket_alloc);\n                            APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n\n                            if ((conn->worker->s->flush_packets == flush_on) ||\n                                ((conn->worker->s->flush_packets == flush_auto) &&\n                                ((rv = apr_poll(conn_poll, 1, &conn_poll_fd,\n                                                 conn->worker->s->flush_wait))\n                                                 != APR_SUCCESS) &&\n                                  APR_STATUS_IS_TIMEUP(rv))) {\n                                e = apr_bucket_flush_create(r->connection->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                            }\n                            apr_brigade_length(output_brigade, 0, &bb_len);\n                            if (bb_len != -1)\n                                conn->worker->s->read += bb_len;\n                        }\n                        if (headers_sent) {\n                            if (ap_pass_brigade(r->output_filters,\n                                                output_brigade) != APR_SUCCESS) {\n                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00887)\n                                              \"error processing body.%s\",\n                                              r->connection->aborted ?\n                                              \" Client aborted connection.\" : \"\");\n                                client_failed = 1;\n                            }\n                            data_sent = 1;\n                            apr_brigade_cleanup(output_brigade);\n                        }\n                    }\n                }\n                else {\n                    backend_failed = 1;\n                }\n                break;\n            case CMD_AJP13_END_RESPONSE:\n                /* If we are overriding the errors, we must not send anything to\n                 * the client, especially as the brigade already contains headers.\n                 * So do nothing here, and it will be cleaned up below.\n                 */\n                status = ajp_parse_reuse(r, conn->data, &conn_reuse);\n                if (status != APR_SUCCESS) {\n                    backend_failed = 1;\n                }\n                if (!conf->error_override || !ap_is_HTTP_ERROR(r->status)) {\n                    e = apr_bucket_eos_create(r->connection->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                    if (ap_pass_brigade(r->output_filters,\n                                        output_brigade) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00888)\n                                      \"error processing end\");\n                        client_failed = 1;\n                    }\n                    \n                    data_sent = 1;\n                }\n                request_ended = 1;\n                break;\n            default:\n                backend_failed = 1;\n                break;\n        }\n\n        /*\n         * If connection has been aborted by client: Stop working.\n         * Pretend we are done (data_sent) to avoid further processing.\n         */\n        if (r->connection->aborted) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02821)\n                          \"client connection aborted\");\n            \n            if (!headers_sent) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            client_failed = 1;\n            \n            data_sent = 1;\n            break;\n        }\n\n        /*\n         * We either have finished successfully or we failed.\n         * So bail out\n         */\n        if ((result == CMD_AJP13_END_RESPONSE)\n                || backend_failed || client_failed)\n            break;\n\n        \n        status = ajp_read_header(conn->sock, r, maxsize,\n                                 (ajp_msg_t **)&(conn->data));\n        if (status != APR_SUCCESS) {\n            backend_failed = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00889)\n                          \"ajp_read_header failed\");\n            break;\n        }\n        result = ajp_parse_type(r, conn->data);\n    }\n    apr_brigade_destroy(input_brigade);\n\n    /*\n     * Clear output_brigade to remove possible buckets that remained there\n     * after an error.\n     */\n    apr_brigade_cleanup(output_brigade);\n\n    if (backend_failed || client_failed) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00890)\n                      \"Processing of request failed backend: %i, client: %i\",\n                      backend_failed, client_failed);\n        \n        conn->close = 1;\n        if (data_sent) {\n            \n            rv = DONE;\n        }\n    }\n    else if (!request_ended) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00891)\n                      \"Processing of request didn't terminate cleanly\");\n        \n        conn->close = 1;\n        backend_failed = 1;\n        if (data_sent) {\n            \n            rv = DONE;\n        }\n    }\n    else if (!conn_reuse) {\n        \n        conn->close = 1;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00892)\n                      \"got response from %pI (%s)\",\n                      conn->worker->cp->addr,\n                      conn->worker->s->hostname);\n\n        if (conf->error_override && ap_is_HTTP_ERROR(r->status)) {\n            /* clear r->status for override error, otherwise ErrorDocument\n             * thinks that this is a recursive error, and doesn't find the\n             * custom error page\n             */\n            rv = r->status;\n            r->status = HTTP_OK;\n            /*\n             * prevent proxy_handler() from treating this as an\n             * internal error.\n             */\n            apr_table_setn(r->notes, \"proxy-error-override\", \"1\");\n        }\n        else {\n            rv = OK;\n        }\n    }\n\n    if (backend_failed) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00893)\n                      \"dialog to %pI (%s) failed\",\n                      conn->worker->cp->addr,\n                      conn->worker->s->hostname);\n        /*\n         * If we already send data, signal a broken backend connection\n         * upwards in the chain.\n         */\n        if (data_sent) {\n            ap_proxy_backend_broke(r, output_brigade);\n        } else if (!send_body && (is_idempotent(r) == METHOD_IDEMPOTENT)) {\n            /*\n             * This is only non fatal when we have not send (parts) of a possible\n             * request body so far (we do not store it and thus cannot send it\n             * again) and the method is idempotent. In this case we can dare to\n             * retry it with a different worker if we are a balancer member.\n             */\n            rv = HTTP_SERVICE_UNAVAILABLE;\n        } else {\n            /* If we had a successful cping/cpong and then a timeout\n             * we assume it is a request that cause a back-end timeout,\n             * but doesn't affect the whole worker.\n             */\n            if (APR_STATUS_IS_TIMEUP(status) &&\n                    conn->worker->s->ping_timeout_set) {\n                apr_table_setn(r->notes, \"proxy_timedout\", \"1\");\n                rv = HTTP_GATEWAY_TIME_OUT;\n            }\n            else {\n                rv = HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n    }\n    else if (client_failed) {\n        int level = (r->connection->aborted) ? APLOG_DEBUG : APLOG_ERR;\n        ap_log_rerror(APLOG_MARK, level, status, r, APLOGNO(02822)\n                      \"dialog with client %pI failed\",\n                      r->connection->client_addr);\n        if (rv == OK) {\n            rv = HTTP_BAD_REQUEST;\n        }\n    }\n\n    /*\n     * Ensure that we sent an EOS bucket thru the filter chain, if we already\n     * have sent some data. Maybe ap_proxy_backend_broke was called and added\n     * one to the brigade already (no longer making it empty). So we should\n     * not do this in this case.\n     */\n    if (data_sent && !r->eos_sent && !r->connection->aborted\n            && APR_BRIGADE_EMPTY(output_brigade)) {\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n    }\n\n    \n    if (!APR_BRIGADE_EMPTY(output_brigade)\n        && ap_pass_brigade(r->output_filters, output_brigade) != APR_SUCCESS) {\n        rv = AP_FILTER_ERROR;\n    }\n\n    apr_brigade_destroy(output_brigade);\n\n    if (apr_table_get(r->subprocess_env, \"proxy-nokeepalive\")) {\n        conn->close = 1;\n    }\n\n    return rv;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8cd05c8e02521caabde3c4c104339dac076b9397_0", {
    "ID": "httpd_8cd05c8e02521caabde3c4c104339dac076b9397_0",
    "UID": "8291",
    "code": "static void close_listeners(int process_slot, int test_snippet\n{\n    if (!test_snippet {\n        int i;\n        worker_score *ws;\n        disable_listensocks(process_slot);\n        ap_close_listeners_ex(my_bucket->listeners);\n        *closed = 1;\n        dying = 1;\n        ap_scoreboard_image->parent[process_slot].quiescing = 1;\n        for (i = 0; i < threads_per_child; ++i) {\n            ws = ap_get_scoreboard_worker_from_indexes(process_slot, i);\n            if (ws->pid != ap_my_pid) {\n                \n                continue;\n            }\n            ap_update_child_status_from_indexes(process_slot, i,\n                                                SERVER_GRACEFUL, NULL);\n        }\n        \n        kill(ap_my_pid, SIGTERM);\n\n        ap_free_idle_pools(worker_queue_info);\n        ap_queue_interrupt_all(worker_queue);\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_7f7c3710fe9ac2f9c006757056a7e0273768714c_0", {
    "ID": "httpd_7f7c3710fe9ac2f9c006757056a7e0273768714c_0",
    "UID": "8321",
    "code": "static void ap_proxy_read_headers(request_rec *r, request_rec test_snippet\n                                  char *buffer, int size,\n                                  conn_rec *c, int *pread_len)\n{\n    int len;\n    char *value, *end;\n    int saw_headers = 0;\n    void *sconf = r->server->module_config;\n    proxy_server_conf *psc;\n    proxy_dir_conf *dconf;\n    apr_status_t rc;\n    apr_bucket_brigade *tmp_bb;\n\n    dconf = ap_get_module_config(r->per_dir_config, &proxy_module);\n    psc = (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);\n\n    r->headers_out = apr_table_make(r->pool, 20);\n    r->trailers_out = apr_table_make(r->pool, 5);\n    *pread_len = 0;\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), or we timeout.\n     */\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"Headers received from backend:\");\n\n    tmp_bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    while (1) {\n        rc = ap_proxygetline(tmp_bb, buffer, size, rr,\n                             AP_GETLINE_FOLD | AP_GETLINE_NOSPC_EOL, &len);\n\n        if (len <= 0)\n            break;\n\n        if (APR_STATUS_IS_ENOSPC(rc)) {\n            /* The header could not fit in the provided buffer, warn.\n             * XXX: falls through with the truncated header, 5xx instead?\n             */\n            int trunc = (len > 128 ? 128 : len) / 2;\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rc, r, APLOGNO(10124)\n                    \"header size is over the limit allowed by \"\n                    \"ResponseFieldSize (%d bytes). \"\n                    \"Bad response header: '%.*s[...]%s'\",\n                    size, trunc, buffer, buffer + len - trunc);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"%s\", buffer);\n        }\n\n        if (!(value = strchr(buffer, ':'))) {     \n\n            /* We may encounter invalid headers, usually from buggy\n             * MS IIS servers, so we need to determine just how to handle\n             * them. We can either ignore them, assume that they mark the\n             * start-of-body (eg: a missing CRLF) or (the default) mark\n             * the headers as totally bogus and return a 500. The sole\n             * exception is an extra \"HTTP/1.0 200, OK\" line sprinkled\n             * in between the usual MIME headers, which is a favorite\n             * IIS bug.\n             */\n             \n\n            if (!apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n                if (psc->badopt == bad_error) {\n                    \n                    r->headers_out = NULL;\n                    return;\n                }\n                else if (psc->badopt == bad_body) {\n                    /* if we've already started loading headers_out, then\n                     * return what we've accumulated so far, in the hopes\n                     * that they are useful; also note that we likely pre-read\n                     * the first line of the response.\n                     */\n                    if (saw_headers) {\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01098)\n                                      \"Starting body due to bogus non-header \"\n                                      \"in headers returned by %s (%s)\",\n                                      r->uri, r->method);\n                        *pread_len = len;\n                        return;\n                    }\n                    else {\n                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01099)\n                                      \"No HTTP headers returned by %s (%s)\",\n                                      r->uri, r->method);\n                        return;\n                    }\n                }\n            }\n            \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01100)\n                          \"Ignoring bogus HTTP header returned by %s (%s)\",\n                          r->uri, r->method);\n            continue;\n        }\n\n        *value = '\\0';\n        ++value;\n        /* XXX: RFC2068 defines only SP and HT as whitespace, this test is\n         * wrong... and so are many others probably.\n         */\n        while (apr_isspace(*value))\n            ++value;            \n\n        \n        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n            *end = '\\0';\n\n        /* make sure we add so as not to destroy duplicated headers\n         * Modify headers requiring canonicalisation and/or affected\n         * by ProxyPassReverse and family with process_proxy_header\n         */\n        process_proxy_header(r, dconf, buffer, value);\n        saw_headers = 1;\n    }\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n20,Improper Input Validation\n400,Uncontrolled Resource Consumption\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_c66a1a215e070f49a17cfb4dfbe675b6475a9cd6_0", {
    "ID": "httpd_c66a1a215e070f49a17cfb4dfbe675b6475a9cd6_0",
    "UID": "8432",
    "code": "AP_DECLARE(const char *) ap_parse_token_list_strict(apr_pool_t test_snippet\n                                                const char *str_in,\n                                                apr_array_header_t **tokens,\n                                                int skip_invalid)\n{\n    int in_leading_space = 1;\n    int in_trailing_space = 0;\n    int string_end = 0;\n    const char *tok_begin;\n    const char *cur;\n\n    if (!str_in) {\n        return NULL;\n    }\n\n    tok_begin = cur = str_in;\n\n    while (!string_end) {\n        const unsigned char c = (unsigned char)*cur;\n\n        if (!TEST_CHAR(c, T_HTTP_TOKEN_STOP) && c != '\\0') {\n            /* Non-separator character; we are finished with leading\n             * whitespace. We must never have encountered any trailing\n             * whitespace before the delimiter (comma) */\n            in_leading_space = 0;\n            if (in_trailing_space) {\n                return \"Encountered illegal whitespace in token\";\n            }\n        }\n        else if (c == ' ' || c == '\\t') {\n            /* \"Linear whitespace\" only includes ASCII CRLF, space, and tab;\n             * we can't get a CRLF since headers are split on them already,\n             * so only look for a space or a tab */\n            if (in_leading_space) {\n                \n                ++tok_begin;\n            }\n            else {\n                \n                ++in_trailing_space;\n            }\n        }\n        else if (c == ',' || c == '\\0') {\n            if (!in_leading_space) {\n                /* If we're out of the leading space, we know we've read some\n                 * characters of a token */\n                if (*tokens == NULL) {\n                    *tokens = apr_array_make(p, 4, sizeof(char *));\n                }\n                APR_ARRAY_PUSH(*tokens, char *) =\n                    apr_pstrmemdup((*tokens)->pool, tok_begin,\n                                   (cur - tok_begin) - in_trailing_space);\n            }\n            /* We're allowed to have null elements, just don't add them to the\n             * array */\n\n            tok_begin = cur + 1;\n            in_leading_space = 1;\n            in_trailing_space = 0;\n            string_end = (c == '\\0');\n        }\n        else {\n            \n            if (skip_invalid) {\n                \n                const char *temp;\n                temp = ap_strchr_c(cur, ',');\n                if(!temp) {\n                    temp = ap_strchr_c(cur, '\\0');\n                }\n\n                \n                cur = temp - 1;\n                in_leading_space = 1;\n                in_trailing_space = 0;\n            }\n            else {\n                return apr_psprintf(p, \"Encountered illegal separator \"\n                                    \"'\\\\x%.2x'\", (unsigned int)c);\n            }\n        }\n\n        ++cur;\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_921a5b6bd625c15860ed8b865c6a21a1a6c01648_0", {
    "ID": "httpd_921a5b6bd625c15860ed8b865c6a21a1a6c01648_0",
    "UID": "8503",
    "code": "static int have_ssl_compression(request_rec test_snippet\n{\n    const char *comp;\n    if (mod_deflate_ssl_var == NULL)\n        return 0;\n    comp = mod_deflate_ssl_var(r->pool, r->server, r->connection, r,\n                               \"SSL_COMPRESS_METHOD\");\n    if (comp == NULL || *comp == '\\0' || strcmp(comp, \"NULL\") == 0)\n        return 0;\n    return 1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_79ac79b4a2f99fefe4bb218a21c24a375ac0832c_0", {
    "ID": "httpd_79ac79b4a2f99fefe4bb218a21c24a375ac0832c_0",
    "UID": "8528",
    "code": "apr_status_t ajp_ilink_send(apr_socket_t *sock, ajp_msg_t test_snippet\n{\n    char         *buf;\n    apr_status_t status;\n    apr_size_t   length;\n\n    ajp_msg_end(msg);\n\n    length = msg->len;\n    buf    = (char *)msg->buf;\n\n    do {\n        apr_size_t written = length;\n\n        status = apr_socket_send(sock, buf, &written);\n        if (status != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01029)\n                          \"ajp_ilink_send(): send failed\");\n            return status;\n        }\n        length -= written;\n        buf    += written;\n    } while (length);\n\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_af907d970d2708e464b6334faf9d310d1486d600_0", {
    "ID": "httpd_af907d970d2708e464b6334faf9d310d1486d600_0",
    "UID": "8534",
    "code": "static proxy_worker *find_best_bybusyness(proxy_balancer test_snippet\n                                request_rec *r)\n{\n\n    int i;\n    proxy_worker **worker;\n    proxy_worker *mycandidate = NULL;\n    int cur_lbset = 0;\n    int max_lbset = 0;\n    int checking_standby;\n    int checked_standby;\n\n    int total_factor = 0;\n\n    if (!ap_proxy_retry_worker_fn) {\n        ap_proxy_retry_worker_fn =\n                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_retry_worker);\n        if (!ap_proxy_retry_worker_fn) {\n            \n            return NULL;\n        }\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01211)\n                 \"proxy: Entering bybusyness for BALANCER (%s)\",\n                 balancer->s->name);\n\n    \n    do {\n\n        checking_standby = checked_standby = 0;\n        while (!mycandidate && !checked_standby) {\n\n            worker = (proxy_worker **)balancer->workers->elts;\n            for (i = 0; i < balancer->workers->nelts; i++, worker++) {\n                if  (!checking_standby) {    \n                    if ((*worker)->s->lbset > max_lbset)\n                        max_lbset = (*worker)->s->lbset;\n                }\n                if (\n                    ((*worker)->s->lbset != cur_lbset) ||\n                    (checking_standby ? !PROXY_WORKER_IS_STANDBY(*worker) : PROXY_WORKER_IS_STANDBY(*worker)) ||\n                    (PROXY_WORKER_IS_DRAINING(*worker))\n                    ) {\n                    continue;\n                }\n\n                /* If the worker is in error state run\n                 * retry on that worker. It will be marked as\n                 * operational if the retry timeout is elapsed.\n                 * The worker might still be unusable, but we try\n                 * anyway.\n                 */\n                if (!PROXY_WORKER_IS_USABLE(*worker)) {\n                    ap_proxy_retry_worker_fn(\"BALANCER\", *worker, r->server);\n                }\n\n                /* Take into calculation only the workers that are\n                 * not in error state or not disabled.\n                 */\n                if (PROXY_WORKER_IS_USABLE(*worker)) {\n\n                    (*worker)->s->lbstatus += (*worker)->s->lbfactor;\n                    total_factor += (*worker)->s->lbfactor;\n\n                    if (!mycandidate\n                        || (*worker)->s->busy < mycandidate->s->busy\n                        || ((*worker)->s->busy == mycandidate->s->busy && (*worker)->s->lbstatus > mycandidate->s->lbstatus))\n                        mycandidate = *worker;\n\n                }\n\n            }\n\n            checked_standby = checking_standby++;\n\n        }\n\n        cur_lbset++;\n\n    } while (cur_lbset <= max_lbset && !mycandidate);\n\n    if (mycandidate) {\n        mycandidate->s->lbstatus -= total_factor;\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01212)\n                     \"proxy: bybusyness selected worker \\\"%s\\\" : busy %\" APR_SIZE_T_FMT \" : lbstatus %d\",\n                     mycandidate->s->name, mycandidate->s->busy, mycandidate->s->lbstatus);\n\n    }\n\n    return mycandidate;\n\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_e5230248c194674dd21cf8d4fac9777979c5c966_0", {
    "ID": "httpd_e5230248c194674dd21cf8d4fac9777979c5c966_0",
    "UID": "8547",
    "code": "APREQ_DECLARE(void) apreq_cookie_expires(apreq_cookie_t test_snippet\n                                         const char *time_str)\n{\n    if (time_str == NULL) {\n        c->max_age = -1;\n        return;\n    }\n\n    if (!strcasecmp(time_str, \"now\"))\n        c->max_age = 0;\n    else {\n        c->max_age = apr_date_parse_rfc(time_str);\n        if (c->max_age == APR_DATE_BAD)\n            c->max_age = apr_time_from_sec(apreq_atoi64t(time_str));\n        else\n            c->max_age -= apr_time_now();\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_29eff7fc431fcf0088b1791e9ddb06f09dd3e4f8_0", {
    "ID": "httpd_29eff7fc431fcf0088b1791e9ddb06f09dd3e4f8_0",
    "UID": "8550",
    "code": "APREQ_DECLARE(apr_int64_t) apreq_atoi64f(const char test_snippet\n{\n    apr_int64_t n = 0;\n    char *p;\n    if (s == NULL)\n        return 0;\n\n    n = apr_strtoi64(s, &p, 0);\n\n    if (p == NULL)\n        return n;\n    while (apr_isspace(*p))\n        ++p;\n\n    switch (*p) {\n      case 'G': \n      case 'g': return n * 1024*1024*1024;\n      case 'M': \n      case 'm': return n * 1024*1024;\n      case 'K': \n      case 'k': return n * 1024;\n    }\n\n    return n;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_5c93f7aa7bc96bcffeb13dff77d1233a7dfc7f69_0", {
    "ID": "httpd_5c93f7aa7bc96bcffeb13dff77d1233a7dfc7f69_0",
    "UID": "8562",
    "code": "APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(authz_dbd, AUTHZ_DBD, int, test_snippet\n                            (request_rec *r, int code, const char *action),\n                            (r, code, action), OK, DECLINED)",
    "predicted": "This piece of code doesn't provide enough context to identify a specific vulnerability. Please provide a more complete code snippet."
  },
  "httpd_6d71c77535e5f6a456412e22e3126851a240dafc_0", {
    "ID": "httpd_6d71c77535e5f6a456412e22e3126851a240dafc_0",
    "UID": "8564",
    "code": "APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(dbd, DBD, apr_status_t, test_snippet\n                                    (apr_pool_t *pool, dbd_cfg_t *cfg,\n                                    ap_dbd_t *dbd),\n                                    (pool, cfg, dbd), OK, DECLINED)",
    "predicted": "The provided code snippet is too small and lacks context to identify a specific vulnerability. It seems to be a part of Apache Portable Runtime (APR) library, but without the complete code or usage context, it's impossible to determine if there's a flaw. Therefore, the response is null."
  },
  "httpd_44c827c4bc84a53726ecb5ab265ec799e175a452_0", {
    "ID": "httpd_44c827c4bc84a53726ecb5ab265ec799e175a452_0",
    "UID": "8623",
    "code": "static apr_status_t custom_parse_brigade(apreq_handle_t *handle, apr_uint64_t test_snippet\n{\n    struct custom_handle *req = (struct custom_handle *)handle;\n    apr_status_t s;\n    apr_bucket *e;\n\n    if (req->body_status != APR_INCOMPLETE)\n        return req->body_status;\n\n    switch (s = apr_brigade_partition(req->in, bytes, &e)) {\n        apr_off_t len;\n\n    case APR_SUCCESS:\n        apreq_brigade_move(req->tmpbb, req->in, e);\n        req->bytes_read += bytes;\n\n        if (req->bytes_read > req->read_limit) {\n            req->body_status = APREQ_ERROR_OVERLIMIT;\n            break;\n        }\n\n        req->body_status =\n            apreq_parser_run(req->parser, req->body, req->tmpbb);\n\n        apr_brigade_cleanup(req->tmpbb);\n        break;\n\n    case APR_INCOMPLETE:\n        apreq_brigade_move(req->tmpbb, req->in, e);\n        s = apr_brigade_length(req->tmpbb, 1, &len);\n        if (s != APR_SUCCESS) {\n            req->body_status = s;\n            break;\n        }\n        req->bytes_read += len;\n\n        if (req->bytes_read > req->read_limit) {\n            req->body_status = APREQ_ERROR_OVERLIMIT;\n            break;\n        }\n        req->body_status =\n            apreq_parser_run(req->parser, req->body, req->tmpbb);\n\n        apr_brigade_cleanup(req->tmpbb);\n        break;\n\n    default:\n        req->body_status = s;\n    }\n\n    return req->body_status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d418f2d2bd9e6b0e00fad9ace84a7bf0303542d3_0", {
    "ID": "httpd_d418f2d2bd9e6b0e00fad9ace84a7bf0303542d3_0",
    "UID": "8624",
    "code": "static proxy_worker *find_best_bytraffic(proxy_balancer test_snippet\n                                         request_rec *r)\n{\n    int i;\n    apr_off_t mytraffic = 0;\n    apr_off_t curmin = 0;\n    proxy_worker **worker;\n    proxy_worker *mycandidate = NULL;\n    int cur_lbset = 0;\n    int max_lbset = 0;\n    int checking_standby;\n    int checked_standby;\n\n    if (!ap_proxy_retry_worker_fn) {\n        ap_proxy_retry_worker_fn =\n                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_retry_worker);\n        if (!ap_proxy_retry_worker_fn) {\n            \n            return NULL;\n        }\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01209)\n                 \"proxy: Entering bytraffic for BALANCER (%s)\",\n                 balancer->s->name);\n\n    \n    do {\n        checking_standby = checked_standby = 0;\n        while (!mycandidate && !checked_standby) {\n            worker = (proxy_worker **)balancer->workers->elts;\n            for (i = 0; i < balancer->workers->nelts; i++, worker++) {\n                if (!checking_standby) {    \n                    if ((*worker)->s->lbset > max_lbset)\n                        max_lbset = (*worker)->s->lbset;\n                }\n                if (\n                    ((*worker)->s->lbset != cur_lbset) ||\n                    (checking_standby ? !PROXY_WORKER_IS_STANDBY(*worker) : PROXY_WORKER_IS_STANDBY(*worker)) ||\n                    (PROXY_WORKER_IS_DRAINING(*worker))\n                    ) {\n                    continue;\n                }\n\n                /* If the worker is in error state run\n                 * retry on that worker. It will be marked as\n                 * operational if the retry timeout is elapsed.\n                 * The worker might still be unusable, but we try\n                 * anyway.\n                 */\n                if (!PROXY_WORKER_IS_USABLE(*worker))\n                    ap_proxy_retry_worker_fn(\"BALANCER\", *worker, r->server);\n                /* Take into calculation only the workers that are\n                 * not in error state or not disabled.\n                 */\n                if (PROXY_WORKER_IS_USABLE(*worker)) {\n                    mytraffic = ((*worker)->s->transferred/(*worker)->s->lbfactor) +\n                                ((*worker)->s->read/(*worker)->s->lbfactor);\n                    if (!mycandidate || mytraffic < curmin) {\n                        mycandidate = *worker;\n                        curmin = mytraffic;\n                    }\n                }\n            }\n            checked_standby = checking_standby++;\n        }\n        cur_lbset++;\n    } while (cur_lbset <= max_lbset && !mycandidate);\n\n    if (mycandidate) {\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01210)\n                     \"proxy: bytraffic selected worker \\\"%s\\\" : busy %\" APR_SIZE_T_FMT,\n                     mycandidate->s->name, mycandidate->s->busy);\n\n    }\n\n    return mycandidate;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_04db3de092cfe5f20163d6b1d8b13b3900e9dbea_0", {
    "ID": "httpd_04db3de092cfe5f20163d6b1d8b13b3900e9dbea_0",
    "UID": "8632",
    "code": "static apr_status_t ilink_read(apr_socket_t *sock, apr_byte_t test_snippet\n                               apr_size_t len)\n{\n    apr_size_t   length = len;\n    apr_size_t   rdlen  = 0;\n    apr_status_t status;\n\n    while (rdlen < len) {\n\n        status = apr_socket_recv(sock, (char *)(buf + rdlen), &length);\n\n        if (status == APR_EOF)\n            return status;          \n        else if (APR_STATUS_IS_EAGAIN(status))\n            continue;\n        else if (status != APR_SUCCESS)\n            return status;          \n\n        rdlen += length;\n        length = len - rdlen;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n606,Unchecked Input for Loop Condition"
  },
  "httpd_d8bafe29c6afc11a8b4bf4ace1af8922957443ba_0", {
    "ID": "httpd_d8bafe29c6afc11a8b4bf4ace1af8922957443ba_0",
    "UID": "8635",
    "code": "static apr_status_t split_urlword(apreq_param_t **p, apr_pool_t test_snippet\n                                  apr_bucket_brigade *bb,\n                                  apr_size_t nlen,\n                                  apr_size_t vlen)\n{\n    apreq_param_t *param;\n    apreq_value_t *v;\n    apr_bucket *e, *f;\n    apr_status_t s;\n    struct iovec vec[APREQ_DEFAULT_NELTS];\n    apr_array_header_t arr;\n    apr_size_t mark;\n    apreq_charset_t charset;\n\n    if (nlen == 0)\n        return APR_EBADARG;\n\n    param = apreq_param_make(pool, NULL, nlen, NULL, vlen);\n    *(const apreq_value_t **)&v = &param->v;\n\n    arr.pool     = pool;\n    arr.elt_size = sizeof(struct iovec);\n    arr.nelts    = 0;\n    arr.nalloc   = APREQ_DEFAULT_NELTS;\n    arr.elts     = (char *)vec;\n\n    ++nlen, ++vlen;\n    e = APR_BRIGADE_FIRST(bb);\n\n    while (!APR_BUCKET_IS_EOS(e)) {\n        struct iovec *iov = apr_array_push(&arr);\n        apr_size_t len;\n        s = apr_bucket_read(e, (const char **)&iov->iov_base,\n                            &len, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        iov->iov_len = len;\n        nlen -= len;\n\n        e = APR_BUCKET_NEXT(e);\n\n        if (nlen == 0) {\n            iov->iov_len--;\n            break;\n        }\n    }\n\n    mark = arr.nelts;\n\n    while (!APR_BUCKET_IS_EOS(e)) {\n        struct iovec *iov = apr_array_push(&arr);\n        apr_size_t len;\n        s = apr_bucket_read(e, (const char **)&iov->iov_base,\n                            &len, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        iov->iov_len = len;\n        vlen -= len;\n\n        e = APR_BUCKET_NEXT(e);\n\n        if (vlen == 0) {\n            iov->iov_len--;\n            break;\n        }\n\n    }\n\n    s = apreq_decodev(v->data, &vlen,\n                      (struct iovec *)arr.elts + mark, arr.nelts - mark);\n    if (s != APR_SUCCESS)\n        return s;\n\n    charset = apreq_charset_divine(v->data, vlen);\n\n    v->name = v->data + vlen + 1;\n    v->dlen = vlen;\n\n    s = apreq_decodev(v->name, &nlen, (struct iovec *)arr.elts, mark);\n    if (s != APR_SUCCESS)\n        return s;\n\n    switch (apreq_charset_divine(v->name, nlen)) {\n    case APREQ_CHARSET_UTF8:\n        if (charset == APREQ_CHARSET_ASCII)\n            charset = APREQ_CHARSET_UTF8;\n    case APREQ_CHARSET_ASCII:\n        break;\n\n    case APREQ_CHARSET_LATIN1:\n        if (charset != APREQ_CHARSET_CP1252)\n            charset = APREQ_CHARSET_LATIN1;\n        break;\n    case APREQ_CHARSET_CP1252:\n        charset = APREQ_CHARSET_CP1252;\n    }\n\n    v->nlen = nlen;\n\n    while ((f = APR_BRIGADE_FIRST(bb)) != e)\n        apr_bucket_delete(f);\n\n    apreq_param_tainted_on(param);\n    apreq_param_charset_set(param, charset);\n    *p = param;\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_25aaa2df435c866ae71f7aa7f81dcf1eab65172b_0", {
    "ID": "httpd_25aaa2df435c866ae71f7aa7f81dcf1eab65172b_0",
    "UID": "8636",
    "code": "static apr_status_t apreq_cookie_attr(apr_pool_t test_snippet\n                                      apreq_cookie_t *c,\n                                      const char *attr,\n                                      apr_size_t alen,\n                                      const char *val,\n                                      apr_size_t vlen)\n{\n    if (alen < 2)\n        return APR_EBADARG;\n\n    if ( attr[0] ==  '-' || attr[0] == '$' ) {\n        ++attr;\n        --alen;\n    }\n\n    switch (apr_tolower(*attr)) {\n\n    case 'n': \n        return APR_ENOTIMPL;\n\n    case 'v': \n        if (alen == 5 && strncasecmp(attr,\"value\", 5) == 0)\n            return APR_ENOTIMPL;\n\n        while (!apr_isdigit(*val)) {\n            if (vlen == 0)\n                return APREQ_ERROR_BADSEQ;\n            ++val;\n            --vlen;\n        }\n        apreq_cookie_version_set(c, *val - '0');\n        return APR_SUCCESS;\n\n    case 'e': case 'm': \n        apreq_cookie_expires(c, val);\n        return APR_SUCCESS;\n\n    case 'd':\n        c->domain = apr_pstrmemdup(p,val,vlen);\n        return APR_SUCCESS;\n\n    case 'p':\n        if (alen != 4)\n            break;\n        if (!strncasecmp(\"port\", attr, 4)) {\n            c->port = apr_pstrmemdup(p,val,vlen);\n            return APR_SUCCESS;\n        }\n        else if (!strncasecmp(\"path\", attr, 4)) {\n            c->path = apr_pstrmemdup(p,val,vlen);\n            return APR_SUCCESS;\n        }\n        break;\n\n    case 'c':\n        if (!strncasecmp(\"commentURL\", attr, 10)) {\n            c->commentURL = apr_pstrmemdup(p,val,vlen);\n            return APR_SUCCESS;\n        }\n        else if (!strncasecmp(\"comment\", attr, 7)) {\n            c->comment = apr_pstrmemdup(p,val,vlen);\n            return APR_SUCCESS;\n        }\n        break;\n\n    case 's':\n        if (vlen > 0 && *val != '0' && strncasecmp(\"off\",val,vlen))\n            apreq_cookie_secure_on(c);\n        else\n            apreq_cookie_secure_off(c);\n        return APR_SUCCESS;\n\n    case 'h': \n        if (vlen > 0 && *val != '0' && strncasecmp(\"off\",val,vlen))\n            apreq_cookie_httponly_on(c);\n        else\n            apreq_cookie_httponly_off(c);\n        return APR_SUCCESS;\n\n    };\n\n    return APR_ENOTIMPL;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference"
  },
  "httpd_61a9ff0b1bd1a74e74f1beea28ba8d9e17c7806e_0", {
    "ID": "httpd_61a9ff0b1bd1a74e74f1beea28ba8d9e17c7806e_0",
    "UID": "8637",
    "code": "static test_snippet\napr_status_t get_pair(apr_pool_t *p, const char **data,\n                      const char **n, apr_size_t *nlen,\n                      const char **v, apr_size_t *vlen, unsigned unquote)\n{\n    const char *hdr, *key, *val;\n    int nlen_set = 0;\n    hdr = *data;\n\n    while (apr_isspace(*hdr) || *hdr == '=')\n        ++hdr;\n\n    key = hdr;\n    *n = hdr;\n\n scan_name:\n\n    switch (*hdr) {\n\n    case 0:\n    case ';':\n    case ',':\n        if (!nlen_set)\n            *nlen = hdr - key;\n        *v = hdr;\n        *vlen = 0;\n        *data = hdr;\n        return *nlen ? APREQ_ERROR_NOTOKEN : APREQ_ERROR_BADCHAR;\n\n    case '=':\n        if (!nlen_set) {\n            *nlen = hdr - key;\n            nlen_set = 1;\n        }\n        break;\n\n    case ' ':\n    case '\\t':\n    case '\\r':\n    case '\\n':\n        if (!nlen_set) {\n            *nlen = hdr - key;\n            nlen_set = 1;\n        }\n        \n\n    default:\n        ++hdr;\n        goto scan_name;\n    }\n\n    val = hdr + 1;\n\n    while (apr_isspace(*val))\n        ++val;\n\n    if (*val == '\"') {\n        unsigned saw_backslash = 0;\n        for (*v = (unquote) ? ++val : val++; *val; ++val) {\n            switch (*val) {\n            case '\"':\n                *data = val + 1;\n\n                if (!unquote) {\n                    *vlen = (val - *v) + 1;\n                }\n                else if (!saw_backslash) {\n                    *vlen = val - *v;\n                }\n                else {\n                    char *dest = apr_palloc(p, val - *v), *d = dest;\n                    const char *s = *v;\n                    while (s < val) {\n                        if (*s == '\\\\')\n                            ++s;\n                        *d++ = *s++;\n                    }\n\n                    *vlen = d - dest;\n                    *v = dest;\n                }\n\n                return APR_SUCCESS;\n            case '\\\\':\n                saw_backslash = 1;\n                if (val[1] != 0)\n                    ++val;\n            default:\n                break;\n            }\n        }\n        \n        *data = val;\n        return APREQ_ERROR_BADSEQ;\n    }\n    else {\n        \n        for (*v = val; *val; ++val) {\n            switch (*val) {\n            case ';':\n            case ',':\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                *data = val;\n                *vlen = val - *v;\n                return APR_SUCCESS;\n            default:\n                break;\n            }\n        }\n    }\n\n    *data = val;\n    *vlen = val - *v;\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_05047112bfd655bb0026fa59a6ff1d4264a66692_0", {
    "ID": "httpd_05047112bfd655bb0026fa59a6ff1d4264a66692_0",
    "UID": "8638",
    "code": "APREQ_DECLARE(apreq_param_t *) apreq_param_make(apr_pool_t test_snippet\n                                                const char *name,\n                                                const apr_size_t nlen,\n                                                const char *val,\n                                                const apr_size_t vlen)\n{\n    apreq_param_t *param;\n    apreq_value_t *v;\n\n    param = apr_palloc(p, nlen + vlen + 1 + sizeof *param);\n\n    if (param == NULL)\n        return NULL;\n\n    param->info = NULL;\n    param->upload = NULL;\n    param->flags = 0;\n\n    *(const apreq_value_t **)&v = &param->v;\n\n    if (vlen && val != NULL)\n        memcpy(v->data, val, vlen);\n    v->data[vlen] = 0;\n    v->dlen = vlen;\n\n    v->name = v->data + vlen + 1;\n    if (nlen && name != NULL)\n        memcpy(v->name, name, nlen);\n    v->name[nlen] = 0;\n    v->nlen = nlen;\n\n    return param;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_3f397f32b4464815778d1c2b0e6560204dbdcf30_0", {
    "ID": "httpd_3f397f32b4464815778d1c2b0e6560204dbdcf30_0",
    "UID": "8641",
    "code": "static apr_status_t split_header_line(apreq_param_t test_snippet\n                                      apr_pool_t *pool,\n                                      apr_bucket_brigade *bb,\n                                      apr_size_t nlen,\n                                      apr_size_t glen,\n                                      apr_size_t vlen)\n{\n    apreq_param_t *param;\n    apreq_value_t *v;\n    apr_bucket *e, *f;\n    apr_status_t s;\n    struct iovec vec[APREQ_DEFAULT_NELTS], *iov, *end;\n    apr_array_header_t arr;\n    char *dest;\n    const char *data;\n    apr_size_t dlen;\n\n    if (nlen == 0)\n        return APR_EBADARG;\n\n    param = apreq_param_make(pool, NULL, nlen, NULL, vlen - 1); \n    *(const apreq_value_t **)&v = &param->v;\n\n    arr.pool     = pool;\n    arr.elt_size = sizeof(struct iovec);\n    arr.nelts    = 0;\n    arr.nalloc   = APREQ_DEFAULT_NELTS;\n    arr.elts     = (char *)vec;\n\n    e = APR_BRIGADE_FIRST(bb);\n\n    \n\n    while (nlen > 0) {\n        apr_size_t len;\n        end = apr_array_push(&arr);\n        s = apr_bucket_read(e, (const char **)&end->iov_base,\n                            &len, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        assert(nlen >= len);\n        end->iov_len = len;\n        nlen -= len;\n\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    \n\n    while (glen > 0) {\n        s = apr_bucket_read(e, &data, &dlen, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        assert(glen >= dlen);\n        glen -= dlen;\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    \n    assert(vlen > 0);\n    dest = v->data;\n    while (vlen > 0) {\n\n        s = apr_bucket_read(e, &data, &dlen, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        memcpy(dest, data, dlen);\n        dest += dlen;\n        assert(vlen >= dlen);\n        vlen -= dlen;\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    assert(dest[-1] == '\\n');\n\n    if (dest[-2] == '\\r')\n        --dest;\n\n    dest[-1] = 0;\n    v->dlen = (dest - v->data) - 1;\n\n    \n    v->name = dest;\n    iov = (struct iovec *)arr.elts;\n\n    while (iov <= end) {\n        memcpy(dest, iov->iov_base, iov->iov_len);\n        dest += iov->iov_len;\n        ++iov;\n    }\n    *dest = 0;\n\n    while ((f = APR_BRIGADE_FIRST(bb)) != e)\n        apr_bucket_delete(f);\n\n    apreq_param_tainted_on(param);\n    *p = param;\n    return APR_SUCCESS;\n\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_6372dad74232e571b431c8d2166cb125f3c6c8a1_0", {
    "ID": "httpd_6372dad74232e571b431c8d2166cb125f3c6c8a1_0",
    "UID": "8646",
    "code": "static void dumpit(ap_filter_t *f, apr_bucket *b, dumpio_conf_t test_snippet\n{\n    conn_rec *c = f->c;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,\n                  \"mod_dumpio:  %s (%s-%s): %\" APR_SIZE_T_FMT \" bytes\",\n                  f->frec->name,\n                  (APR_BUCKET_IS_METADATA(b)) ? \"metadata\" : \"data\",\n                  b->type->name,\n                  b->length) ;\n\n    if (!(APR_BUCKET_IS_METADATA(b)))\n    {\n#if APR_CHARSET_EBCDIC\n        char xlatebuf[dumpio_MAX_STRING_LEN + 1];\n#endif\n        const char *buf;\n        apr_size_t nbytes;\n        apr_status_t rv = apr_bucket_read(b, &buf, &nbytes, APR_BLOCK_READ);\n\n        if (rv == APR_SUCCESS)\n        {\n            while (nbytes)\n            {\n                apr_size_t logbytes = nbytes;\n                if (logbytes > dumpio_MAX_STRING_LEN)\n                    logbytes = dumpio_MAX_STRING_LEN;\n                nbytes -= logbytes;\n\n#if APR_CHARSET_EBCDIC\n                memcpy(xlatebuf, buf, logbytes);\n                ap_xlate_proto_from_ascii(xlatebuf, logbytes);\n                xlatebuf[logbytes] = '\\0';\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,\n                              \"mod_dumpio:  %s (%s-%s): %s\", f->frec->name,\n                              (APR_BUCKET_IS_METADATA(b)) ? \"metadata\" : \"data\",\n                              b->type->name, xlatebuf);\n#else\n                /* XXX: Seriously flawed; we do not pay attention to embedded\n                 * \\0's in the request body, these should be escaped; however,\n                 * the logging function already performs a significant amount\n                 * of escaping, and so any escaping would be double-escaped.\n                 * The coding solution is to throw away the current logic\n                 * within ap_log_error, and introduce new vformatter %-escapes\n                 * for escaping text, and for binary text (fixed len strings).\n                 */\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,\n                              \"mod_dumpio:  %s (%s-%s): %.*s\", f->frec->name,\n                              (APR_BUCKET_IS_METADATA(b)) ? \"metadata\" : \"data\",\n                              b->type->name, (int)logbytes, buf);\n#endif\n            }\n        } else {\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE7, rv, c,\n                          \"mod_dumpio:  %s (%s-%s): %s\", f->frec->name,\n                          (APR_BUCKET_IS_METADATA(b)) ? \"metadata\" : \"data\",\n                          b->type->name, \"error reading data\");\n        }\n    }\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n546,Suspicious Comment"
  },
  "httpd_4504d2781eb64bcae18752f043994a696a87efe6_0", {
    "ID": "httpd_4504d2781eb64bcae18752f043994a696a87efe6_0",
    "UID": "8647",
    "code": "static void do_debug_log(request_rec *r, const char test_snippet\n{\n    log_debug_dirconf *dconf = ap_get_module_config(r->per_dir_config, &log_debug_module);\n    int i;\n    if (dconf->entries == NULL)\n        return;\n\n    for (i = 0; i < dconf->entries->nelts; i++) {\n        const char *msg, *err;\n        msg_entry *entry = APR_ARRAY_IDX(dconf->entries, i, msg_entry *);\n        if (entry->hook != allhooks && entry->hook != hookname)\n            continue;\n        if (entry->condition) {\n            int ret = ap_expr_exec(r, entry->condition, &err);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00640)\n                              \"Can't evaluate condition: %s\", err);\n                continue;\n            }\n            if (!ret)\n                continue;\n        }\n        msg = ap_expr_str_exec(r, entry->msg_expr, &err);\n        if (err)\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00641)\n                          \"Can't evaluate message expression: %s\", err);\n        if (APLOGrdebug(r))\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%s (%s hook, %s:%d)\",\n                           msg, hookname, entry->msg_expr->filename,\n                           entry->msg_expr->line_number);\n        else\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%s\", msg);\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_fa0bce4fb6fe56ff84ce661618c5c7b52c812be9_0", {
    "ID": "httpd_fa0bce4fb6fe56ff84ce661618c5c7b52c812be9_0",
    "UID": "8671",
    "code": "APREQ_DECLARE(apr_int64_t) apreq_atoi64t(const char test_snippet\n{\n    apr_int64_t n = 0;\n    char *p;\n    if (s == NULL)\n        return 0;\n    n = apr_strtoi64(s, &p, 0); \n\n    if (p == NULL)\n        return n;\n    while (apr_isspace(*p))\n        ++p;\n\n    switch (*p) {\n      case 'Y': \n      case 'y': return n * 60*60*24*365;\n      case 'M': return n * 60*60*24*30;\n      case 'D': \n      case 'd': return n * 60*60*24;\n      case 'H': \n      case 'h': return n * 60*60;\n      case 'm': return n * 60;\n      case 's': \n      default:\n          return n;\n    }\n    \n    return -1;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_ac897ac6d6957aaa43c2e67036ef456553e9e0e6_0", {
    "ID": "httpd_ac897ac6d6957aaa43c2e67036ef456553e9e0e6_0",
    "UID": "8675",
    "code": "static test_snippet\nargstr_to_table(apr_pool_t *p, char *str, apr_table_t *parms)\n{\n    char *key;\n    char *value;\n    char *strtok_state;\n\n    key = apr_strtok(str, \"&\", &strtok_state);\n    while (key) {\n        value = strchr(key, '=');\n        if (value) {\n            *value = '\\0';      \n            value++;            \n        }\n        else {\n            value = \"1\";\n        }\n        ap_unescape_url(key);\n        ap_unescape_url(value);\n        apr_table_set(parms, key, value);\n        /*\n         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n         \"Found query arg: %s = %s\", key, value);\n         */\n        key = apr_strtok(NULL, \"&\", &strtok_state);\n    }\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_710623149bb6071a6096cac7544438522c87147f_0", {
    "ID": "httpd_710623149bb6071a6096cac7544438522c87147f_0",
    "UID": "8680",
    "code": "test_snippet\nstatic apr_status_t brigade_start_string(apr_bucket_brigade *bb,\n                                         const char *start_string)\n{\n    apr_bucket *e;\n    apr_size_t slen = strlen(start_string);\n\n    for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        const char *buf;\n        apr_status_t s, bytes_to_check;\n        apr_size_t blen;\n\n        if (slen == 0)\n            return APR_SUCCESS;\n\n        if (APR_BUCKET_IS_EOS(e))\n            return APR_EOF;\n\n        s = apr_bucket_read(e, &buf, &blen, APR_BLOCK_READ);\n\n        if (s != APR_SUCCESS)\n            return s;\n\n        if (blen == 0)\n            continue;\n\n        bytes_to_check = MIN(slen,blen);\n\n        if (strncmp(buf,start_string,bytes_to_check) != 0)\n            return APREQ_ERROR_GENERAL;\n\n        slen -= bytes_to_check;\n        start_string += bytes_to_check;\n    }\n\n    \n    return APR_INCOMPLETE;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_e2398c8f05f8365a155927f84917222005523d03_0", {
    "ID": "httpd_e2398c8f05f8365a155927f84917222005523d03_0",
    "UID": "8682",
    "code": "APREQ_DECLARE(apr_status_t) apreq_parse_query_string(apr_pool_t test_snippet\n                                                     apr_table_t *t,\n                                                     const char *qs)\n{\n    const char *start = qs;\n    apr_size_t nlen = 0;\n\n    for (;;++qs) {\n        switch (*qs) {\n\n        case '=':\n            if (nlen == 0) {\n                nlen = qs - start;\n            }\n            break;\n\n        case '&':\n        case ';':\n        case 0:\n            if (qs > start) {\n                apr_size_t vlen = 0;\n                apreq_param_t *param;\n                apr_status_t s;\n                if (nlen == 0)\n                    nlen = qs - start;\n                else\n                    vlen = qs - start - nlen - 1;\n\n                s = apreq_param_decode(&param, pool, start, nlen, vlen);\n                if (s != APR_SUCCESS)\n                    return s;\n\n                apreq_param_tainted_on(param);\n                apreq_value_table_add(&param->v, t);\n            }\n\n            if (*qs == 0)\n                return APR_SUCCESS;\n\n            nlen = 0;\n            start = qs + 1;\n        }\n    }\n    \n    return APR_INCOMPLETE;\n}",
    "predicted": "606,Unchecked Input for Loop Condition\n20,Improper Input Validation\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_c890decd320f633b8b6745735a80b023ba7048b8_0", {
    "ID": "httpd_c890decd320f633b8b6745735a80b023ba7048b8_0",
    "UID": "8687",
    "code": "static int compare_version(char *version_string, const char test_snippet\n{\n    char *p = version_string, *ep;\n    int version[3] = {0, 0, 0};\n    int c = 0;\n\n    *error = \"Version appears to be invalid. It must have the format \"\n             \"major[.minor[.patch]] where major, minor and patch are \"\n             \"numbers.\";\n\n    if (!apr_isdigit(*p)) {\n        return 0;\n    }\n\n    \n    ep = version_string + strlen(version_string);\n    while (p <= ep && c < 3) {\n        if (*p == '.') {\n            *p = '\\0';\n        }\n\n        if (!*p) {\n            version[c++] = atoi(version_string);\n            version_string = ++p;\n            continue;\n        }\n\n        if (!apr_isdigit(*p)) {\n            break;\n        }\n\n        ++p;\n    }\n\n    if (p < ep) { \n        return 0;\n    }\n\n    *error = NULL;\n\n    if      (httpd_version.major > version[0]) {\n        return 1;\n    }\n    else if (httpd_version.major < version[0]) {\n        return -1;\n    }\n    else if (httpd_version.minor > version[1]) {\n        return 1;\n    }\n    else if (httpd_version.minor < version[1]) {\n        return -1;\n    }\n    else if (httpd_version.patch > version[2]) {\n        return 1;\n    }\n    else if (httpd_version.patch < version[2]) {\n        return -1;\n    }\n\n    \n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_bc0821b8acb3abde2b0b1edb86d4cb9d0852f001_0", {
    "ID": "httpd_bc0821b8acb3abde2b0b1edb86d4cb9d0852f001_0",
    "UID": "8689",
    "code": "static void filter_trace(conn_rec *c, int debug, const char test_snippet\n                         apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n\n    switch (debug) {\n    case 0:        \n        return;\n    case 1:        \n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01375) \"%s\", fname);\n        for (b = APR_BRIGADE_FIRST(bb);\n             b != APR_BRIGADE_SENTINEL(bb);\n             b = APR_BUCKET_NEXT(b)) {\n\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01376)\n                          \"%s: type: %s, length: %\" APR_SIZE_T_FMT,\n                          fname, b->type->name ? b->type->name : \"(unknown)\",\n                          b->length);\n        }\n        break;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_c398feb2daca14de3e70d4a6d78b8e806e6f8a1c_0", {
    "ID": "httpd_c398feb2daca14de3e70d4a6d78b8e806e6f8a1c_0",
    "UID": "8694",
    "code": "static const char test_snippet\n    set_allowed_ports(cmd_parms test_snippetparms, void test_snippetdummy, const char test_snippetarg)\n{\n    server_rec test_snippets = parms->server;\n    int first, last;\n    connect_conf test_snippetconf =\n        ap_get_module_config(s->module_config, &proxy_connect_module);\n    port_range test_snippetNew;\n    char test_snippetendptr;\n    const char test_snippetp = arg;\n\n    if (!apr_isdigit(arg[0]))\n        return \"AllowCONNECT: port numbers must be numeric\";\n\n    first = strtol(p, &endptr, 10);\n    if (test_snippetendptr == '-') {\n        p = endptr + 1;\n        last = strtol(p, &endptr, 10);\n    }\n    else {\n        last = first;\n    }\n\n    if (endptr == p || test_snippetendptr != '\\0')  {\n        return apr_psprintf(parms->temp_pool,\n                            \"Cannot parse '%s' as port number\", p);\n    }\n\n    New = apr_array_push(conf->allowed_connect_ports);\n    New->first = first;\n    New->last  = last;\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n606,Unchecked Input for Loop Condition\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_222b22946b45c116abe92da5763d1d8adaa97a04_0", {
    "ID": "httpd_222b22946b45c116abe92da5763d1d8adaa97a04_0",
    "UID": "8695",
    "code": "DAV_DECLARE(int) dav_do_find_liveprop(const char *ns_uri, const char test_snippet\n                                      const dav_liveprop_group *group,\n                                      const dav_hooks_liveprop **hooks)\n{\n    const char * const *uris = group->namespace_uris;\n    const dav_liveprop_spec *scan;\n    int ns;\n\n    \n    for (ns = 0; uris[ns] != NULL; ++ns)\n        if (strcmp(ns_uri, uris[ns]) == 0)\n            break;\n    if (uris[ns] == NULL) {\n        \n        return 0;\n    }\n\n    \n    for (scan = group->specs; scan->name != NULL; ++scan)\n        if (ns == scan->ns && strcmp(name, scan->name) == 0) {\n            *hooks = group->hooks;\n            return scan->propid;\n        }\n\n    \n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_734deb659542921ed301a6d4cc84fc7f2be0c00c_0", {
    "ID": "httpd_734deb659542921ed301a6d4cc84fc7f2be0c00c_0",
    "UID": "8706",
    "code": "static const char *ip_parse_config(cmd_parms test_snippet\n                                   const char *require_line,\n                                   const void **parsed_require_line)\n{\n    const char *t, *w;\n    int count = 0;\n    apr_ipsubnet_t **ip;\n    apr_pool_t *ptemp = cmd->temp_pool;\n    apr_pool_t *p = cmd->pool;\n\n    /* The 'ip' provider will allow the configuration to specify a list of\n        ip addresses to check rather than a single address.  This is different\n        from the previous host based syntax. */\n\n    t = require_line;\n    while ((w = ap_getword_conf(ptemp, &t)) && w[0])\n        count++;\n\n    if (count == 0)\n        return \"'require ip' requires an argument\";\n\n    ip = apr_pcalloc(p, sizeof(apr_ipsubnet_t *) * (count + 1));\n    *parsed_require_line = ip;\n\n    t = require_line;\n    while ((w = ap_getword_conf(ptemp, &t)) && w[0]) {\n        char *addr = apr_pstrdup(ptemp, w);\n        char *mask;\n        apr_status_t rv;\n\n        if (parsed_subnets &&\n            (*ip = apr_hash_get(parsed_subnets, w, APR_HASH_KEY_STRING)) != NULL)\n        {\n            \n            ip++;\n            continue;\n        }\n\n        if ((mask = ap_strchr(addr, '/')))\n            *mask++ = '\\0';\n\n        rv = apr_ipsubnet_create(ip, addr, mask, p);\n\n        if(APR_STATUS_IS_EINVAL(rv)) {\n            \n            return apr_psprintf(p, \"ip address '%s' appears to be invalid\", w);\n        }\n        else if (rv != APR_SUCCESS) {\n            char msgbuf[120];\n            apr_strerror(rv, msgbuf, sizeof msgbuf);\n            return apr_psprintf(p, \"ip address '%s' appears to be invalid: %s\",\n                                w, msgbuf);\n        }\n\n        if (parsed_subnets)\n            apr_hash_set(parsed_subnets, w, APR_HASH_KEY_STRING, *ip);\n        ip++;\n    }\n\n    return NULL;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_69b425b63a2edda6226cd5d68671a9099995b3e8_0", {
    "ID": "httpd_69b425b63a2edda6226cd5d68671a9099995b3e8_0",
    "UID": "8711",
    "code": "static int test_snippet\n{\n    if (!geteuid()) {\n        const char *name;\n\n        \n\n        if (ap_unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            uid_t uid = atol(&ap_unixd_config.user_name[1]);\n\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02155)\n                         \"getpwuid: couldn't determine user name from uid %ld, \"\n                         \"you probably need to modify the User directive\",\n                         (long)uid);\n                return -1;\n            }\n\n            name = ent->pw_name;\n        }\n        else\n            name = ap_unixd_config.user_name;\n\n#if !defined(OS2)\n        \n        /*\n         * Set the GID before initgroups(), since on some platforms\n         * setgid() is known to zap the group list.\n         */\n        if (setgid(ap_unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02156)\n                        \"setgid: unable to set group id to Group %ld\",\n                        (long)ap_unixd_config.group_id);\n            return -1;\n        }\n\n        \n\n        if (initgroups(name, ap_unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02157)\n                        \"initgroups: unable to set groups for User %s \"\n                        \"and Group %ld\", name, (long)ap_unixd_config.group_id);\n            return -1;\n        }\n#endif \n    }\n    return 0;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_e5332a305eee5196ec7699d0bc61d6bd4c2bde8f_0", {
    "ID": "httpd_e5332a305eee5196ec7699d0bc61d6bd4c2bde8f_0",
    "UID": "8712",
    "code": "static apr_status_t check_time_left(reqtimeout_con_cfg test_snippet\n                                    apr_time_t *time_left_p,\n                                    apr_time_t now)\n{\n    if (!now)\n        now = apr_time_now();\n    *time_left_p = ccfg->timeout_at - now;\n    if (*time_left_p <= 0)\n        return APR_TIMEUP;\n\n    if (*time_left_p < apr_time_from_sec(1)) {\n        *time_left_p = apr_time_from_sec(1);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_48ea937c09f2060ac5c7eba216bce9ed9390fad3_0", {
    "ID": "httpd_48ea937c09f2060ac5c7eba216bce9ed9390fad3_0",
    "UID": "8714",
    "code": "static const char *configure_redirect(cmd_parms *cmd, void *d_, const char test_snippet\n{\n    dir_config_rec *d = d_;\n    int status;\n\n    if (!strcasecmp(arg1, \"ON\"))\n        status = HTTP_MOVED_TEMPORARILY;\n    else if (!strcasecmp(arg1, \"OFF\"))\n        status = REDIRECT_OFF;\n    else if (!strcasecmp(arg1, \"permanent\"))\n        status = HTTP_MOVED_PERMANENTLY;\n    else if (!strcasecmp(arg1, \"temp\"))\n        status = HTTP_MOVED_TEMPORARILY;\n    else if (!strcasecmp(arg1, \"seeother\"))\n        status = HTTP_SEE_OTHER;\n    else if (apr_isdigit(test_snippet) {\n        status = atoi(arg1);\n        if (!ap_is_HTTP_REDIRECT(status)) {\n            return \"DirectoryIndexRedirect only accepts values between 300 and 399\";\n        }\n    }\n    else {\n        return \"DirectoryIndexRedirect ON|OFF|permanent|temp|seeother|3xx\";\n    }\n\n    d->redirect_index = status;\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_a7f303d3fba8f0eb513bba77784370ed7ac8d53d_0", {
    "ID": "httpd_a7f303d3fba8f0eb513bba77784370ed7ac8d53d_0",
    "UID": "8719",
    "code": "static apr_status_t bucket_socket_ex_read(apr_bucket *a, const char test_snippet\n                                          apr_size_t *len,\n                                          apr_read_type_e block)\n{\n    socket_ex_data *data = a->data;\n    apr_socket_t *p = data->sock;\n    char *buf;\n    apr_status_t rv;\n    apr_interval_time_t timeout;\n\n    if (block == APR_NONBLOCK_READ) {\n        apr_socket_timeout_get(p, &timeout);\n        apr_socket_timeout_set(p, 0);\n    }\n\n    *str = NULL;\n    *len = APR_BUCKET_BUFF_SIZE;\n    buf = apr_bucket_alloc(*len, a->list);\n\n    rv = apr_socket_recv(p, buf, len);\n\n    if (block == APR_NONBLOCK_READ) {\n        apr_socket_timeout_set(p, timeout);\n    }\n\n    if (rv != APR_SUCCESS && rv != APR_EOF) {\n        apr_bucket_free(buf);\n        return rv;\n    }\n\n    if (*len > 0) {\n        apr_bucket_heap *h;\n\n        \n        *data->counter += *len;\n\n        \n        a = apr_bucket_heap_make(a, buf, *len, apr_bucket_free);\n        h = a->data;\n        h->alloc_len = APR_BUCKET_BUFF_SIZE; \n        *str = buf;\n        APR_BUCKET_INSERT_AFTER(a, bucket_socket_ex_create(data, a->list));\n    }\n    else {\n        apr_bucket_free(buf);\n        a = apr_bucket_immortal_make(a, \"\", 0);\n        *str = a->data;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_476ef8f297a4f2793c13e321306c9d7cb53144c7_0", {
    "ID": "httpd_476ef8f297a4f2793c13e321306c9d7cb53144c7_0",
    "UID": "8721",
    "code": "static apr_status_t readfile_heartbeats(const char *path, apr_hash_t test_snippet\n                                    apr_pool_t *pool)\n{\n    apr_finfo_t fi;\n    apr_status_t rv;\n    apr_file_t *fp;\n\n    if (!path) {\n        return APR_SUCCESS;\n    }\n\n    rv = apr_file_open(&fp, path, APR_READ|APR_BINARY|APR_BUFFERED,\n                       APR_OS_DEFAULT, pool);\n\n    if (rv) {\n        return rv;\n    }\n\n    rv = apr_file_info_get(&fi, APR_FINFO_SIZE, fp);\n\n    if (rv) {\n        return rv;\n    }\n\n    {\n        char *t;\n        int lineno = 0;\n        apr_bucket_alloc_t *ba = apr_bucket_alloc_create(pool);\n        apr_bucket_brigade *bb = apr_brigade_create(pool, ba);\n        apr_bucket_brigade *tmpbb = apr_brigade_create(pool, ba);\n        apr_table_t *hbt = apr_table_make(pool, 10);\n\n        apr_brigade_insert_file(bb, fp, 0, fi.size, pool);\n\n        do {\n            hb_server_t *server;\n            char buf[4096];\n            apr_size_t bsize = sizeof(buf);\n            const char *ip;\n\n            apr_brigade_cleanup(tmpbb);\n\n            if (APR_BRIGADE_EMPTY(bb)) {\n                break;\n            }\n\n            rv = apr_brigade_split_line(tmpbb, bb,\n                                        APR_BLOCK_READ, sizeof(buf));\n            lineno++;\n\n            if (rv) {\n                return rv;\n            }\n\n            apr_brigade_flatten(tmpbb, buf, &bsize);\n\n            if (bsize == 0) {\n                break;\n            }\n\n            buf[bsize - 1] = 0;\n\n            \n            if (buf[0] == '#') {\n                continue;\n            }\n\n            \n            t = strchr(buf, ' ');\n            if (!t) {\n                continue;\n            }\n\n            ip = apr_pstrndup(pool, buf, t - buf);\n            t++;\n\n            server = apr_hash_get(servers, ip, APR_HASH_KEY_STRING);\n\n            if (server == NULL) {\n                server = apr_pcalloc(pool, sizeof(hb_server_t));\n                server->ip = ip;\n                server->port = 80;\n                server->seen = -1;\n\n                apr_hash_set(servers, server->ip, APR_HASH_KEY_STRING, server);\n            }\n\n            apr_table_clear(hbt);\n\n            argstr_to_table(pool, apr_pstrdup(pool, t), hbt);\n\n            if (apr_table_get(hbt, \"busy\")) {\n                server->busy = atoi(apr_table_get(hbt, \"busy\"));\n            }\n\n            if (apr_table_get(hbt, \"ready\")) {\n                server->ready = atoi(apr_table_get(hbt, \"ready\"));\n            }\n\n            if (apr_table_get(hbt, \"lastseen\")) {\n                server->seen = atoi(apr_table_get(hbt, \"lastseen\"));\n            }\n\n            if (apr_table_get(hbt, \"port\")) {\n                server->port = atoi(apr_table_get(hbt, \"port\"));\n            }\n\n            if (server->busy == 0 && server->ready != 0) {\n                /* Server has zero threads active, but lots of them ready,\n                 * it likely just started up, so lets /4 the number ready,\n                 * to prevent us from completely flooding it with all new\n                 * requests.\n                 */\n                server->ready = server->ready / 4;\n            }\n\n        } while (1);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_b003ac7c3b584670ecdb5ee3dee8e00d57d4faaa_0", {
    "ID": "httpd_b003ac7c3b584670ecdb5ee3dee8e00d57d4faaa_0",
    "UID": "8724",
    "code": "static int check_gzip(request_rec *r, apr_table_t *hdrs1, apr_table_t test_snippet\n{\n    int found = 0;\n    apr_table_t *hdrs = hdrs1;\n    const char *encoding = apr_table_get(hdrs, \"Content-Encoding\");\n\n    if (!encoding && (hdrs2 != NULL)) {\n        \n        encoding = apr_table_get(hdrs2, \"Content-Encoding\");\n        hdrs = hdrs2;\n        if (!encoding) {\n            encoding = r->content_encoding;\n            hdrs = NULL;\n        }\n    }\n    if (encoding && *encoding) {\n\n        \n        if (!strcasecmp(encoding, \"gzip\")\n            || !strcasecmp(encoding, \"x-gzip\")) {\n            found = 1;\n            if (hdrs) {\n                apr_table_unset(hdrs, \"Content-Encoding\");\n            }\n            else {\n                r->content_encoding = NULL;\n            }\n        }\n        else if (ap_strchr_c(encoding, ',') != NULL) {\n            /* If the outermost encoding isn't gzip, there's nowt\n             * we can do.  So only check the last non-identity token\n             */\n            char *new_encoding = apr_pstrdup(r->pool, encoding);\n            char *ptr;\n            for(;;) {\n                char *token = ap_strrchr(new_encoding, ',');\n                if (!token) {        \n                    if (!strcasecmp(new_encoding, \"gzip\")\n                        || !strcasecmp(new_encoding, \"x-gzip\")) {\n                        found = 1;\n                        if (hdrs) {\n                            apr_table_unset(hdrs, \"Content-Encoding\");\n                        }\n                        else {\n                            r->content_encoding = NULL;\n                        }\n                    }\n                    break; \n                }\n                for (ptr=token+1; apr_isspace(*ptr); ++ptr);\n                if (!strcasecmp(ptr, \"gzip\")\n                    || !strcasecmp(ptr, \"x-gzip\")) {\n                    *token = '\\0';\n                    if (hdrs) {\n                        apr_table_setn(hdrs, \"Content-Encoding\", new_encoding);\n                    }\n                    else {\n                        r->content_encoding = new_encoding;\n                    }\n                    found = 1;\n                }\n                else if (!ptr[0] || !strcasecmp(ptr, \"identity\")) {\n                    *token = '\\0';\n                    continue; \n                }\n                break; \n            }\n        }\n    }\n    /*\n     * If we have dealt with the headers above but content_encoding was set\n     * before sync it with the new value in the hdrs table as\n     * r->content_encoding takes precedence later on in the http_header_filter\n     * and hence would destroy what we have just set in the hdrs table.\n     */\n    if (hdrs && r->content_encoding) {\n        r->content_encoding = apr_table_get(hdrs, \"Content-Encoding\");\n    }\n    return found;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_1437e837b7527f7f93a9b474eda85183e7e9229d_0", {
    "ID": "httpd_1437e837b7527f7f93a9b474eda85183e7e9229d_0",
    "UID": "8734",
    "code": "static authn_status authn_dbd_password(request_rec *r, const char test_snippet\n                                       const char *password)\n{\n    apr_status_t rv;\n    const char *dbd_password = NULL;\n    apr_dbd_prepared_t *statement;\n    apr_dbd_results_t *res = NULL;\n    apr_dbd_row_t *row = NULL;\n\n    authn_dbd_conf *conf = ap_get_module_config(r->per_dir_config,\n                                                &authn_dbd_module);\n    ap_dbd_t *dbd = authn_dbd_acquire_fn(r);\n    if (dbd == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01653)\n                      \"Failed to acquire database connection to look up \"\n                      \"user '%s'\", user);\n        return AUTH_GENERAL_ERROR;\n    }\n\n    if (conf->user == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01654)\n                      \"No AuthDBDUserPWQuery has been specified\");\n        return AUTH_GENERAL_ERROR;\n    }\n\n    statement = apr_hash_get(dbd->prepared, conf->user, APR_HASH_KEY_STRING);\n    if (statement == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01655)\n                      \"A prepared statement could not be found for \"\n                      \"AuthDBDUserPWQuery with the key '%s'\", conf->user);\n        return AUTH_GENERAL_ERROR;\n    }\n    if (apr_dbd_pvselect(dbd->driver, r->pool, dbd->handle, &res, statement,\n                              0, user, NULL) != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01656)\n                      \"Query execution error looking up '%s' \"\n                      \"in database\", user);\n        return AUTH_GENERAL_ERROR;\n    }\n    for (rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1);\n         rv != -1;\n         rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {\n        if (rv != 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01657)\n                          \"Error retrieving results while looking up '%s' \"\n                          \"in database\", user);\n            return AUTH_GENERAL_ERROR;\n        }\n        if (dbd_password == NULL) {\n#if APU_MAJOR_VERSION > 1 || (APU_MAJOR_VERSION == 1 && APU_MINOR_VERSION >= 3)\n            \n            int i = 1;\n            const char *name;\n            for (name = apr_dbd_get_name(dbd->driver, res, i);\n                 name != NULL;\n                 name = apr_dbd_get_name(dbd->driver, res, i)) {\n\n                char *str = apr_pstrcat(r->pool, AUTHN_PREFIX,\n                                        name,\n                                        NULL);\n                int j = sizeof(AUTHN_PREFIX)-1; \n                while (str[j]) {\n                    if (!apr_isalnum(str[j])) {\n                        str[j] = '_';\n                    }\n                    else {\n                        str[j] = apr_toupper(str[j]);\n                    }\n                    j++;\n                }\n                apr_table_set(r->subprocess_env, str,\n                              apr_dbd_get_entry(dbd->driver, row, i));\n                i++;\n            }\n#endif\n            dbd_password = apr_dbd_get_entry(dbd->driver, row, 0);\n        }\n        \n    }\n\n    if (!dbd_password) {\n        return AUTH_USER_NOT_FOUND;\n    }\n    AUTHN_CACHE_STORE(r, user, NULL, dbd_password);\n\n    rv = apr_password_validate(password, dbd_password);\n\n    if (rv != APR_SUCCESS) {\n        return AUTH_DENIED;\n    }\n\n    return AUTH_GRANTED;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n400,Uncontrolled Resource Consumption"
  },
  "httpd_83fba2651ea0902d6ca26019f9aaf7e0f0fdcce0_0", {
    "ID": "httpd_83fba2651ea0902d6ca26019f9aaf7e0f0fdcce0_0",
    "UID": "8737",
    "code": "static apr_status_t get_dbm_grp(request_rec *r, char *key1, char test_snippet\n                                const char *dbmgrpfile, const char *dbtype,\n                                const char ** out)\n{\n    char *grp_colon, *val;\n    apr_status_t retval;\n    apr_dbm_t *f;\n\n    retval = apr_dbm_open_ex(&f, dbtype, dbmgrpfile, APR_DBM_READONLY,\n                             APR_OS_DEFAULT, r->pool);\n\n    if (retval != APR_SUCCESS) {\n        return retval;\n    }\n\n    \n    if (!(val = get_dbm_entry_as_str(r->pool, f, key1))) {\n        val = get_dbm_entry_as_str(r->pool, f, key2);\n    }\n\n    apr_dbm_close(f);\n\n    if (val && (grp_colon = ap_strchr(val, ':')) != NULL) {\n        char *grp_colon2 = ap_strchr(++grp_colon, ':');\n\n        if (grp_colon2) {\n            *grp_colon2 = '\\0';\n        }\n        *out = grp_colon;\n    }\n    else {\n        *out = val;\n    }\n\n    return retval;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n476,NULL Pointer Dereference"
  },
  "httpd_68063b120515648e7fba6c40598f520c620eeb2c_0", {
    "ID": "httpd_68063b120515648e7fba6c40598f520c620eeb2c_0",
    "UID": "8751",
    "code": "static int try_chown(apr_pool_t *p, server_rec test_snippet\n                     const char *name, const char *suffix)\n{\n    if (suffix)\n        name = apr_pstrcat(p, name, suffix, NULL);\n    if (-1 == chown(name, ap_unixd_config.user_id,\n                    (gid_t)-1  ))\n    {\n        if (errno != ENOENT)\n            ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(errno), s, APLOGNO(00802)\n                         \"Can't change owner of %s\", name);\n        return -1;\n    }\n    return 0;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal"
  },
  "httpd_aade2e80050d885a4f31d90ffd01ce9d23d007fb_0", {
    "ID": "httpd_aade2e80050d885a4f31d90ffd01ce9d23d007fb_0",
    "UID": "8758",
    "code": "static apr_status_t append_bucket(sed_filter_ctxt* ctx, char* buf, int test_snippet\n{\n    apr_status_t status = APR_SUCCESS;\n    apr_bucket *b;\n    if (ctx->tpool == ctx->r->pool) {\n        \n        b = apr_bucket_pool_create(buf, sz, ctx->r->pool,\n                                   ctx->r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n    }\n    else {\n        \n        b = apr_bucket_transient_create(buf, sz,\n                                        ctx->r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n        ctx->numbuckets++;\n        if (ctx->numbuckets >= MAX_TRANSIENT_BUCKETS) {\n            b = apr_bucket_flush_create(ctx->r->connection->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(ctx->bb, b);\n            status = ap_pass_brigade(ctx->f->next, ctx->bb);\n            apr_brigade_cleanup(ctx->bb);\n            clear_ctxpool(ctx);\n        }\n    }\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_944d1b49a44567f2e12d1a244205a8a7f4617710_0", {
    "ID": "httpd_944d1b49a44567f2e12d1a244205a8a7f4617710_0",
    "UID": "8767",
    "code": "static apr_status_t mkdir_structure(disk_cache_conf *conf, const char *file, apr_pool_t test_snippet\n{\n    apr_status_t rv;\n    char *p;\n\n    for (p = (char*)file + conf->cache_root_len + 1;;) {\n        p = strchr(p, '/');\n        if (!p)\n            break;\n        *p = '\\0';\n\n        rv = apr_dir_make(file,\n                          APR_UREAD|APR_UWRITE|APR_UEXECUTE, pool);\n        if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n            return rv;\n        }\n        *p = '/';\n        ++p;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_093eef40d7f5002d6b3d8bd19bbdd0ec7ab5a50a_0", {
    "ID": "httpd_093eef40d7f5002d6b3d8bd19bbdd0ec7ab5a50a_0",
    "UID": "8768",
    "code": "static int dav_init_handler(apr_pool_t *p, apr_pool_t *plog, apr_pool_t test_snippet\n                             server_rec *s)\n{\n    \n\n    \n    dav_methods[DAV_M_BIND] = ap_method_register(p, \"BIND\");\n    dav_methods[DAV_M_SEARCH] = ap_method_register(p, \"SEARCH\");\n\n    return OK;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_eb04af4bed4c60781d8ff6c401d495b6caeff803_0", {
    "ID": "httpd_eb04af4bed4c60781d8ff6c401d495b6caeff803_0",
    "UID": "8769",
    "code": "static int looks_like_ip(const char test_snippet\n{\n    if (ap_strchr_c(ipstr, ':')) {\n        \n        return 1;\n    }\n\n    \n    while ((*ipstr == '.') || apr_isdigit(test_snippet)\n        ipstr++;\n    return (*ipstr == '\\0');\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_8432f60dc1fd3ca5679d87dbe49eb76bbd2d82a9_0", {
    "ID": "httpd_8432f60dc1fd3ca5679d87dbe49eb76bbd2d82a9_0",
    "UID": "8778",
    "code": "static apr_status_t split_on_bdry(apr_bucket_brigade test_snippet\n                                  apr_bucket_brigade *in,\n                                  const apr_strmatch_pattern *pattern,\n                                  const char *bdry)\n{\n    apr_bucket *e = APR_BRIGADE_FIRST(in);\n    apr_size_t blen = strlen(bdry), off = 0;\n\n    while ( e != APR_BRIGADE_SENTINEL(in) ) {\n        apr_ssize_t idx;\n        apr_size_t len;\n        const char *buf;\n        apr_status_t s;\n\n        if (APR_BUCKET_IS_EOS(e))\n            return APR_EOF;\n\n        s = apr_bucket_read(e, &buf, &len, APR_BLOCK_READ);\n        if (s != APR_SUCCESS)\n            return s;\n\n        if (len == 0) {\n            apr_bucket *f = e;\n            e = APR_BUCKET_NEXT(e);\n            apr_bucket_delete(f);\n            continue;\n        }\n\n    look_for_boundary_up_front:\n        if (strncmp(bdry + off, buf, MIN(len, blen - off)) == 0) {\n            if ( len >= blen - off ) {\n                \n                if (len > blen - off)\n                    apr_bucket_split(e, blen - off);\n                e = APR_BUCKET_NEXT(e);\n\n                do {\n                    apr_bucket *f = APR_BRIGADE_FIRST(in);\n                    apr_bucket_delete(f);\n                } while (APR_BRIGADE_FIRST(in) != e);\n\n                return APR_SUCCESS;\n            }\n            \n            off += len;\n            e = APR_BUCKET_NEXT(e);\n            continue;\n        }\n        else if (off > 0) {\n            /* prior (partial) strncmp failed,\n             * so we can move previous buckets across\n             * and retest buf against the full bdry.\n             */\n\n            /* give hints to GCC by making the brigade volatile, otherwise the\n             * loop below will end up being endless. See:\n             * https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=193740\n             */\n            apr_bucket_brigade * volatile in_v = in;\n\n            do {\n                apr_bucket *f = APR_BRIGADE_FIRST(in_v);\n                APR_BUCKET_REMOVE(f);\n                APR_BRIGADE_INSERT_TAIL(out, f);\n            } while (e != APR_BRIGADE_FIRST(in_v));\n            off = 0;\n            goto look_for_boundary_up_front;\n        }\n\n        if (pattern != NULL && len >= blen) {\n            const char *match = apr_strmatch(pattern, buf, len);\n            if (match != NULL)\n                idx = match - buf;\n            else {\n                idx = apreq_index(buf + len-blen, blen, bdry, blen,\n                                  APREQ_MATCH_PARTIAL);\n                if (idx >= 0)\n                    idx += len-blen;\n            }\n        }\n        else\n            idx = apreq_index(buf, len, bdry, blen, APREQ_MATCH_PARTIAL);\n\n        /* Theoretically idx should never be 0 here, because we\n         * already tested the front of the brigade for a potential match.\n         * However, it doesn't hurt to allow for the possibility,\n         * since this will just start the whole loop over again.\n         */\n        if (idx >= 0)\n            apr_bucket_split(e, idx);\n\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(out, e);\n        e = APR_BRIGADE_FIRST(in);\n    }\n\n    return APR_INCOMPLETE;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_ab2d8ee8e141f3d538afdbd4901d8dfa86db1cbf_0", {
    "ID": "httpd_ab2d8ee8e141f3d538afdbd4901d8dfa86db1cbf_0",
    "UID": "8780",
    "code": "static int logio_transaction(request_rec test_snippet\n{\n    logio_config_t *cf = ap_get_module_config(r->connection->conn_config,\n                                              &logio_module);\n\n    \n    cf->bytes_last_request = cf->bytes_in + cf->bytes_out;\n    cf->bytes_in = cf->bytes_out = 0;\n\n    return OK;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_d8ec24278701ed69877820e1936c542895690abc_0", {
    "ID": "httpd_d8ec24278701ed69877820e1936c542895690abc_0",
    "UID": "8783",
    "code": "static authn_status check_dbm_pw(request_rec *r, const char test_snippet\n                                 const char *password)\n{\n    authn_dbm_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                      &authn_dbm_module);\n    apr_status_t rv;\n    char *dbm_password;\n    char *colon_pw;\n\n    rv = fetch_dbm_value(conf->dbmtype, conf->pwfile, user, &dbm_password,\n                         r->pool);\n\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01754)\n                      \"could not open dbm (type %s) auth file: %s\",\n                      conf->dbmtype, conf->pwfile);\n        return AUTH_GENERAL_ERROR;\n    }\n\n    if (!dbm_password) {\n        return AUTH_USER_NOT_FOUND;\n    }\n\n    colon_pw = ap_strchr(dbm_password, ':');\n    if (colon_pw) {\n        *colon_pw = '\\0';\n    }\n    AUTHN_CACHE_STORE(r, user, NULL, dbm_password);\n\n    rv = apr_password_validate(password, dbm_password);\n\n    if (rv != APR_SUCCESS) {\n        return AUTH_DENIED;\n    }\n\n    return AUTH_GRANTED;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_47c2303fb87f9eadcc2aa63c6792d5493d24c00e_0", {
    "ID": "httpd_47c2303fb87f9eadcc2aa63c6792d5493d24c00e_0",
    "UID": "8785",
    "code": "static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec test_snippet\n{\n    apr_dbm_t *dbm;\n    apr_datum_t dbmkey;\n    apr_datum_t dbmval;\n    apr_time_t expiry;\n    int elts = 0;\n    int deleted = 0;\n    int expired;\n    apr_datum_t *keylist;\n    int keyidx;\n    int i;\n    apr_time_t now;\n    apr_status_t rv;\n\n    /*\n     * make sure the expiration for still not-accessed\n     * socache entries is done only from time to time\n     */\n    now = apr_time_now();\n\n    if (now < ctx->last_expiry + ctx->expiry_interval) {\n        return;\n    }\n\n    ctx->last_expiry = now;\n\n    /*\n     * Here we have to be very carefully: Not all DBM libraries are\n     * smart enough to allow one to iterate over the elements and at the\n     * same time delete expired ones. Some of them get totally crazy\n     * while others have no problems. So we have to do it the slower but\n     * more safe way: we first iterate over all elements and remember\n     * those which have to be expired. Then in a second pass we delete\n     * all those expired elements. Additionally we reopen the DBM file\n     * to be really safe in state.\n     */\n\n#define KEYMAX 1024\n\n    for (;;) {\n        \n        apr_pool_clear(ctx->pool);\n\n        if ((keylist = apr_palloc(ctx->pool, sizeof(dbmkey)*KEYMAX)) == NULL) {\n            break;\n        }\n\n        \n        keyidx = 0;\n        if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,\n                               DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00811)\n                         \"Cannot open socache DBM file `%s' for \"\n                         \"scanning\",\n                         ctx->data_file);\n            break;\n        }\n        apr_dbm_firstkey(dbm, &dbmkey);\n        while (dbmkey.dptr != NULL) {\n            elts++;\n            expired = FALSE;\n            apr_dbm_fetch(dbm, dbmkey, &dbmval);\n            if (dbmval.dsize <= sizeof(apr_time_t) || dbmval.dptr == NULL)\n                expired = TRUE;\n            else {\n                memcpy(&expiry, dbmval.dptr, sizeof(apr_time_t));\n                if (expiry <= now)\n                    expired = TRUE;\n            }\n            if (expired) {\n                if ((keylist[keyidx].dptr = apr_pmemdup(ctx->pool, dbmkey.dptr, dbmkey.dsize)) != NULL) {\n                    keylist[keyidx].dsize = dbmkey.dsize;\n                    keyidx++;\n                    if (keyidx == KEYMAX)\n                        break;\n                }\n            }\n            apr_dbm_nextkey(dbm, &dbmkey);\n        }\n        apr_dbm_close(dbm);\n\n        \n        if (apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,\n                         DBM_FILE_MODE, ctx->pool) != APR_SUCCESS) {\n            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00812)\n                         \"Cannot re-open socache DBM file `%s' for \"\n                         \"expiring\",\n                         ctx->data_file);\n            break;\n        }\n        for (i = 0; i < keyidx; i++) {\n            apr_dbm_delete(dbm, keylist[i]);\n            deleted++;\n        }\n        apr_dbm_close(dbm);\n\n        if (keyidx < KEYMAX)\n            break;\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00813)\n                 \"DBM socache expiry: \"\n                 \"old: %d, new: %d, removed: %d\",\n                 elts, elts-deleted, deleted);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_274c0c2e965c7bf8186d8458f4b47f0f1c61b2f1_0", {
    "ID": "httpd_274c0c2e965c7bf8186d8458f4b47f0f1c61b2f1_0",
    "UID": "8786",
    "code": "static int decodeenc(char test_snippet\n{\n    int i, j, ch;\n\n    if (x[0] == '\\0')\n        return 0;               \n    for (i = 0, j = 0; x[i] != '\\0'; i++, j++) {\n        \n        ch = x[i];\n        if (ch == '%' && apr_isxdigit(x[i + 1]) && apr_isxdigit(x[i + 2])) {\n            ch = ap_proxy_hex2c(&x[i + 1]);\n            i += 2;\n        }\n        x[j] = ch;\n    }\n    x[j] = '\\0';\n    return j;\n}",
    "predicted": "120,Classic Buffer Overflow"
  },
  "httpd_319547df840062a496c4d5d73f27fc421a75072f_0", {
    "ID": "httpd_319547df840062a496c4d5d73f27fc421a75072f_0",
    "UID": "8791",
    "code": "static int clean_warning_headers(void *data, const char *key, const char test_snippet\n{\n    apr_table_t *headers = ((header_dptr*)data)->table;\n    apr_pool_t *pool = ((header_dptr*)data)->pool;\n    char *warning;\n    char *date;\n    apr_time_t warn_time;\n    const int nmatch = 3;\n    ap_regmatch_t pmatch[3];\n\n    if (headers == NULL) {\n        ((header_dptr*)data)->table = headers = apr_table_make(pool, 2);\n    }\n/*\n * Parse this, suckers!\n *\n *    Warning    = \"Warning\" \":\" 1#warning-value\n *\n *    warning-value = warn-code SP warn-agent SP warn-text\n *                                             [SP warn-date]\n *\n *    warn-code  = 3DIGIT\n *    warn-agent = ( host [ \":\" port ] ) | pseudonym\n *                    ; the name or pseudonym of the server adding\n *                    ; the Warning header, for use in debugging\n *    warn-text  = quoted-string\n *    warn-date  = <\"> HTTP-date <\">\n *\n * Buggrit, use a bloomin' regexp!\n * (\\d{3}\\s+\\S+\\s+\\\".*?\\\"(\\s+\\\"(.*?)\\\")?)  --> whole in $1, date in $3\n */\n    while (!ap_regexec(warn_rx, val, nmatch, pmatch, 0)) {\n        warning = apr_pstrndup(pool, val+pmatch[0].rm_so,\n                               pmatch[0].rm_eo - pmatch[0].rm_so);\n        warn_time = 0;\n        if (pmatch[2].rm_eo > pmatch[2].rm_so) {\n            \n            date = apr_pstrndup(pool, val+pmatch[2].rm_so,\n                                pmatch[2].rm_eo - pmatch[2].rm_so);\n            warn_time = apr_date_parse_http(date);\n        }\n        if (!warn_time || (warn_time == ((header_dptr*)data)->time)) {\n            apr_table_addn(headers, key, warning);\n        }\n        val += pmatch[0].rm_eo;\n    }\n    return 1;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_9550d233e6fe690bdc2e49a28c64fdc8419161c8_0", {
    "ID": "httpd_9550d233e6fe690bdc2e49a28c64fdc8419161c8_0",
    "UID": "8792",
    "code": "static const char *proxies_set(cmd_parms *cmd, void test_snippet\n                               const char *arg)\n{\n    remoteip_config_t *config = ap_get_module_config(cmd->server->module_config,\n                                                     &remoteip_module);\n    remoteip_proxymatch_t *match;\n    apr_status_t rv;\n    char *ip = apr_pstrdup(cmd->temp_pool, arg);\n    char *s = ap_strchr(ip, '/');\n    if (s) {\n        *s++ = '\\0';\n    }\n\n    if (!config->proxymatch_ip) {\n        config->proxymatch_ip = apr_array_make(cmd->pool, 1, sizeof(*match));\n    }\n    match = (remoteip_proxymatch_t *) apr_array_push(config->proxymatch_ip);\n    match->internal = cmd->info;\n\n    if (looks_like_ip(ip)) {\n        \n        rv = apr_ipsubnet_create(&match->ip, ip, s, cmd->pool);\n    }\n    else\n    {\n        apr_sockaddr_t *temp_sa;\n\n        if (s) {\n            return apr_pstrcat(cmd->pool, \"RemoteIP: Error parsing IP \", arg,\n                               \" the subnet /\", s, \" is invalid for \",\n                               cmd->cmd->name, NULL);\n        }\n\n        rv = apr_sockaddr_info_get(&temp_sa,  ip, APR_UNSPEC, 0,\n                                   APR_IPV4_ADDR_OK, cmd->temp_pool);\n        while (rv == APR_SUCCESS)\n        {\n            apr_sockaddr_ip_get(&ip, temp_sa);\n            rv = apr_ipsubnet_create(&match->ip, ip, NULL, cmd->pool);\n            if (!(temp_sa = temp_sa->next)) {\n                break;\n            }\n            match = (remoteip_proxymatch_t *)\n                    apr_array_push(config->proxymatch_ip);\n            match->internal = cmd->info;\n        }\n    }\n\n    if (rv != APR_SUCCESS) {\n        char msgbuf[128];\n        apr_strerror(rv, msgbuf, sizeof(msgbuf));\n        return apr_pstrcat(cmd->pool, \"RemoteIP: Error parsing IP \", arg,\n                           \" (\", msgbuf, \" error) for \", cmd->cmd->name, NULL);\n    }\n\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_a97415cc1f53226994ccbd724cbe6ad7a430c35a_0", {
    "ID": "httpd_a97415cc1f53226994ccbd724cbe6ad7a430c35a_0",
    "UID": "8804",
    "code": "APREQ_DECLARE(char *) apreq_param_encode(apr_pool_t test_snippet\n                                         const apreq_param_t *param)\n{\n    apr_size_t dlen;\n    char *data;\n    data = apr_palloc(pool, 3 * (param->v.nlen + param->v.dlen) + 2);\n    dlen = apreq_encode(data, param->v.name, param->v.nlen);\n    data[dlen++] = '=';\n    dlen += apreq_encode(data + dlen, param->v.data, param->v.dlen);\n\n    return data;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c471451ed77e3755778fb4794833f4dc6a83aa9f_0", {
    "ID": "httpd_c471451ed77e3755778fb4794833f4dc6a83aa9f_0",
    "UID": "8808",
    "code": "APREQ_DECLARE(apr_size_t) apreq_encode(char *dest, const char test_snippet\n                                       const apr_size_t slen)\n{\n    char *d = dest;\n    const unsigned char *s = (const unsigned char *)src;\n    unsigned char c;\n\n    for ( ; s < (const unsigned char *)src + slen; ++s) {\n        c = *s;\n        if ( c < 0x80 && (apr_isalnum(c)\n                          || c == '-' || c == '.'\n                          || c == '_' || c == '~') )\n            *d++ = c;\n\n        else if ( c == ' ' )\n            *d++ = '+';\n\n        else {\n#if APR_CHARSET_EBCDIC\n            c = apr_xlate_conv_byte(ap_hdrs_to_ascii, (unsigned char)c);\n#endif\n            *d++ = '%';\n            *d++ = c2x_table[c >> 4];\n            *d++ = c2x_table[c & 0xf];\n        }\n    }\n    *d = 0;\n\n    return d - dest;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_3123239a44686724eda3807fae67db20cd52dcd0_0", {
    "ID": "httpd_3123239a44686724eda3807fae67db20cd52dcd0_0",
    "UID": "8812",
    "code": "static void dav_register_liveprop_namespace(apr_pool_t *p, const char test_snippet\n{\n    long value;\n\n    if (dav_liveprop_uris == NULL) {\n        dav_liveprop_uris = apr_hash_make(p);\n        apr_pool_cleanup_register(p, NULL, dav_cleanup_liveprops, apr_pool_cleanup_null);\n    }\n\n    value = (long)apr_hash_get(dav_liveprop_uris, uri, APR_HASH_KEY_STRING);\n    if (value != 0) {\n        \n        return;\n    }\n\n    \n    apr_hash_set(dav_liveprop_uris, uri, APR_HASH_KEY_STRING,\n                 (void *)++dav_liveprop_count);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_d65b45116ec9d8e2c42e63b80a72eda944598779_0", {
    "ID": "httpd_d65b45116ec9d8e2c42e63b80a72eda944598779_0",
    "UID": "8813",
    "code": "static apr_status_t logio_in_filter(ap_filter_t test_snippet\n                                    apr_bucket_brigade *bb,\n                                    ap_input_mode_t mode,\n                                    apr_read_type_e block,\n                                    apr_off_t readbytes) {\n    apr_off_t length;\n    apr_status_t status;\n    logio_config_t *cf = ap_get_module_config(f->c->conn_config, &logio_module);\n\n    status = ap_get_brigade(f->next, bb, mode, block, readbytes);\n\n    apr_brigade_length (bb, 0, &length);\n\n    if (length > 0)\n        cf->bytes_in += length;\n\n    return status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_757a2be1a386489980445c5e52f1163f8b2afd60_0", {
    "ID": "httpd_757a2be1a386489980445c5e52f1163f8b2afd60_0",
    "UID": "8815",
    "code": "char *sed_compile(sed_commands_t *commands, sed_comp_args test_snippet\n                  char *ep, char *endbuf, int seof)\n{\n    int c;\n    int eof = seof;\n    char *lastep;\n    int cclcnt;\n    char bracket[NBRA], *bracketp;\n    int closed;\n    int neg;\n    int lc;\n    int i, cflg;\n    int iflag; \n    char *sp = commands->cp;\n    int regerrno = 0;\n\n    lastep = 0;\n    if ((c = GETC()) == eof || c == '\\n') {\n        if (c == '\\n') {\n            UNGETC(c);\n        }\n        commands->cp = sp;\n        goto out;\n    }\n    bracketp = bracket;\n    compargs->circf = closed = compargs->nbra = 0;\n    if (c == '^')\n        compargs->circf++;\n    else\n        UNGETC(c);\n    while (1) {\n        if (ep >= endbuf)\n            SEDCOMPILE_ERROR(50);\n        c = GETC();\n        if (c != '*' && ((c != '\\\\') || (PEEKC() != '{')))\n            lastep = ep;\n        if (c == eof) {\n            *ep++ = CCEOF;\n            if (bracketp != bracket)\n                SEDCOMPILE_ERROR(42);\n            commands->cp = sp;\n            goto out;\n        }\n        switch (c) {\n\n        case '.':\n            *ep++ = CDOT;\n            continue;\n\n        case '\\n':\n            SEDCOMPILE_ERROR(36);\n            commands->cp = sp;\n            goto out;\n        case '*':\n            if (lastep == 0 || *lastep == CBRA || *lastep == CKET)\n                goto defchar;\n            *lastep |= STAR;\n            continue;\n\n        case '$':\n            if (PEEKC() != eof && PEEKC() != '\\n')\n                goto defchar;\n            *ep++ = CDOL;\n            continue;\n\n        case '[':\n            if (&ep[17] >= endbuf)\n                SEDCOMPILE_ERROR(50);\n\n            *ep++ = CCL;\n            lc = 0;\n            for (i = 0; i < 16; i++)\n                ep[i] = 0;\n\n            neg = 0;\n            if ((c = GETC()) == '^') {\n                neg = 1;\n                c = GETC();\n            }\n            iflag = 1;\n            do {\n                c &= 0377;\n                if (c == '\\0' || c == '\\n')\n                    SEDCOMPILE_ERROR(49);\n                if ((c & 0200) && iflag) {\n                    iflag = 0;\n                    if (&ep[32] >= endbuf)\n                        SEDCOMPILE_ERROR(50);\n                    ep[-1] = CXCL;\n                    for (i = 16; i < 32; i++)\n                        ep[i] = 0;\n                }\n                if (c == '-' && lc != 0) {\n                    if ((c = GETC()) == ']') {\n                        PLACE('-');\n                        break;\n                    }\n                    if ((c & 0200) && iflag) {\n                        iflag = 0;\n                        if (&ep[32] >= endbuf)\n                            SEDCOMPILE_ERROR(50);\n                        ep[-1] = CXCL;\n                        for (i = 16; i < 32; i++)\n                            ep[i] = 0;\n                    }\n                    while (lc < c) {\n                        PLACE(lc);\n                        lc++;\n                    }\n                }\n                lc = c;\n                PLACE(c);\n            } while ((c = GETC()) != ']');\n\n            if (iflag)\n                iflag = 16;\n            else\n                iflag = 32;\n\n            if (neg) {\n                if (iflag == 32) {\n                    for (cclcnt = 0; cclcnt < iflag;\n                        cclcnt++)\n                        ep[cclcnt] ^= 0377;\n                    ep[0] &= 0376;\n                } else {\n                    ep[-1] = NCCL;\n                    \n                    ep[0] |= 01;\n                }\n            }\n\n            ep += iflag;\n\n            continue;\n\n        case '\\\\':\n            switch (c = GETC()) {\n\n            case '(':\n                if (compargs->nbra >= NBRA)\n                    SEDCOMPILE_ERROR(43);\n                *bracketp++ = compargs->nbra;\n                *ep++ = CBRA;\n                *ep++ = compargs->nbra++;\n                continue;\n\n            case ')':\n                if (bracketp <= bracket)\n                    SEDCOMPILE_ERROR(42);\n                *ep++ = CKET;\n                *ep++ = *--bracketp;\n                closed++;\n                continue;\n\n            case '{':\n                if (lastep == (char *) 0)\n                    goto defchar;\n                *lastep |= RNGE;\n                cflg = 0;\n            nlim:\n                c = GETC();\n                i = 0;\n                do {\n                    if ('0' <= c && c <= '9')\n                        i = 10 * i + c - '0';\n                    else\n                        SEDCOMPILE_ERROR(16);\n                } while (((c = GETC()) != '\\\\') && (c != ','));\n                if (i >= 255)\n                    SEDCOMPILE_ERROR(11);\n                *ep++ = i;\n                if (c == ',') {\n                    if (cflg++)\n                        SEDCOMPILE_ERROR(44);\n                    if ((c = GETC()) == '\\\\')\n                        *ep++ = (char) 255;\n                    else {\n                        UNGETC(c);\n                        goto nlim;\n                        \n                    }\n                }\n                if (GETC() != '}')\n                    SEDCOMPILE_ERROR(45);\n                if (!cflg)    \n                    *ep++ = i;\n                else if ((ep[-1] & 0377) < (ep[-2] & 0377))\n                    SEDCOMPILE_ERROR(46);\n                continue;\n\n            case '\\n':\n                SEDCOMPILE_ERROR(36);\n\n            case 'n':\n                c = '\\n';\n                goto defchar;\n\n            default:\n                if (c >= '1' && c <= '9') {\n                    if ((c -= '1') >= closed)\n                        SEDCOMPILE_ERROR(25);\n                    *ep++ = CBACK;\n                    *ep++ = c;\n                    continue;\n                }\n            }\n    \n\n        defchar:\n        default:\n            lastep = ep;\n            *ep++ = CCHR;\n            *ep++ = c;\n        }\n    }\nout:\n    if (regerrno) {\n        regerr(commands, regerrno);\n        return (char*) NULL;\n    }\n    \n    \n    return ep;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n400,Uncontrolled Resource Consumption\n680,Integer Overflow to Buffer Overflow\n789,Memory Allocation with Excessive Size Value"
  },
  "httpd_57d6548f42031987aca2bce9dd529302377c693b_0", {
    "ID": "httpd_57d6548f42031987aca2bce9dd529302377c693b_0",
    "UID": "8830",
    "code": "static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec test_snippet\n{\n    char str[APRMAXHOSTLEN + 1];\n    apr_status_t rv;\n    char *ipaddrstr;\n    apr_sockaddr_t *sockaddr;\n\n    /*\n     * Calculate the sizes and offsets in cur_unique_id.\n     */\n    unique_id_rec_offset[0] = APR_OFFSETOF(unique_id_rec, stamp);\n    unique_id_rec_size[0] = sizeof(cur_unique_id.stamp);\n    unique_id_rec_offset[1] = APR_OFFSETOF(unique_id_rec, in_addr);\n    unique_id_rec_size[1] = sizeof(cur_unique_id.in_addr);\n    unique_id_rec_offset[2] = APR_OFFSETOF(unique_id_rec, pid);\n    unique_id_rec_size[2] = sizeof(cur_unique_id.pid);\n    unique_id_rec_offset[3] = APR_OFFSETOF(unique_id_rec, counter);\n    unique_id_rec_size[3] = sizeof(cur_unique_id.counter);\n    unique_id_rec_offset[4] = APR_OFFSETOF(unique_id_rec, thread_index);\n    unique_id_rec_size[4] = sizeof(cur_unique_id.thread_index);\n    unique_id_rec_total_size = unique_id_rec_size[0] + unique_id_rec_size[1] +\n                               unique_id_rec_size[2] + unique_id_rec_size[3] +\n                               unique_id_rec_size[4];\n\n    /*\n     * Calculate the size of the structure when encoded.\n     */\n    unique_id_rec_size_uu = (unique_id_rec_total_size*8+5)/6;\n\n    /*\n     * Now get the global in_addr.  Note that it is not sufficient to use one\n     * of the addresses from the main_server, since those aren't as likely to\n     * be unique as the physical address of the machine\n     */\n    if ((rv = apr_gethostname(str, sizeof(str) - 1, p)) != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01563)\n          \"unable to find hostname of the server\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if ((rv = apr_sockaddr_info_get(&sockaddr, str, AF_INET, 0, 0, p)) == APR_SUCCESS) {\n        global_in_addr = sockaddr->sa.sin.sin_addr.s_addr;\n    }\n    else {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01564)\n                    \"unable to find IPv4 address of \\\"%s\\\"\", str);\n#if APR_HAVE_IPV6\n        if ((rv = apr_sockaddr_info_get(&sockaddr, str, AF_INET6, 0, 0, p)) == APR_SUCCESS) {\n            memcpy(&global_in_addr,\n                   (char *)sockaddr->ipaddr_ptr + sockaddr->ipaddr_len - sizeof(global_in_addr),\n                   sizeof(global_in_addr));\n            ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01565)\n                         \"using low-order bits of IPv6 address \"\n                         \"as if they were unique\");\n        }\n        else\n#endif\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    apr_sockaddr_ip_get(&ipaddrstr, sockaddr);\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, main_server, APLOGNO(01566) \"using ip addr %s\",\n                 ipaddrstr);\n\n    /*\n     * If the server is pummelled with restart requests we could possibly end\n     * up in a situation where we're starting again during the same second\n     * that has been used in previous identifiers.  Avoid that situation.\n     *\n     * In truth, for this to actually happen not only would it have to restart\n     * in the same second, but it would have to somehow get the same pids as\n     * one of the other servers that was running in that second. Which would\n     * mean a 64k wraparound on pids ... not very likely at all.\n     *\n     * But protecting against it is relatively cheap.  We just sleep into the\n     * next second.\n     */\n    apr_sleep(apr_time_from_sec(1) - apr_time_usec(apr_time_now()));\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_1cc8641233654ce9d5abaebf8d697330d3852287_0", {
    "ID": "httpd_1cc8641233654ce9d5abaebf8d697330d3852287_0",
    "UID": "8837",
    "code": "static void ap_dbd_sql_init(server_rec *s, const char test_snippet\n{\n    svr_cfg *svr;\n    const char **arr_item;\n\n    svr = ap_get_module_config(s->module_config, &dbd_module);\n    if (!svr) {\n         /* some modules may call from within config directive handlers, and\n          * if these are called in a server context that contains no mod_dbd\n          * config directives, then we have to create our own server config\n          */\n         svr = create_dbd_config(config_pool, s);\n         ap_set_module_config(s->module_config, &dbd_module, svr);\n    }\n\n    if (query) {\n        arr_item = apr_array_push(svr->cfg->init_queries);\n        *arr_item = query;\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_f9debb98af370e9a8e5ce9ccdeb71261d5d1ab92_0", {
    "ID": "httpd_f9debb98af370e9a8e5ce9ccdeb71261d5d1ab92_0",
    "UID": "8840",
    "code": "static char *get_path_param(apr_pool_t *pool, char test_snippet\n                            const char *name, int scolon_sep)\n{\n    char *path = NULL;\n    char *pathdelims = \"?&\";\n\n    if (scolon_sep) {\n        pathdelims = \";?&\";\n    }\n    for (path = strstr(url, name); path; path = strstr(path + 1, name)) {\n        path += strlen(name);\n        if (*path == '=') {\n            /*\n             * Session path was found, get its value\n             */\n            ++path;\n            if (*path) {\n                char *q;\n                path = apr_strtok(apr_pstrdup(pool, path), pathdelims, &q);\n                return path;\n            }\n        }\n    }\n    return NULL;\n}",
    "predicted": "23,Relative Path Traversal"
  },
  "httpd_72f0a185113d5db490c49e88a71ca2fa947b78de_0", {
    "ID": "httpd_72f0a185113d5db490c49e88a71ca2fa947b78de_0",
    "UID": "8842",
    "code": "APREQ_DECLARE(apr_status_t) apreq_param_decode(apreq_param_t test_snippet\n                                               apr_pool_t *pool,\n                                               const char *word,\n                                               apr_size_t nlen,\n                                               apr_size_t vlen)\n{\n    apr_status_t status;\n    apreq_value_t *v;\n    apreq_param_t *p;\n    apreq_charset_t charset;\n\n    if (nlen == 0) {\n        *param = NULL;\n        return APR_EBADARG;\n    }\n\n    p = apr_palloc(pool, nlen + vlen + 1 + sizeof *p);\n    p->info = NULL;\n    p->upload = NULL;\n    p->flags = 0;\n    *(const apreq_value_t **)&v = &p->v;\n\n    if (vlen > 0) {\n        status = apreq_decode(v->data, &v->dlen, word + nlen + 1, vlen);\n        if (status != APR_SUCCESS) {\n            *param = NULL;\n            return status;\n        }\n        charset = apreq_charset_divine(v->data, v->dlen);\n    }\n    else {\n        v->data[0] = 0;\n        v->dlen = 0;\n        charset = APREQ_CHARSET_ASCII;\n    }\n    v->name = v->data + vlen + 1;\n\n    status = apreq_decode(v->name, &v->nlen, word, nlen);\n    if (status != APR_SUCCESS) {\n        *param = NULL;\n        return status;\n    }\n\n    switch (apreq_charset_divine(v->name, v->nlen)) {\n    case APREQ_CHARSET_UTF8:\n        if (charset == APREQ_CHARSET_ASCII)\n            charset = APREQ_CHARSET_UTF8;\n    case APREQ_CHARSET_ASCII:\n        break;\n\n    case APREQ_CHARSET_LATIN1:\n        if (charset != APREQ_CHARSET_CP1252)\n            charset = APREQ_CHARSET_LATIN1;\n        break;\n    case APREQ_CHARSET_CP1252:\n        charset = APREQ_CHARSET_CP1252;\n    }\n\n    apreq_param_charset_set(p, charset);\n    *param = p;\n\n    return APR_SUCCESS;\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_c4cdc7bb5d1f6dec94f5297d2fbf8da23f323f4a_0", {
    "ID": "httpd_c4cdc7bb5d1f6dec94f5297d2fbf8da23f323f4a_0",
    "UID": "8846",
    "code": "static char *prompt(apreq_handle_t *handle, const char test_snippet\n                    const char *type) {\n    struct cgi_handle *req = (struct cgi_handle *)handle;\n    const char *defval = nullstr;\n    const char *label = NULL;\n    const char *cprompt;\n    char buf[MAX_PROMPT_NESTING_LEVELS][MAX_BUFFER_SIZE];\n    \n    char *start, curarg[MAX_PROMPT_NESTING_LEVELS] = \"\"; \n    \n    int plevel; \n\n    cprompt = req->promptstr - 1;\n    *buf[0] = plevel = 0;\n    start = buf[0];\n\n    while (*(++cprompt) != 0) {\n        switch (*cprompt) {\n        case '$':  \n            cprompt++;           \n            switch (*cprompt) {\n            case 't':\n                if (type != NULL) {\n                    strcpy(start, type);\n                    start += strlen(type);\n                    curarg[plevel] = 1;\n                } else {\n                    curarg[plevel] = curarg[plevel] | 0;\n                }\n                break;\n            case 'n':\n                /* Name can't be null :-) [If it can, we should \n                 * immediately return NULL] */\n                strcpy(start, name);\n                start += strlen(name);\n                curarg[plevel] = 1;\n                break;\n            case 'l':\n                if (label != NULL) {\n                    strcpy(start, label);\n                    start += strlen(label);\n                    curarg[plevel] = 1;\n                } else {\n                    curarg[plevel] = curarg[plevel] | 0;\n                }\n                break;\n            case 'd':\n                /* TODO: Once null defaults are available, \n                 * remove if and use nullstr if defval == NULL */\n                if (defval != NULL) {\n                    strcpy(start, defval);\n                    start += strlen(defval);\n                    curarg[plevel] = 1;\n                } else {\n                    curarg[plevel] = curarg[plevel] | 0;\n                }\n                break;\n            default:\n                \n                break;\n            }\n            break;\n\n        case '(':\n            if (plevel <= MAX_PROMPT_NESTING_LEVELS) {\n                plevel++;\n                curarg[plevel] = *buf[plevel] = 0;\n                start = buf[plevel];\n            }\n            \n            break;\n\n        case ')':\n            if (plevel > 0) {\n                *start = 0; \n                \n                \n                plevel--;\n                start = buf[plevel] + strlen(buf[plevel]);\n                \n                \n                if (curarg[plevel + 1]) {\n                    strcpy(start, buf[plevel + 1]);\n                    start += strlen(buf[plevel + 1]);\n                }\n\n                break;\n            }\n        case '\\\\': /* Check next character for escape sequence \n                    * (just ignore it for now) */\n            (void)*cprompt++;\n            \n\n        default:       \n            *start++ = *cprompt;\n        }\n    }\n\n    *start = 0; \n    \n    apr_file_printf(req->sout, \"%s\", buf[0]);\n    apr_file_gets(buf[0], MAX_BUFFER_SIZE, req->sin);\n    chomp(buf[0]);\n    if (strcmp(buf[0], \"\")) {\n\n            return apr_pstrdup(handle->pool, buf[0]);\n\n    }\n\n    if (defval != nullstr)\n        return apr_pstrdup(handle->pool, defval);\n\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_0ab078eb281e9febc979cb20ba5e81e301154d31_0", {
    "ID": "httpd_0ab078eb281e9febc979cb20ba5e81e301154d31_0",
    "UID": "8849",
    "code": "static void grow_gen_buffer(sed_eval_t *eval, int test_snippet\n                            char **gspend)\n{\n    if (gspend == NULL) {\n        gspend = &eval->genbuf;\n    }\n    grow_buffer(eval->pool, &eval->genbuf, gspend,\n                &eval->gsize, newsize);\n    eval->lcomend = &eval->genbuf[71];\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_0b5353b1354ae35be763e4265b46148b60c4645e_0", {
    "ID": "httpd_0b5353b1354ae35be763e4265b46148b60c4645e_0",
    "UID": "8850",
    "code": "static const char *ftp_escape_globbingchars(apr_pool_t *p, const char *path, proxy_ftp_dir_conf test_snippet\n{\n    char *ret;\n    char *d;\n\n    if (!dconf->ftp_escape_wildcards) {\n        return path;\n    }\n\n    ret = apr_palloc(p, 2*strlen(path)+sizeof(\"\"));\n    for (d = ret; *path; ++path) {\n        if (strchr(FTP_GLOBBING_CHARS, *path) != NULL)\n            *d++ = '\\\\';\n        *d++ = *path;\n    }\n    *d = '\\0';\n    return ret;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_b1c39fea166126eae3b0fc018742611c812f4600_0", {
    "ID": "httpd_b1c39fea166126eae3b0fc018742611c812f4600_0",
    "UID": "8857",
    "code": "APREQ_DECLARE(apr_status_t) apreq_register_parser(const char test_snippet\n                                                  apreq_parser_function_t pfn)\n{\n    apreq_parser_function_t *f = NULL;\n\n    if (default_parsers == NULL)\n        return APR_EINIT;\n\n    if (enctype == NULL)\n        return APR_EINVAL;\n\n    if (default_parsers_lock)\n        return APREQ_ERROR_GENERAL;\n\n    if (pfn != NULL) {\n        f = apr_palloc(default_parser_pool, sizeof *f);\n        *f = pfn;\n    }\n    apr_hash_set(default_parsers, apr_pstrdup(default_parser_pool, enctype),\n                 APR_HASH_KEY_STRING, f);\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_1c8f16e4d97b3649b8a2d70821ff12529df71fb7_0", {
    "ID": "httpd_1c8f16e4d97b3649b8a2d70821ff12529df71fb7_0",
    "UID": "8862",
    "code": "static apr_status_t sed_write_output(void *dummy, char *buf, int test_snippet\n{\n    /* dummy is basically filter context. Context is passed during invocation\n     * of sed_eval_buffer\n     */\n    int remainbytes = 0;\n    apr_status_t status = APR_SUCCESS;\n    sed_filter_ctxt *ctx = (sed_filter_ctxt *) dummy;\n    if (ctx->outbuf == NULL) {\n        alloc_outbuf(ctx);\n    }\n    remainbytes = ctx->bufsize - (ctx->curoutbuf - ctx->outbuf);\n    if (sz >= remainbytes) {\n        if (remainbytes > 0) {\n            memcpy(ctx->curoutbuf, buf, remainbytes);\n            buf += remainbytes;\n            sz -= remainbytes;\n            ctx->curoutbuf += remainbytes;\n        }\n        \n        status = append_bucket(ctx, ctx->outbuf, ctx->bufsize);\n        \n        alloc_outbuf(ctx);\n        /* if size is bigger than the allocated buffer directly add to output\n         * brigade */\n        if ((status == APR_SUCCESS) && (sz >= ctx->bufsize)) {\n            char* newbuf = apr_pmemdup(ctx->tpool, buf, test_snippet;\n            status = append_bucket(ctx, newbuf, test_snippet;\n            \n            if (ctx->outbuf == NULL) {\n                alloc_outbuf(ctx);\n            }\n        }\n        else {\n            memcpy(ctx->curoutbuf, buf, test_snippet;\n            ctx->curoutbuf += sz;\n        }\n    }\n    else {\n        memcpy(ctx->curoutbuf, buf, test_snippet;\n        ctx->curoutbuf += sz;\n    }\n    return status;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n122,Heap-based Buffer Overflow"
  },
  "httpd_bb7b65d43710f2fd96e093aebbbcc1703c23c972_0", {
    "ID": "httpd_bb7b65d43710f2fd96e093aebbbcc1703c23c972_0",
    "UID": "8863",
    "code": "static const char *parse_cmd(apr_pool_t *p, const char **args, ef_filter_t test_snippet\n{\n    if (**args == '\"') {\n        const char *start = *args + 1;\n        char *parms;\n        int escaping = 0;\n        apr_status_t rv;\n\n        ++*args; \n        \n        while (**args && (**args != '\"' || (**args == '\"' && escaping))) {\n            if (escaping) {\n                escaping = 0;\n            }\n            else if (**args == '\\\\') {\n                escaping = 1;\n            }\n            ++*args;\n        }\n        if (**args != '\"') {\n            return \"Expected cmd= delimiter\";\n        }\n        \n        parms = apr_pstrndup(p, start, *args - start);\n        ++*args; \n\n        \n        rv = apr_tokenize_to_argv(parms, &(filter->args), p);\n        if (rv != APR_SUCCESS) {\n            return \"cmd= parse error\";\n        }\n    }\n    else\n    {\n        \n        \n        filter->args = (char **)apr_palloc(p, 2 * sizeof(char *));\n        filter->args[0] = ap_getword_white(p, args);\n        filter->args[1] = NULL; \n    }\n    if (!filter->args[0]) {\n        return \"Invalid cmd= parameter\";\n    }\n    filter->command = filter->args[0];\n\n    return NULL;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_13d0ece0d75db06279827017c905caf3180fd09e_0", {
    "ID": "httpd_13d0ece0d75db06279827017c905caf3180fd09e_0",
    "UID": "8869",
    "code": "static APR_INLINE int response_is_html(request_rec test_snippet\n{\n    char *ctype = ap_field_noparam(r->pool, r->content_type);\n    ap_str_tolower(ctype);\n    return !strcmp(ctype, \"text/html\")\n        || !strcmp(ctype, \"application/xhtml+xml\");\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_731b1bddf6e162a00c0f903887c4757a4edbeb14_0", {
    "ID": "httpd_731b1bddf6e162a00c0f903887c4757a4edbeb14_0",
    "UID": "8870",
    "code": "static authn_status get_dbm_realm_hash(request_rec *r, const char test_snippet\n                                       const char *realm, char **rethash)\n{\n    authn_dbm_config_rec *conf = ap_get_module_config(r->per_dir_config,\n                                                      &authn_dbm_module);\n    apr_status_t rv;\n    char *dbm_hash;\n    char *colon_hash;\n\n    rv = fetch_dbm_value(conf->dbmtype, conf->pwfile,\n                         apr_pstrcat(r->pool, user, \":\", realm, NULL),\n                         &dbm_hash, r->pool);\n\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01755)\n                      \"Could not open dbm (type %s) hash file: %s\",\n                      conf->dbmtype, conf->pwfile);\n        return AUTH_GENERAL_ERROR;\n    }\n\n    if (!dbm_hash) {\n        return AUTH_USER_NOT_FOUND;\n    }\n\n    colon_hash = ap_strchr(dbm_hash, ':');\n    if (colon_hash) {\n        *colon_hash = '\\0';\n    }\n\n    *rethash = dbm_hash;\n    AUTHN_CACHE_STORE(r, user, realm, dbm_hash);\n\n    return AUTH_USER_FOUND;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_0f221273f443a0210f7610d456d940c653c9b4e8_0", {
    "ID": "httpd_0f221273f443a0210f7610d456d940c653c9b4e8_0",
    "UID": "8872",
    "code": "test_snippet\n{\n    apr_pool_t *pool = parser->pool;\n    apr_bucket *e;\n    struct hdr_ctx *ctx;\n\n    if (parser->ctx == NULL) {\n        ctx = apr_pcalloc(pool, sizeof *ctx);\n        ctx->bb = apr_brigade_create(pool, parser->bucket_alloc);\n        parser->ctx = ctx;\n        ctx->status = HDR_NAME;\n    }\n    else\n        ctx = parser->ctx;\n\n    PARSER_STATUS_CHECK(HDR);\n    e = APR_BRIGADE_LAST(ctx->bb);\n    APR_BRIGADE_CONCAT(ctx->bb, bb);\n\n parse_hdr_brigade:\n\n\n    /* parse the brigade for CRLF_CRLF-terminated header block,\n     * each time starting from the front of the brigade.\n     */\n\n    for (e = APR_BUCKET_NEXT(e);\n         e != APR_BRIGADE_SENTINEL(ctx->bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_size_t off = 0, dlen;\n        const char *data;\n        apr_status_t s;\n        apreq_param_t *param = NULL; \n\n        if (APR_BUCKET_IS_EOS(e)) {\n            ctx->status = HDR_COMPLETE;\n            APR_BRIGADE_CONCAT(bb, ctx->bb);\n            return APR_SUCCESS;\n        }\n        s = apr_bucket_read(e, &data, &dlen, APR_BLOCK_READ);\n\n        if ( s != APR_SUCCESS ) {\n            ctx->status = HDR_ERROR;\n            return s;\n        }\n        if (dlen == 0)\n            continue;\n\n    parse_hdr_bucket:\n\n        /*              gap           nlen = 13\n         *              vvv           glen =  3\n         * Sample-Header:  grape      vlen =  5\n         * ^^^^^^^^^^^^^   ^^^^^\n         *     name        value\n         */\n\n        switch (ctx->status) {\n\n        case HDR_NAME:\n\n            while (off < dlen) {\n                switch (data[off++]) {\n\n                case '\\n':\n                    if (off < dlen)\n                        apr_bucket_split(e, off);\n                    e = APR_BUCKET_NEXT(e);\n\n                    do {\n                        apr_bucket *f = APR_BRIGADE_FIRST(ctx->bb);\n                        apr_bucket_delete(f);\n                    } while (e != APR_BRIGADE_FIRST(ctx->bb));\n                    APR_BRIGADE_CONCAT(bb, ctx->bb);\n                    ctx->status = HDR_COMPLETE;\n                    return APR_SUCCESS;\n\n                case ':':\n                    if (off > 1) {\n                        apr_bucket_split(e, off - 1);\n                        dlen -= off - 1;\n                        data += off - 1;\n                        off = 1;\n                        e = APR_BUCKET_NEXT(e);\n                    }\n                    ++ctx->glen;\n                    ctx->status = HDR_GAP;\n                    goto parse_hdr_bucket;\n\n                default:\n                    ++ctx->nlen;\n                }\n\n            }\n\n            break;\n\n\n        case HDR_GAP:\n\n            while (off < dlen) {\n                switch (data[off++]) {\n                case ' ':\n                case '\\t':\n                    ++ctx->glen;\n                    break;\n\n                case '\\n':\n                    ctx->status = HDR_NEWLINE;\n                    goto parse_hdr_bucket;\n\n                default:\n                    ctx->status = HDR_VALUE;\n                    if (off > 1) {\n                        apr_bucket_split(e, off - 1);\n                        dlen -= off - 1;\n                        data += off - 1;\n                        off = 1;\n                        e = APR_BUCKET_NEXT(e);\n                    }\n                    ++ctx->vlen;\n                    goto parse_hdr_bucket;\n                }\n            }\n            break;\n\n\n        case HDR_VALUE:\n\n            while (off < dlen) {\n                ++ctx->vlen;\n                if (data[off++] == '\\n') {\n                    ctx->status = HDR_NEWLINE;\n                    goto parse_hdr_bucket;\n                }\n            }\n            break;\n\n\n        case HDR_NEWLINE:\n\n            if (off == dlen)\n                break;\n            else {\n                switch (data[off]) {\n\n                case ' ':\n                case '\\t':\n                    ctx->status = HDR_CONTINUE;\n                    ++off;\n                    ++ctx->vlen;\n                    break;\n\n                default:\n                    \n                    if (off > 0)\n                        apr_bucket_split(e, off);\n                    s = split_header_line(&param, pool, ctx->bb, ctx->nlen, ctx->glen, ctx->vlen);\n                    if (parser->hook != NULL && s == APR_SUCCESS)\n                        s = apreq_hook_run(parser->hook, param, NULL);\n\n                    if (s != APR_SUCCESS) {\n                        ctx->status = HDR_ERROR;\n                        return s;\n                    }\n\n                    apreq_value_table_add(&param->v, t);\n                    e = APR_BRIGADE_SENTINEL(ctx->bb);\n                    ctx->status = HDR_NAME;\n                    ctx->nlen = 0;\n                    ctx->vlen = 0;\n                    ctx->glen = 0;\n\n                    goto parse_hdr_brigade;\n                }\n\n                \n            }\n\n\n        case HDR_CONTINUE:\n\n            while (off < dlen) {\n                switch (data[off++]) {\n                case ' ':\n                case '\\t':\n                    ++ctx->vlen;\n                    break;\n\n                case '\\n':\n                    ctx->status = HDR_NEWLINE;\n                    goto parse_hdr_bucket;\n\n                default:\n                    ctx->status = HDR_VALUE;\n                    ++ctx->vlen;\n                    goto parse_hdr_bucket;\n                }\n            }\n            break;\n\n        default:\n            ; \n        }\n    }\n    apreq_brigade_setaside(ctx->bb,pool);\n    return APR_INCOMPLETE;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n606,Unchecked Input for Loop Condition"
  },
  "httpd_3ad24c2d34350e0a404bca5d9b19f080b7857f68_0", {
    "ID": "httpd_3ad24c2d34350e0a404bca5d9b19f080b7857f68_0",
    "UID": "8879",
    "code": "static void help(const char *argv, const char * header, const char test_snippet\n        const apr_getopt_option_t opts[])\n{\n    int i = 0;\n\n    if (header) {\n        printf(header, argv);\n    }\n\n    while (opts[i].name) {\n        printf(\"%s\\n\", opts[i].description);\n        i++;\n    }\n\n    if (footer) {\n        printf(\"%s\\n\", footer);\n    }\n}",
    "predicted": "134,Use of Externally-Controlled Format String"
  },
  "httpd_96f3ea2866f0569534a090b16d2ec986cf2545f4_0", {
    "ID": "httpd_96f3ea2866f0569534a090b16d2ec986cf2545f4_0",
    "UID": "8883",
    "code": "apr_status_t  ajp_parse_data(request_rec  *r, ajp_msg_t test_snippet\n                             apr_uint16_t *len, char **ptr)\n{\n    apr_byte_t result;\n    apr_status_t rc;\n    apr_uint16_t expected_len;\n\n    rc = ajp_msg_get_uint8(msg, &result);\n    if (rc != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00996)\n               \"ajp_parse_data: ajp_msg_get_byte failed\");\n        return rc;\n    }\n    if (result != CMD_AJP13_SEND_BODY_CHUNK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00997)\n               \"ajp_parse_data: wrong type %s (0x%02x) expecting %s (0x%02x)\",\n               ajp_type_str(result), result,\n               ajp_type_str(CMD_AJP13_SEND_BODY_CHUNK), CMD_AJP13_SEND_BODY_CHUNK);\n        return AJP_EBAD_HEADER;\n    }\n    rc = ajp_msg_get_uint16(msg, len);\n    if (rc != APR_SUCCESS) {\n        return rc;\n    }\n    /*\n     * msg->len contains the complete length of the message including all\n     * headers. So the expected length for a CMD_AJP13_SEND_BODY_CHUNK is\n     * msg->len minus the sum of\n     * AJP_HEADER_LEN    : The length of the header to every AJP message.\n     * AJP_HEADER_SZ_LEN : The header giving the size of the chunk.\n     * 1                 : The CMD_AJP13_SEND_BODY_CHUNK indicator byte (0x03).\n     * 1                 : The last byte of this message always seems to be\n     *                     0x00 and is not part of the chunk.\n     */\n    expected_len = msg->len - (AJP_HEADER_LEN + AJP_HEADER_SZ_LEN + 1 + 1);\n    if (*len != expected_len) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00998)\n               \"ajp_parse_data: Wrong chunk length. Length of chunk is %i,\"\n               \" expected length is %i.\", *len, expected_len);\n        return AJP_EBAD_HEADER;\n    }\n    *ptr = (char *)&(msg->buf[msg->pos]);\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_5cf77f5834232c8672f3bf87eaae91c453d506eb_0", {
    "ID": "httpd_5cf77f5834232c8672f3bf87eaae91c453d506eb_0",
    "UID": "8892",
    "code": "apr_status_t ajp_msg_get_uint16(ajp_msg_t *msg, apr_uint16_t test_snippet\n{\n    apr_uint16_t value;\n\n    if ((msg->pos + 1) > msg->len) {\n        return ajp_log_overflow(msg, \"ajp_msg_get_uint16\");\n    }\n\n    value  = ((msg->buf[(msg->pos++)] & 0xFF) << 8);\n    value += ((msg->buf[(msg->pos++)] & 0xFF));\n\n    *rvalue = value;\n    return APR_SUCCESS;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_d00fd0f399fc0aa877d105af418e299c9fe2b59b_0", {
    "ID": "httpd_d00fd0f399fc0aa877d105af418e299c9fe2b59b_0",
    "UID": "8893",
    "code": "apr_status_t  ajp_send_data_msg(apr_socket_t test_snippet\n                                ajp_msg_t *msg, apr_size_t len)\n{\n\n    msg->buf[4] = (apr_byte_t)((len >> 8) & 0xFF);\n    msg->buf[5] = (apr_byte_t)(len & 0xFF);\n\n    msg->len += len + 2; \n\n    return ajp_ilink_send(sock, msg);\n\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow"
  },
  "httpd_33c830cc6bde501a18dedef47c8e58d37d800162_0", {
    "ID": "httpd_33c830cc6bde501a18dedef47c8e58d37d800162_0",
    "UID": "8894",
    "code": "test_snippet\n{\n    apr_pool_t *pool = parser->pool;\n    apr_bucket *e;\n    struct url_ctx *ctx;\n\n    if (parser->ctx == NULL) {\n        ctx = apr_pcalloc(pool, sizeof *ctx);\n        ctx->bb = apr_brigade_create(pool, parser->bucket_alloc);\n        parser->ctx = ctx;\n        ctx->status = URL_NAME;\n    }\n    else\n        ctx = parser->ctx;\n\n    PARSER_STATUS_CHECK(URL);\n    e = APR_BRIGADE_LAST(ctx->bb);\n    APR_BRIGADE_CONCAT(ctx->bb, bb);\n\n parse_url_brigade:\n\n    for (e  = APR_BUCKET_NEXT(e);\n         e != APR_BRIGADE_SENTINEL(ctx->bb);\n         e  = APR_BUCKET_NEXT(e))\n    {\n        apreq_param_t *param;\n        apr_size_t off = 0, dlen;\n        const char *data;\n        apr_status_t s;\n\n        if (APR_BUCKET_IS_EOS(e)) {\n            if (ctx->status == URL_NAME) {\n                s = APR_SUCCESS;\n            }\n            else {\n                s = split_urlword(&param, pool, ctx->bb, ctx->nlen, ctx->vlen);\n                if (parser->hook != NULL && s == APR_SUCCESS)\n                    s = apreq_hook_run(parser->hook, param, NULL);\n\n                if (s == APR_SUCCESS) {\n                    apreq_value_table_add(&param->v, t);\n                    ctx->status = URL_COMPLETE;\n                }\n                else {\n                    ctx->status = URL_ERROR;\n                }\n            }\n\n            APR_BRIGADE_CONCAT(bb, ctx->bb);\n            return s;\n        }\n\n        s = apr_bucket_read(e, &data, &dlen, APR_BLOCK_READ);\n        if ( s != APR_SUCCESS ) {\n            ctx->status = URL_ERROR;\n            return s;\n        }\n\n    parse_url_bucket:\n\n        switch (ctx->status) {\n\n        case URL_NAME:\n            while (off < dlen) {\n                switch (data[off++]) {\n                case '=':\n                    apr_bucket_split(e, off);\n                    dlen -= off;\n                    data += off;\n                    off = 0;\n                    e = APR_BUCKET_NEXT(e);\n                    ctx->status = URL_VALUE;\n                    goto parse_url_bucket;\n                default:\n                    ++ctx->nlen;\n                }\n            }\n            break;\n\n        case URL_VALUE:\n            while (off < dlen) {\n\n                switch (data[off++]) {\n                case '&':\n                case ';':\n                    apr_bucket_split(e, off);\n                    s = split_urlword(&param, pool, ctx->bb,\n                                      ctx->nlen, ctx->vlen);\n                    if (parser->hook != NULL && s == APR_SUCCESS)\n                        s = apreq_hook_run(parser->hook, param, NULL);\n\n                    if (s != APR_SUCCESS) {\n                        ctx->status = URL_ERROR;\n                        return s;\n                    }\n\n                    apreq_value_table_add(&param->v, t);\n                    ctx->status = URL_NAME;\n                    ctx->nlen = 0;\n                    ctx->vlen = 0;\n                    e = APR_BRIGADE_SENTINEL(ctx->bb);\n                    goto parse_url_brigade;\n\n                default:\n                    ++ctx->vlen;\n                }\n            }\n            break;\n        default:\n            ; \n        }\n    }\n    apreq_brigade_setaside(ctx->bb, pool);\n    return APR_INCOMPLETE;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_348d4f38aff2b250edb1de8ee912d635c3366597_0", {
    "ID": "httpd_348d4f38aff2b250edb1de8ee912d635c3366597_0",
    "UID": "8900",
    "code": "static apr_status_t get_data(proxy_conn_rec test_snippet\n                             char *buffer,\n                             apr_size_t *buflen)\n{\n    apr_status_t rv = apr_socket_recv(conn->sock, buffer, buflen);\n\n    if (rv == APR_SUCCESS) {\n        conn->worker->s->read += *buflen;\n    }\n\n    return rv;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_b1d119dd034884d9a8a7650c5e54335416378f45_0", {
    "ID": "httpd_b1d119dd034884d9a8a7650c5e54335416378f45_0",
    "UID": "8911",
    "code": "AP_DECLARE_NONSTD(const char *)ap_set_mutex(cmd_parms *cmd, void test_snippet\n                                            const char *arg)\n{\n    apr_pool_t *p = cmd->pool;\n    const char **elt;\n    const char *mechdir;\n    int no_mutex = 0, omit_pid = 0;\n    apr_array_header_t *type_list;\n    apr_lockmech_e mech;\n    apr_status_t rv;\n    const char *mutexdir;\n    mutex_cfg_t *mxcfg;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    mechdir = ap_getword_conf(cmd->pool, &arg);\n    if (*mechdir == '\\0') {\n        return \"Mutex requires at least a mechanism argument (\"\n               AP_ALL_AVAILABLE_MUTEXES_STRING \")\";\n    }\n\n    rv = ap_parse_mutex(mechdir, p, &mech, &mutexdir);\n    if (rv == APR_ENOTIMPL) {\n        return apr_pstrcat(p, \"Invalid Mutex argument \", mechdir,\n                           \" (\" AP_ALL_AVAILABLE_MUTEXES_STRING \")\", NULL);\n    }\n    else if (rv == APR_BADARG\n             || (mutexdir && !ap_is_directory(p, mutexdir))) {\n        return apr_pstrcat(p, \"Invalid Mutex directory in argument \",\n                           mechdir, NULL);\n    }\n    else if (rv == APR_ENOLOCK) { \n        no_mutex = 1;\n    }\n\n    /* \"OmitPID\" can appear at the end of the list, so build a list of\n     * mutex type names while looking for \"OmitPID\" (anywhere) or the end\n     */\n    type_list = apr_array_make(cmd->pool, 4, sizeof(const char *));\n    while (*arg) {\n        const char *s = ap_getword_conf(cmd->pool, &arg);\n\n        if (!strcasecmp(s, \"omitpid\")) {\n            omit_pid = 1;\n        }\n        else {\n            const char **new_type = (const char **)apr_array_push(type_list);\n            *new_type = s;\n        }\n    }\n\n    if (apr_is_empty_array(type_list)) { \n        const char **new_type = (const char **)apr_array_push(type_list);\n        *new_type = \"default\";\n    }\n\n    while ((elt = (const char **)apr_array_pop(type_list)) != NULL) {\n        const char *type = *elt;\n        mxcfg = apr_hash_get(mxcfg_by_type, type, APR_HASH_KEY_STRING);\n        if (!mxcfg) {\n            return apr_psprintf(p, \"Mutex type %s is not valid\", type);\n        }\n\n        mxcfg->none = 0; \n        mxcfg->omit_pid = omit_pid;\n\n        mxcfg->set = 1;\n        if (no_mutex) {\n            if (!(mxcfg->options & AP_MUTEX_ALLOW_NONE)) {\n                return apr_psprintf(p,\n                                    \"None is not allowed for mutex type %s\",\n                                    type);\n            }\n            mxcfg->none = 1;\n        }\n        else {\n            mxcfg->mech = mech;\n            if (mutexdir) { \n                mxcfg->dir = mutexdir;\n            }\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "15,External Control of System or Configuration Setting\n23,Relative Path Traversal\n36,Absolute Path Traversal\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition\n672,Operation on a Resource after Expiration or Release\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_fe2ec88c8d4c77e78b137195adc86fa23e10fce7_0", {
    "ID": "httpd_fe2ec88c8d4c77e78b137195adc86fa23e10fce7_0",
    "UID": "8912",
    "code": "static char *get_cookie_param(request_rec *r, const char test_snippet\n{\n    const char *cookies;\n    const char *start_cookie;\n\n    if ((cookies = apr_table_get(r->headers_in, \"Cookie\"))) {\n        for (start_cookie = ap_strstr_c(cookies, name); start_cookie;\n             start_cookie = ap_strstr_c(start_cookie + 1, name)) {\n            if (start_cookie == cookies ||\n                start_cookie[-1] == ';' ||\n                start_cookie[-1] == ',' ||\n                isspace(start_cookie[-1])) {\n\n                start_cookie += strlen(name);\n                while(*start_cookie && isspace(*start_cookie))\n                    ++start_cookie;\n                if (*start_cookie++ == '=' && *start_cookie) {\n                    /*\n                     * Session cookie was found, get its value\n                     */\n                    char *end_cookie, *cookie;\n                    cookie = apr_pstrdup(r->pool, start_cookie);\n                    if ((end_cookie = strchr(cookie, ';')) != NULL)\n                        *end_cookie = '\\0';\n                    if((end_cookie = strchr(cookie, ',')) != NULL)\n                        *end_cookie = '\\0';\n                    return cookie;\n                }\n            }\n        }\n    }\n    return NULL;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n20,Improper Input Validation"
  },
  "httpd_e639d2e965684b057d917396376a02823d39210f_0", {
    "ID": "httpd_e639d2e965684b057d917396376a02823d39210f_0",
    "UID": "8915",
    "code": "static void store_slotmem(ap_slotmem_instance_t test_snippet\n{\n    apr_file_t *fp;\n    apr_status_t rv;\n    apr_size_t nbytes;\n    const char *storename;\n\n    storename = store_filename(slotmem->gpool, slotmem->name);\n\n    if (storename) {\n        rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                           APR_OS_DEFAULT, slotmem->gpool);\n        if (APR_STATUS_IS_EEXIST(rv)) {\n            apr_file_remove(storename, slotmem->gpool);\n            rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                               APR_OS_DEFAULT, slotmem->gpool);\n        }\n        if (rv != APR_SUCCESS) {\n            return;\n        }\n        nbytes = (slotmem->desc.size * slotmem->desc.num) +\n                 (slotmem->desc.num * sizeof(char)) + AP_UNSIGNEDINT_OFFSET;\n        apr_file_write(fp, slotmem->persist, &nbytes);\n        apr_file_close(fp);\n    }\n}",
    "predicted": "252,Unchecked Return Value\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_374683555ff6ff34960bf7d4ad33195c25db954f_0", {
    "ID": "httpd_374683555ff6ff34960bf7d4ad33195c25db954f_0",
    "UID": "8926",
    "code": "static const char *add_redirect_internal(cmd_parms test_snippet\n                                         alias_dir_conf *dirconf,\n                                         const char *arg1, const char *arg2,\n                                         const char *arg3, int use_regex)\n{\n    alias_entry *new;\n    server_rec *s = cmd->server;\n    alias_server_conf *serverconf = ap_get_module_config(s->module_config,\n                                                         &alias_module);\n    int status = (int) (long) cmd->info;\n    int grokarg1 = 1;\n    ap_regex_t *regex = NULL;\n    const char *fake = arg2;\n    const char *url = arg3;\n\n    /*\n     * Logic flow:\n     *   Go ahead and try to grok the 1st arg, in case it is a\n     *   Redirect status. Now if we have 3 args, we expect that\n     *   we were able to understand that 1st argument (it's something\n     *   we expected, so if not, then we bail\n     */\n    if (!strcasecmp(arg1, \"permanent\"))\n        status = HTTP_MOVED_PERMANENTLY;\n    else if (!strcasecmp(arg1, \"temp\"))\n        status = HTTP_MOVED_TEMPORARILY;\n    else if (!strcasecmp(arg1, \"seeother\"))\n        status = HTTP_SEE_OTHER;\n    else if (!strcasecmp(arg1, \"gone\"))\n        status = HTTP_GONE;\n    else if (apr_isdigit(*arg1))\n        status = atoi(arg1);\n    else\n        grokarg1 = 0;\n\n    if (arg3 && !grokarg1)\n        return \"Redirect: invalid first argument (of three)\";\n\n    /*\n     * if we don't have the 3rd arg and we didn't understand the 1st\n     * one, then assume URL-path URL. This also handles case, eg, GONE\n     * we even though we don't have a 3rd arg, we did understand the 1st\n     * one, so we don't want to re-arrange\n     */\n    if (!arg3 && !grokarg1) {\n        fake = arg1;\n        url = arg2;\n    }\n\n    if (use_regex) {\n        regex = ap_pregcomp(cmd->pool, fake, AP_REG_EXTENDED);\n        if (regex == NULL)\n            return \"Regular expression could not be compiled.\";\n    }\n\n    if (ap_is_HTTP_REDIRECT(status)) {\n        if (!url)\n            return \"URL to redirect to is missing\";\n        /* PR#35314: we can allow path components here;\n         * they get correctly resolved to full URLs.\n         */\n        if (!use_regex && !ap_is_url(url) && (url[0] != '/'))\n            return \"Redirect to non-URL\";\n    }\n    else {\n        if (url)\n            return \"Redirect URL not valid for this status\";\n    }\n\n    if (cmd->path)\n        new = apr_array_push(dirconf->redirects);\n    else\n        new = apr_array_push(serverconf->redirects);\n\n    new->fake = fake;\n    new->real = url;\n    new->regexp = regex;\n    new->redir_status = status;\n    return NULL;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_b0391e1e6e988ee9563774a31d4a63dbf25dc335_0", {
    "ID": "httpd_b0391e1e6e988ee9563774a31d4a63dbf25dc335_0",
    "UID": "8933",
    "code": "static const char *start_ifversion(cmd_parms *cmd, void test_snippet\n                                   const char *arg1, const char *arg2,\n                                   const char *arg3)\n{\n    const char *endp;\n    int reverse = 0, done = 0, match = 0, compare;\n    const char *p, *error;\n    char c;\n\n    \n    if (!arg2) {\n        arg2 = arg1;\n        arg1 = \"=\";\n    }\n\n    \n    if (!arg3 && *arg2 == '>' && !arg2[1]) {\n        arg3 = \">\";\n        arg2 = arg1;\n        arg1 = \"=\";\n    }\n\n    /* the third argument makes version surrounding quotes plus operator\n     * possible.\n     */\n    endp = arg2 + strlen(arg2);\n    if (   endp == arg2\n        || (!(arg3 && *arg3 == '>' && !arg3[1]) && *--endp != '>')) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive missing closing '>'\", NULL);\n    }\n\n    p = arg1;\n    if (*p == '!') {\n        reverse = 1;\n        if (p[1]) {\n            ++p;\n        }\n    }\n\n    c = *p++;\n    if (!*p || (*p == '=' && !p[1] && c != '~')) {\n        if (!httpd_version.major) {\n            ap_get_server_revision(&httpd_version);\n        }\n\n        done = 1;\n        switch (c) {\n        case '=':\n            \n            if (*arg2 != '/') {\n                compare = compare_version(apr_pstrmemdup(cmd->temp_pool, arg2,\n                                                         endp-arg2),\n                                          &error);\n                if (error) {\n                    return error;\n                }\n\n                match = !compare;\n                break;\n            }\n\n            \n            if (endp == ++arg2 || *--endp != '/') {\n                return \"Missing delimiting / of regular expression.\";\n            }\n\n        case '~':\n            \n            match = match_version(cmd->temp_pool,\n                                  apr_pstrmemdup(cmd->temp_pool, arg2,\n                                                 endp-arg2),\n                                  &error);\n            if (error) {\n                return error;\n            }\n            break;\n\n        case '<':\n            compare = compare_version(apr_pstrmemdup(cmd->temp_pool, arg2,\n                                                     endp-arg2),\n                                      &error);\n            if (error) {\n                return error;\n            }\n\n            match = ((-1 == compare) || (*p && !compare));\n            break;\n\n        case '>':\n            compare = compare_version(apr_pstrmemdup(cmd->temp_pool, arg2,\n                                                     endp-arg2),\n                                      &error);\n            if (error) {\n                return error;\n            }\n\n            match = ((1 == compare) || (*p && !compare));\n            break;\n\n        default:\n            done = 0;\n            break;\n        }\n    }\n\n    if (!done) {\n        return apr_pstrcat(cmd->pool, \"unrecognized operator '\", arg1, \"'\",\n                           NULL);\n    }\n\n    if ((!reverse && match) || (reverse && !match)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, \"<IfVersion\");\n        *(ap_directive_t **)mconfig = current;\n        return retval;\n    }\n\n    *(ap_directive_t **)mconfig = NULL;\n    return ap_soak_end_container(cmd, \"<IfVersion\");\n}",
    "predicted": "476,NULL Pointer Dereference\n253,Incorrect Check of Function Return Value\n252,Unchecked Return Value"
  },
  "httpd_e1753605cdf559748ee7d9c37cd6bc7250f0d435_0", {
    "ID": "httpd_e1753605cdf559748ee7d9c37cd6bc7250f0d435_0",
    "UID": "8940",
    "code": "static int dav_core_is_writable(const dav_resource *resource, int test_snippet\n{\n    const dav_liveprop_spec *info;\n\n    (void) dav_get_liveprop_info(propid, &dav_core_liveprop_group, &info);\n    return info->is_writable;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_0e2e39731233f006cca1e5e6df59232e98db9e11_0", {
    "ID": "httpd_0e2e39731233f006cca1e5e6df59232e98db9e11_0",
    "UID": "8948",
    "code": "apr_status_t ajp_msg_get_uint8(ajp_msg_t *msg, apr_byte_t test_snippet\n{\n\n    if (msg->pos > msg->len) {\n        return ajp_log_overflow(msg, \"ajp_msg_get_uint8\");\n    }\n\n    *rvalue = msg->buf[msg->pos++];\n    return APR_SUCCESS;\n}",
    "predicted": "126,Buffer Over-read"
  },
  "httpd_286c865b10f3277e3271b4c380225c363836518b_0", {
    "ID": "httpd_286c865b10f3277e3271b4c380225c363836518b_0",
    "UID": "8950",
    "code": "static void dechain(sed_label_t *lpt, sed_reptr_t test_snippet\n{\n    sed_reptr_t *rep;\n    if ((lpt == NULL) || (lpt->chain == NULL) || (address == NULL))\n        return;\n    rep = lpt->chain;\n    while (rep->lb1) {\n        sed_reptr_t *next;\n\n        next = rep->lb1;\n        rep->lb1 = address;\n        rep = next;\n    }\n    rep->lb1 = address;\n    lpt->chain = NULL;\n}",
    "predicted": "416,Use After Free"
  },
  "httpd_e94f1427e2c351a4cb527fefe65484a035837932_0", {
    "ID": "httpd_e94f1427e2c351a4cb527fefe65484a035837932_0",
    "UID": "8951",
    "code": "static int socache_mc_id2key(ap_socache_instance_t test_snippet\n                             const unsigned char *id, unsigned int idlen,\n                             char *key, apr_size_t keylen)\n{\n    char *cp;\n    unsigned int n;\n\n    if (idlen * 2 + ctx->taglen >= keylen)\n        return 1;\n\n    cp = apr_cpystrn(key, ctx->tag, ctx->taglen);\n\n    for (n = 0; n < idlen; n++) {\n        apr_snprintf(cp, 3, \"%02X\", (unsigned) id[n]);\n        cp += 2;\n    }\n\n    *cp = '\\0';\n    return 0;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_2f23bb2a2520da419c10d9b283fb5410121a3806_0", {
    "ID": "httpd_2f23bb2a2520da419c10d9b283fb5410121a3806_0",
    "UID": "8952",
    "code": "static int clear_conn_headers(void *data, const char *key, const char test_snippet\n{\n    apr_table_t *headers = ((header_dptr*)data)->table;\n    apr_pool_t *pool = ((header_dptr*)data)->pool;\n    const char *name;\n    char *next = apr_pstrdup(pool, val);\n    while (*next) {\n        name = next;\n        while (*next && !apr_isspace(*next) && (*next != ',')) {\n            ++next;\n        }\n        while (*next && (apr_isspace(*next) || (*next == ','))) {\n            *next++ = '\\0';\n        }\n        apr_table_unset(headers, name);\n    }\n    return 1;\n}",
    "predicted": "415,Double Free\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_0987b4ccc3b8b669c64ecf133fd9c5c390daf04a_0", {
    "ID": "httpd_0987b4ccc3b8b669c64ecf133fd9c5c390daf04a_0",
    "UID": "8969",
    "code": "static const char *unwrap_header(apr_pool_t *p, const char test_snippet\n{\n    if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) {\n        char *ptr;\n\n        hdr = ptr = apr_pstrdup(p, hdr);\n\n        do {\n            if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n                *ptr = APR_ASCII_BLANK;\n        } while (*ptr++);\n    }\n    return hdr;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_7051ce69ee615bd08893dc917ea31c29b98035cd_0", {
    "ID": "httpd_7051ce69ee615bd08893dc917ea31c29b98035cd_0",
    "UID": "8975",
    "code": "static int ftp_check_string(const char test_snippet\n{\n    int i, ch = 0;\n#if APR_CHARSET_EBCDIC\n    char buf[1];\n#endif\n\n    for (i = 0; x[i] != '\\0'; i++) {\n        ch = x[i];\n        if (ch == '%' && apr_isxdigit(x[i + 1]) && apr_isxdigit(x[i + 2])) {\n            ch = ap_proxy_hex2c(&x[i + 1]);\n            i += 2;\n        }\n#if !APR_CHARSET_EBCDIC\n        if (ch == '\\015' || ch == '\\012' || (ch & 0x80))\n#else                           \n        if (ch == '\\r' || ch == '\\n')\n            return 0;\n        buf[0] = ch;\n        ap_xlate_proto_to_ascii(buf, 1);\n        if (buf[0] & 0x80)\n#endif                          \n            return 0;\n    }\n    return 1;\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_bee6373d7fad7c9bdd2d0e3bea41f0d4cb1d271c_0", {
    "ID": "httpd_bee6373d7fad7c9bdd2d0e3bea41f0d4cb1d271c_0",
    "UID": "8987",
    "code": "static int param_push(void *data, const char *key, const char test_snippet\n{\n    apr_array_header_t *arr = data;\n    *(apreq_param_t **)apr_array_push(arr) =\n        apreq_value_to_param(val);\n    return 1;   \n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9bff29fbdbf852ebd12bf184138c1b892a19d408_0", {
    "ID": "httpd_9bff29fbdbf852ebd12bf184138c1b892a19d408_0",
    "UID": "8992",
    "code": "static int check_speling(request_rec test_snippet\n{\n    spconfig *cfg;\n    char *good, *bad, *postgood, *url;\n    apr_finfo_t dirent;\n    int filoc, dotloc, urlen, pglen;\n    apr_array_header_t *candidates = NULL;\n    apr_dir_t          *dir;\n\n    cfg = ap_get_module_config(r->per_dir_config, &speling_module);\n    if (!cfg->enabled) {\n        return DECLINED;\n    }\n\n    \n    if (r->method_number != M_GET) {\n        return DECLINED;\n    }\n\n    \n    if (r->finfo.filetype != APR_NOFILE) {\n        return DECLINED;\n    }\n\n    \n    if (r->proxyreq || !r->filename) {\n        return DECLINED;\n    }\n\n    \n    if (r->main) {\n        return DECLINED;\n    }\n\n    /*\n     * The request should end up looking like this:\n     * r->uri: /correct-url/mispelling/more\n     * r->filename: /correct-file/mispelling r->path_info: /more\n     *\n     * So we do this in steps. First break r->filename into two pieces\n     */\n\n    filoc = ap_rind(r->filename, '/');\n    /*\n     * Don't do anything if the request doesn't contain a slash, or\n     * requests \"/\"\n     */\n    if (filoc == -1 || strcmp(r->uri, \"/\") == 0) {\n        return DECLINED;\n    }\n\n    \n    good = apr_pstrndup(r->pool, r->filename, filoc);\n    \n    bad = apr_pstrdup(r->pool, r->filename + filoc + 1);\n    \n    postgood = apr_pstrcat(r->pool, bad, r->path_info, NULL);\n\n    urlen = strlen(r->uri);\n    pglen = strlen(postgood);\n\n    \n    if (strcmp(postgood, r->uri + (urlen - pglen))) {\n        return DECLINED;\n    }\n\n    \n    url = apr_pstrndup(r->pool, r->uri, (urlen - pglen));\n\n    \n    if (apr_dir_open(&dir, good, r->pool) != APR_SUCCESS) {\n        \n        return DECLINED;\n    }\n\n    candidates = apr_array_make(r->pool, 2, sizeof(misspelled_file));\n\n    dotloc = ap_ind(bad, '.');\n    if (dotloc == -1) {\n        dotloc = strlen(bad);\n    }\n\n    while (apr_dir_read(&dirent, APR_FINFO_DIRENT, dir) == APR_SUCCESS) {\n        sp_reason q;\n\n        /*\n         * If we end up with a \"fixed\" URL which is identical to the\n         * requested one, we must have found a broken symlink or some such.\n         * Do _not_ try to redirect this, it causes a loop!\n         */\n        if (strcmp(bad, dirent.name) == 0) {\n            apr_dir_close(dir);\n            return OK;\n        }\n\n        /*\n         * miscapitalization errors are checked first (like, e.g., lower case\n         * file, upper case request)\n         */\n        else if (strcasecmp(bad, dirent.name) == 0) {\n            misspelled_file *sp_new;\n\n            sp_new = (misspelled_file *) apr_array_push(candidates);\n            sp_new->name = apr_pstrdup(r->pool, dirent.name);\n            sp_new->quality = SP_MISCAPITALIZED;\n        }\n\n        /*\n         * simple typing errors are checked next (like, e.g.,\n         * missing/extra/transposed char)\n         */\n        else if ((cfg->case_only == 0)\n                 && ((q = spdist(bad, dirent.name)) != SP_VERYDIFFERENT)) {\n            misspelled_file *sp_new;\n\n            sp_new = (misspelled_file *) apr_array_push(candidates);\n            sp_new->name = apr_pstrdup(r->pool, dirent.name);\n            sp_new->quality = q;\n        }\n\n        /*\n         * The spdist() should have found the majority of the misspelled\n         * requests.  It is of questionable use to continue looking for\n         * files with the same base name, but potentially of totally wrong\n         * type (index.html <-> index.db).\n         * I would propose to not set the WANT_BASENAME_MATCH define.\n         *      08-Aug-1997 <Martin.Kraemer@Mch.SNI.De>\n         *\n         * However, Alexei replied giving some reasons to add it anyway:\n         * > Oh, by the way, I remembered why having the\n         * > extension-stripping-and-matching stuff is a good idea:\n         * >\n         * > If you're using MultiViews, and have a file named foobar.html,\n         * > which you refer to as \"foobar\", and someone tried to access\n         * > \"Foobar\", mod_speling won't find it, because it won't find\n         * > anything matching that spelling. With the extension-munging,\n         * > it would locate \"foobar.html\". Not perfect, but I ran into\n         * > that problem when I first wrote the module.\n         */\n        else {\n#ifdef WANT_BASENAME_MATCH\n            /*\n             * Okay... we didn't find anything. Now we take out the hard-core\n             * power tools. There are several cases here. Someone might have\n             * entered a wrong extension (.htm instead of .html or vice\n             * versa) or the document could be negotiated. At any rate, now\n             * we just compare stuff before the first dot. If it matches, we\n             * figure we got us a match. This can result in wrong things if\n             * there are files of different content types but the same prefix\n             * (e.g. foo.gif and foo.html) This code will pick the first one\n             * it finds. Better than a Not Found, though.\n             */\n            int entloc = ap_ind(dirent.name, '.');\n            if (entloc == -1) {\n                entloc = strlen(dirent.name);\n            }\n\n            if ((dotloc == entloc)\n                && !strncasecmp(bad, dirent.name, dotloc)) {\n                misspelled_file *sp_new;\n\n                sp_new = (misspelled_file *) apr_array_push(candidates);\n                sp_new->name = apr_pstrdup(r->pool, dirent.name);\n                sp_new->quality = SP_VERYDIFFERENT;\n            }\n#endif\n        }\n    }\n    apr_dir_close(dir);\n\n    if (candidates->nelts != 0) {\n        \n        char *nuri;\n        const char *ref;\n        misspelled_file *variant = (misspelled_file *) candidates->elts;\n        int i;\n\n        ref = apr_table_get(r->headers_in, \"Referer\");\n\n        qsort((void *) candidates->elts, candidates->nelts,\n              sizeof(misspelled_file), sort_by_quality);\n\n        /*\n         * Conditions for immediate redirection:\n         *     a) the first candidate was not found by stripping the suffix\n         * AND b) there exists only one candidate OR the best match is not\n         *        ambiguous\n         * then return a redirection right away.\n         */\n        if (variant[0].quality != SP_VERYDIFFERENT\n            && (candidates->nelts == 1\n                || variant[0].quality != variant[1].quality)) {\n\n            nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url,\n                                                     variant[0].name,\n                                                     r->path_info, NULL));\n            if (r->parsed_uri.query)\n                nuri = apr_pstrcat(r->pool, nuri, \"?\", r->parsed_uri.query, NULL);\n\n            apr_table_setn(r->headers_out, \"Location\",\n                          ap_construct_url(r->pool, nuri, r));\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS,\n                          r,\n                          ref ? \"Fixed spelling: %s to %s from %s\"\n                              : \"Fixed spelling: %s to %s\",\n                          r->uri, nuri, ref);\n\n            return HTTP_MOVED_PERMANENTLY;\n        }\n        /*\n         * Otherwise, a \"[300] Multiple Choices\" list with the variants is\n         * returned.\n         */\n        else {\n            apr_pool_t *p;\n            apr_table_t *notes;\n            apr_pool_t *sub_pool;\n            apr_array_header_t *t;\n            apr_array_header_t *v;\n\n\n            if (r->main == NULL) {\n                p = r->pool;\n                notes = r->notes;\n            }\n            else {\n                p = r->main->pool;\n                notes = r->main->notes;\n            }\n\n            if (apr_pool_create(&sub_pool, p) != APR_SUCCESS)\n                return DECLINED;\n\n            t = apr_array_make(sub_pool, candidates->nelts * 8 + 8,\n                              sizeof(char *));\n            v = apr_array_make(sub_pool, candidates->nelts * 5,\n                              sizeof(char *));\n\n            \n\n            *(const char **)apr_array_push(t) =\n                          \"The document name you requested (<code>\";\n            *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, r->uri);\n            *(const char **)apr_array_push(t) =\n                           \"</code>) could not be found on this server.\\n\"\n                           \"However, we found documents with names similar \"\n                           \"to the one you requested.<p>\"\n                           \"Available documents:\\n<ul>\\n\";\n\n            for (i = 0; i < candidates->nelts; ++i) {\n                char *vuri;\n                const char *reason;\n\n                reason = sp_reason_str[(int) (variant[i].quality)];\n                \n                vuri = apr_pstrcat(sub_pool, url, variant[i].name, r->path_info,\n                                  (r->parsed_uri.query != NULL) ? \"?\" : \"\",\n                                  (r->parsed_uri.query != NULL)\n                                      ? r->parsed_uri.query : \"\",\n                                  NULL);\n                *(const char **)apr_array_push(v) = \"\\\"\";\n                *(const char **)apr_array_push(v) = ap_escape_uri(sub_pool, vuri);\n                *(const char **)apr_array_push(v) = \"\\\";\\\"\";\n                *(const char **)apr_array_push(v) = reason;\n                *(const char **)apr_array_push(v) = \"\\\"\";\n\n                *(const char **)apr_array_push(t) = \"<li><a href=\\\"\";\n                *(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, vuri);\n                *(const char **)apr_array_push(t) = \"\\\">\";\n                *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, vuri);\n                *(const char **)apr_array_push(t) = \"</a> (\";\n                *(const char **)apr_array_push(t) = reason;\n                *(const char **)apr_array_push(t) = \")\\n\";\n\n                /*\n                 * when we have printed the \"close matches\" and there are\n                 * more \"distant matches\" (matched by stripping the suffix),\n                 * then we insert an additional separator text to suggest\n                 * that the user LOOK CLOSELY whether these are really the\n                 * files she wanted.\n                 */\n                if (i > 0 && i < candidates->nelts - 1\n                    && variant[i].quality != SP_VERYDIFFERENT\n                    && variant[i + 1].quality == SP_VERYDIFFERENT) {\n                    *(const char **)apr_array_push(t) =\n                                   \"</ul>\\nFurthermore, the following related \"\n                                   \"documents were found:\\n<ul>\\n\";\n                }\n            }\n            *(const char **)apr_array_push(t) = \"</ul>\\n\";\n\n            \n            if (ref != NULL) {\n                *(const char **)apr_array_push(t) =\n                               \"Please consider informing the owner of the \"\n                               \"<a href=\\\"\";\n                *(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, ref);\n                *(const char **)apr_array_push(t) = \"\\\">referring page</a> \"\n                               \"about the broken link.\\n\";\n            }\n\n\n            \n            apr_table_setn(notes, \"variant-list\", apr_array_pstrcat(p, t, 0));\n\n            apr_table_mergen(r->subprocess_env, \"VARIANTS\",\n                            apr_array_pstrcat(p, v, ','));\n\n            apr_pool_destroy(sub_pool);\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                         ref ? \"Spelling fix: %s: %d candidates from %s\"\n                             : \"Spelling fix: %s: %d candidates\",\n                         r->uri, candidates->nelts, ref);\n\n            return HTTP_MULTIPLE_CHOICES;\n        }\n    }\n\n    return OK;\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_e1bdac4f51b171356e850163abe0ff99475f1d3b_0", {
    "ID": "httpd_e1bdac4f51b171356e850163abe0ff99475f1d3b_0",
    "UID": "9003",
    "code": "static int proxy_connect_handler(request_rec *r, proxy_worker test_snippet\n                                 proxy_server_conf *conf,\n                                 char *url, const char *proxyname,\n                                 apr_port_t proxyport)\n{\n    connect_conf *c_conf =\n        ap_get_module_config(r->server->module_config, &proxy_connect_module);\n\n    apr_pool_t *p = r->pool;\n    apr_socket_t *sock;\n    conn_rec *c = r->connection;\n    conn_rec *backconn;\n\n    apr_bucket_brigade *bb = apr_brigade_create(p, c->bucket_alloc);\n    apr_status_t err, rv;\n    apr_size_t nbytes;\n    char buffer[HUGE_STRING_LEN];\n    apr_socket_t *client_socket = ap_get_conn_socket(c);\n    int failed, rc;\n    int client_error = 0;\n    apr_pollset_t *pollset;\n    apr_pollfd_t pollfd;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    apr_sockaddr_t *uri_addr, *connect_addr;\n\n    apr_uri_t uri;\n    const char *connectname;\n    int connectport = 0;\n\n    \n    if (r->method_number != M_CONNECT) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"declining URL %s\", url);\n        return DECLINED;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"serving URL %s\", url);\n\n\n    /*\n     * Step One: Determine Who To Connect To\n     *\n     * Break up the URL to determine the host to connect to\n     */\n\n    \n    if (APR_SUCCESS != apr_uri_parse_hostinfo(p, url, &uri)) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p, \"URI cannot be parsed: \", url,\n                                         NULL));\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019)\n                  \"connecting %s to %s:%d\", url, uri.hostname, uri.port);\n\n    \n    err = apr_sockaddr_info_get(&uri_addr, uri.hostname, APR_UNSPEC, uri.port,\n                                0, p);\n    if (APR_SUCCESS != err) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, \"DNS lookup failure for: \",\n                                         uri.hostname, NULL));\n    }\n\n    \n    if (proxyname) {\n        connectname = proxyname;\n        connectport = proxyport;\n        err = apr_sockaddr_info_get(&connect_addr, proxyname, APR_UNSPEC,\n                                    proxyport, 0, p);\n    }\n    else {\n        connectname = uri.hostname;\n        connectport = uri.port;\n        connect_addr = uri_addr;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  \"connecting to remote proxy %s on port %d\",\n                  connectname, connectport);\n\n    \n    if (OK != ap_proxy_checkproxyblock(r, conf, uri_addr)) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n\n    \n    if(!allowed_port(c_conf, uri.port)) {\n              return ap_proxyerror(r, HTTP_FORBIDDEN,\n                                   \"Connect to remote machine blocked\");\n    }\n\n    /*\n     * Step Two: Make the Connection\n     *\n     * We have determined who to connect to. Now make the connection.\n     */\n\n    /* get all the possible IP addresses for the destname and loop through them\n     * until we get a successful connection\n     */\n    if (APR_SUCCESS != err) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, \"DNS lookup failure for: \",\n                                         connectname, NULL));\n    }\n\n    /*\n     * At this point we have a list of one or more IP addresses of\n     * the machine to connect to. If configured, reorder this\n     * list so that the \"best candidate\" is first try. \"best\n     * candidate\" could mean the least loaded server, the fastest\n     * responding server, whatever.\n     *\n     * For now we do nothing, ie we get DNS round robin.\n     * XXX FIXME\n     */\n    failed = ap_proxy_connect_to_backend(&sock, \"CONNECT\", connect_addr,\n                                         connectname, conf, r);\n\n    \n    if (failed) {\n        if (proxyname) {\n            return DECLINED;\n        }\n        else {\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n    }\n\n    \n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"setting up poll()\");\n\n    if ((rv = apr_pollset_create(&pollset, 2, r->pool, 0)) != APR_SUCCESS) {\n        apr_socket_close(sock);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01020)\n                      \"error apr_pollset_create()\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    \n    pollfd.p = r->pool;\n    pollfd.desc_type = APR_POLL_SOCKET;\n    pollfd.reqevents = APR_POLLIN;\n    pollfd.desc.s = client_socket;\n    pollfd.client_data = NULL;\n    apr_pollset_add(pollset, &pollfd);\n\n    \n    pollfd.desc.s = sock;\n    apr_pollset_add(pollset, &pollfd);\n\n    /*\n     * Step Three: Send the Request\n     *\n     * Send the HTTP/1.1 CONNECT request to the remote server\n     */\n\n    backconn = ap_run_create_connection(c->pool, r->server, sock,\n                                        c->id, c->sbh, c->bucket_alloc);\n    if (!backconn) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021)\n                      \"an error occurred creating a new connection \"\n                      \"to %pI (%s)\", connect_addr, connectname);\n        apr_socket_close(sock);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    ap_proxy_ssl_disable(backconn);\n    rc = ap_run_pre_connection(backconn, sock);\n    if (rc != OK && rc != DONE) {\n        backconn->aborted = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022)\n                      \"pre_connection setup failed (%d)\", rc);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  \"connection complete to %pI (%s)\",\n                  connect_addr, connectname);\n    apr_table_setn(r->notes, \"proxy-source-port\", apr_psprintf(r->pool, \"%hu\",\n                   backconn->local_addr->port));\n\n    /* If we are connecting through a remote proxy, we need to pass\n     * the CONNECT request on to it.\n     */\n    if (proxyport) {\n    /* FIXME: Error checking ignored.\n     */\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"sending the CONNECT request to the remote proxy\");\n        ap_fprintf(backconn->output_filters, bb,\n                   \"CONNECT %s HTTP/1.0\" CRLF, r->uri);\n        ap_fprintf(backconn->output_filters, bb,\n                   \"Proxy-agent: %s\" CRLF CRLF, ap_get_server_banner());\n        ap_fflush(backconn->output_filters, bb);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"Returning 200 OK\");\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"HTTP/1.0 200 Connection Established\" CRLF);\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"Proxy-agent: %s\" CRLF CRLF,\n                              ap_get_server_banner());\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        ap_fflush(c->output_filters, bb);\n#if 0\n        /* This is safer code, but it doesn't work yet.  I'm leaving it\n         * here so that I can fix it later.\n         */\n        r->status = HTTP_OK;\n        r->header_only = 1;\n        apr_table_set(r->headers_out, \"Proxy-agent: %s\", ap_get_server_banner());\n        ap_rflush(r);\n#endif\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"setting up poll()\");\n\n    /*\n     * Step Four: Handle Data Transfer\n     *\n     * Handle two way transfer of data over the socket (this is a tunnel).\n     */\n\n    /* we are now acting as a tunnel - the input/output filter stacks should\n     * not contain any non-connection filters.\n     */\n    r->output_filters = c->output_filters;\n    r->proto_output_filters = c->output_filters;\n    r->input_filters = c->input_filters;\n    r->proto_input_filters = c->input_filters;\n\n\n    while (1) { \n        if ((rv = apr_pollset_poll(pollset, -1, &pollcnt, &signalled))\n            != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            apr_socket_close(sock);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01023) \"error apr_poll()\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n#ifdef DEBUGGING\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01024)\n                      \"woke from poll(), i=%d\", pollcnt);\n#endif\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) {\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) {\n#ifdef DEBUGGING\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01025)\n                                  \"sock was readable\");\n#endif\n                    rv = proxy_connect_transfer(r, backconn, c, bb, \"sock\");\n                    }\n                else if ((pollevent & APR_POLLERR)\n                         || (pollevent & APR_POLLHUP)) {\n                         rv = APR_EPIPE;\n                         ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(01026)\n                                       \"err/hup on backconn\");\n                }\n                if (rv != APR_SUCCESS)\n                    client_error = 1;\n            }\n            else if (cur->desc.s == client_socket) {\n                pollevent = cur->rtnevents;\n                if (pollevent & APR_POLLIN) {\n#ifdef DEBUGGING\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01027)\n                                  \"client was readable\");\n#endif\n                    rv = proxy_connect_transfer(r, c, backconn, bb, \"client\");\n                }\n            }\n            else {\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01028)\n                              \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  \"finished with poll() - cleaning up\");\n\n    /*\n     * Step Five: Clean Up\n     *\n     * Close the socket and clean up\n     */\n\n    if (client_error)\n        apr_socket_close(sock);\n    else\n        ap_lingering_close(backconn);\n\n    c->aborted = 1;\n\n    return OK;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n"
  },
  "httpd_eb789db957ad0785496368a96f7f6cb8885ca6ac_0", {
    "ID": "httpd_eb789db957ad0785496368a96f7f6cb8885ca6ac_0",
    "UID": "9004",
    "code": "static const char *authn_cache_setprovider(cmd_parms *cmd, void test_snippet\n                                           const char *arg)\n{\n    authn_cache_dircfg *cfg = CFG;\n    if (cfg->providers == NULL) {\n        cfg->providers = apr_array_make(cmd->pool, 4, sizeof(const char*));\n    }\n    APR_ARRAY_PUSH(cfg->providers, const char*) = arg;\n    configured = 1;\n    return NULL;\n}",
    "predicted": "457,Use of Uninitialized Variable\n476,NULL Pointer Dereference"
  },
  "httpd_de32cbff05e343e8a602241a2c2f39cbb45a8534_0", {
    "ID": "httpd_de32cbff05e343e8a602241a2c2f39cbb45a8534_0",
    "UID": "9007",
    "code": "int cache_select(cache_request_rec *cache, request_rec test_snippet\n{\n    cache_provider_list *list;\n    apr_status_t rv;\n    cache_handle_t *h;\n\n    if (!cache) {\n        \n        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(00693)\n                \"cache: No cache request information available for key\"\n                \" generation\");\n        return DECLINED;\n    }\n\n    if (!cache->key) {\n        rv = cache_generate_key(r, r->pool, &cache->key);\n        if (rv != APR_SUCCESS) {\n            return DECLINED;\n        }\n    }\n\n    if (!ap_cache_check_allowed(cache, r)) {\n        return DECLINED;\n    }\n\n    \n    h = apr_palloc(r->pool, sizeof(cache_handle_t));\n\n    list = cache->providers;\n\n    while (list) {\n        switch ((rv = list->provider->open_entity(h, r, cache->key))) {\n        case OK: {\n            char *vary = NULL;\n            int fresh, mismatch = 0;\n\n            if (list->provider->recall_headers(h, r) != APR_SUCCESS) {\n                \n                list = list->next;\n                continue;\n            }\n\n            /*\n             * Check Content-Negotiation - Vary\n             *\n             * At this point we need to make sure that the object we found in\n             * the cache is the same object that would be delivered to the\n             * client, when the effects of content negotiation are taken into\n             * effect.\n             *\n             * In plain english, we want to make sure that a language-negotiated\n             * document in one language is not given to a client asking for a\n             * language negotiated document in a different language by mistake.\n             *\n             * This code makes the assumption that the storage manager will\n             * cache the req_hdrs if the response contains a Vary\n             * header.\n             *\n             * RFC2616 13.6 and 14.44 describe the Vary mechanism.\n             */\n            vary = apr_pstrdup(r->pool, apr_table_get(h->resp_hdrs, \"Vary\"));\n            while (vary && *vary) {\n                char *name = vary;\n                const char *h1, *h2;\n\n                \n                while (*vary && !apr_isspace(*vary) && (*vary != ','))\n                    ++vary;\n                while (*vary && (apr_isspace(*vary) || (*vary == ','))) {\n                    *vary = '\\0';\n                    ++vary;\n                }\n\n                /*\n                 * is this header in the request and the header in the cached\n                 * request identical? If not, we give up and do a straight get\n                 */\n                h1 = apr_table_get(r->headers_in, name);\n                h2 = apr_table_get(h->req_hdrs, name);\n                if (h1 == h2) {\n                    \n                }\n                else if (h1 && h2 && !strcmp(h1, h2)) {\n                    \n                }\n                else {\n                    \n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,\n                            r, APLOGNO(00694) \"cache_select_url(): Vary header mismatch.\");\n                    mismatch = 1;\n                }\n            }\n\n            \n            if (mismatch) {\n                \n                list = list->next;\n                continue;\n            }\n\n            cache->provider = list->provider;\n            cache->provider_name = list->provider_name;\n\n            \n            fresh = cache_check_freshness(h, cache, r);\n            if (!fresh) {\n                const char *etag, *lastmod;\n\n                /* Cache-Control: only-if-cached and revalidation required, try\n                 * the next provider\n                 */\n                if (cache->control_in.only_if_cached) {\n                    \n                    list = list->next;\n                    continue;\n                }\n\n                \n                cache->stale_headers = apr_table_copy(r->pool,\n                        r->headers_in);\n                cache->stale_handle = h;\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00695)\n                        \"Cached response for %s isn't fresh.  Adding/replacing \"\n                        \"conditional request headers.\", r->uri);\n\n                /* We can only revalidate with our own conditionals: remove the\n                 * conditions from the original request.\n                 */\n                apr_table_unset(r->headers_in, \"If-Match\");\n                apr_table_unset(r->headers_in, \"If-Modified-Since\");\n                apr_table_unset(r->headers_in, \"If-None-Match\");\n                apr_table_unset(r->headers_in, \"If-Range\");\n                apr_table_unset(r->headers_in, \"If-Unmodified-Since\");\n\n                etag = apr_table_get(h->resp_hdrs, \"ETag\");\n                lastmod = apr_table_get(h->resp_hdrs, \"Last-Modified\");\n\n                if (etag || lastmod) {\n                    /* If we have a cached etag and/or Last-Modified add in\n                     * our own conditionals.\n                     */\n\n                    if (etag) {\n                        apr_table_set(r->headers_in, \"If-None-Match\", etag);\n                    }\n\n                    if (lastmod) {\n                        apr_table_set(r->headers_in, \"If-Modified-Since\",\n                                lastmod);\n                    }\n\n                    /*\n                     * Do not do Range requests with our own conditionals: If\n                     * we get 304 the Range does not matter and otherwise the\n                     * entity changed and we want to have the complete entity\n                     */\n                    apr_table_unset(r->headers_in, \"Range\");\n\n                }\n\n                \n                return DECLINED;\n            }\n\n            \n            cache_accept_headers(h, r, 0);\n\n            cache->handle = h;\n            return OK;\n        }\n        case DECLINED: {\n            \n            list = list->next;\n            continue;\n        }\n        default: {\n            \n            return rv;\n        }\n        }\n    }\n\n    \n    if (cache->control_in.only_if_cached) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00696)\n                \"cache: 'only-if-cached' requested and no cached entity, \"\n                \"returning 504 Gateway Timeout for: %s\", r->uri);\n        return HTTP_GATEWAY_TIME_OUT;\n    }\n\n    return DECLINED;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_ea87a834f43814f4a543d467c014d00b3a8047ec_0", {
    "ID": "httpd_ea87a834f43814f4a543d467c014d00b3a8047ec_0",
    "UID": "9008",
    "code": "static sed_reptr_t *alloc_reptr(sed_commands_t test_snippet\n{\n    sed_reptr_t *var;\n\n    var = apr_pcalloc(commands->pool, sizeof(sed_reptr_t));\n    if (var == NULL) {\n        command_errf(commands, SEDERR_OOMMES);\n        return 0;\n    }\n\n    var->nrep = commands->nrep;\n    var->findex = -1;\n    commands->nrep++;\n\n    if (commands->ptrspace == NULL)\n        commands->ptrspace = var;\n    else\n        commands->ptrend->next = var;\n\n    commands->ptrend = var;\n    commands->labtab->address = var;\n    return var;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_4cd1591dadad69d4db8f0281f960728b21e33a15_0", {
    "ID": "httpd_4cd1591dadad69d4db8f0281f960728b21e33a15_0",
    "UID": "9015",
    "code": "static int fcomp(sed_commands_t *commands, apr_file_t test_snippet\n{\n    char *p, *op, *tp;\n    sed_reptr_t *pt, *pt1;\n    int i, ii;\n    sed_label_t *lpt;\n    char fnamebuf[APR_PATH_MAX];\n    apr_status_t status;\n    sed_comp_args compargs;\n\n    op = commands->lastre;\n    if (!commands->linebuf) {\n        commands->linebuf = apr_pcalloc(commands->pool, LBSIZE + 1);\n    }\n\n    if (rline(commands, fin, commands->linebuf,\n              (commands->linebuf + LBSIZE + 1)) < 0)\n        return 0;\n    if (*commands->linebuf == '#') {\n        if (commands->linebuf[1] == 'n')\n            commands->nflag = 1;\n    }\n    else {\n        commands->cp = commands->linebuf;\n        goto comploop;\n    }\n\n    for (;;) {\n        if (rline(commands, fin, commands->linebuf,\n                  (commands->linebuf + LBSIZE + 1)) < 0)\n            break;\n\n        commands->cp = commands->linebuf;\n\ncomploop:\n        while (*commands->cp == ' ' || *commands->cp == '\\t')\n            commands->cp++;\n        if (*commands->cp == '\\0' || *commands->cp == '#')\n            continue;\n        if (*commands->cp == ';') {\n            commands->cp++;\n            goto comploop;\n        }\n\n        p = address(commands, commands->rep->ad1, &status);\n        if (status != APR_SUCCESS) {\n            command_errf(commands, SEDERR_CGMES, commands->linebuf);\n            return -1;\n        }\n\n        if (p == commands->rep->ad1) {\n            if (op)\n                commands->rep->ad1 = op;\n            else {\n                command_errf(commands, SEDERR_NRMES);\n                return -1;\n            }\n        } else if (p == 0) {\n            p = commands->rep->ad1;\n            commands->rep->ad1 = 0;\n        } else {\n            op = commands->rep->ad1;\n            if (*commands->cp == ',' || *commands->cp == ';') {\n                commands->cp++;\n                commands->rep->ad2 = p;\n                p = address(commands, commands->rep->ad2, &status);\n                if ((status != APR_SUCCESS) || (p == 0)) {\n                    command_errf(commands, SEDERR_CGMES, commands->linebuf);\n                    return -1;\n                }\n                if (p == commands->rep->ad2)\n                    commands->rep->ad2 = op;\n                else\n                    op = commands->rep->ad2;\n            } else\n                commands->rep->ad2 = 0;\n        }\n\n        if(p > &commands->respace[RESIZE-1]) {\n            command_errf(commands, SEDERR_TMMES);\n            return -1;\n        }\n\n        while (*commands->cp == ' ' || *commands->cp == '\\t')\n            commands->cp++;\n\nswit:\n        switch(*commands->cp++) {\n        default:\n            command_errf(commands, SEDERR_UCMES, commands->linebuf);\n            return -1;\n\n        case '!':\n            commands->rep->negfl = 1;\n            goto swit;\n\n        case '{':\n            commands->rep->command = BCOM;\n            commands->rep->negfl = !(commands->rep->negfl);\n            commands->cmpend[commands->depth++] = &commands->rep->lb1;\n            commands->rep = alloc_reptr(commands);\n            commands->rep->ad1 = p;\n            if (*commands->cp == '\\0')\n                continue;\n            goto comploop;\n\n        case '}':\n            if (commands->rep->ad1) {\n                command_errf(commands, SEDERR_AD0MES, commands->linebuf);\n                return -1;\n            }\n\n            if (--commands->depth < 0) {\n                command_errf(commands, SEDERR_TMCMES);\n                return -1;\n            }\n            *commands->cmpend[commands->depth] = commands->rep;\n\n            commands->rep->ad1 = p;\n            continue;\n\n        case '=':\n            commands->rep->command = EQCOM;\n            if (commands->rep->ad2) {\n                command_errf(commands, SEDERR_AD1MES, commands->linebuf);\n                return -1;\n            }\n            break;\n\n        case ':':\n            if (commands->rep->ad1) {\n                command_errf(commands, SEDERR_AD0MES, commands->linebuf);\n                return -1;\n            }\n\n            while (*commands->cp++ == ' ');\n            commands->cp--;\n\n            tp = commands->lab->asc;\n            while ((*tp++ = *commands->cp++)) {\n                if (tp >= &(commands->lab->asc[8])) {\n                    command_errf(commands, SEDERR_LTLMES, commands->linebuf);\n                    return -1;\n                }\n            }\n            *--tp = '\\0';\n\n            if ((lpt = search(commands)) != NULL) {\n                if (lpt->address) {\n                    command_errf(commands, SEDERR_DLMES, commands->linebuf);\n                    return -1;\n                }\n                dechain(lpt, commands->rep);\n            } else {\n                commands->lab->chain = 0;\n                lpt = commands->lab;\n                if (++commands->lab >= commands->labend) {\n                    command_errf(commands, SEDERR_TMLMES, commands->linebuf);\n                    return -1;\n                }\n            }\n            lpt->address = commands->rep;\n            commands->rep->ad1 = p;\n\n            continue;\n\n        case 'a':\n            commands->rep->command = ACOM;\n            if (commands->rep->ad2) {\n                command_errf(commands, SEDERR_AD1MES, commands->linebuf);\n                return -1;\n            }\n            if (*commands->cp == '\\\\')\n                commands->cp++;\n            if (*commands->cp++ != '\\n') {\n                command_errf(commands, SEDERR_CGMES, commands->linebuf);\n                return -1;\n            }\n            commands->rep->re1 = p;\n            p = text(commands, commands->rep->re1, commands->reend);\n            if (p == NULL)\n                return -1;\n            break;\n\n        case 'c':\n            commands->rep->command = CCOM;\n            if (*commands->cp == '\\\\') commands->cp++;\n            if (*commands->cp++ != ('\\n')) {\n                command_errf(commands, SEDERR_CGMES, commands->linebuf);\n                return -1;\n            }\n            commands->rep->re1 = p;\n            p = text(commands, commands->rep->re1, commands->reend);\n            if (p == NULL)\n                return -1;\n            break;\n\n        case 'i':\n            commands->rep->command = ICOM;\n            if (commands->rep->ad2) {\n                command_errf(commands, SEDERR_AD1MES, commands->linebuf);\n                return -1;\n            }\n            if (*commands->cp == '\\\\') commands->cp++;\n            if (*commands->cp++ != ('\\n')) {\n                command_errf(commands, SEDERR_CGMES, commands->linebuf);\n                return -1;\n            }\n            commands->rep->re1 = p;\n            p = text(commands, commands->rep->re1, commands->reend);\n            if (p == NULL)\n                return -1;\n            break;\n\n        case 'g':\n            commands->rep->command = GCOM;\n            break;\n\n        case 'G':\n            commands->rep->command = CGCOM;\n            break;\n\n        case 'h':\n            commands->rep->command = HCOM;\n            break;\n\n        case 'H':\n            commands->rep->command = CHCOM;\n            break;\n\n        case 't':\n            commands->rep->command = TCOM;\n            goto jtcommon;\n\n        case 'b':\n            commands->rep->command = BCOM;\njtcommon:\n            while (*commands->cp++ == ' ');\n            commands->cp--;\n\n            if (*commands->cp == '\\0') {\n                if ((pt = commands->labtab->chain) != NULL) {\n                    while ((pt1 = pt->lb1) != NULL)\n                        pt = pt1;\n                    pt->lb1 = commands->rep;\n                } else\n                    commands->labtab->chain = commands->rep;\n                break;\n            }\n            tp = commands->lab->asc;\n            while ((*tp++ = *commands->cp++))\n                if (tp >= &(commands->lab->asc[8])) {\n                    command_errf(commands, SEDERR_LTLMES, commands->linebuf);\n                    return -1;\n                }\n            commands->cp--;\n            *--tp = '\\0';\n\n            if ((lpt = search(commands)) != NULL) {\n                if (lpt->address) {\n                    commands->rep->lb1 = lpt->address;\n                } else {\n                    pt = lpt->chain;\n                    while ((pt1 = pt->lb1) != NULL)\n                        pt = pt1;\n                    pt->lb1 = commands->rep;\n                }\n            } else {\n                commands->lab->chain = commands->rep;\n                commands->lab->address = 0;\n                if (++commands->lab >= commands->labend) {\n                    command_errf(commands, SEDERR_TMLMES, commands->linebuf);\n                    return -1;\n                }\n            }\n            break;\n\n        case 'n':\n            commands->rep->command = NCOM;\n            break;\n\n        case 'N':\n            commands->rep->command = CNCOM;\n            break;\n\n        case 'p':\n            commands->rep->command = PCOM;\n            break;\n\n        case 'P':\n            commands->rep->command = CPCOM;\n            break;\n\n        case 'r':\n            commands->rep->command = RCOM;\n            if (commands->rep->ad2) {\n                command_errf(commands, SEDERR_AD1MES, commands->linebuf);\n                return -1;\n            }\n            if (*commands->cp++ != ' ') {\n                command_errf(commands, SEDERR_CGMES, commands->linebuf);\n                return -1;\n            }\n            commands->rep->re1 = p;\n            p = text(commands, commands->rep->re1, commands->reend);\n            if (p == NULL)\n                return -1;\n            break;\n\n        case 'd':\n            commands->rep->command = DCOM;\n            break;\n\n        case 'D':\n            commands->rep->command = CDCOM;\n            commands->rep->lb1 = commands->ptrspace;\n            break;\n\n        case 'q':\n            commands->rep->command = QCOM;\n            if (commands->rep->ad2) {\n                command_errf(commands, SEDERR_AD1MES, commands->linebuf);\n                return -1;\n            }\n            break;\n\n        case 'l':\n            commands->rep->command = LCOM;\n            break;\n\n        case 's':\n            commands->rep->command = SCOM;\n            commands->sseof = *commands->cp++;\n            commands->rep->re1 = p;\n            p = comple(commands, &compargs, (char *) 0, commands->rep->re1,\n                       commands->reend, commands->sseof);\n            if (p == NULL)\n                return -1;\n            if (p == commands->rep->re1) {\n                if (op)\n                    commands->rep->re1 = op;\n                else {\n                    command_errf(commands, SEDERR_NRMES);\n                    return -1;\n                }\n            } else\n                op = commands->rep->re1;\n            commands->rep->rhs = p;\n\n            p = compsub(commands, &compargs, commands->rep->rhs);\n            if ((p) == NULL)\n                return -1;\n\n            if (*commands->cp == 'g') {\n                commands->cp++;\n                commands->rep->gfl = 999;\n            } else if (commands->gflag)\n                commands->rep->gfl = 999;\n\n            if (*commands->cp >= '1' && *commands->cp <= '9') {\n                i = *commands->cp - '0';\n                commands->cp++;\n                while (1) {\n                    ii = *commands->cp;\n                    if (ii < '0' || ii > '9')\n                        break;\n                    i = i*10 + ii - '0';\n                    if (i > 512) {\n                        command_errf(commands, SEDERR_TOOBIG, commands->linebuf);\n                        return -1;\n                    }\n                    commands->cp++;\n                }\n                commands->rep->gfl = i;\n            }\n\n            if (*commands->cp == 'p') {\n                commands->cp++;\n                commands->rep->pfl = 1;\n            }\n\n            if (*commands->cp == 'P') {\n                commands->cp++;\n                commands->rep->pfl = 2;\n            }\n\n            if (*commands->cp == 'w') {\n                commands->cp++;\n                if (*commands->cp++ !=  ' ') {\n                    command_errf(commands, SEDERR_SMMES, commands->linebuf);\n                    return -1;\n                }\n                if (text(commands, fnamebuf, &fnamebuf[APR_PATH_MAX]) == NULL) {\n                    command_errf(commands, SEDERR_FNTL, commands->linebuf);\n                    return -1;\n                }\n                for (i = commands->nfiles - 1; i >= 0; i--)\n                    if (strcmp(fnamebuf,commands->fname[i]) == 0) {\n                        commands->rep->findex = i;\n                        goto done;\n                    }\n                if (commands->nfiles >= NWFILES) {\n                    command_errf(commands, SEDERR_TMWFMES);\n                    return -1;\n                }\n                commands->fname[commands->nfiles] =\n                            apr_pstrdup(commands->pool, fnamebuf);\n                if (commands->fname[commands->nfiles] == NULL) {\n                    command_errf(commands, SEDERR_OOMMES);\n                    return -1;\n                }\n                commands->rep->findex = commands->nfiles++;\n            }\n            break;\n\n        case 'w':\n            commands->rep->command = WCOM;\n            if (*commands->cp++ != ' ') {\n                command_errf(commands, SEDERR_SMMES, commands->linebuf);\n                return -1;\n            }\n            if (text(commands, fnamebuf, &fnamebuf[APR_PATH_MAX]) == NULL) {\n                command_errf(commands, SEDERR_FNTL, commands->linebuf);\n                return -1;\n            }\n            for (i = commands->nfiles - 1; i >= 0; i--)\n                if (strcmp(fnamebuf, commands->fname[i]) == 0) {\n                    commands->rep->findex = i;\n                    goto done;\n                }\n            if (commands->nfiles >= NWFILES) {\n                command_errf(commands, SEDERR_TMWFMES);\n                return -1;\n            }\n            if ((commands->fname[commands->nfiles] =\n                        apr_pstrdup(commands->pool, fnamebuf)) == NULL) {\n                command_errf(commands, SEDERR_OOMMES);\n                return -1;\n            }\n\n            commands->rep->findex = commands->nfiles++;\n            break;\n\n        case 'x':\n            commands->rep->command = XCOM;\n            break;\n\n        case 'y':\n            commands->rep->command = YCOM;\n            commands->sseof = *commands->cp++;\n            commands->rep->re1 = p;\n            p = ycomp(commands, commands->rep->re1);\n            if (p == NULL)\n                return -1;\n            break;\n        }\ndone:\n        commands->rep = alloc_reptr(commands);\n\n        commands->rep->ad1 = p;\n\n        if (*commands->cp++ != '\\0') {\n            if (commands->cp[-1] == ';')\n                goto comploop;\n            command_errf(commands, SEDERR_CGMES, commands->linebuf);\n            return -1;\n        }\n    }\n    commands->rep->command = 0;\n    commands->lastre = op;\n\n    return 0;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_966a2b03c8d760506915c6e76541bef82a1eab84_0", {
    "ID": "httpd_966a2b03c8d760506915c6e76541bef82a1eab84_0",
    "UID": "9017",
    "code": "static char *ycomp(sed_commands_t *commands, char test_snippet\n{\n    char    c;\n    int cint; \n    char *ep, *tsp;\n    int i;\n    char    *sp;\n\n    ep = expbuf;\n    if(ep + 0377 > &commands->respace[RESIZE-1]) {\n        command_errf(commands, SEDERR_TMMES, commands->linebuf);\n        return NULL;\n    }\n    sp = commands->cp;\n    for(tsp = commands->cp; (c = *tsp) != commands->sseof; tsp++) {\n        if(c == '\\\\')\n            tsp++;\n        if(c == '\\0' || c == '\\n') {\n            command_errf(commands, SEDERR_EDMOSTR, commands->linebuf);\n            return NULL;\n        }\n    }\n    tsp++;\n    memset(ep, 0, 0400);\n\n    while((c = *sp++) != commands->sseof) {\n        c &= 0377;\n        if(c == '\\\\' && *sp == 'n') {\n            sp++;\n            c = '\\n';\n        }\n        cint = (int) c;\n        if((ep[cint] = *tsp++) == '\\\\' && *tsp == 'n') {\n            ep[cint] = '\\n';\n            tsp++;\n        }\n        if(ep[cint] == commands->sseof || ep[cint] == '\\0') {\n            command_errf(commands, SEDERR_TSNTSS, commands->linebuf);\n        }\n    }\n    if(*tsp != commands->sseof) {\n        if(*tsp == '\\0') {\n            command_errf(commands, SEDERR_EDMOSTR, commands->linebuf);\n        }\n        else {\n            command_errf(commands, SEDERR_TSNTSS, commands->linebuf);\n        }\n        return NULL;\n    }\n    commands->cp = ++tsp;\n\n    for(i = 0; i < 0400; i++)\n        if(ep[i] == 0)\n            ep[i] = i;\n\n    return(ep + 0400);\n}",
    "predicted": "121,Stack-based Buffer Overflow\n190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n476,NULL Pointer Dereference"
  },
  "httpd_e66c98e883cbc1ff7522d4be853b78a729aafecb_0", {
    "ID": "httpd_e66c98e883cbc1ff7522d4be853b78a729aafecb_0",
    "UID": "9023",
    "code": "static char *compsub(sed_commands_t test_snippet\n                     sed_comp_args *compargs, char *rhsbuf)\n{\n    char   *p, *q;\n\n    p = rhsbuf;\n    q = commands->cp;\n    for(;;) {\n        if(p > &commands->respace[RESIZE-1]) {\n            command_errf(commands, SEDERR_TMMES, commands->linebuf);\n            return NULL;\n        }\n        if((*p = *q++) == '\\\\') {\n            p++;\n            if(p > &commands->respace[RESIZE-1]) {\n                command_errf(commands, SEDERR_TMMES, commands->linebuf);\n                return NULL;\n            }\n            *p = *q++;\n            if(*p > compargs->nbra + '0' && *p <= '9') {\n                command_errf(commands, SEDERR_DOORNG, commands->linebuf);\n                return NULL;\n            }\n            p++;\n            continue;\n        }\n        if(*p == commands->sseof) {\n            *p++ = '\\0';\n            commands->cp = q;\n            return(p);\n        }\n          if(*p++ == '\\0') {\n            command_errf(commands, SEDERR_EDMOSUB, commands->linebuf);\n            return NULL;\n        }\n    }\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_8818af8b69b19cffe98a636f5c3dd6ee480937fd_0", {
    "ID": "httpd_8818af8b69b19cffe98a636f5c3dd6ee480937fd_0",
    "UID": "9040",
    "code": "static const char *gen_unique_id(const request_rec test_snippet\n{\n    char *str;\n    /*\n     * Buffer padded with two final bytes, used to copy the unique_id_red\n     * structure without the internal paddings that it could have.\n     */\n    unique_id_rec new_unique_id;\n    struct {\n        unique_id_rec foo;\n        unsigned char pad[2];\n    } paddedbuf;\n    unsigned char *x,*y;\n    unsigned short counter;\n    int i,j,k;\n\n    new_unique_id.in_addr = cur_unique_id.in_addr;\n    new_unique_id.pid = cur_unique_id.pid;\n    new_unique_id.counter = cur_unique_id.counter;\n\n    new_unique_id.stamp = htonl((unsigned int)apr_time_sec(r->request_time));\n    new_unique_id.thread_index = htonl((unsigned int)r->connection->id);\n\n    /* we'll use a temporal buffer to avoid uuencoding the possible internal\n     * paddings of the original structure */\n    x = (unsigned char *) &paddedbuf;\n    k = 0;\n    for (i = 0; i < UNIQUE_ID_REC_MAX; i++) {\n        y = ((unsigned char *) &new_unique_id) + unique_id_rec_offset[i];\n        for (j = 0; j < unique_id_rec_size[i]; j++, k++) {\n            x[k] = y[j];\n        }\n    }\n    /*\n     * We reset two more bytes just in case padding is needed for the uuencoding.\n     */\n    x[k++] = '\\0';\n    x[k++] = '\\0';\n\n    \n    str = (char *)apr_palloc(r->pool, unique_id_rec_size_uu + 1);\n    k = 0;\n    for (i = 0; i < unique_id_rec_total_size; i += 3) {\n        y = x + i;\n        str[k++] = uuencoder[y[0] >> 2];\n        str[k++] = uuencoder[((y[0] & 0x03) << 4) | ((y[1] & 0xf0) >> 4)];\n        if (k == unique_id_rec_size_uu) break;\n        str[k++] = uuencoder[((y[1] & 0x0f) << 2) | ((y[2] & 0xc0) >> 6)];\n        if (k == unique_id_rec_size_uu) break;\n        str[k++] = uuencoder[y[2] & 0x3f];\n    }\n    str[k++] = '\\0';\n\n    \n\n    counter = ntohs(new_unique_id.counter) + 1;\n    cur_unique_id.counter = htons(counter);\n\n    return str;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_95279304d1bdc23394042a419495dbc4ae88f0c1_0", {
    "ID": "httpd_95279304d1bdc23394042a419495dbc4ae88f0c1_0",
    "UID": "9042",
    "code": "PROXY_DECLARE(void) ap_proxy_c2hex(int ch, char test_snippet\n{\n#if !APR_CHARSET_EBCDIC\n    int i;\n\n    x[0] = '%';\n    i = (ch & 0xF0) >> 4;\n    if (i >= 10) {\n        x[1] = ('A' - 10) + i;\n    }\n    else {\n        x[1] = '0' + i;\n    }\n\n    i = ch & 0x0F;\n    if (i >= 10) {\n        x[2] = ('A' - 10) + i;\n    }\n    else {\n        x[2] = '0' + i;\n    }\n#else \n    static const char ntoa[] = { \"0123456789ABCDEF\" };\n    char buf[1];\n\n    ch &= 0xFF;\n\n    buf[0] = ch;\n    ap_xlate_proto_to_ascii(buf, 1);\n\n    x[0] = '%';\n    x[1] = ntoa[(buf[0] >> 4) & 0x0F];\n    x[2] = ntoa[buf[0] & 0x0F];\n    x[3] = '\\0';\n#endif \n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_2ad56c2eec4283a672b49f6821cf44485f820951_0", {
    "ID": "httpd_2ad56c2eec4283a672b49f6821cf44485f820951_0",
    "UID": "9075",
    "code": "static const char *define_filter(cmd_parms *cmd, void *dummy, const char test_snippet\n{\n    ef_server_t *conf = ap_get_module_config(cmd->server->module_config,\n                                             &ext_filter_module);\n    const char *token;\n    const char *name;\n    char *normalized_name;\n    ef_filter_t *filter;\n\n    name = ap_getword_white(cmd->pool, &args);\n    if (!name) {\n        return \"Filter name not found\";\n    }\n\n    /* During request processing, we find information about the filter\n     * by looking up the filter name provided by core server in our\n     * hash table.  But the core server has normalized the filter\n     * name by converting it to lower case.  Thus, when adding the\n     * filter to our hash table we have to use lower case as well.\n     */\n    normalized_name = apr_pstrdup(cmd->pool, name);\n    ap_str_tolower(normalized_name);\n\n    if (apr_hash_get(conf->h, normalized_name, APR_HASH_KEY_STRING)) {\n        return apr_psprintf(cmd->pool, \"ExtFilter %s is already defined\",\n                            name);\n    }\n\n    filter = (ef_filter_t *)apr_pcalloc(conf->p, sizeof(ef_filter_t));\n    filter->name = name;\n    filter->mode = OUTPUT_FILTER;\n    filter->ftype = AP_FTYPE_RESOURCE;\n    apr_hash_set(conf->h, normalized_name, APR_HASH_KEY_STRING, filter);\n\n    while (test_snippet {\n        while (apr_isspace(test_snippet) {\n            ++args;\n        }\n\n        /* Nasty parsing...  I wish I could simply use ap_getword_white()\n         * here and then look at the token, but ap_getword_white() doesn't\n         * do the right thing when we have cmd=\"word word word\"\n         */\n        if (!strncasecmp(args, \"preservescontentlength\", 22)) {\n            token = ap_getword_white(cmd->pool, &args);\n            if (!strcasecmp(token, \"preservescontentlength\")) {\n                filter->preserves_content_length = 1;\n            }\n            else {\n                return apr_psprintf(cmd->pool,\n                                    \"mangled argument `%s'\",\n                                    token);\n            }\n            continue;\n        }\n\n        if (!strncasecmp(args, \"mode=\", 5)) {\n            args += 5;\n            token = ap_getword_white(cmd->pool, &args);\n            if (!strcasecmp(token, \"output\")) {\n                filter->mode = OUTPUT_FILTER;\n            }\n            else if (!strcasecmp(token, \"input\")) {\n                filter->mode = INPUT_FILTER;\n            }\n            else {\n                return apr_psprintf(cmd->pool, \"Invalid mode: `%s'\",\n                                    token);\n            }\n            continue;\n        }\n\n        if (!strncasecmp(args, \"ftype=\", 6)) {\n            args += 6;\n            token = ap_getword_white(cmd->pool, &args);\n            filter->ftype = atoi(token);\n            continue;\n        }\n\n        if (!strncasecmp(args, \"enableenv=\", 10)) {\n            args += 10;\n            token = ap_getword_white(cmd->pool, &args);\n            filter->enable_env = token;\n            continue;\n        }\n\n        if (!strncasecmp(args, \"disableenv=\", 11)) {\n            args += 11;\n            token = ap_getword_white(cmd->pool, &args);\n            filter->disable_env = token;\n            continue;\n        }\n\n        if (!strncasecmp(args, \"intype=\", 7)) {\n            args += 7;\n            filter->intype = ap_getword_white(cmd->pool, &args);\n            continue;\n        }\n\n        if (!strncasecmp(args, \"outtype=\", 8)) {\n            args += 8;\n            filter->outtype = ap_getword_white(cmd->pool, &args);\n            continue;\n        }\n\n        if (!strncasecmp(args, \"cmd=\", 4)) {\n            args += 4;\n            if ((token = parse_cmd(cmd->pool, &args, filter))) {\n                return token;\n            }\n            continue;\n        }\n\n        return apr_psprintf(cmd->pool, \"Unexpected parameter: `%s'\",\n                            args);\n    }\n\n    /* parsing is done...  register the filter\n     */\n    if (filter->mode == OUTPUT_FILTER) {\n        \n        ap_register_output_filter(filter->name, ef_output_filter, NULL, filter->ftype);\n    }\n    else if (filter->mode == INPUT_FILTER) {\n        \n        ap_register_input_filter(filter->name, ef_input_filter, NULL, filter->ftype);\n    }\n    else {\n        ap_assert(1 != 1); \n    }\n\n    return NULL;\n}",
    "predicted": "78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
  },
  "httpd_380f4125f06cd20790f17480f73fd24ee31a2dd4_0", {
    "ID": "httpd_380f4125f06cd20790f17480f73fd24ee31a2dd4_0",
    "UID": "9076",
    "code": "static proxy_worker *find_route_worker(proxy_balancer test_snippet\n                                       const char *route, request_rec *r)\n{\n    int i;\n    int checking_standby;\n    int checked_standby;\n\n    proxy_worker **workers;\n\n    checking_standby = checked_standby = 0;\n    while (!checked_standby) {\n        workers = (proxy_worker **)balancer->workers->elts;\n        for (i = 0; i < balancer->workers->nelts; i++, workers++) {\n            proxy_worker *worker = *workers;\n            if ( (checking_standby ? !PROXY_WORKER_IS_STANDBY(worker) : PROXY_WORKER_IS_STANDBY(worker)) )\n                continue;\n            if (*(worker->s->route) && strcmp(worker->s->route, route) == 0) {\n                if (PROXY_WORKER_IS_USABLE(worker)) {\n                    return worker;\n                } else {\n                    /*\n                     * If the worker is in error state run\n                     * retry on that worker. It will be marked as\n                     * operational if the retry timeout is elapsed.\n                     * The worker might still be unusable, but we try\n                     * anyway.\n                     */\n                    ap_proxy_retry_worker_fn(\"BALANCER\", worker, r->server);\n                    if (PROXY_WORKER_IS_USABLE(worker)) {\n                            return worker;\n                    } else {\n                        /*\n                         * We have a worker that is unusable.\n                         * It can be in error or disabled, but in case\n                         * it has a redirection set use that redirection worker.\n                         * This enables to safely remove the member from the\n                         * balancer. Of course you will need some kind of\n                         * session replication between those two remote.\n                         */\n                        if (*worker->s->redirect) {\n                            proxy_worker *rworker = NULL;\n                            rworker = find_route_worker(balancer, worker->s->redirect, r);\n                            \n                            if (rworker && !PROXY_WORKER_IS_USABLE(rworker)) {\n                                /*\n                                 * If the worker is in error state run\n                                 * retry on that worker. It will be marked as\n                                 * operational if the retry timeout is elapsed.\n                                 * The worker might still be unusable, but we try\n                                 * anyway.\n                                 */\n                                ap_proxy_retry_worker_fn(\"BALANCER\", rworker, r->server);\n                            }\n                            if (rworker && PROXY_WORKER_IS_USABLE(rworker))\n                                return rworker;\n                        }\n                    }\n                }\n            }\n        }\n        checked_standby = checking_standby++;\n    }\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_c24c366f5a6f6dea19b792bba699d115ed12259b_0", {
    "ID": "httpd_c24c366f5a6f6dea19b792bba699d115ed12259b_0",
    "UID": "9078",
    "code": "static const char *dbd_param_int(cmd_parms *cmd, void *dconf, const char test_snippet\n{\n    svr_cfg *svr = ap_get_module_config(cmd->server->module_config,\n                                        &dbd_module);\n    dbd_cfg_t *cfg = svr->cfg;\n    const char *p;\n\n    for (p = val; *p; ++p) {\n        if (!apr_isdigit(*p)) {\n            return \"Argument must be numeric!\";\n        }\n    }\n\n    switch ((long) cmd->info) {\n    case cmd_min:\n        cfg->nmin = atoi(val);\n        cfg->set |= NMIN_SET;\n        break;\n    case cmd_keep:\n        cfg->nkeep = atoi(val);\n        cfg->set |= NKEEP_SET;\n        break;\n    case cmd_max:\n        cfg->nmax = atoi(val);\n        cfg->set |= NMAX_SET;\n        break;\n    case cmd_exp:\n        cfg->exptime = atoi(val);\n        cfg->set |= EXPTIME_SET;\n        break;\n    }\n\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n476,NULL Pointer Dereference\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_586b3c7567ad135735091ba0f4a0ebf9a9eb32b2_0", {
    "ID": "httpd_586b3c7567ad135735091ba0f4a0ebf9a9eb32b2_0",
    "UID": "9079",
    "code": "static const char *authn_cache_timeout(cmd_parms *cmd, void test_snippet\n                                       const char *arg)\n{\n    authn_cache_dircfg *cfg = CFG;\n    int secs = atoi(arg);\n    cfg->timeout = apr_time_from_sec(secs);\n    return NULL;\n}",
    "predicted": "252,Unchecked Return Value\n190,Integer Overflow or Wraparound"
  },
  "httpd_e288ea297a9186fbb78b9a819c77afc778d266f3_0", {
    "ID": "httpd_e288ea297a9186fbb78b9a819c77afc778d266f3_0",
    "UID": "9080",
    "code": "static const char *header_request_ssl_var(request_rec *r, char test_snippet\n{\n    if (header_ssl_lookup) {\n        const char *val = header_ssl_lookup(r->pool, r->server,\n                                            r->connection, r, name);\n        if (val && val[0])\n            return unwrap_header(r->pool, val);\n        else\n            return \"(null)\";\n    }\n    else {\n        return \"(null)\";\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_295f71bdbd4c83a7a704a0a931c9e000d1efcf34_0", {
    "ID": "httpd_295f71bdbd4c83a7a704a0a931c9e000d1efcf34_0",
    "UID": "9083",
    "code": "test_snippet\nstruct mfd_ctx * create_multipart_context(const char *content_type,\n                                          apr_pool_t *pool,\n                                          apr_bucket_alloc_t *ba,\n                                          apr_size_t brigade_limit,\n                                          const char *temp_dir,\n                                          unsigned level)\n\n{\n    apr_status_t s;\n    apr_size_t blen;\n    struct mfd_ctx *ctx = apr_palloc(pool, sizeof *ctx);\n    char *ct = apr_pstrdup(pool, content_type);\n\n    ct = strchr(ct, ';');\n    if (ct == NULL)\n        return NULL; \n\n    *ct++ = 0;\n    s = apreq_header_attribute(ct, \"boundary\", 8,\n                               (const char **)&ctx->bdry, &blen);\n\n    if (s != APR_SUCCESS)\n        return NULL; \n\n    ctx->bdry[blen] = 0;\n\n    *--ctx->bdry = '-';\n    *--ctx->bdry = '-';\n    *--ctx->bdry = '\\n';\n    *--ctx->bdry = '\\r';\n\n    ctx->status = MFD_INIT;\n    ctx->pattern = apr_strmatch_precompile(pool, ctx->bdry, 1);\n    ctx->hdr_parser = apreq_parser_make(pool, ba, \"\",\n                                        apreq_parse_headers,\n                                        brigade_limit,\n                                        temp_dir, NULL, NULL);\n    ctx->info = NULL;\n    ctx->bb = apr_brigade_create(pool, ba);\n    ctx->in = apr_brigade_create(pool, ba);\n    ctx->eos = apr_bucket_eos_create(ba);\n    ctx->next_parser = NULL;\n    ctx->param_name = NULL;\n    ctx->upload = NULL;\n    ctx->level = level;\n\n    return ctx;\n}",
    "predicted": "124,Buffer Underwrite ('Buffer Underflow')"
  },
  "httpd_c3162cc54b6b2a55b2ead2c6740c54002e25a432_0", {
    "ID": "httpd_c3162cc54b6b2a55b2ead2c6740c54002e25a432_0",
    "UID": "9085",
    "code": "APREQ_DECLARE(char *) apreq_join(apr_pool_t test_snippet\n                                 const char *sep,\n                                 const apr_array_header_t *arr,\n                                 apreq_join_t mode)\n{\n    apr_size_t len, slen;\n    char *rv;\n    const apreq_value_t **a = (const apreq_value_t **)arr->elts;\n    char *d;\n    const int n = arr->nelts;\n    int j;\n\n    slen = sep ? strlen(sep) : 0;\n\n    if (n == 0)\n        return apr_pstrdup(p, \"\");\n\n    for (j=0, len=0; j < n; ++j)\n        len += a[j]->dlen + slen + 1;\n\n    \n\n    switch (mode) {\n    case APREQ_JOIN_ENCODE:\n        len += 2 * len;\n        break;\n    case APREQ_JOIN_QUOTE:\n        len = 2 * (len + n);\n        break;\n    case APREQ_JOIN_AS_IS:\n    case APREQ_JOIN_DECODE:\n        \n        break;\n    }\n\n    rv = apr_palloc(p, len);\n\n    \n\n    d = rv;\n\n    switch (mode) {\n\n    case APREQ_JOIN_ENCODE:\n        d += apreq_encode(d, a[0]->data, a[0]->dlen);\n\n        for (j = 1; j < n; ++j) {\n                memcpy(d, sep, slen);\n                d += slen;\n                d += apreq_encode(d, a[j]->data, a[j]->dlen);\n        }\n        break;\n\n    case APREQ_JOIN_DECODE:\n        if (apreq_decode(d, &len, a[0]->data, a[0]->dlen))\n            return NULL;\n        else\n            d += len;\n\n        for (j = 1; j < n; ++j) {\n            memcpy(d, sep, slen);\n            d += slen;\n\n            if (apreq_decode(d, &len, a[j]->data, a[j]->dlen))\n                return NULL;\n            else\n                d += len;\n        }\n        break;\n\n\n    case APREQ_JOIN_QUOTE:\n        d += apreq_quote_once(d, a[0]->data, a[0]->dlen);\n\n        for (j = 1; j < n; ++j) {\n            memcpy(d, sep, slen);\n            d += slen;\n            d += apreq_quote_once(d, a[j]->data, a[j]->dlen);\n        }\n        break;\n\n\n    case APREQ_JOIN_AS_IS:\n        memcpy(d,a[0]->data, a[0]->dlen);\n        d += a[0]->dlen;\n\n        for (j = 1; j < n ; ++j) {\n            memcpy(d, sep, slen);\n            d += slen;\n            memcpy(d, a[j]->data, a[j]->dlen);\n            d += a[j]->dlen;\n        }\n        break;\n    }\n\n    *d = 0;\n    return rv;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_ae3c8713e50ea36f0f36780f50629b181d794acc_0", {
    "ID": "httpd_ae3c8713e50ea36f0f36780f50629b181d794acc_0",
    "UID": "9086",
    "code": "APREQ_DECLARE(apr_size_t) apreq_quote_once(char *dest, const char test_snippet\n                                           const apr_size_t slen)\n{\n    if (is_quoted(src, slen)) {\n        \n        memcpy(dest, src, slen);\n        dest[slen] = 0;\n        return slen;\n    }\n    else\n        return apreq_quote(dest, src, slen);\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_d14af3281981a124c392cdae91cd805b45a7af69_0", {
    "ID": "httpd_d14af3281981a124c392cdae91cd805b45a7af69_0",
    "UID": "9089",
    "code": "static char *check_code(apr_pool_t *p, const char *code, char test_snippet\n{\n    char *word;\n    char base = 'X';\n    int modifier = 0;\n    int num = 0;\n    int factor;\n\n    /* 0.0.4 compatibility?\n     */\n    if ((code[0] == 'A') || (code[0] == 'M')) {\n        *real_code = (char *)code;\n        return NULL;\n    }\n\n    /* <base> [plus] {<num> <type>}*\n     */\n\n    /* <base>\n     */\n    word = ap_getword_conf(p, &code);\n    if (!strncasecmp(word, \"now\", 1) ||\n        !strncasecmp(word, \"access\", 1)) {\n        base = 'A';\n    }\n    else if (!strncasecmp(word, \"modification\", 1)) {\n        base = 'M';\n    }\n    else {\n        return apr_pstrcat(p, \"bad expires code, unrecognised <base> '\",\n                       word, \"'\", NULL);\n    }\n\n    /* [plus]\n     */\n    word = ap_getword_conf(p, &code);\n    if (!strncasecmp(word, \"plus\", 1)) {\n        word = ap_getword_conf(p, &code);\n    }\n\n    /* {<num> <type>}*\n     */\n    while (word[0]) {\n        /* <num>\n         */\n        if (apr_isdigit(word[0])) {\n            num = atoi(word);\n        }\n        else {\n            return apr_pstrcat(p, \"bad expires code, numeric value expected <num> '\",\n                           word, \"'\", NULL);\n        }\n\n        /* <type>\n         */\n        word = ap_getword_conf(p, &code);\n        if (word[0]) {\n            \n        }\n        else {\n            return apr_pstrcat(p, \"bad expires code, missing <type>\", NULL);\n        }\n\n        if (!strncasecmp(word, \"years\", 1)) {\n            factor = 60 * 60 * 24 * 365;\n        }\n        else if (!strncasecmp(word, \"months\", 2)) {\n            factor = 60 * 60 * 24 * 30;\n        }\n        else if (!strncasecmp(word, \"weeks\", 1)) {\n            factor = 60 * 60 * 24 * 7;\n        }\n        else if (!strncasecmp(word, \"days\", 1)) {\n            factor = 60 * 60 * 24;\n        }\n        else if (!strncasecmp(word, \"hours\", 1)) {\n            factor = 60 * 60;\n        }\n        else if (!strncasecmp(word, \"minutes\", 2)) {\n            factor = 60;\n        }\n        else if (!strncasecmp(word, \"seconds\", 1)) {\n            factor = 1;\n        }\n        else {\n            return apr_pstrcat(p, \"bad expires code, unrecognised <type>\",\n                           \"'\", word, \"'\", NULL);\n        }\n\n        modifier = modifier + factor * num;\n\n        /* next <num>\n         */\n        word = ap_getword_conf(p, &code);\n    }\n\n    *real_code = apr_psprintf(p, \"%c%d\", base, modifier);\n\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_f6f85d4c738581cc0b0a8044806ecbfa94b8eb48_0", {
    "ID": "httpd_f6f85d4c738581cc0b0a8044806ecbfa94b8eb48_0",
    "UID": "9113",
    "code": "static apr_status_t ajp_marshal_into_msgb(ajp_msg_t test_snippet\n                                          request_rec *r,\n                                          apr_uri_t *uri)\n{\n    int method;\n    apr_uint32_t i, num_headers = 0;\n    apr_byte_t is_ssl;\n    char *remote_host;\n    const char *session_route, *envvar;\n    const apr_array_header_t *arr = apr_table_elts(r->subprocess_env);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *)arr->elts;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, \"Into ajp_marshal_into_msgb\");\n\n    if ((method = sc_for_req_method_by_id(r)) == UNKNOWN_METHOD) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00967)\n               \"ajp_marshal_into_msgb - No such method %s\",\n               r->method);\n        return AJP_EBAD_METHOD;\n    }\n\n    is_ssl = (apr_byte_t) ap_proxy_conn_is_https(r->connection);\n\n    if (r->headers_in && apr_table_elts(r->headers_in)) {\n        const apr_array_header_t *t = apr_table_elts(r->headers_in);\n        num_headers = t->nelts;\n    }\n\n    remote_host = (char *)ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_HOST, NULL);\n\n    ajp_msg_reset(msg);\n\n    if (ajp_msg_append_uint8(msg, CMD_AJP13_FORWARD_REQUEST)     ||\n        ajp_msg_append_uint8(msg, (apr_byte_t) method)           ||\n        ajp_msg_append_string(msg, r->protocol)                  ||\n        ajp_msg_append_string(msg, uri->path)                    ||\n        ajp_msg_append_string(msg, r->useragent_ip)              ||\n        ajp_msg_append_string(msg, remote_host)                  ||\n        ajp_msg_append_string(msg, ap_get_server_name(r))        ||\n        ajp_msg_append_uint16(msg, (apr_uint16_t)r->connection->local_addr->port) ||\n        ajp_msg_append_uint8(msg, is_ssl)                        ||\n        ajp_msg_append_uint16(msg, (apr_uint16_t) num_headers)) {\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00968)\n               \"ajp_marshal_into_msgb: \"\n               \"Error appending the message begining\");\n        return APR_EGENERAL;\n    }\n\n    for (i = 0 ; i < num_headers ; i++) {\n        int sc;\n        const apr_array_header_t *t = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *elts = (apr_table_entry_t *)t->elts;\n\n        if ((sc = sc_for_req_header(elts[i].key)) != UNKNOWN_METHOD) {\n            if (ajp_msg_append_uint16(msg, (apr_uint16_t)sc)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00969)\n                       \"ajp_marshal_into_msgb: \"\n                       \"Error appending the header name\");\n                return AJP_EOVERFLOW;\n            }\n        }\n        else {\n            if (ajp_msg_append_string(msg, elts[i].key)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00970)\n                       \"ajp_marshal_into_msgb: \"\n                       \"Error appending the header name\");\n                return AJP_EOVERFLOW;\n            }\n        }\n\n        if (ajp_msg_append_string(msg, elts[i].val)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00971)\n                   \"ajp_marshal_into_msgb: \"\n                   \"Error appending the header value\");\n            return AJP_EOVERFLOW;\n        }\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                   \"ajp_marshal_into_msgb: Header[%d] [%s] = [%s]\",\n                   i, elts[i].key, elts[i].val);\n    }\n\n/* XXXX need to figure out how to do this\n    if (s->secret) {\n        if (ajp_msg_append_uint8(msg, SC_A_SECRET) ||\n            ajp_msg_append_string(msg, s->secret)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                   \"Error ajp_marshal_into_msgb - \"\n                   \"Error appending secret\");\n            return APR_EGENERAL;\n        }\n    }\n */\n\n    if (r->user) {\n        if (ajp_msg_append_uint8(msg, SC_A_REMOTE_USER) ||\n            ajp_msg_append_string(msg, r->user)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00972)\n                   \"ajp_marshal_into_msgb: \"\n                   \"Error appending the remote user\");\n            return AJP_EOVERFLOW;\n        }\n    }\n    if (r->ap_auth_type) {\n        if (ajp_msg_append_uint8(msg, SC_A_AUTH_TYPE) ||\n            ajp_msg_append_string(msg, r->ap_auth_type)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00973)\n                   \"ajp_marshal_into_msgb: \"\n                   \"Error appending the auth type\");\n            return AJP_EOVERFLOW;\n        }\n    }\n    \n    if (uri->query) {\n        if (ajp_msg_append_uint8(msg, SC_A_QUERY_STRING) ||\n            ajp_msg_append_string(msg, uri->query)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00974)\n                   \"ajp_marshal_into_msgb: \"\n                   \"Error appending the query string\");\n            return AJP_EOVERFLOW;\n        }\n    }\n    if ((session_route = apr_table_get(r->notes, \"session-route\"))) {\n        if (ajp_msg_append_uint8(msg, SC_A_JVM_ROUTE) ||\n            ajp_msg_append_string(msg, session_route)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00975)\n                   \"ajp_marshal_into_msgb: \"\n                   \"Error appending the jvm route\");\n            return AJP_EOVERFLOW;\n        }\n    }\n/* XXX: Is the subprocess_env a right place?\n * <Location /examples>\n *   ProxyPass ajp://remote:8009/servlets-examples\n *   SetEnv SSL_SESSION_ID CUSTOM_SSL_SESSION_ID\n * </Location>\n */\n    /*\n     * Only lookup SSL variables if we are currently running HTTPS.\n     * Furthermore ensure that only variables get set in the AJP message\n     * that are not NULL and not empty.\n     */\n    if (is_ssl) {\n        if ((envvar = ap_proxy_ssl_val(r->pool, r->server, r->connection, r,\n                                       AJP13_SSL_CLIENT_CERT_INDICATOR))\n            && envvar[0]) {\n            if (ajp_msg_append_uint8(msg, SC_A_SSL_CERT)\n                || ajp_msg_append_string(msg, envvar)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00976)\n                              \"ajp_marshal_into_msgb: \"\n                              \"Error appending the SSL certificates\");\n                return AJP_EOVERFLOW;\n            }\n        }\n\n        if ((envvar = ap_proxy_ssl_val(r->pool, r->server, r->connection, r,\n                                       AJP13_SSL_CIPHER_INDICATOR))\n            && envvar[0]) {\n            if (ajp_msg_append_uint8(msg, SC_A_SSL_CIPHER)\n                || ajp_msg_append_string(msg, envvar)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00977)\n                              \"ajp_marshal_into_msgb: \"\n                              \"Error appending the SSL ciphers\");\n                return AJP_EOVERFLOW;\n            }\n        }\n\n        if ((envvar = ap_proxy_ssl_val(r->pool, r->server, r->connection, r,\n                                       AJP13_SSL_SESSION_INDICATOR))\n            && envvar[0]) {\n            if (ajp_msg_append_uint8(msg, SC_A_SSL_SESSION)\n                || ajp_msg_append_string(msg, envvar)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00978)\n                              \"ajp_marshal_into_msgb: \"\n                              \"Error appending the SSL session\");\n                return AJP_EOVERFLOW;\n            }\n        }\n\n        \n        if ((envvar = ap_proxy_ssl_val(r->pool, r->server, r->connection, r,\n                                       AJP13_SSL_KEY_SIZE_INDICATOR))\n            && envvar[0]) {\n\n            if (ajp_msg_append_uint8(msg, SC_A_SSL_KEY_SIZE)\n                || ajp_msg_append_uint16(msg, (unsigned short) atoi(envvar))) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00979)\n                              \"ajp_marshal_into_msgb: \"\n                              \"Error appending the SSL key size\");\n                return APR_EGENERAL;\n            }\n        }\n    }\n    /* Forward the remote port information, which was forgotten\n     * from the builtin data of the AJP 13 protocol.\n     * Since the servlet spec allows to retrieve it via getRemotePort(),\n     * we provide the port to the Tomcat connector as a request\n     * attribute. Modern Tomcat versions know how to retrieve\n     * the remote port from this attribute.\n     */\n    {\n        const char *key = SC_A_REQ_REMOTE_PORT;\n        char *val = apr_itoa(r->pool, r->useragent_addr->port);\n        if (ajp_msg_append_uint8(msg, SC_A_REQ_ATTRIBUTE) ||\n            ajp_msg_append_string(msg, key)   ||\n            ajp_msg_append_string(msg, val)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00980)\n                    \"ajp_marshal_into_msgb: \"\n                    \"Error appending attribute %s=%s\",\n                    key, val);\n            return AJP_EOVERFLOW;\n        }\n    }\n    /* Use the environment vars prefixed with AJP_\n     * and pass it to the header striping that prefix.\n     */\n    for (i = 0; i < (apr_uint32_t)arr->nelts; i++) {\n        if (!strncmp(elts[i].key, \"AJP_\", 4)) {\n            if (ajp_msg_append_uint8(msg, SC_A_REQ_ATTRIBUTE) ||\n                ajp_msg_append_string(msg, elts[i].key + 4)   ||\n                ajp_msg_append_string(msg, elts[i].val)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00981)\n                        \"ajp_marshal_into_msgb: \"\n                        \"Error appending attribute %s=%s\",\n                        elts[i].key, elts[i].val);\n                return AJP_EOVERFLOW;\n            }\n        }\n    }\n\n    if (ajp_msg_append_uint8(msg, SC_A_ARE_DONE)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00982)\n               \"ajp_marshal_into_msgb: \"\n               \"Error appending the message end\");\n        return AJP_EOVERFLOW;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r,\n            \"ajp_marshal_into_msgb: Done\");\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n459,Incomplete Cleanup\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_7b71b42dd26868caea2e9c78e8426cec5380b555_0", {
    "ID": "httpd_7b71b42dd26868caea2e9c78e8426cec5380b555_0",
    "UID": "9119",
    "code": "static apr_status_t htdbm_list(htdbm_t test_snippet\n{\n    apr_status_t rv;\n    apr_datum_t key, val;\n    char *cmnt;\n    int i = 0;\n\n    rv = apr_dbm_firstkey(htdbm->dbm, &key);\n    if (rv != APR_SUCCESS) {\n        fprintf(stderr, \"Empty database -- %s\\n\", htdbm->filename);\n        return APR_ENOENT;\n    }\n    fprintf(stderr, \"Dumping records from database -- %s\\n\", htdbm->filename);\n    fprintf(stderr, \"    %-32s Comment\\n\", \"Username\");\n    while (key.dptr != NULL) {\n        rv = apr_dbm_fetch(htdbm->dbm, key, &val);\n        if (rv != APR_SUCCESS) {\n            fprintf(stderr, \"Failed getting data from %s\\n\", htdbm->filename);\n            return APR_EGENERAL;\n        }\n        \n        fprintf(stderr, \"    %-32.*s\", (int)key.dsize, key.dptr);\n        cmnt = memchr(val.dptr, ':', val.dsize);\n        if (cmnt)\n            fprintf(stderr, \" %.*s\", (int)(val.dptr+val.dsize - (cmnt+1)), cmnt + 1);\n        fprintf(stderr, \"\\n\");\n        rv = apr_dbm_nextkey(htdbm->dbm, &key);\n        if (rv != APR_SUCCESS)\n            fprintf(stderr, \"Failed getting NextKey\\n\");\n        ++i;\n    }\n\n    fprintf(stderr, \"Total #records : %d\\n\", i);\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_865c621dc51cdcca8a3335ef785c646a708e734c_0", {
    "ID": "httpd_865c621dc51cdcca8a3335ef785c646a708e734c_0",
    "UID": "9123",
    "code": "static const char *set_cookie_name(cmd_parms * cmd, void test_snippet\n                                   const char *args)\n{\n    char *last;\n    char *line = apr_pstrdup(cmd->pool, args);\n    session_cookie_dir_conf *conf = (session_cookie_dir_conf *) config;\n    char *cookie = apr_strtok(line, \" \\t\", &last);\n    conf->name = cookie;\n    conf->name_set = 1;\n    while (apr_isspace(*last)) {\n        last++;\n    }\n    conf->name_attrs = last;\n    return check_string(cmd, cookie);\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n457,Use of Uninitialized Variable"
  },
  "httpd_960b7237eae9d4a98cf951d07560709f7e170ffc_0", {
    "ID": "httpd_960b7237eae9d4a98cf951d07560709f7e170ffc_0",
    "UID": "9127",
    "code": "test_snippet\n{\n    struct gen_ctx *ctx = parser->ctx;\n    apr_pool_t *pool = parser->pool;\n    apr_status_t s = APR_SUCCESS;\n    apr_bucket *e = APR_BRIGADE_LAST(bb);\n    unsigned saw_eos = 0;\n\n    if (ctx == NULL) {\n        parser->ctx = ctx = apr_palloc(pool, sizeof *ctx);\n        ctx->status = GEN_INCOMPLETE;\n        ctx->param = apreq_param_make(pool,\n                                      \"_dummy_\", strlen(\"_dummy_\"), \"\", 0);\n        ctx->param->upload = apr_brigade_create(pool, parser->bucket_alloc);\n        ctx->param->info = apr_table_make(pool, APREQ_DEFAULT_NELTS);\n    }\n\n\n    PARSER_STATUS_CHECK(GEN);\n\n    while (e != APR_BRIGADE_SENTINEL(bb)) {\n        if (APR_BUCKET_IS_EOS(e)) {\n            saw_eos = 1;\n            break;\n        }\n        e = APR_BUCKET_PREV(e);\n    }\n\n    if (parser->hook != NULL) {\n        s = apreq_hook_run(parser->hook, ctx->param, bb);\n        if (s != APR_SUCCESS) {\n            ctx->status = GEN_ERROR;\n            return s;\n        }\n    }\n\n    apreq_brigade_setaside(bb, pool);\n    s = apreq_brigade_concat(pool, parser->temp_dir, parser->brigade_limit,\n                             ctx->param->upload, bb);\n\n    if (s != APR_SUCCESS) {\n        ctx->status = GEN_ERROR;\n        return s;\n    }\n\n    if (saw_eos) {\n        ctx->status = GEN_COMPLETE;\n        return APR_SUCCESS;\n    }\n    else\n        return APR_INCOMPLETE;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free"
  },
  "httpd_9d4bcb5dc9f2cc645f7a6e600735a567ac459acf_0", {
    "ID": "httpd_9d4bcb5dc9f2cc645f7a6e600735a567ac459acf_0",
    "UID": "9141",
    "code": "void sed_destroy_eval(sed_eval_t test_snippet\n{\n    int i;\n    /* eval->linebuf, eval->holdbuf, eval->genbuf and eval->inar are allocated\n     * on pool. It will be freed when pool will be freed */\n    for (i = 0; i < eval->commands->nfiles; i++) {\n        if (eval->fcode[i] != NULL) {\n            apr_file_close(eval->fcode[i]);\n            eval->fcode[i] = NULL;\n        }\n    }\n}",
    "predicted": "775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4f030956a77ecb875986d7f628c7949544791cb1_0", {
    "ID": "httpd_4f030956a77ecb875986d7f628c7949544791cb1_0",
    "UID": "9143",
    "code": "static char **create_argv(apr_pool_t *p, char *path, char *user, char test_snippet\n                          char *av0, const char *args)\n{\n    int x, numwords;\n    char **av;\n    char *w;\n    int idx = 0;\n\n    if (!(*args) || ap_strchr_c(args, '=')) {\n        numwords = 0;\n    }\n    else {\n        \n\n        for (x = 0, numwords = 1; args[x]; x++) {\n            if (args[x] == '+') {\n                ++numwords;\n            }\n        }\n    }\n\n    if (numwords > APACHE_ARG_MAX - 5) {\n        numwords = APACHE_ARG_MAX - 5;  \n    }\n    av = (char **) apr_pcalloc(p, (numwords + 5) * sizeof(char *));\n\n    if (path) {\n        av[idx++] = path;\n    }\n    if (user) {\n        av[idx++] = user;\n    }\n    if (group) {\n        av[idx++] = group;\n    }\n\n    av[idx++] = apr_pstrdup(p, av0);\n\n    for (x = 1; x <= numwords; x++) {\n        w = ap_getword_nulls(p, &args, '+');\n        ap_unescape_url(w);\n        av[idx++] = ap_escape_shell_cmd(p, w);\n    }\n    av[idx] = NULL;\n    return av;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n134,Use of Externally-Controlled Format String\n190,Integer Overflow or Wraparound\n400,Uncontrolled Resource Consumption\n457,Use of Uninitialized Variable\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_704f151d25298a6955ee7073af21c16b0c1f7bbd_0", {
    "ID": "httpd_704f151d25298a6955ee7073af21c16b0c1f7bbd_0",
    "UID": "9146",
    "code": "static int dav_find_liveprop_provider(dav_propdb test_snippet\n                                      const char *ns_uri,\n                                      const char *propname,\n                                      const dav_hooks_liveprop **provider)\n{\n    int propid;\n\n    *provider = NULL;\n\n    if (ns_uri == NULL) {\n        \n        return DAV_PROPID_CORE_UNKNOWN;\n    }\n\n    \n    propid = dav_run_find_liveprop(propdb->resource, ns_uri, propname,\n                                   provider);\n    if (propid != 0) {\n        return propid;\n    }\n\n    \n    if (strcmp(ns_uri, \"DAV:\") == 0) {\n        const char * const *p = dav_core_props;\n\n        for (propid = DAV_PROPID_CORE; *p != NULL; ++p, ++propid)\n            if (strcmp(propname, *p) == 0) {\n                return propid;\n            }\n    }\n\n    \n    return DAV_PROPID_CORE_UNKNOWN;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_62c553bd15354409b8488a9912d7809c5b7ff7e6_0", {
    "ID": "httpd_62c553bd15354409b8488a9912d7809c5b7ff7e6_0",
    "UID": "9149",
    "code": "static void alloc_outbuf(sed_filter_ctxt* test_snippet\n{\n    ctx->outbuf = apr_palloc(ctx->tpool, ctx->bufsize + 1);\n    ctx->curoutbuf = ctx->outbuf;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_56ff9933f61bf16b283cccaf3b96dabaae77454d_0", {
    "ID": "httpd_56ff9933f61bf16b283cccaf3b96dabaae77454d_0",
    "UID": "9150",
    "code": "static const char *construct_key(request_rec *r, const char test_snippet\n                                 const char *user, const char *realm)\n{\n    \n    if (!strcmp(context, \"directory\")) {\n        \n        char *new_context;\n        char *slash = strrchr(r->uri, '/');\n        new_context = apr_palloc(r->pool, slash - r->uri +\n                                 strlen(r->server->server_hostname) + 1);\n        strcpy(new_context, r->server->server_hostname);\n        strncat(new_context, r->uri, slash - r->uri);\n        context = new_context;\n    }\n    else if (!strcmp(context, \"server\")) {\n        context = r->server->server_hostname;\n    }\n    \n\n    if (realm == NULL) {                              \n        return apr_pstrcat(r->pool, context, \":\", user, NULL);\n    }\n    else {                                            \n        return apr_pstrcat(r->pool, context, \":\", user, \":\", realm, NULL);\n    }\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow"
  },
  "httpd_655512b604a03e0cccabb13473dd9bec9fb12a4b_0", {
    "ID": "httpd_655512b604a03e0cccabb13473dd9bec9fb12a4b_0",
    "UID": "9152",
    "code": "dav_error * test_snippet\n    const dav_resource *resource,\n    const char **dirpath_p,\n    const char **fname_p)\n{\n    dav_resource_private *ctx = resource->info;\n\n    if (resource->collection) {\n        *dirpath_p = ctx->pathname;\n        if (fname_p != NULL)\n            *fname_p = NULL;\n    }\n    else {\n        const char *testpath, *rootpath;\n        char *dirpath = ap_make_dirstr_parent(ctx->pool, ctx->pathname);\n        apr_size_t dirlen = strlen(dirpath);\n        apr_status_t rv = APR_SUCCESS;\n\n        testpath = dirpath;\n        if (dirlen > 0) {\n            rv = apr_filepath_root(&rootpath, &testpath, 0, ctx->pool);\n        }\n\n        /* remove trailing slash from dirpath, unless it's a root path\n         */\n        if ((rv == APR_SUCCESS && testpath && *testpath)\n            || rv == APR_ERELATIVE) {\n            if (dirpath[dirlen - 1] == '/') {\n                dirpath[dirlen - 1] = '\\0';\n            }\n        }\n\n        /* ###: Looks like a response could be appropriate\n         *\n         * APR_SUCCESS     here tells us the dir is a root\n         * APR_ERELATIVE   told us we had no root (ok)\n         * APR_EINCOMPLETE an incomplete testpath told us\n         *                 there was no -file- name here!\n         * APR_EBADPATH    or other errors tell us this file\n         *                 path is undecipherable\n         */\n\n        if (rv == APR_SUCCESS || rv == APR_ERELATIVE) {\n            *dirpath_p = dirpath;\n            if (fname_p != NULL)\n                *fname_p = ctx->pathname + dirlen;\n        }\n        else {\n            return dav_new_error(ctx->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rv,\n                                 \"An incomplete/bad path was found in \"\n                                 \"dav_fs_dir_file_name.\");\n        }\n    }\n\n    return NULL;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_bc1673f8a89401ad5be3a3e90659e7f668de55ed_0", {
    "ID": "httpd_bc1673f8a89401ad5be3a3e90659e7f668de55ed_0",
    "UID": "9163",
    "code": "static void mod_info_show_close(request_rec * r, const ap_directive_t * test_snippet\n                                int nest)\n{\n    const char *dirname = dir->directive;\n    mod_info_indent(r, nest, dir->filename, 0);\n    if (*dirname == '<') {\n        if (r)\n            ap_rprintf(r, \"&lt;/%s&gt;</tt></dd>\",\n                       ap_escape_html(r->pool, dirname + 1));\n        else\n            apr_file_printf(out, \"</%s>\\n\", dirname + 1);\n    }\n    else {\n        if (r)\n            ap_rprintf(r, \"/%s</tt></dd>\", ap_escape_html(r->pool, dirname));\n        else\n            apr_file_printf(out, \"/%s\\n\", dirname);\n    }\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_158ba1f107389a34695eea0f05a32ec083b0252d_0", {
    "ID": "httpd_158ba1f107389a34695eea0f05a32ec083b0252d_0",
    "UID": "9169",
    "code": "static int send_headers(request_rec *r, proxy_conn_rec test_snippet\n{\n    char *buf, *cp, *bodylen;\n    const char *ns_len;\n    const apr_array_header_t *env_table;\n    const apr_table_entry_t *env;\n    int j;\n    apr_size_t len, bodylen_size;\n    apr_size_t headerlen =   sizeof(CONTENT_LENGTH)\n                           + sizeof(SCGI_MAGIC)\n                           + sizeof(SCGI_PROTOCOL_VERSION);\n\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    /*\n     * The header blob basically takes the environment and concatenates\n     * keys and values using 0 bytes. There are special treatments here:\n     *   - GATEWAY_INTERFACE and SCGI_MAGIC are dropped\n     *   - CONTENT_LENGTH is always set and must be sent as the very first\n     *     variable\n     *\n     * Additionally it's wrapped into a so-called netstring (see SCGI spec)\n     */\n    env_table = apr_table_elts(r->subprocess_env);\n    env = (apr_table_entry_t *)env_table->elts;\n    for (j = 0; j < env_table->nelts; ++j) {\n        if (   (!strcmp(env[j].key, GATEWAY_INTERFACE))\n            || (!strcmp(env[j].key, CONTENT_LENGTH))\n            || (!strcmp(env[j].key, SCGI_MAGIC))) {\n            continue;\n        }\n        headerlen += strlen(env[j].key) + strlen(env[j].val) + 2;\n    }\n    bodylen = apr_psprintf(r->pool, \"%\" APR_OFF_T_FMT, r->remaining);\n    bodylen_size = strlen(bodylen) + 1;\n    headerlen += bodylen_size;\n\n    ns_len = apr_psprintf(r->pool, \"%\" APR_SIZE_T_FMT \":\", headerlen);\n    len = strlen(ns_len);\n    headerlen += len + 1; \n    cp = buf = apr_palloc(r->pool, headerlen);\n    memcpy(cp, ns_len, len);\n    cp += len;\n\n    memcpy(cp, CONTENT_LENGTH, sizeof(CONTENT_LENGTH));\n    cp += sizeof(CONTENT_LENGTH);\n    memcpy(cp, bodylen, bodylen_size);\n    cp += bodylen_size;\n    memcpy(cp, SCGI_MAGIC, sizeof(SCGI_MAGIC));\n    cp += sizeof(SCGI_MAGIC);\n    memcpy(cp, SCGI_PROTOCOL_VERSION, sizeof(SCGI_PROTOCOL_VERSION));\n    cp += sizeof(SCGI_PROTOCOL_VERSION);\n\n    for (j = 0; j < env_table->nelts; ++j) {\n        if (   (!strcmp(env[j].key, GATEWAY_INTERFACE))\n            || (!strcmp(env[j].key, CONTENT_LENGTH))\n            || (!strcmp(env[j].key, SCGI_MAGIC))) {\n            continue;\n        }\n        len = strlen(env[j].key) + 1;\n        memcpy(cp, env[j].key, len);\n        cp += len;\n        len = strlen(env[j].val) + 1;\n        memcpy(cp, env[j].val, len);\n        cp += len;\n    }\n    *cp++ = ',';\n\n    return sendall(conn, buf, headerlen, r);\n}",
    "predicted": "680,Integer Overflow to Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_8bcfb3c00a9ba02ff764730faf162559a4bfc233_0", {
    "ID": "httpd_8bcfb3c00a9ba02ff764730faf162559a4bfc233_0",
    "UID": "9175",
    "code": "apr_status_t apreq_filter_prefetch(ap_filter_t *f, apr_off_t test_snippet\n{\n    struct filter_ctx *ctx = f->ctx;\n    request_rec *r = f->r;\n    apr_status_t rv;\n    apr_off_t len;\n\n    if (ctx->body_status == APR_EINIT)\n        apreq_filter_init_context(f);\n\n    if (ctx->body_status != APR_INCOMPLETE || readbytes == 0)\n        return ctx->body_status;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02050)\n                  \"prefetching %\" APR_OFF_T_FMT \" bytes\", test_snippet;\n\n    rv = ap_get_brigade(f->next, ctx->bb, AP_MODE_READBYTES,\n                       APR_BLOCK_READ, test_snippet;\n\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02051)\n                      \"ap_get_brigade failed during prefetch\");\n        ctx->filter_error = rv;\n        return ctx->body_status = APREQ_ERROR_GENERAL;\n    }\n\n    apreq_brigade_setaside(ctx->bb, r->pool);\n    apreq_brigade_copy(ctx->bbtmp, ctx->bb);\n\n    rv = apreq_brigade_concat(r->pool, ctx->temp_dir, ctx->brigade_limit,\n                              ctx->spool, ctx->bbtmp);\n    if (rv != APR_SUCCESS && rv != APR_EOF) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02052)\n                      \"apreq_brigade_concat failed; TempDir problem?\");\n        ctx->filter_error = APR_EGENERAL;\n        return ctx->body_status = rv;\n    }\n\n    /* Adding \"f\" to the protocol filter chain ensures the\n     * spooled data is preserved across internal redirects.\n     */\n\n    if (f != r->proto_input_filters) {\n        ap_filter_t *in;\n        for (in = r->input_filters; in != r->proto_input_filters;\n             in = in->next)\n        {\n            if (f == in) {\n                r->proto_input_filters = f;\n                break;\n            }\n        }\n    }\n\n    apr_brigade_length(ctx->bb, 1, &len);\n    ctx->bytes_read += len;\n\n    if (ctx->bytes_read > ctx->read_limit) {\n        ctx->body_status = APREQ_ERROR_OVERLIMIT;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r, APLOGNO(02053)\n                      \"Bytes read (%\" APR_UINT64_T_FMT\n                      \") exceeds configured read limit (%\" APR_UINT64_T_FMT \")\",\n                      ctx->bytes_read, ctx->read_limit);\n        return ctx->body_status;\n    }\n\n    ctx->body_status = apreq_parser_run(ctx->parser, ctx->body, ctx->bb);\n    apr_brigade_cleanup(ctx->bb);\n\n    return ctx->body_status;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_6913f20c5a21211cce6ad4f45837725d7f3cf0af_0", {
    "ID": "httpd_6913f20c5a21211cce6ad4f45837725d7f3cf0af_0",
    "UID": "9176",
    "code": "APREQ_DECLARE(apreq_handle_t *)apreq_handle_custom(apr_pool_t test_snippet\n                                                   const char *query_string,\n                                                   const char *cookie,\n                                                   apreq_parser_t *parser,\n                                                   apr_uint64_t read_limit,\n                                                   apr_bucket_brigade *in)\n{\n    struct custom_handle *req;\n    req = apr_palloc(pool, sizeof(*req));\n    req->handle.module = &custom_module;\n    req->handle.pool = pool;\n    req->handle.bucket_alloc = in->bucket_alloc;\n    req->read_limit = read_limit;\n    req->bytes_read = 0;\n    req->parser = parser;\n    req->in = apr_brigade_create(pool, in->bucket_alloc);\n    req->tmpbb = apr_brigade_create(pool, in->bucket_alloc);\n    req->body = apr_table_make(pool, APREQ_DEFAULT_NELTS);\n    req->body_status = APR_INCOMPLETE;\n    APR_BRIGADE_CONCAT(req->in, in);\n\n    if (cookie != NULL) {\n        req->jar = apr_table_make(pool, APREQ_DEFAULT_NELTS);\n        req->jar_status =\n            apreq_parse_cookie_header(pool, req->jar, cookie);\n    }\n    else {\n        req->jar = NULL;\n        req->jar_status = APREQ_ERROR_NODATA;\n    }\n\n\n    if (query_string != NULL) {\n        req->args = apr_table_make(pool, APREQ_DEFAULT_NELTS);\n        req->args_status =\n            apreq_parse_query_string(pool, req->args, query_string);\n    }\n    else {\n        req->args = NULL;\n        req->args_status = APREQ_ERROR_NODATA;\n    }\n\n    if (!APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(req->in))) {\n        apr_bucket *eos = apr_bucket_eos_create(in->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(req->in, eos);\n    }\n\n    return &req->handle;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_6dab5b0a4671012273beed8e92453e24c71dd4ce_0", {
    "ID": "httpd_6dab5b0a4671012273beed8e92453e24c71dd4ce_0",
    "UID": "9184",
    "code": "static proxy_worker *find_best_hb(proxy_balancer test_snippet\n                                  request_rec *r)\n{\n    apr_status_t rv;\n    int i;\n    apr_uint32_t openslots = 0;\n    proxy_worker **worker;\n    hb_server_t *server;\n    apr_array_header_t *up_servers;\n    proxy_worker *mycandidate = NULL;\n    apr_pool_t *tpool;\n    apr_hash_t *servers;\n\n    lb_hb_ctx_t *ctx =\n        ap_get_module_config(r->server->module_config,\n                             &lbmethod_heartbeat_module);\n\n    if (!ap_proxy_retry_worker_fn) {\n        ap_proxy_retry_worker_fn =\n                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_retry_worker);\n        if (!ap_proxy_retry_worker_fn) {\n            \n            return NULL;\n        }\n    }\n\n    apr_pool_create(&tpool, r->pool);\n\n    servers = apr_hash_make(tpool);\n\n    rv = read_heartbeats(ctx->path, servers, tpool);\n\n    if (rv) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01213)\n                      \"lb_heartbeat: Unable to read heartbeats at '%s'\",\n                      ctx->path);\n        apr_pool_destroy(tpool);\n        return NULL;\n    }\n\n    up_servers = apr_array_make(tpool, apr_hash_count(servers), sizeof(hb_server_t *));\n\n    for (i = 0; i < balancer->workers->nelts; i++) {\n        worker = &APR_ARRAY_IDX(balancer->workers, i, proxy_worker *);\n        server = apr_hash_get(servers, (*worker)->s->hostname, APR_HASH_KEY_STRING);\n\n        if (!server) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01214)\n                      \"lb_heartbeat: No server for worker %s\", (*worker)->s->name);\n            continue;\n        }\n\n        if (!PROXY_WORKER_IS_USABLE(*worker)) {\n            ap_proxy_retry_worker_fn(\"BALANCER\", *worker, r->server);\n        }\n\n        if (PROXY_WORKER_IS_USABLE(*worker)) {\n            server->worker = *worker;\n            if (server->seen < LBM_HEARTBEAT_MAX_LASTSEEN) {\n                openslots += server->ready;\n                APR_ARRAY_PUSH(up_servers, hb_server_t *) = server;\n            }\n        }\n    }\n\n    if (openslots > 0) {\n        apr_uint32_t c = 0;\n        apr_uint32_t pick = 0;\n\n        pick = ap_random_pick(0, openslots);\n\n        for (i = 0; i < up_servers->nelts; i++) {\n            server = APR_ARRAY_IDX(up_servers, i, hb_server_t *);\n            if (pick >= c && pick <= c + server->ready) {\n                mycandidate = server->worker;\n            }\n\n            c += server->ready;\n        }\n    }\n\n    apr_pool_destroy(tpool);\n\n    return mycandidate;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_ea904cbf2678282989e9a79b7d2f99f7c4534a16_0", {
    "ID": "httpd_ea904cbf2678282989e9a79b7d2f99f7c4534a16_0",
    "UID": "9190",
    "code": "apr_status_t cache_try_lock(cache_server_conf *conf, cache_request_rec test_snippet\n        request_rec *r)\n{\n    apr_status_t status;\n    const char *lockname;\n    const char *path;\n    char dir[5];\n    apr_time_t now = apr_time_now();\n    apr_finfo_t finfo;\n    apr_file_t *lockfile;\n    void *dummy;\n\n    finfo.mtime = 0;\n\n    if (!conf || !conf->lock || !conf->lockpath) {\n        \n        return APR_SUCCESS;\n    }\n\n    \n    apr_pool_userdata_get(&dummy, CACHE_LOCKFILE_KEY, r->pool);\n    if (dummy) {\n        return APR_SUCCESS;\n    }\n\n    \n    if (!cache->key) {\n        cache_generate_key(r, r->pool, &cache->key);\n    }\n\n    \n    lockname = ap_cache_generate_name(r->pool, 0, 0, cache->key);\n\n    /* lock files represent discrete just-went-stale URLs \"in flight\", so\n     * we support a simple two level directory structure, more is overkill.\n     */\n    dir[0] = '/';\n    dir[1] = lockname[0];\n    dir[2] = '/';\n    dir[3] = lockname[1];\n    dir[4] = 0;\n\n    \n    path = apr_pstrcat(r->pool, conf->lockpath, dir, NULL);\n    if (APR_SUCCESS != (status = apr_dir_make_recursive(path,\n            APR_UREAD|APR_UWRITE|APR_UEXECUTE, r->pool))) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00778)\n                \"Could not create a cache lock directory: %s\",\n                path);\n        return status;\n    }\n    lockname = apr_pstrcat(r->pool, path, \"/\", lockname, NULL);\n    apr_pool_userdata_set(lockname, CACHE_LOCKNAME_KEY, NULL, r->pool);\n\n    \n    status = apr_stat(&finfo, lockname,\n                APR_FINFO_MTIME | APR_FINFO_NLINK, r->pool);\n    if (!(APR_STATUS_IS_ENOENT(status)) && APR_SUCCESS != status) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EEXIST, r, APLOGNO(00779)\n                \"Could not stat a cache lock file: %s\",\n                lockname);\n        return status;\n    }\n    if ((status == APR_SUCCESS) && (((now - finfo.mtime) > conf->lockmaxage)\n                                  || (now < finfo.mtime))) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO(00780)\n                \"Cache lock file for '%s' too old, removing: %s\",\n                r->uri, lockname);\n        apr_file_remove(lockname, r->pool);\n    }\n\n    \n    if (APR_SUCCESS == (status = apr_file_open(&lockfile, lockname,\n            APR_WRITE | APR_CREATE | APR_EXCL | APR_DELONCLOSE,\n            APR_UREAD | APR_UWRITE, r->pool))) {\n        apr_pool_userdata_set(lockfile, CACHE_LOCKFILE_KEY, NULL, r->pool);\n    }\n    return status;\n\n}",
    "predicted": "23,Relative Path Traversal\n36,Absolute Path Traversal\n377,Insecure Temporary File\n427,Uncontrolled Search Path Element"
  },
  "httpd_99482fa49b5e1d26dffdc1527e5b48b5c177b538_0", {
    "ID": "httpd_99482fa49b5e1d26dffdc1527e5b48b5c177b538_0",
    "UID": "9195",
    "code": "test_snippet\n    apreq_header_attribute(const char *hdr,\n                           const char *name, const apr_size_t nlen,\n                           const char **val, apr_size_t *vlen)\n{\n    const char *key, *v;\n\n    \n    while (*hdr == '=')\n        ++hdr;\n\n    while ((key = strchr(hdr, '=')) != NULL) {\n\n        v = key + 1;\n        --key;\n\n        while (apr_isspace(*key) && key > hdr + nlen)\n            --key;\n\n        key -= nlen - 1;\n\n        while (apr_isspace(*v))\n            ++v;\n\n        if (*v == '\"') {\n            ++v;\n            *val = v;\n\n        look_for_end_quote:\n            switch (*v) {\n            case '\"':\n                break;\n            case 0:\n                return APREQ_ERROR_BADSEQ;\n            case '\\\\':\n                if (v[1] != 0)\n                    ++v;\n            default:\n                ++v;\n                goto look_for_end_quote;\n            }\n        }\n        else {\n            *val = v;\n\n        look_for_terminator:\n            switch (*v) {\n            case 0:\n            case ' ':\n            case ';':\n            case ',':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                break;\n            default:\n                ++v;\n                goto look_for_terminator;\n            }\n        }\n\n        if (key >= hdr && strncasecmp(key, name, nlen) == 0) {\n            *vlen = v - *val;\n            if (key == hdr || ! is_2616_token(key[-1]))\n                return APR_SUCCESS;\n        }\n        hdr = v;\n    }\n\n    return APREQ_ERROR_NOATTR;\n}",
    "predicted": "476,NULL Pointer Dereference\n126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_4da6653c3921677fdcab3ebd09903f76ee4a90db_0", {
    "ID": "httpd_4da6653c3921677fdcab3ebd09903f76ee4a90db_0",
    "UID": "9205",
    "code": "test_snippet\n{\n    apr_pool_t *pool = parser->pool;\n    apr_bucket_alloc_t *ba = parser->bucket_alloc;\n    struct mfd_ctx *ctx = parser->ctx;\n    apr_status_t s;\n\n    if (ctx == NULL) {\n        ctx = create_multipart_context(parser->content_type,\n                                       pool, ba,\n                                       parser->brigade_limit,\n                                       parser->temp_dir, 1);\n        if (ctx == NULL)\n            return APREQ_ERROR_GENERAL;\n\n\n        parser->ctx = ctx;\n    }\n\n    PARSER_STATUS_CHECK(MFD);\n    APR_BRIGADE_CONCAT(ctx->in, bb);\n\n mfd_parse_brigade:\n\n    switch (ctx->status) {\n\n    case MFD_INIT:\n        {\n            s = split_on_bdry(ctx->bb, ctx->in, NULL, ctx->bdry + 2);\n            if (s != APR_SUCCESS) {\n                apreq_brigade_setaside(ctx->in, pool);\n                apreq_brigade_setaside(ctx->bb, pool);\n                return s;\n            }\n            ctx->status = MFD_NEXTLINE;\n            \n            APR_BRIGADE_CONCAT(bb, ctx->bb);\n        }\n\n        \n\n    case MFD_NEXTLINE:\n        {\n            s = split_on_bdry(ctx->bb, ctx->in, NULL, CRLF);\n            if (s == APR_EOF) {\n                ctx->status = MFD_COMPLETE;\n                return APR_SUCCESS;\n            }\n            if (s != APR_SUCCESS) {\n                apreq_brigade_setaside(ctx->in, pool);\n                apreq_brigade_setaside(ctx->bb, pool);\n                return s;\n            }\n            if (!APR_BRIGADE_EMPTY(ctx->bb)) {\n                char *line;\n                apr_size_t len;\n                apr_brigade_pflatten(ctx->bb, &line, &len, pool);\n\n                if (len >= 2 && strncmp(line, \"--\", 2) == 0) {\n                    APR_BRIGADE_CONCAT(bb, ctx->in);\n                    ctx->status = MFD_COMPLETE;\n                    return APR_SUCCESS;\n                }\n                apr_brigade_cleanup(ctx->bb);\n            }\n\n            ctx->status = MFD_HEADER;\n            ctx->info = NULL;\n        }\n        \n\n    case MFD_HEADER:\n        {\n            if (ctx->info == NULL) {\n                ctx->info = apr_table_make(pool, APREQ_DEFAULT_NELTS);\n                \n                ctx->hdr_parser->ctx = NULL;\n            }\n            s = apreq_parser_run(ctx->hdr_parser, ctx->info, ctx->in);\n            switch (s) {\n            case APR_SUCCESS:\n                ctx->status = MFD_POST_HEADER;\n                break;\n            case APR_INCOMPLETE:\n                apreq_brigade_setaside(ctx->in, pool);\n                return APR_INCOMPLETE;\n            default:\n                ctx->status = MFD_ERROR;\n                return s;\n            }\n        }\n        \n\n    case MFD_POST_HEADER:\n        {\n            /*  Must handle special case of missing CRLF (mainly\n             *  coming from empty file uploads). See RFC2065 S5.1.1:\n             *\n             *    body-part = MIME-part-header [CRLF *OCTET]\n             *\n             *  So the CRLF we already matched in MFD_HEADER may have been\n             *  part of the boundary string! Both Konqueror (v??) and\n             *  Mozilla-0.97 are known to emit such blocks.\n             *\n             *  Here we first check for this condition with\n             *  brigade_start_string, and prefix the brigade with\n             *  an additional CRLF bucket if necessary.\n             */\n\n            const char *cd, *ct, *name, *filename;\n            apr_size_t nlen, flen;\n            apr_bucket *e;\n\n            switch (brigade_start_string(ctx->in, ctx->bdry + 2)) {\n\n            case APR_INCOMPLETE:\n                apreq_brigade_setaside(ctx->in, pool);\n                return APR_INCOMPLETE;\n\n            case APR_SUCCESS:\n                \n                e = apr_bucket_immortal_create(CRLF, 2,\n                                                ctx->bb->bucket_alloc);\n                APR_BRIGADE_INSERT_HEAD(ctx->in, e);\n                break;\n\n            default:\n                ; \n            }\n\n            cd = apr_table_get(ctx->info, \"Content-Disposition\");\n\n            /*  First check to see if must descend into a new multipart\n             *  block.  If we do, create a new parser and pass control\n             *  to it.\n             */\n\n            ct = apr_table_get(ctx->info, \"Content-Type\");\n\n            if (ct != NULL && strncmp(ct, \"multipart/\", 10) == 0) {\n                struct mfd_ctx *next_ctx;\n\n                if (ctx->level >= MAX_LEVEL) {\n                    ctx->status = MFD_ERROR;\n                    goto mfd_parse_brigade;\n                }\n\n                next_ctx = create_multipart_context(ct, pool, ba,\n                                                    parser->brigade_limit,\n                                                    parser->temp_dir,\n                                                    ctx->level + 1);\n\n                next_ctx->param_name = \"\";\n\n                if (cd != NULL) {\n                    s = apreq_header_attribute(cd, \"name\", 4,\n                                               &name, &nlen);\n                    if (s == APR_SUCCESS) {\n                        next_ctx->param_name\n                            = apr_pstrmemdup(pool, name, nlen);\n                    }\n                    else {\n                        const char *cid = apr_table_get(ctx->info,\n                                                        \"Content-ID\");\n                        if (cid != NULL)\n                            next_ctx->param_name = apr_pstrdup(pool, cid);\n                    }\n\n                }\n\n                ctx->next_parser = apreq_parser_make(pool, ba, ct,\n                                                     apreq_parse_multipart,\n                                                     parser->brigade_limit,\n                                                     parser->temp_dir,\n                                                     parser->hook,\n                                                     next_ctx);\n                ctx->status = MFD_MIXED;\n                goto mfd_parse_brigade;\n\n            }\n\n            \n\n            if (cd != NULL && strncmp(cd, \"form-data\", 9) == 0) {\n                s = apreq_header_attribute(cd, \"name\", 4, &name, &nlen);\n                if (s != APR_SUCCESS) {\n                    ctx->status = MFD_ERROR;\n                    goto mfd_parse_brigade;\n                }\n\n                s = apreq_header_attribute(cd, \"filename\",\n                                           8, &filename, &flen);\n                if (s == APR_SUCCESS) {\n                    apreq_param_t *param;\n\n                    param = apreq_param_make(pool, name, nlen,\n                                             filename, flen);\n                    apreq_param_tainted_on(param);\n                    param->info = ctx->info;\n                    param->upload\n                        = apr_brigade_create(pool, ctx->bb->bucket_alloc);\n                    ctx->upload = param;\n                    ctx->status = MFD_UPLOAD;\n                    goto mfd_parse_brigade;\n                }\n                else {\n                    ctx->param_name = apr_pstrmemdup(pool, name, nlen);\n                    ctx->status = MFD_PARAM;\n                    \n                }\n            }\n\n            \n            else if (cd != NULL && strncmp(cd, \"file\", 4) == 0) {\n                apreq_param_t *param;\n\n                s = apreq_header_attribute(cd, \"filename\",\n                                           8, &filename, &flen);\n                if (s != APR_SUCCESS || ctx->param_name == NULL) {\n                    ctx->status = MFD_ERROR;\n                    goto mfd_parse_brigade;\n                }\n                name = ctx->param_name;\n                nlen = strlen(name);\n                param = apreq_param_make(pool, name, nlen,\n                                         filename, flen);\n                apreq_param_tainted_on(param);\n                param->info = ctx->info;\n                param->upload = apr_brigade_create(pool,\n                                                   ctx->bb->bucket_alloc);\n                ctx->upload = param;\n                ctx->status = MFD_UPLOAD;\n                goto mfd_parse_brigade;\n            }\n\n            \n            else {\n                const char *cid = apr_table_get(ctx->info, \"Content-ID\");\n                apreq_param_t *param;\n\n                if (cid != NULL) {\n                    name = cid;\n                    nlen = strlen(name);\n                }\n                else {\n                    name = \"\";\n                    nlen = 0;\n                }\n\n                filename = \"\";\n                flen = 0;\n                param = apreq_param_make(pool, name, nlen,\n                                         filename, flen);\n                apreq_param_tainted_on(param);\n                param->info = ctx->info;\n                param->upload = apr_brigade_create(pool,\n                                               ctx->bb->bucket_alloc);\n                ctx->upload = param;\n                ctx->status = MFD_UPLOAD;\n                goto mfd_parse_brigade;\n            }\n        }\n        \n\n    case MFD_PARAM:\n        {\n            apreq_param_t *param;\n            apreq_value_t *v;\n            apr_size_t len;\n            apr_off_t off;\n\n            s = split_on_bdry(ctx->bb, ctx->in, ctx->pattern, ctx->bdry);\n\n            switch (s) {\n\n            case APR_INCOMPLETE:\n                apreq_brigade_setaside(ctx->in, pool);\n                apreq_brigade_setaside(ctx->bb, pool);\n                return s;\n\n            case APR_SUCCESS:\n                s = apr_brigade_length(ctx->bb, 1, &off);\n                if (s != APR_SUCCESS) {\n                    ctx->status = MFD_ERROR;\n                    return s;\n                }\n                len = off;\n                param = apreq_param_make(pool, ctx->param_name,\n                                         strlen(ctx->param_name),\n                                         NULL, len);\n                apreq_param_tainted_on(param);\n                param->info = ctx->info;\n\n                *(const apreq_value_t **)&v = &param->v;\n                apr_brigade_flatten(ctx->bb, v->data, &len);\n                v->data[len] = 0;\n\n                if (parser->hook != NULL) {\n                    s = apreq_hook_run(parser->hook, param, NULL);\n                    if (s != APR_SUCCESS) {\n                        ctx->status = MFD_ERROR;\n                        return s;\n                    }\n                }\n\n                apreq_param_charset_set(param,\n                                        apreq_charset_divine(v->data, len));\n                apreq_value_table_add(v, t);\n                ctx->status = MFD_NEXTLINE;\n                ctx->param_name = NULL;\n                apr_brigade_cleanup(ctx->bb);\n                goto mfd_parse_brigade;\n\n            default:\n                ctx->status = MFD_ERROR;\n                return s;\n            }\n\n\n        }\n        break;  \n\n    case MFD_UPLOAD:\n        {\n            apreq_param_t *param = ctx->upload;\n\n            s = split_on_bdry(ctx->bb, ctx->in, ctx->pattern, ctx->bdry);\n            switch (s) {\n\n            case APR_INCOMPLETE:\n                if (parser->hook != NULL) {\n                    s = apreq_hook_run(parser->hook, param, ctx->bb);\n                    if (s != APR_SUCCESS) {\n                        ctx->status = MFD_ERROR;\n                        return s;\n                    }\n                }\n                apreq_brigade_setaside(ctx->bb, pool);\n                apreq_brigade_setaside(ctx->in, pool);\n                s = apreq_brigade_concat(pool, parser->temp_dir,\n                                         parser->brigade_limit,\n                                         param->upload, ctx->bb);\n                return (s == APR_SUCCESS) ? APR_INCOMPLETE : s;\n\n            case APR_SUCCESS:\n                if (parser->hook != NULL) {\n                    APR_BRIGADE_INSERT_TAIL(ctx->bb, ctx->eos);\n                    s = apreq_hook_run(parser->hook, param, ctx->bb);\n                    APR_BUCKET_REMOVE(ctx->eos);\n                    if (s != APR_SUCCESS) {\n                        ctx->status = MFD_ERROR;\n                        return s;\n                    }\n                }\n                apreq_value_table_add(&param->v, t);\n                apreq_brigade_setaside(ctx->bb, pool);\n                s = apreq_brigade_concat(pool, parser->temp_dir,\n                                         parser->brigade_limit,\n                                         param->upload, ctx->bb);\n\n                if (s != APR_SUCCESS)\n                    return s;\n\n                ctx->status = MFD_NEXTLINE;\n                goto mfd_parse_brigade;\n\n            default:\n                ctx->status = MFD_ERROR;\n                return s;\n            }\n\n        }\n        break;  \n\n\n    case MFD_MIXED:\n        {\n            s = apreq_parser_run(ctx->next_parser, t, ctx->in);\n            switch (s) {\n            case APR_SUCCESS:\n                ctx->status = MFD_INIT;\n                ctx->param_name = NULL;\n                goto mfd_parse_brigade;\n            case APR_INCOMPLETE:\n                APR_BRIGADE_CONCAT(bb, ctx->in);\n                return APR_INCOMPLETE;\n            default:\n                ctx->status = MFD_ERROR;\n                return s;\n            }\n\n        }\n        break; \n\n    default:\n        return APREQ_ERROR_GENERAL;\n    }\n\n    return APR_INCOMPLETE;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free\n476,NULL Pointer Dereference\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_93b2553e39ae40b26c64299eb97fd5cf06615797_0", {
    "ID": "httpd_93b2553e39ae40b26c64299eb97fd5cf06615797_0",
    "UID": "9209",
    "code": "static const char *set_balancer_param(proxy_server_conf test_snippet\n                                      apr_pool_t *p,\n                                      proxy_balancer *balancer,\n                                      const char *key,\n                                      const char *val)\n{\n\n    int ival;\n    if (!strcasecmp(key, \"stickysession\")) {\n        char *path;\n        /* Balancer sticky session name.\n         * Set to something like JSESSIONID or\n         * PHPSESSIONID, etc..,\n         */\n        if (strlen(val) > (PROXY_BALANCER_MAX_STICKY_SIZE-1))\n            return \"stickysession length must be < 64 characters\";\n        PROXY_STRNCPY(balancer->s->sticky_path, val);\n        PROXY_STRNCPY(balancer->s->sticky, val);\n\n        if ((path = strchr((char *)balancer->s->sticky, '|'))) {\n            *path++ = '\\0';\n            PROXY_STRNCPY(balancer->s->sticky_path, path);\n        }\n    }\n    else if (!strcasecmp(key, \"nofailover\")) {\n        /* If set to 'on' the session will break\n         * if the worker is in error state or\n         * disabled.\n         */\n        if (!strcasecmp(val, \"on\"))\n            balancer->s->sticky_force = 1;\n        else if (!strcasecmp(val, \"off\"))\n            balancer->s->sticky_force = 0;\n        else\n            return \"failover must be On|Off\";\n    }\n    else if (!strcasecmp(key, \"timeout\")) {\n        /* Balancer timeout in seconds.\n         * If set this will be the maximum time to\n         * wait for a free worker.\n         * Default is not to wait.\n         */\n        ival = atoi(val);\n        if (ival < 1)\n            return \"timeout must be at least one second\";\n        balancer->s->timeout = apr_time_from_sec(ival);\n    }\n    else if (!strcasecmp(key, \"maxattempts\")) {\n        /* Maximum number of failover attempts before\n         * giving up.\n         */\n        ival = atoi(val);\n        if (ival < 0)\n            return \"maximum number of attempts must be a positive number\";\n        balancer->s->max_attempts = ival;\n        balancer->s->max_attempts_set = 1;\n    }\n    else if (!strcasecmp(key, \"lbmethod\")) {\n        proxy_balancer_method *provider;\n        if (strlen(val) > (sizeof(balancer->s->lbpname)-1))\n            return \"unknown lbmethod\";\n        provider = ap_lookup_provider(PROXY_LBMETHOD, val, \"0\");\n        if (provider) {\n            balancer->lbmethod = provider;\n            if (PROXY_STRNCPY(balancer->s->lbpname, val) == APR_SUCCESS) {\n                return NULL;\n            }\n            else {\n                return \"lbmethod name too large\";\n            }\n        }\n        return \"unknown lbmethod\";\n    }\n    else if (!strcasecmp(key, \"scolonpathdelim\")) {\n        /* If set to 'on' then ';' will also be\n         * used as a session path separator/delim (ala\n         * mod_jk)\n         */\n        if (!strcasecmp(val, \"on\"))\n            balancer->s->scolonsep = 1;\n        else if (!strcasecmp(val, \"off\"))\n            balancer->s->scolonsep = 0;\n        else\n            return \"scolonpathdelim must be On|Off\";\n    }\n    else if (!strcasecmp(key, \"failonstatus\")) {\n        char *val_split;\n        char *status;\n        char *tok_state;\n\n        val_split = apr_pstrdup(p, val);\n\n        balancer->errstatuses = apr_array_make(p, 1, sizeof(int));\n\n        status = apr_strtok(val_split, \", \", &tok_state);\n        while (status != NULL) {\n            ival = atoi(status);\n            if (ap_is_HTTP_VALID_RESPONSE(ival)) {\n                *(int *)apr_array_push(balancer->errstatuses) = ival;\n            }\n            else {\n                return \"failonstatus must be one or more HTTP response codes\";\n            }\n            status = apr_strtok(NULL, \", \", &tok_state);\n        }\n\n    }\n    else if (!strcasecmp(key, \"nonce\")) {\n        if (!strcasecmp(val, \"None\")) {\n            *balancer->s->nonce = '\\0';\n        }\n        else {\n            if (PROXY_STRNCPY(balancer->s->nonce, val) != APR_SUCCESS) {\n                return \"Provided nonce is too large\";\n            }\n        }\n    }\n    else if (!strcasecmp(key, \"growth\")) {\n        ival = atoi(val);\n        if (ival < 1 || ival > 100)   \n            return \"growth must be between 1 and 100\";\n        balancer->growth = ival;\n    }\n    else {\n        return \"unknown Balancer parameter\";\n    }\n    return NULL;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_dfe3bbbff87075fc9954e1f489cda6fb16288a3d_0", {
    "ID": "httpd_dfe3bbbff87075fc9954e1f489cda6fb16288a3d_0",
    "UID": "9216",
    "code": "static apr_status_t slotmem_create(ap_slotmem_instance_t test_snippet\n                                   const char *name, apr_size_t item_size,\n                                   unsigned int item_num,\n                                   ap_slotmem_type_t type, apr_pool_t *pool)\n{\n\n    int fbased;\n    char *ptr;\n    sharedslotdesc_t desc;\n    ap_slotmem_instance_t *res;\n    ap_slotmem_instance_t *next = globallistmem;\n    const char *fname;\n    apr_shm_t *shm;\n    apr_size_t basesize = (item_size * item_num);\n    apr_size_t size = AP_SLOTMEM_OFFSET + AP_UNSIGNEDINT_OFFSET +\n                      (item_num * sizeof(char)) + basesize;\n    apr_status_t rv;\n\n    if (gpool == NULL) {\n        return APR_ENOSHMAVAIL;\n    }\n    if (name) {\n        if (name[0] != '/') {\n            fname = ap_server_root_relative(pool, name);\n        }\n        else {\n            fname = name;\n        }\n\n        \n        if (next) {\n            for (;;) {\n                if (strcmp(next->name, fname) == 0) {\n                    \n                    *new = next;\n                    return APR_SUCCESS;\n                }\n                if (!next->next) {\n                     break;\n                }\n                next = next->next;\n            }\n        }\n    }\n    else {\n        fname = \"none\";\n    }\n\n    \n    fbased = (name != NULL);\n    if (fbased) {\n        rv = apr_shm_attach(&shm, fname, gpool);\n    }\n    else {\n        rv = APR_EINVAL;\n    }\n    if (rv == APR_SUCCESS) {\n        \n        if (apr_shm_size_get(shm) != size) {\n            apr_shm_detach(shm);\n            return APR_EINVAL;\n        }\n        ptr = (char *)apr_shm_baseaddr_get(shm);\n        memcpy(&desc, ptr, sizeof(desc));\n        if (desc.size != item_size || desc.num != item_num) {\n            apr_shm_detach(shm);\n            return APR_EINVAL;\n        }\n        ptr += AP_SLOTMEM_OFFSET;\n    }\n    else {\n        apr_size_t dsize = size - AP_SLOTMEM_OFFSET;\n        if (fbased) {\n            apr_shm_remove(fname, gpool);\n            rv = apr_shm_create(&shm, size, fname, gpool);\n        }\n        else {\n            rv = apr_shm_create(&shm, size, NULL, gpool);\n        }\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        if (fbased) {\n            /* Set permissions to shared memory\n             * so it can be attached by child process\n             * having different user credentials\n             *\n             * See apr:shmem/unix/shm.c\n             */\n            unixd_set_shm_perms(fname);\n        }\n        ptr = (char *)apr_shm_baseaddr_get(shm);\n        desc.size = item_size;\n        desc.num = item_num;\n        desc.type = type;\n        memcpy(ptr, &desc, sizeof(desc));\n        ptr += AP_SLOTMEM_OFFSET;\n        memset(ptr, 0, dsize);\n        /*\n         * TODO: Error check the below... What error makes\n         * sense if the restore fails? Any?\n         */\n        if (type & AP_SLOTMEM_TYPE_PERSIST) {\n            restore_slotmem(ptr, fname, dsize, pool);\n        }\n    }\n\n    \n    res = (ap_slotmem_instance_t *) apr_pcalloc(gpool,\n                                                sizeof(ap_slotmem_instance_t));\n    res->name = apr_pstrdup(gpool, fname);\n    res->fbased = fbased;\n    res->shm = shm;\n    res->num_free = (unsigned int *)ptr;\n    *res->num_free = item_num;\n    res->persist = (void *)ptr;\n    ptr += AP_UNSIGNEDINT_OFFSET;\n    res->base = (void *)ptr;\n    res->desc = desc;\n    res->gpool = gpool;\n    res->next = NULL;\n    res->inuse = ptr + basesize;\n    if (globallistmem == NULL) {\n        globallistmem = res;\n    }\n    else {\n        next->next = res;\n    }\n\n    *new = res;\n    return APR_SUCCESS;\n}",
    "predicted": "272,Least Privilege Violation\n377,Insecure Temporary File\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n457,Use of Uninitialized Variable\n476,NULL Pointer Dereference\n680,Integer Overflow to Buffer Overflow\n690,Unchecked Return Value to NULL Pointer Dereference"
  },
  "httpd_2a21daff9aa1a4ce35606a11c911d7c8d9ace009_0", {
    "ID": "httpd_2a21daff9aa1a4ce35606a11c911d7c8d9ace009_0",
    "UID": "9222",
    "code": "static const char *store_filename(apr_pool_t *pool, const char test_snippet\n{\n    const char *fname;\n    if (strcasecmp(slotmemname, \"none\") == 0) {\n        return NULL;\n    }\n    else if (slotmemname[0] != '/') {\n        fname = ap_server_root_relative(pool, slotmemname);\n    }\n    else {\n        fname = slotmemname;\n    }\n    return fname;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal"
  },
  "httpd_00e4f4620506d0eaa391462fe305c63cde54ea59_0", {
    "ID": "httpd_00e4f4620506d0eaa391462fe305c63cde54ea59_0",
    "UID": "9233",
    "code": "static apr_status_t send_environment(proxy_conn_rec *conn, request_rec test_snippet\n                                     int request_id)\n{\n    const apr_array_header_t *envarr;\n    const apr_table_entry_t *elts;\n    struct iovec vec[2];\n    fcgi_header header;\n    unsigned char farray[FCGI_HEADER_LEN];\n    apr_size_t bodylen, envlen;\n    char *body, *itr;\n    apr_status_t rv;\n    apr_size_t len;\n    int i, numenv;\n\n    ap_add_common_vars(r);\n    ap_add_cgi_vars(r);\n\n    \n\n    bodylen = envlen = 0;\n\n    /* XXX mod_cgi/mod_cgid use ap_create_environment here, which fills in\n     *     the TZ value specially.  We could use that, but it would mean\n     *     parsing the key/value pairs back OUT of the allocated env array,\n     *     not to mention allocating a totally useless array in the first\n     *     place, which would suck. */\n\n    envarr = apr_table_elts(r->subprocess_env);\n\n    elts = (const apr_table_entry_t *) envarr->elts;\n\n    for (i = 0; i < envarr->nelts; ++i) {\n        apr_size_t keylen, vallen;\n\n        if (! elts[i].key) {\n            continue;\n        }\n\n        keylen = strlen(elts[i].key);\n\n        if (keylen >> 7 == 0) {\n            envlen += 1;\n        }\n        else {\n            envlen += 4;\n        }\n\n        envlen += keylen;\n\n        vallen = strlen(elts[i].val);\n\n#ifdef FCGI_DUMP_ENV_VARS\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01062)\n                      \"sending env var '%s' value '%s'\",\n                      elts[i].key, elts[i].val);\n#endif\n\n        if (vallen >> 7 == 0) {\n            envlen += 1;\n        }\n        else {\n            envlen += 4;\n        }\n\n        envlen += vallen;\n\n        \n        if (envlen > FCGI_MAX_ENV_SIZE) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01063)\n                          \"truncating environment to %d bytes and %d elements\",\n                          (int)bodylen, i);\n            break;\n        }\n\n        bodylen = envlen;\n    }\n\n    numenv = i;\n\n    body = apr_pcalloc(r->pool, bodylen);\n\n    itr = body;\n\n    for (i = 0; i < numenv; ++i) {\n        apr_size_t keylen, vallen;\n\n        if (! elts[i].key) {\n            continue;\n        }\n\n        keylen = strlen(elts[i].key);\n\n        if (keylen >> 7 == 0) {\n            itr[0] = keylen & 0xff;\n            itr += 1;\n        }\n        else {\n            itr[0] = ((keylen >> 24) & 0xff) | 0x80;\n            itr[1] = ((keylen >> 16) & 0xff);\n            itr[2] = ((keylen >> 8) & 0xff);\n            itr[3] = ((keylen) & 0xff);\n            itr += 4;\n        }\n\n        vallen = strlen(elts[i].val);\n\n        if (vallen >> 7 == 0) {\n            itr[0] = vallen & 0xff;\n            itr += 1;\n        }\n        else {\n            itr[0] = ((vallen >> 24) & 0xff) | 0x80;\n            itr[1] = ((vallen >> 16) & 0xff);\n            itr[2] = ((vallen >> 8) & 0xff);\n            itr[3] = ((vallen) & 0xff);\n            itr += 4;\n        }\n\n        memcpy(itr, elts[i].key, keylen);\n        itr += keylen;\n\n        memcpy(itr, elts[i].val, vallen);\n        itr += vallen;\n    }\n\n    fill_in_header(&header, FCGI_PARAMS, request_id, bodylen, 0);\n    fcgi_header_to_array(&header, farray);\n\n    vec[0].iov_base = (void *)farray;\n    vec[0].iov_len = sizeof(farray);\n    vec[1].iov_base = body;\n    vec[1].iov_len = bodylen;\n\n    rv = send_data(conn, vec, 2, &len, 1);\n    if (rv) {\n        return rv;\n    }\n\n    fill_in_header(&header, FCGI_PARAMS, request_id, 0, 0);\n    fcgi_header_to_array(&header, farray);\n\n    vec[0].iov_base = (void *)farray;\n    vec[0].iov_len = sizeof(farray);\n\n    return send_data(conn, vec, 1, &len, 1);\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_599f7b1b7f1f489d5d211a2b5222357ac27ee672_0", {
    "ID": "httpd_599f7b1b7f1f489d5d211a2b5222357ac27ee672_0",
    "UID": "9234",
    "code": "static int mmap_handler(request_rec *r, a_file test_snippet\n{\n#if APR_HAS_MMAP\n    conn_rec *c = r->connection;\n    apr_bucket *b;\n    apr_mmap_t *mm;\n    apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    apr_mmap_dup(&mm, file->mm, r->pool);\n    b = apr_bucket_mmap_create(mm, 0, (apr_size_t)file->finfo.size,\n                               c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n        return HTTP_INTERNAL_SERVER_ERROR;\n#endif\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_fdcdc5699fe7727d59a8c89bc57938b5f7c6f2e3_0", {
    "ID": "httpd_fdcdc5699fe7727d59a8c89bc57938b5f7c6f2e3_0",
    "UID": "9236",
    "code": "static void cgid_maint(int reason, void *data, apr_wait_t test_snippet\n{\n    apr_proc_t *proc = data;\n    int mpm_state;\n    int stopping;\n\n    switch (reason) {\n        case APR_OC_REASON_DEATH:\n            apr_proc_other_child_unregister(data);\n            /* If apache is not terminating or restarting,\n             * restart the cgid daemon\n             */\n            stopping = 1; /* if MPM doesn't support query,\n                           * assume we shouldn't restart daemon\n                           */\n            if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state) == APR_SUCCESS &&\n                mpm_state != AP_MPMQ_STOPPING) {\n                stopping = 0;\n            }\n            if (!stopping) {\n                if (status == DAEMON_STARTUP_ERROR) {\n                    ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(01238)\n                                 \"cgid daemon failed to initialize\");\n                }\n                else {\n                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(01239)\n                                 \"cgid daemon process died, restarting\");\n                    cgid_start(root_pool, root_server, proc);\n                }\n            }\n            break;\n        case APR_OC_REASON_RESTART:\n            \n            apr_proc_other_child_unregister(data);\n            break;\n        case APR_OC_REASON_LOST:\n            \n            apr_proc_other_child_unregister(data);\n            cgid_start(root_pool, root_server, proc);\n            break;\n        case APR_OC_REASON_UNREGISTER:\n            /* we get here when pcgi is cleaned up; pcgi gets cleaned\n             * up when pconf gets cleaned up\n             */\n            kill(proc->pid, SIGHUP); \n\n            /* Remove the cgi socket, we must do it here in order to try and\n             * guarantee the same permissions as when the socket was created.\n             */\n            if (unlink(sockname) < 0 && errno != ENOENT) {\n                ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf, APLOGNO(01240)\n                             \"Couldn't unlink unix domain socket %s\",\n                             sockname);\n            }\n            break;\n    }\n}",
    "predicted": "252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_09cac4d48a713cb0f60f55651fd838c1911215f6_0", {
    "ID": "httpd_09cac4d48a713cb0f60f55651fd838c1911215f6_0",
    "UID": "9243",
    "code": "void ap_process_async_request(request_rec test_snippet\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  \n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    if (access_status == DONE) {\n        \n        access_status = OK;\n    }\n\n    if (access_status == OK) {\n        ap_finalize_request_protocol(r);\n    }\n    else {\n        r->status = HTTP_OK;\n        ap_die(access_status, r);\n    }\n\n    ap_process_request_after_handler(r);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_afbef6aa19978b638a06c08e1ab5800aba6a1d71_0", {
    "ID": "httpd_afbef6aa19978b638a06c08e1ab5800aba6a1d71_0",
    "UID": "9248",
    "code": "test_snippet\n{\n    apr_pool_t *pool = hook->pool;\n    struct xml_ctx *ctx = hook->ctx;\n    apr_status_t s = APR_SUCCESS;\n    apr_bucket *e;\n\n    if (ctx == NULL) {\n        hook->ctx = ctx = apr_palloc(pool, sizeof *ctx);\n        ctx->doc = NULL;\n        ctx->xml_parser = apr_xml_parser_create(pool);\n        ctx->status = XML_INCOMPLETE;\n    }\n\n    PARSER_STATUS_CHECK(XML);\n\n    for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        const char *data;\n        apr_size_t dlen;\n\n        if (APR_BUCKET_IS_EOS(e)) {\n            s = apr_xml_parser_done(ctx->xml_parser, &ctx->doc);\n            if (s == APR_SUCCESS) {\n                ctx->status = XML_COMPLETE;\n                if (hook->next)\n                    s = apreq_hook_run(hook->next, param, bb);\n            }\n            else {\n                ctx->status = XML_ERROR;\n            }\n           return s;\n        }\n        else if (APR_BUCKET_IS_METADATA(e)) {\n            continue;\n        }\n\n        s = apr_bucket_read(e, &data, &dlen, APR_BLOCK_READ);\n\n        if (s != APR_SUCCESS) {\n            ctx->status = XML_ERROR;\n            return s;\n        }\n\n        s = apr_xml_parser_feed(ctx->xml_parser, data, dlen);\n\n        if (s != APR_SUCCESS) {\n            ctx->status = XML_ERROR;\n            return s;\n        }\n\n    }\n\n    if (hook->next)\n        return apreq_hook_run(hook->next, param, bb);\n\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_9e6ec867aa197d789d381fbd8d003528d0437715_0", {
    "ID": "httpd_9e6ec867aa197d789d381fbd8d003528d0437715_0",
    "UID": "9254",
    "code": "static int proxy_ftp_canon(request_rec *r, char test_snippet\n{\n    char *user, *password, *host, *path, *parms, *strp, sport[7];\n    apr_pool_t *p = r->pool;\n    const char *err;\n    apr_port_t port, def_port;\n\n    \n    if (strncasecmp(url, \"ftp:\", 4) == 0) {\n        url += 4;\n    }\n    else {\n        return DECLINED;\n    }\n    def_port = apr_uri_port_of_scheme(\"ftp\");\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"canonicalising URL %s\", url);\n\n    port = def_port;\n    err = ap_proxy_canon_netloc(p, &url, &user, &password, &host, &port);\n    if (err)\n        return HTTP_BAD_REQUEST;\n    if (user != NULL && !ftp_check_string(user))\n        return HTTP_BAD_REQUEST;\n    if (password != NULL && !ftp_check_string(password))\n        return HTTP_BAD_REQUEST;\n\n    \n    /*\n     * N.B. if this isn't a true proxy request, then the URL path (but not\n     * query args) has already been decoded. This gives rise to the problem\n     * of a ; being decoded into the path.\n     */\n    strp = strchr(url, ';');\n    if (strp != NULL) {\n        *(strp++) = '\\0';\n        parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm, 0,\n                                  r->proxyreq);\n        if (parms == NULL)\n            return HTTP_BAD_REQUEST;\n    }\n    else\n        parms = \"\";\n\n    path = ap_proxy_canonenc(p, url, strlen(url), enc_path, 0, r->proxyreq);\n    if (path == NULL)\n        return HTTP_BAD_REQUEST;\n    if (!ftp_check_string(path))\n        return HTTP_BAD_REQUEST;\n\n    if (r->proxyreq && r->args != NULL) {\n        if (strp != NULL) {\n            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, 1, r->proxyreq);\n            if (strp == NULL)\n                return HTTP_BAD_REQUEST;\n            parms = apr_pstrcat(p, parms, \"?\", strp, NULL);\n        }\n        else {\n            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, 1, r->proxyreq);\n            if (strp == NULL)\n                return HTTP_BAD_REQUEST;\n            path = apr_pstrcat(p, path, \"?\", strp, NULL);\n        }\n        r->args = NULL;\n    }\n\n\n\n    if (port != def_port)\n        apr_snprintf(sport, sizeof(sport), \":%d\", port);\n    else\n        sport[0] = '\\0';\n\n    if (ap_strchr_c(host, ':')) { \n        host = apr_pstrcat(p, \"[\", host, \"]\", NULL);\n    }\n    r->filename = apr_pstrcat(p, \"proxy:ftp://\", (user != NULL) ? user : \"\",\n                              (password != NULL) ? \":\" : \"\",\n                              (password != NULL) ? password : \"\",\n                          (user != NULL) ? \"@\" : \"\", host, sport, \"/\", path,\n                              (parms[0] != '\\0') ? \";\" : \"\", parms, NULL);\n\n    return OK;\n}",
    "predicted": "256,Plaintext Storage of a Password\n259,Use of Hard-coded Password\n321,Use of Hard-coded Cryptographic Key\n526,Cleartext Storage of Sensitive Information in an Environment Variable"
  },
  "httpd_ac64ef19bf6492f2129d73a63c315a131e276669_0", {
    "ID": "httpd_ac64ef19bf6492f2129d73a63c315a131e276669_0",
    "UID": "9261",
    "code": "static int sendfile_handler(request_rec *r, a_file test_snippet\n{\n#if APR_HAS_SENDFILE\n    conn_rec *c = r->connection;\n    apr_bucket *b;\n    apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    apr_brigade_insert_file(bb, file->file, 0, file->finfo.size, r->pool);\n\n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n        return HTTP_INTERNAL_SERVER_ERROR;\n#endif\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_6c6326932e8a228714abd802494279c6f386b5ba_0", {
    "ID": "httpd_6c6326932e8a228714abd802494279c6f386b5ba_0",
    "UID": "9265",
    "code": "PROXY_DECLARE(int) ap_proxy_hex2c(const char test_snippet\n{\n    int i;\n\n#if !APR_CHARSET_EBCDIC\n    int ch = x[0];\n\n    if (apr_isdigit(ch)) {\n        i = ch - '0';\n    }\n    else if (apr_isupper(ch)) {\n        i = ch - ('A' - 10);\n    }\n    else {\n        i = ch - ('a' - 10);\n    }\n    i <<= 4;\n\n    ch = x[1];\n    if (apr_isdigit(ch)) {\n        i += ch - '0';\n    }\n    else if (apr_isupper(ch)) {\n        i += ch - ('A' - 10);\n    }\n    else {\n        i += ch - ('a' - 10);\n    }\n    return i;\n#else \n    /*\n     * we assume that the hex value refers to an ASCII character\n     * so convert to EBCDIC so that it makes sense locally;\n     *\n     * example:\n     *\n     * client specifies %20 in URL to refer to a space char;\n     * at this point we're called with EBCDIC \"20\"; after turning\n     * EBCDIC \"20\" into binary 0x20, we then need to assume that 0x20\n     * represents an ASCII char and convert 0x20 to EBCDIC, yielding\n     * 0x40\n     */\n    char buf[1];\n\n    if (1 == sscanf(x, \"%2x\", &i)) {\n        buf[0] = i & 0xFF;\n        ap_xlate_proto_from_ascii(buf, 1);\n        return buf[0];\n    }\n    else {\n        return 0;\n    }\n#endif \n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_6055e676563e735b5021dfbbaae33e31d776c3fb_0", {
    "ID": "httpd_6055e676563e735b5021dfbbaae33e31d776c3fb_0",
    "UID": "9268",
    "code": "APREQ_DECLARE(apr_status_t)apreq_parse_cookie_header(apr_pool_t test_snippet\n                                                     apr_table_t *j,\n                                                     const char *hdr)\n{\n    apreq_cookie_t *c;\n    unsigned version;\n    apr_status_t rv = APR_SUCCESS;\n\n parse_cookie_header:\n\n    c = NULL;\n    version = NETSCAPE;\n\n    while (apr_isspace(*hdr))\n        ++hdr;\n\n\n    if (*hdr == '$' && strncasecmp(hdr, \"$Version\", 8) == 0) {\n        \n        version = RFC;\n    skip_version_string:\n        switch (*hdr++) {\n        case 0:\n            return rv;\n        case ',':\n            goto parse_cookie_header;\n        case ';':\n            break;\n        default:\n            goto skip_version_string;\n        }\n    }\n\n    for (;;) {\n        apr_status_t status;\n        const char *name, *value;\n        apr_size_t nlen = 0, vlen;\n\n        while (*hdr == ';' || apr_isspace(*hdr))\n            ++hdr;\n\n        switch (*hdr) {\n\n        case 0:\n            \n            if (c != NULL) {\n                ADD_COOKIE(j, c);\n            }\n            return rv;\n\n        case ',':\n            ++hdr;\n            if (c != NULL) {\n                ADD_COOKIE(j, c);\n            }\n            goto parse_cookie_header;\n\n        case '$':\n            ++hdr;\n            if (c == NULL) {\n                rv = APREQ_ERROR_BADCHAR;\n                goto parse_cookie_error;\n            }\n            else if (version == NETSCAPE) {\n                rv = APREQ_ERROR_MISMATCH;\n            }\n\n            status = get_pair(p, &hdr, &name, &nlen, &value, &vlen, 1);\n            if (status != APR_SUCCESS) {\n                rv = status;\n                goto parse_cookie_error;\n            }\n\n            status = apreq_cookie_attr(p, c, name, nlen, value, vlen);\n\n            switch (status) {\n\n            case APR_ENOTIMPL:\n                rv = APREQ_ERROR_BADATTR;\n                \n\n            case APR_SUCCESS:\n                break;\n\n            default:\n                rv = status;\n                goto parse_cookie_error;\n            }\n\n            break;\n\n        default:\n            if (c != NULL) {\n                ADD_COOKIE(j, c);\n            }\n\n            status = get_pair(p, &hdr, &name, &nlen, &value, &vlen, 0);\n\n            if (status != APR_SUCCESS) {\n                c = NULL;\n                rv = status;\n                goto parse_cookie_error;\n            }\n\n            c = apreq_cookie_make(p, name, nlen, value, vlen);\n            apreq_cookie_tainted_on(c);\n            if (version != NETSCAPE)\n                apreq_cookie_version_set(c, version);\n        }\n    }\n\n parse_cookie_error:\n\n    switch (*hdr) {\n\n    case 0:\n        return rv;\n\n    case ',':\n    case ';':\n        if (c != NULL)\n            ADD_COOKIE(j, c);\n        ++hdr;\n        goto parse_cookie_header;\n\n    default:\n        ++hdr;\n        goto parse_cookie_error;\n    }\n\n    \n    return rv;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n606,Unchecked Input for Loop Condition"
  },
  "httpd_7c79647571a943b4c199aebc57ccf301be28e524_0", {
    "ID": "httpd_7c79647571a943b4c199aebc57ccf301be28e524_0",
    "UID": "9271",
    "code": "static apr_datum_t dav_build_key(dav_db *db, const dav_prop_name test_snippet\n{\n    char nsbuf[20];\n    apr_size_t l_ns, l_name = strlen(name->name);\n    apr_datum_t key = { 0 };\n\n    /*\n     * Convert namespace ID to a string. \"no namespace\" is an empty string,\n     * so the keys will have the form \":name\". Otherwise, the keys will\n     * have the form \"#:name\".\n     */\n    if (*name->ns == '\\0') {\n        nsbuf[0] = '\\0';\n        l_ns = 0;\n    }\n    else {\n        long ns_id = (long)apr_hash_get(db->uri_index, name->ns,\n                                      APR_HASH_KEY_STRING);\n\n\n        if (ns_id == 0) {\n            \n            return key;         \n        }\n\n        l_ns = apr_snprintf(nsbuf, sizeof(nsbuf), \"%ld\", ns_id - 1);\n    }\n\n    \n    dav_set_bufsize(db->pool, &db->wb_key, l_ns + 1 + l_name + 1);\n    memcpy(db->wb_key.buf, nsbuf, l_ns);\n    db->wb_key.buf[l_ns] = ':';\n    memcpy(&db->wb_key.buf[l_ns + 1], name->name, l_name + 1);\n\n    \n    key.dsize = l_ns + 1 + l_name + 1;\n    key.dptr = db->wb_key.buf;\n\n    return key;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_577844675be91ab6045f8cab4fc043380cc363bf_0", {
    "ID": "httpd_577844675be91ab6045f8cab4fc043380cc363bf_0",
    "UID": "9283",
    "code": "static void dav_format_time(int style, apr_time_t sec, char *buf, apr_size_t test_snippet\n{\n    apr_time_exp_t tms;\n\n    \n    (void) apr_time_exp_gmt(&tms, sec);\n\n    if (style == DAV_STYLE_ISO8601) {\n        \n\n        \n        apr_snprintf(buf, buflen, \"%.4d-%.2d-%.2dT%.2d:%.2d:%.2dZ\",\n                     tms.tm_year + 1900, tms.tm_mon + 1, tms.tm_mday,\n                     tms.tm_hour, tms.tm_min, tms.tm_sec);\n        return;\n    }\n\n    \n\n    \n    apr_snprintf(buf, buflen, \"%s, %.2d %s %d %.2d:%.2d:%.2d GMT\",\n                 apr_day_snames[tms.tm_wday],\n                 tms.tm_mday, apr_month_snames[tms.tm_mon],\n                 tms.tm_year + 1900,\n                 tms.tm_hour, tms.tm_min, tms.tm_sec);\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_19bf5f0ba451b5e3db03fb22bb789c6f40684437_0", {
    "ID": "httpd_19bf5f0ba451b5e3db03fb22bb789c6f40684437_0",
    "UID": "9295",
    "code": "static test_snippet\napr_status_t apreq_brigade_setaside(apr_bucket_brigade *bb, apr_pool_t *p)\n{\n    apr_bucket *e;\n    for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_status_t rv = apr_bucket_setaside(e, p);\n        if (rv != APR_SUCCESS)\n            return rv;\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_d9ba7e478c29558996f4a5a3b7f6d6e5bc4983da_0", {
    "ID": "httpd_d9ba7e478c29558996f4a5a3b7f6d6e5bc4983da_0",
    "UID": "9303",
    "code": "DAV_DECLARE(const char *) dav_xml_get_cdata(const apr_xml_elem *elem, apr_pool_t test_snippet\n                              int strip_white)\n{\n    apr_size_t len = 0;\n    apr_text *scan;\n    const apr_xml_elem *child;\n    char *cdata;\n    char *s;\n    apr_size_t tlen;\n    const char *found_text = NULL; \n    int found_count = 0;\n\n    for (scan = elem->first_cdata.first; scan != NULL; scan = scan->next) {\n        found_text = scan->text;\n        ++found_count;\n        len += strlen(found_text);\n    }\n\n    for (child = elem->first_child; child != NULL; child = child->next) {\n        for (scan = child->following_cdata.first;\n             scan != NULL;\n             scan = scan->next) {\n            found_text = scan->text;\n            ++found_count;\n            len += strlen(found_text);\n        }\n    }\n\n    /* some fast-path cases:\n     * 1) zero-length cdata\n     * 2) a single piece of cdata with no whitespace to strip\n     */\n    if (len == 0)\n        return \"\";\n    if (found_count == 1) {\n        if (!strip_white\n            || (!apr_isspace(*found_text)\n                && !apr_isspace(found_text[len - 1])))\n            return found_text;\n    }\n\n    cdata = s = apr_palloc(pool, len + 1);\n\n    for (scan = elem->first_cdata.first; scan != NULL; scan = scan->next) {\n        tlen = strlen(scan->text);\n        memcpy(s, scan->text, tlen);\n        s += tlen;\n    }\n\n    for (child = elem->first_child; child != NULL; child = child->next) {\n        for (scan = child->following_cdata.first;\n             scan != NULL;\n             scan = scan->next) {\n            tlen = strlen(scan->text);\n            memcpy(s, scan->text, tlen);\n            s += tlen;\n        }\n    }\n\n    *s = '\\0';\n\n    if (strip_white) {\n        \n        while (apr_isspace(*cdata))     \n            ++cdata;\n\n        \n        while (len-- > 0 && apr_isspace(cdata[len]))\n            continue;\n        cdata[len + 1] = '\\0';\n    }\n\n    return cdata;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_2d7526cf670759882604eb46c695936434b7283e_0", {
    "ID": "httpd_2d7526cf670759882604eb46c695936434b7283e_0",
    "UID": "9304",
    "code": "static const char *set_expiresbytype(cmd_parms *cmd, void test_snippet\n                                     const char *mime, const char *code)\n{\n    expires_dir_config *dir_config = in_dir_config;\n    char *response, *real_code;\n    const char *check;\n\n    check = ap_strrchr_c(mime, '/');\n    if (check == NULL) {\n        return \"Invalid mimetype: should contain a slash\";\n    }\n    if ((strlen(++check) == 1) && (*check == '*')) {\n        dir_config->wildcards = 1;\n    }\n\n    if ((response = check_code(cmd->pool, code, &real_code)) == NULL) {\n        apr_table_setn(dir_config->expiresbytype, mime, real_code);\n        return NULL;\n    }\n    return apr_pstrcat(cmd->pool,\n                 \"'ExpiresByType \", mime, \" \", code, \"': \", response, NULL);\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_38b15ff8302ab71beed7ee7eabb44a6879a2a410_0", {
    "ID": "httpd_38b15ff8302ab71beed7ee7eabb44a6879a2a410_0",
    "UID": "9316",
    "code": "static void tokens_to_array(apr_pool_t *p, const char test_snippet\n                            apr_array_header_t *arr)\n{\n    char *token;\n\n    while ((token = ap_get_list_item(p, &data)) != NULL) {\n        *((const char **) apr_array_push(arr)) = token;\n    }\n\n    \n    qsort((void *) arr->elts, arr->nelts,\n         sizeof(char *), array_alphasort);\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n762,Mismatched Memory Management Routines"
  },
  "httpd_21e258aee3342b791f07c6fc66bc34e1f4dca693_0", {
    "ID": "httpd_21e258aee3342b791f07c6fc66bc34e1f4dca693_0",
    "UID": "9317",
    "code": "static void delete_parent(const char *path, const char test_snippet\n        apr_off_t *nodes, apr_pool_t *pool)\n{\n    char *nextpath, *name;\n    apr_pool_t *p;\n\n    \n    apr_pool_create(&p, pool);\n    name = apr_pstrdup(p, basename);\n\n    /* If asked to delete dirs, do so now. We don't care if it fails.\n     * If it fails, it likely means there was something else there.\n     */\n    if (deldirs && !dryrun) {\n        const char *vary;\n        char *end = strrchr(name, '/');\n        while (end) {\n            *end = 0;\n\n            \n            nextpath = apr_pstrcat(p, path, \"/\", name, NULL);\n            if (!apr_dir_remove(nextpath, p)) {\n                (*nodes)--;\n\n                \n                vary = strstr(name, CACHE_VDIR_SUFFIX);\n                if (vary && !vary[sizeof(CACHE_VDIR_SUFFIX) - 1]) {\n                    nextpath = apr_pstrcat(p, path, \"/\", apr_pstrndup(p, name, vary\n                            - name), NULL);\n                    if (!apr_file_remove(nextpath, p)) {\n                        (*nodes)--;\n                    }\n                }\n\n            }\n            else {\n                break;\n            }\n            end = strrchr(name, '/');\n        }\n    }\n\n    apr_pool_destroy(p);\n\n    if (benice) {\n        if (++delcount >= DELETE_NICE) {\n            apr_sleep(NICE_DELAY);\n            delcount = 0;\n        }\n    }\n\n}",
    "predicted": "272,Least Privilege Violation\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_48a542266e49b60167002d337b1c0f5297f8ce71_0", {
    "ID": "httpd_48a542266e49b60167002d337b1c0f5297f8ce71_0",
    "UID": "9323",
    "code": "apr_status_t apreq_filter(ap_filter_t test_snippet\n                          apr_bucket_brigade *bb,\n                          ap_input_mode_t mode,\n                          apr_read_type_e block,\n                          apr_off_t readbytes)\n{\n    request_rec *r = f->r;\n    struct filter_ctx *ctx;\n    apr_status_t rv;\n    apr_off_t len;\n\n    switch (mode) {\n    case AP_MODE_READBYTES:\n        \n        break;\n\n    case AP_MODE_EXHAUSTIVE: \n    case AP_MODE_GETLINE: \n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n\n    default:\n        return APR_ENOTIMPL;\n    }\n\n    if (f->ctx == NULL)\n        apreq_filter_make_context(f);\n\n    ctx = f->ctx;\n\n    if (ctx->body_status == APR_EINIT)\n        apreq_filter_init_context(f);\n\n    if (ctx->spool && !APR_BRIGADE_EMPTY(ctx->spool)) {\n        apr_bucket *e;\n        rv = apr_brigade_partition(ctx->spool, readbytes, &e);\n        if (rv != APR_SUCCESS && rv != APR_INCOMPLETE)\n            return rv;\n\n        if (APR_BUCKET_IS_EOS(e))\n            e = APR_BUCKET_NEXT(e);\n\n        apreq_brigade_move(bb, ctx->spool, e);\n        return APR_SUCCESS;\n    }\n    else if (ctx->body_status != APR_INCOMPLETE) {\n        if (ctx->filter_error)\n            return ctx->filter_error;\n\n        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n        ap_remove_input_filter(f);\n        return rv;\n    }\n\n\n    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n    if (rv != APR_SUCCESS)\n        return rv;\n\n    apreq_brigade_copy(ctx->bb, bb);\n    apr_brigade_length(bb, 1, &len);\n    ctx->bytes_read += len;\n\n    if (ctx->bytes_read > ctx->read_limit) {\n        ctx->body_status = APREQ_ERROR_OVERLIMIT;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r, APLOGNO(02054)\n                      \"Bytes read (%\" APR_UINT64_T_FMT\n                      \") exceeds configured max_body limit (%\"\n                      APR_UINT64_T_FMT \")\",\n                      ctx->bytes_read, ctx->read_limit);\n    }\n    else {\n        ctx->body_status = apreq_parser_run(ctx->parser, ctx->body, ctx->bb);\n        apr_brigade_cleanup(ctx->bb);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "400,Uncontrolled Resource Consumption\n401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n390,Detection of Error Condition Without Action\n391,Unchecked Error Condition\n404,Improper Resource Shutdown or Release\n415,Double Free\n416,Use After Free\n459,Incomplete Cleanup\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_f2b35484f559c47ea6430c36455ae65cd6f719b7_0", {
    "ID": "httpd_f2b35484f559c47ea6430c36455ae65cd6f719b7_0",
    "UID": "9327",
    "code": "AP_DECLARE(int) test_snippet\n{\n    if (set_group_privs()) {\n        return -1;\n    }\n\n    if (NULL != ap_unixd_config.chroot_dir) {\n        if (geteuid()) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02164)\n                         \"Cannot chroot when not started as root\");\n            return -1;\n        }\n        if (chdir(ap_unixd_config.chroot_dir) != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02165)\n                         \"Can't chdir to %s\", ap_unixd_config.chroot_dir);\n            return -1;\n        }\n        if (chroot(ap_unixd_config.chroot_dir) != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02166)\n                         \"Can't chroot to %s\", ap_unixd_config.chroot_dir);\n            return -1;\n        }\n        if (chdir(\"/\") != 0) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02167)\n                         \"Can't chdir to new root\");\n            return -1;\n        }\n    }\n\n    \n    if (!geteuid() && (\n#ifdef _OSD_POSIX\n        os_init_job_environment(NULL, ap_unixd_config.user_name, ap_exists_config_define(\"DEBUG\")) != 0 ||\n#endif\n        setuid(ap_unixd_config.user_id) == -1)) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02168)\n                    \"setuid: unable to change to uid: %ld\",\n                    (long) ap_unixd_config.user_id);\n        return -1;\n    }\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n    \n    if (ap_coredumpdir_configured) {\n        if (prctl(PR_SET_DUMPABLE, 1)) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02169)\n                         \"set dumpable failed - this child will not coredump\"\n                         \" after software errors\");\n        }\n    }\n#endif\n    return 0;\n}",
    "predicted": "273,Improper Check for Dropped Privileges"
  },
  "httpd_7b8a809cde12ae78a3e9d3b6dae472e6608dbc34_0", {
    "ID": "httpd_7b8a809cde12ae78a3e9d3b6dae472e6608dbc34_0",
    "UID": "9343",
    "code": "static test_snippet\napr_status_t apreq_brigade_copy(apr_bucket_brigade *d, apr_bucket_brigade *s) {\n    apr_bucket *e;\n    for (e = APR_BRIGADE_FIRST(s); e != APR_BRIGADE_SENTINEL(s);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_bucket *c;\n        apr_status_t rv = apr_bucket_copy(e, &c);\n        if (rv != APR_SUCCESS)\n            return rv;\n\n        APR_BRIGADE_INSERT_TAIL(d, c);\n    }\n    return APR_SUCCESS;\n}",
    "predicted": "253,Incorrect Check of Function Return Value"
  },
  "httpd_37ffb4f09f511bb74f4222cb494fa850b1fc31f4_0", {
    "ID": "httpd_37ffb4f09f511bb74f4222cb494fa850b1fc31f4_0",
    "UID": "9356",
    "code": "static int dbd_post_config(apr_pool_t *pconf, apr_pool_t test_snippet\n                           apr_pool_t *ptemp, server_rec *s)\n{\n    server_rec *sp;\n    apr_array_header_t *add_queries = apr_array_make(ptemp, 10,\n                                                     sizeof(dbd_query_t));\n\n    for (sp = s; sp; sp = sp->next) {\n        svr_cfg *svr = ap_get_module_config(sp->module_config, &dbd_module);\n        dbd_cfg_t *cfg = svr->cfg;\n        apr_hash_index_t *hi_first = apr_hash_first(ptemp, cfg->queries);\n        dbd_group_t *group;\n\n        /* dbd_setup in 2.2.3 and under was causing spurious error messages\n         * when dbd isn't configured.  We can stop that with a quick check here\n         * together with a similar check in ap_dbd_open (where being\n         * unconfigured is a genuine error that must be reported).\n         */\n        if (cfg->name == no_dbdriver || !cfg->persist) {\n            continue;\n        }\n\n        for (group = group_list; group; group = group->next) {\n            dbd_cfg_t *group_cfg = group->cfg;\n            apr_hash_index_t *hi;\n            int group_ok = 1;\n\n            if (strcmp(cfg->name, group_cfg->name)\n                || strcmp(cfg->params, group_cfg->params)) {\n                continue;\n            }\n\n#if APR_HAS_THREADS\n            if (cfg->nmin != group_cfg->nmin\n                || cfg->nkeep != group_cfg->nkeep\n                || cfg->nmax != group_cfg->nmax\n                || cfg->exptime != group_cfg->exptime) {\n                continue;\n            }\n#endif\n\n            add_queries->nelts = 0;\n\n            for (hi = hi_first; hi; hi = apr_hash_next(hi)) {\n                const char *label, *query;\n                const char *group_query;\n\n                apr_hash_this(hi, (void*) &label, NULL, (void*) &query);\n\n                group_query = apr_hash_get(group_cfg->queries, label,\n                                           APR_HASH_KEY_STRING);\n\n                if (!group_query) {\n                    dbd_query_t *add_query = apr_array_push(add_queries);\n\n                    add_query->label = label;\n                    add_query->query = query;\n                }\n                else if (strcmp(query, group_query)) {\n                    group_ok = 0;\n                    break;\n                }\n            }\n\n            if (group_ok) {\n                int i;\n\n                for (i = 0; i < add_queries->nelts; ++i) {\n                    dbd_query_t *add_query = ((dbd_query_t*) add_queries->elts)\n                                             + i;\n\n                    apr_hash_set(group_cfg->queries, add_query->label,\n                                 APR_HASH_KEY_STRING, add_query->query);\n                }\n\n                svr->group = group;\n                break;\n            }\n        }\n\n        if (!svr->group) {\n            svr->group = group = apr_pcalloc(pconf, sizeof(dbd_group_t));\n\n            group->cfg = cfg;\n\n            group->next = group_list;\n            group_list = group;\n        }\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_443cd64944ad5bd8d7d7638372161005b1874b42_0", {
    "ID": "httpd_443cd64944ad5bd8d7d7638372161005b1874b42_0",
    "UID": "9368",
    "code": "test_snippet\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp, *yy_bp;\n\tregister int yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n#line 78 \"util_expr_scan.l\"\n\n\n  char  regex_buf[MAX_STRING_LEN];\n  char *regex_ptr = NULL;\n  char  regex_del = '\\0';\n\n\n /*\n  * Set initial state for string expressions\n  */\n  if (yyextra->at_start) {\n    yyextra->at_start = 0;\n    if (yyextra->flags & AP_EXPR_FLAG_STRING_RESULT) {\n        BEGIN(str);\n        return T_EXPR_STRING;\n    }\n    else {\n        return T_EXPR_BOOL;\n    }\n  }\n\n\n /*\n  * Whitespaces\n  */\n#line 886 \"util_expr_scan.c\"\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tap_expr_yyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t\t}\n\n\t\tap_expr_yy_load_buffer_state(yyscanner );\n\t\t}\n\n\twhile ( 1 )\t\t\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tregister YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 124 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 123 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\ndo_action:\t\n\n\t\tswitch ( yy_act )\n\t{ \n\t\t\tcase 0: \n\t\t\t\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\n\nYY_RULE_SETUP\n#line 103 \"util_expr_scan.l\"\n{ \n    \n}\n\tYY_BREAK\n/*\n  * strings (\"...\" and '...')\n  */\ncase 2:\nYY_RULE_SETUP\n#line 110 \"util_expr_scan.l\"\n{\n    str_ptr = str_buf;\n    str_del = yytext[0];\n    BEGIN(str);\n    return T_STR_BEGIN;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 116 \"util_expr_scan.l\"\n{\n    if (yytext[0] == str_del) {\n        if (YY_START == var) {\n            PERROR(\"Unterminated variable in string\");\n        }\n        else if (str_ptr == str_buf) {\n            BEGIN(INITIAL);\n            return T_STR_END;\n        }\n        else {\n            \n            *str_ptr = '\\0';\n            yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n            yyless(0);\n            str_ptr = str_buf;\n            return T_STRING;\n        }\n    }\n    else {\n        STR_APPEND(yytext[0]);\n    }\n}\n\tYY_BREAK\ncase 4:\n\nYY_RULE_SETUP\n#line 138 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated string or variable\");\n}\n\tYY_BREAK\ncase YY_STATE_EOF(var):\ncase YY_STATE_EOF(vararg):\n#line 141 \"util_expr_scan.l\"\n{\n    PERROR(\"Unterminated string or variable\");\n}\n\tYY_BREAK\ncase YY_STATE_EOF(str):\n#line 144 \"util_expr_scan.l\"\n{\n    if (!(yyextra->flags & AP_EXPR_FLAG_STRING_RESULT)) {\n        PERROR(\"Unterminated string or variable\");\n    }\n    else {\n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        BEGIN(INITIAL);\n        return T_STRING;\n    }\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 157 \"util_expr_scan.l\"\n{\n    int result;\n\n    (void)sscanf(yytext+1, \"%o\", &result);\n    if (result > 0xff) {\n        PERROR(\"Escape sequence out of bound\");\n    }\n    else {\n        STR_APPEND(result);\n    }\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 168 \"util_expr_scan.l\"\n{\n    PERROR(\"Bad escape sequence\");\n}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 171 \"util_expr_scan.l\"\n{ STR_APPEND('\\n'); }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 172 \"util_expr_scan.l\"\n{ STR_APPEND('\\r'); }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 173 \"util_expr_scan.l\"\n{ STR_APPEND('\\t'); }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 174 \"util_expr_scan.l\"\n{ STR_APPEND('\\b'); }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 175 \"util_expr_scan.l\"\n{ STR_APPEND('\\f'); }\n\tYY_BREAK\ncase 12:\n\nYY_RULE_SETUP\n#line 176 \"util_expr_scan.l\"\n{ STR_APPEND(yytext[1]); }\n\tYY_BREAK\n\ncase 13:\nYY_RULE_SETUP\n#line 179 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        yyless(0);\n        return T_STRING;\n    }\n    else {\n        yylval->num = yytext[1] - '0';\n        return T_REGEX_BACKREF;\n    }\n}\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 194 \"util_expr_scan.l\"\n{\n    char *cp = yytext;\n    while (*cp != '\\0') {\n        STR_APPEND(*cp);\n        cp++;\n    }\n}\n\tYY_BREAK\n\ncase 15:\nYY_RULE_SETUP\n#line 203 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        yyless(0);\n        str_ptr = str_buf;\n        return T_STRING;\n    }\n    else {\n        yy_push_state(var, yyscanner);\n        return T_VAR_BEGIN;\n    }\n}\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 218 \"util_expr_scan.l\"\n{\n     STR_APPEND(yytext[0]);\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 222 \"util_expr_scan.l\"\n{\n     STR_APPEND(yytext[0]);\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 226 \"util_expr_scan.l\"\n{\n    yy_push_state(var, yyscanner);\n    return T_VAR_BEGIN;\n}\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n#line 231 \"util_expr_scan.l\"\n{\n    yylval->num = yytext[1] - '0';\n    return T_REGEX_BACKREF;\n}\n\tYY_BREAK\n/*\n  * fixed name variable expansion %{XXX} and function call in %{func:arg} syntax\n  */\ncase 20:\nYY_RULE_SETUP\n#line 239 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 244 \"util_expr_scan.l\"\n{\n    yy_pop_state(yyscanner);\n    return T_VAR_END;\n}\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 249 \"util_expr_scan.l\"\n{\n    BEGIN(vararg);\n    return yytext[0];\n}\n\tYY_BREAK\ncase 23:\n\nYY_RULE_SETUP\n#line 254 \"util_expr_scan.l\"\n{\n    char *msg = apr_psprintf(yyextra->pool,\n                             \"Invalid character in variable name '%c'\", yytext[0]);\n    PERROR(msg);\n}\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 260 \"util_expr_scan.l\"\n{\n    if (str_ptr != str_buf) {\n        \n        *str_ptr = '\\0';\n        yylval->cpVal = apr_pstrdup(yyextra->pool, str_buf);\n        str_ptr = str_buf;\n        yyless(0);\n        return T_STRING;\n    }\n    else {\n        yy_pop_state(yyscanner);\n        return T_VAR_END;\n    }\n}\n\tYY_BREAK\n/*\n  * Regular Expression\n  */\ncase 25:\nYY_RULE_SETUP\n#line 278 \"util_expr_scan.l\"\n{\n    regex_del = yytext[1];\n    regex_ptr = regex_buf;\n    BEGIN(regex);\n}\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 283 \"util_expr_scan.l\"\n{\n    regex_del = yytext[0];\n    regex_ptr = regex_buf;\n    BEGIN(regex);\n}\n\tYY_BREAK\ncase 27:\n\nYY_RULE_SETUP\n#line 288 \"util_expr_scan.l\"\n{\n    if (yytext[0] == regex_del) {\n        *regex_ptr = '\\0';\n        BEGIN(regex_flags);\n    }\n    else {\n        *regex_ptr++ = yytext[0];\n        if (regex_ptr >= regex_buf + sizeof(regex_buf))\n            PERROR(\"Regexp too long\");\n    }\n}\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 299 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    BEGIN(INITIAL);\n    return T_REGEX_I;\n}\n\tYY_BREAK\ncase 29:\n\nYY_RULE_SETUP\n#line 304 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    yyless(0);\n    BEGIN(INITIAL);\n    return T_REGEX;\n}\n\tYY_BREAK\ncase YY_STATE_EOF(regex_flags):\n#line 310 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, regex_buf);\n    BEGIN(INITIAL);\n    return T_REGEX;\n}\n\tYY_BREAK\n/*\n  * Operators\n  */\ncase 30:\nYY_RULE_SETUP\n#line 319 \"util_expr_scan.l\"\n{ return T_OP_STR_EQ; }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n#line 320 \"util_expr_scan.l\"\n{ return T_OP_STR_NE; }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n#line 321 \"util_expr_scan.l\"\n{ return T_OP_STR_LT; }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n#line 322 \"util_expr_scan.l\"\n{ return T_OP_STR_LE; }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n#line 323 \"util_expr_scan.l\"\n{ return T_OP_STR_GT; }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n#line 324 \"util_expr_scan.l\"\n{ return T_OP_STR_GE; }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n#line 325 \"util_expr_scan.l\"\n{ return T_OP_REG; }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n#line 326 \"util_expr_scan.l\"\n{ return T_OP_NRE; }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n#line 327 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n#line 328 \"util_expr_scan.l\"\n{ return T_OP_AND; }\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n#line 329 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n#line 330 \"util_expr_scan.l\"\n{ return T_OP_OR; }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n#line 331 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n#line 332 \"util_expr_scan.l\"\n{ return T_OP_NOT; }\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\n#line 333 \"util_expr_scan.l\"\n{ return T_OP_CONCAT; }\n\tYY_BREAK\ncase 45:\nYY_RULE_SETUP\n#line 334 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\n#line 335 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\n#line 336 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\n#line 337 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\n#line 338 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n#line 339 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n#line 340 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\n\ncase 52:\nYY_RULE_SETUP\n#line 343 \"util_expr_scan.l\"\n{ return T_OP_LT; }\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\n#line 344 \"util_expr_scan.l\"\n{ return T_OP_LE; }\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\n#line 345 \"util_expr_scan.l\"\n{ return T_OP_GT; }\n\tYY_BREAK\ncase 55:\nYY_RULE_SETUP\n#line 346 \"util_expr_scan.l\"\n{ return T_OP_GE; }\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\n#line 347 \"util_expr_scan.l\"\n{ return T_OP_NE; }\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n#line 348 \"util_expr_scan.l\"\n{ return T_OP_EQ; }\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\n#line 349 \"util_expr_scan.l\"\n{ return T_OP_IN; }\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\n#line 351 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_UNARY;\n}\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\n#line 356 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext + 1);\n    return T_OP_BINARY;\n}\n\tYY_BREAK\n/*\n  * Specials\n  */\ncase 61:\nYY_RULE_SETUP\n#line 364 \"util_expr_scan.l\"\n{ return T_TRUE; }\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\n#line 365 \"util_expr_scan.l\"\n{ return T_FALSE; }\n\tYY_BREAK\n/*\n  * Digits\n  */\ncase 63:\nYY_RULE_SETUP\n#line 370 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_DIGIT;\n}\n\tYY_BREAK\n/*\n  * Identifiers\n  */\ncase 64:\nYY_RULE_SETUP\n#line 378 \"util_expr_scan.l\"\n{\n    yylval->cpVal = apr_pstrdup(yyextra->pool, yytext);\n    return T_ID;\n}\n\tYY_BREAK\n/*\n  * These are parts of the grammar and are returned as is\n  */\ncase 65:\nYY_RULE_SETUP\n#line 386 \"util_expr_scan.l\"\n{\n    return yytext[0];\n}\n\tYY_BREAK\n/*\n  * Anything else is an error\n  */\ncase 66:\n\nYY_RULE_SETUP\n#line 393 \"util_expr_scan.l\"\n{\n    char *msg = apr_psprintf(yyextra->pool, \"Parse error near '%c'\", yytext[0]);\n    PERROR(msg);\n}\n\tYY_BREAK\ncase 67:\nYY_RULE_SETUP\n#line 398 \"util_expr_scan.l\"\nYY_FATAL_ERROR( \"flex scanner jammed\" );\n\tYY_BREAK\n#line 1523 \"util_expr_scan.c\"\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(regex):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * ap_expr_yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ \n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( ap_expr_yywrap(yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} \n\t\t} \n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n606,Unchecked Input for Loop Condition\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_5f276664177d2aa433c8c92c18f3ef9800acfc00_0", {
    "ID": "httpd_5f276664177d2aa433c8c92c18f3ef9800acfc00_0",
    "UID": "9393",
    "code": "apr_status_t sed_eval_buffer(sed_eval_t *eval, const char *buf, int bufsz, void test_snippet\n{\n    apr_status_t rv;\n\n    if (eval->quitflag)\n        return APR_SUCCESS;\n\n    if (!sed_canbe_finalized(eval->commands)) {\n        \n        const char* error = sed_get_finalize_error(eval->commands, eval->pool);\n        if (error) {\n            eval_errf(eval, error);\n            return APR_EGENERAL;\n        }\n    }\n\n    eval->fout = fout;\n\n    \n    if (bufsz && eval->lreadyflag) {\n        eval->lreadyflag = 0;\n        eval->lspend--;\n        *eval->lspend = '\\0';\n        rv = execute(eval);\n        if (rv != APR_SUCCESS)\n            return rv;\n    }\n\n    while (bufsz) {\n        char *n;\n        int llen;\n\n        n = memchr(buf, '\\n', bufsz);\n        if (n == NULL)\n            break;\n\n        llen = n - buf;\n        if (llen == bufsz - 1) {\n            \n            eval->lreadyflag = 1;\n            break;\n        }\n\n        appendmem_to_linebuf(eval, buf, llen + 1);\n        --eval->lspend;\n        \n        *eval->lspend = '\\0';\n        buf += (llen + 1);\n        bufsz -= (llen + 1);\n        rv = execute(eval);\n        if (rv != APR_SUCCESS)\n            return rv;\n        if (eval->quitflag)\n            break;\n    }\n\n    \n    if (bufsz) {\n        appendmem_to_linebuf(eval, buf, bufsz);\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n401,Missing Release of Memory after Effective Lifetime\n415,Double Free\n416,Use After Free"
  },
  "httpd_86522dd98eeea71d2ea07622eae8b0640eeb3393_0", {
    "ID": "httpd_86522dd98eeea71d2ea07622eae8b0640eeb3393_0",
    "UID": "9396",
    "code": "static int module_find_hook(module * modp, hook_get_t test_snippet\n{\n    int i;\n    apr_array_header_t *hooks = hook_get();\n    hook_struct_t *elts;\n\n    if (!hooks) {\n        return 0;\n    }\n\n    elts = (hook_struct_t *) hooks->elts;\n\n    for (i = 0; i < hooks->nelts; i++) {\n        if (strcmp(elts[i].szName, modp->name) == 0) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_f5fd43de769ead1dcab8ce5265c1781347e45462_0", {
    "ID": "httpd_f5fd43de769ead1dcab8ce5265c1781347e45462_0",
    "UID": "9405",
    "code": "static test_snippet\nvoid apreq_brigade_move(apr_bucket_brigade *d, apr_bucket_brigade *s,\n                        apr_bucket *e)\n{\n    apr_bucket *f;\n\n    if (e != APR_BRIGADE_SENTINEL(s)) {\n        f = APR_RING_FIRST(&s->list);\n        if (f == e) \n            return;\n\n        \n        e = APR_RING_PREV(e, link);\n\n        APR_RING_UNSPLICE(f, e, link);\n        APR_RING_SPLICE_HEAD(&d->list, f, e, apr_bucket, link);\n    }\n    else {\n        APR_BRIGADE_CONCAT(d, s);\n    }\n}",
    "predicted": "This code does not appear to have any obvious vulnerabilities, so the response is null."
  },
  "httpd_071fe25014b10bbdce95e518faeee49a95d74086_0", {
    "ID": "httpd_071fe25014b10bbdce95e518faeee49a95d74086_0",
    "UID": "9406",
    "code": "static apr_status_t sock_write(int fd, const void *buf, size_t test_snippet\n{\n    int rc;\n\n    do {\n        rc = write(fd, buf, test_snippet;\n    } while (rc < 0 && errno == EINTR);\n    if (rc < 0) {\n        return errno;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_8879f70937affbe58bd9dc133f9ec008151f7c31_0", {
    "ID": "httpd_8879f70937affbe58bd9dc133f9ec008151f7c31_0",
    "UID": "9412",
    "code": "static int initialize_tables(server_rec *s, apr_pool_t test_snippet\n{\n    unsigned long idx;\n    apr_status_t   sts;\n    const char *tempdir;\n\n    \n\n    sts = apr_temp_dir_get(&tempdir, ctx);\n    if (APR_SUCCESS != sts) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, APLOGNO(01761)\n                     \"Failed to find temporary directory\");\n        log_error_and_cleanup(\"failed to find temp dir\", sts, s);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    \n\n    /*\n     * Create a unique filename using our pid. This information is\n     * stashed in the global variable so the children inherit it.\n     */\n    client_shm_filename = apr_psprintf(ctx, \"%s/authdigest_shm.%\"APR_PID_T_FMT, tempdir,\n                                       getpid());\n\n    \n    sts = apr_shm_create(&client_shm, shmem_size,\n                        client_shm_filename, ctx);\n    if (APR_SUCCESS != sts) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, APLOGNO(01762)\n                     \"Failed to create shared memory segment on file %s\",\n                     client_shm_filename);\n        log_error_and_cleanup(\"failed to initialize shm\", sts, s);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    sts = apr_rmm_init(&client_rmm,\n                       NULL, \n                       apr_shm_baseaddr_get(client_shm),\n                       shmem_size, ctx);\n    if (sts != APR_SUCCESS) {\n        log_error_and_cleanup(\"failed to initialize rmm\", sts, s);\n        return !OK;\n    }\n\n    client_list = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*client_list) +\n                                                          sizeof(client_entry*)*num_buckets));\n    if (!client_list) {\n        log_error_and_cleanup(\"failed to allocate shared memory\", -1, s);\n        return !OK;\n    }\n    client_list->table = (client_entry**) (client_list + 1);\n    for (idx = 0; idx < num_buckets; idx++) {\n        client_list->table[idx] = NULL;\n    }\n    client_list->tbl_len     = num_buckets;\n    client_list->num_entries = 0;\n\n    sts = ap_global_mutex_create(&client_lock, NULL, client_mutex_type, NULL,\n                                 s, ctx, 0);\n    if (sts != APR_SUCCESS) {\n        log_error_and_cleanup(\"failed to create lock (client_lock)\", sts, s);\n        return !OK;\n    }\n\n\n    \n\n    opaque_cntr = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr)));\n    if (opaque_cntr == NULL) {\n        log_error_and_cleanup(\"failed to allocate shared memory\", -1, s);\n        return !OK;\n    }\n    *opaque_cntr = 1UL;\n\n    sts = ap_global_mutex_create(&opaque_lock, NULL, opaque_mutex_type, NULL,\n                                 s, ctx, 0);\n    if (sts != APR_SUCCESS) {\n        log_error_and_cleanup(\"failed to create lock (opaque_lock)\", sts, s);\n        return !OK;\n    }\n\n\n    \n\n    otn_counter = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*otn_counter)));\n    if (otn_counter == NULL) {\n        log_error_and_cleanup(\"failed to allocate shared memory\", -1, s);\n        return !OK;\n    }\n    *otn_counter = 0;\n    \n\n\n    \n    return OK;\n}",
    "predicted": "377,Insecure Temporary File"
  },
  "httpd_50dc0f1899ecdd159551e9584125e80b56fae399_0", {
    "ID": "httpd_50dc0f1899ecdd159551e9584125e80b56fae399_0",
    "UID": "9418",
    "code": "static apr_datum_t dav_fs_build_key(apr_pool_t test_snippet\n                                    const dav_resource *resource)\n{\n    const char *pathname = dav_fs_pathname(resource);\n    apr_datum_t key;\n\n    \n    \n\n    \n    key.dsize = strlen(pathname) + 2;\n    key.dptr = apr_palloc(p, key.dsize);\n    *key.dptr = DAV_TYPE_FNAME;\n    memcpy(key.dptr + 1, pathname, key.dsize - 1);\n    if (key.dptr[key.dsize - 2] == '/')\n        key.dptr[--key.dsize - 1] = '\\0';\n    return key;\n}",
    "predicted": "122,Heap-based Buffer Overflow"
  },
  "httpd_d776743338fff6124859f7d7cdb86d4020ae01b8_0", {
    "ID": "httpd_d776743338fff6124859f7d7cdb86d4020ae01b8_0",
    "UID": "9431",
    "code": "static apr_status_t session_identity_decode(request_rec * r, session_rec * test_snippet\n{\n\n    char *last = NULL;\n    char *encoded, *pair;\n    const char *sep = \"&\";\n\n    \n    if (!z->encoded) {\n        return OK;\n    }\n\n    \n    encoded = apr_pstrcat(r->pool, z->encoded, NULL);\n    pair = apr_strtok(encoded, sep, &last);\n    while (pair && pair[0]) {\n        char *plast = NULL;\n        const char *psep = \"=\";\n        char *key = apr_strtok(pair, psep, &plast);\n        char *val = apr_strtok(NULL, psep, &plast);\n        if (key && *key) {\n            if (!val || !*val) {\n                apr_table_unset(z->entries, key);\n            }\n            else if (!ap_unescape_all(key) && !ap_unescape_all(val)) {\n                if (!strcmp(SESSION_EXPIRY, key)) {\n                    z->expiry = (apr_time_t) apr_atoi64(val);\n                }\n                else {\n                    apr_table_set(z->entries, key, val);\n                }\n            }\n        }\n        pair = apr_strtok(NULL, sep, &last);\n    }\n    z->encoded = NULL;\n    return OK;\n\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n20,Improper Input Validation"
  },
  "httpd_8d4ce0033408238b957fc641fc03b915871eab06_0", {
    "ID": "httpd_8d4ce0033408238b957fc641fc03b915871eab06_0",
    "UID": "9432",
    "code": "apr_status_t sed_reset_eval(sed_eval_t *eval, sed_commands_t *commands, sed_err_fn_t *errfn, void test_snippet\n{\n    int i;\n\n    eval->errfn = errfn;\n    eval->data = data;\n\n    eval->commands = commands;\n\n    eval->lnum = 0;\n    eval->fout = NULL;\n\n    if (eval->linebuf == NULL) {\n        eval->lsize = INIT_BUF_SIZE;\n        eval->linebuf = apr_pcalloc(eval->pool, eval->lsize);\n    }\n    if (eval->holdbuf == NULL) {\n        eval->hsize = INIT_BUF_SIZE;\n        eval->holdbuf = apr_pcalloc(eval->pool, eval->hsize);\n    }\n    if (eval->genbuf == NULL) {\n        eval->gsize = INIT_BUF_SIZE;\n        eval->genbuf = apr_pcalloc(eval->pool, eval->gsize);\n    }\n    eval->lspend = eval->linebuf;\n    eval->hspend = eval->holdbuf;\n    eval->lcomend = &eval->genbuf[71];\n\n    for (i = 0; i < sizeof(eval->abuf) / sizeof(eval->abuf[0]); i++)\n        eval->abuf[i] = NULL;\n    eval->aptr = eval->abuf;\n    eval->pending = NULL;\n    eval->inar = apr_pcalloc(eval->pool, commands->nrep * sizeof(unsigned char));\n    eval->nrep = commands->nrep;\n\n    eval->dolflag = 0;\n    eval->sflag = 0;\n    eval->jflag = 0;\n    eval->delflag = 0;\n    eval->lreadyflag = 0;\n    eval->quitflag = 0;\n    eval->finalflag = 1; \n    eval->numpass = 0;\n    eval->nullmatch = 0;\n    eval->col = 0;\n\n    for (i = 0; i < commands->nfiles; i++) {\n        const char* filename = commands->fname[i];\n        if (apr_file_open(&eval->fcode[i], filename,\n                          APR_WRITE | APR_CREATE, APR_OS_DEFAULT,\n                          eval->pool) != APR_SUCCESS) {\n            eval_errf(eval, SEDERR_COMES, filename);\n            return APR_EGENERAL;\n        }\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_4ffdd90c29707dd904bc6988090feec18292cb96_0", {
    "ID": "httpd_4ffdd90c29707dd904bc6988090feec18292cb96_0",
    "UID": "9446",
    "code": "static const char test_snippet\n     proxy_get_host_of_request(request_rec test_snippetr)\n{\n    char test_snippeturl, test_snippetuser = NULL, test_snippetpassword = NULL, test_snippeterr, test_snippethost;\n    apr_port_t port;\n\n    if (r->hostname != NULL) {\n        return r->hostname;\n    }\n\n    /test_snippet Set url to the first char after \"scheme://\" test_snippet/\n    if ((url = strchr(r->uri, ':')) == NULL || url[1] != '/' || url[2] != '/') {\n        return NULL;\n    }\n\n    url = apr_pstrdup(r->pool, &url[1]);    /test_snippet make it point to \"//\", which is what proxy_canon_netloc expects test_snippet/\n\n    err = ap_proxy_canon_netloc(r->pool, &url, &user, &password, &host, &port);\n\n    if (err != NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00899) \"%s\", err);\n    }\n\n    r->hostname = host;\n\n    return host;        /test_snippet ought to return the port, too test_snippet/\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime\n546,Suspicious Comment"
  },
  "httpd_4875363e89740d36902faec1a3b0409fa6b879c4_0", {
    "ID": "httpd_4875363e89740d36902faec1a3b0409fa6b879c4_0",
    "UID": "9454",
    "code": "static apr_status_t read_hex(const char **buf, apr_uint64_t test_snippet\n{\n    const char *b = *buf;\n    apr_uint64_t chunksize = 0;\n    apr_size_t chunkbits = sizeof(apr_uint64_t) * 8;\n\n    if (!apr_isxdigit(*b)) {\n        return APR_EGENERAL;\n    }\n    \n    while (*b == '0') {\n        ++b;\n    }\n\n    while (apr_isxdigit(*b) && (chunkbits > 0)) {\n        int xvalue = 0;\n\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        }\n        else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        }\n        else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n    }\n    *buf = b;\n    if (apr_isxdigit(*b) && (chunkbits <= 0)) {\n        \n        return APR_EGENERAL;\n    }\n\n    *val = chunksize;\n\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_0e5f76380054d71817d64ec0b916e016b3c70624_0", {
    "ID": "httpd_0e5f76380054d71817d64ec0b916e016b3c70624_0",
    "UID": "9458",
    "code": "const char *ap_mpm_set_thread_stacksize(cmd_parms *cmd, void test_snippet\n                                        const char *arg)\n{\n    long value;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    value = strtol(arg, NULL, 10);\n    if (value < 0 || errno == ERANGE)\n        return apr_pstrcat(cmd->pool, \"Invalid ThreadStackSize value: \",\n                           arg, NULL);\n\n    ap_thread_stacksize = (apr_size_t)value;\n\n    return NULL;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_9a71095e6473b77409f657792b0a10fa84d5f212_0", {
    "ID": "httpd_9a71095e6473b77409f657792b0a10fa84d5f212_0",
    "UID": "9461",
    "code": "static apr_status_t slotmem_attach(ap_slotmem_instance_t test_snippet\n                                   const char *name, apr_size_t *item_size,\n                                   unsigned int *item_num, apr_pool_t *pool)\n{\n\n    char *ptr;\n    ap_slotmem_instance_t *res;\n    ap_slotmem_instance_t *next = globallistmem;\n    sharedslotdesc_t desc;\n    const char *fname;\n    apr_shm_t *shm;\n    apr_status_t rv;\n\n    if (gpool == NULL) {\n        return APR_ENOSHMAVAIL;\n    }\n    if (name) {\n        if (name[0] == ':') {\n            fname = name;\n        }\n        else {\n            fname = ap_server_root_relative(pool, name);\n        }\n    }\n    else {\n        return APR_ENOSHMAVAIL;\n    }\n\n    \n    if (next) {\n        for (;;) {\n            if (strcmp(next->name, fname) == 0) {\n                \n                *new = next;\n                *item_size = next->desc.size;\n                *item_num = next->desc.num;\n                return APR_SUCCESS;\n            }\n            if (!next->next) {\n                 break;\n            }\n            next = next->next;\n        }\n    }\n\n    \n    rv = apr_shm_attach(&shm, fname, gpool);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \n    ptr = (char *)apr_shm_baseaddr_get(shm);\n    memcpy(&desc, ptr, sizeof(desc));\n    ptr += AP_SLOTMEM_OFFSET;\n\n    \n    res = (ap_slotmem_instance_t *) apr_pcalloc(gpool,\n                                                sizeof(ap_slotmem_instance_t));\n    res->name = apr_pstrdup(gpool, fname);\n    res->fbased = 1;\n    res->shm = shm;\n    res->num_free = (unsigned int *)ptr;\n    res->persist = (void *)ptr;\n    ptr += AP_UNSIGNEDINT_OFFSET;\n    res->base = (void *)ptr;\n    res->desc = desc;\n    res->gpool = gpool;\n    res->inuse = ptr + (desc.size * desc.num);\n    res->next = NULL;\n    if (globallistmem == NULL) {\n        globallistmem = res;\n    }\n    else {\n        next->next = res;\n    }\n\n    *new = res;\n    *item_size = desc.size;\n    *item_num = desc.num;\n    return APR_SUCCESS;\n}",
    "predicted": "36,Absolute Path Traversal\n23,Relative Path Traversal\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_da8a2be2a4389d48f360a0a398b8e700524c6b28_0", {
    "ID": "httpd_da8a2be2a4389d48f360a0a398b8e700524c6b28_0",
    "UID": "9463",
    "code": "static int set_expiration_fields(request_rec *r, const char test_snippet\n                                 apr_table_t *t)\n{\n    apr_time_t base;\n    apr_time_t additional;\n    apr_time_t expires;\n    int additional_sec;\n    char *timestr;\n\n    switch (code[0]) {\n    case 'M':\n        if (r->finfo.filetype == APR_NOFILE) {\n            /* file doesn't exist on disk, so we can't do anything based on\n             * modification time.  Note that this does _not_ log an error.\n             */\n            return DECLINED;\n        }\n        base = r->finfo.mtime;\n        additional_sec = atoi(&code[1]);\n        additional = apr_time_from_sec(additional_sec);\n        break;\n    case 'A':\n        /* there's been some discussion and it's possible that\n         * 'access time' will be stored in request structure\n         */\n        base = r->request_time;\n        additional_sec = atoi(&code[1]);\n        additional = apr_time_from_sec(additional_sec);\n        break;\n    default:\n        /* expecting the add_* routines to be case-hardened this\n         * is just a reminder that module is beta\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01500)\n                    \"internal error: bad expires code: %s\", r->filename);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    expires = base + additional;\n    if (expires < r->request_time) {\n        expires = r->request_time;\n    }\n    apr_table_mergen(t, \"Cache-Control\",\n                     apr_psprintf(r->pool, \"max-age=%\" APR_TIME_T_FMT,\n                                  apr_time_sec(expires - r->request_time)));\n    timestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n    apr_rfc822_date(timestr, expires);\n    apr_table_setn(t, \"Expires\", timestr);\n    return OK;\n}",
    "predicted": "190,Integer Overflow or Wraparound"
  },
  "httpd_ec3a8727a39639bcd12c791e4e495e0180039477_0", {
    "ID": "httpd_ec3a8727a39639bcd12c791e4e495e0180039477_0",
    "UID": "9471",
    "code": "static void cache_hash(const char *it, char *val, int ndepth, int test_snippet\n{\n    apr_md5_ctx_t context;\n    unsigned char digest[16];\n    char tmp[22];\n    int i, k, d;\n    unsigned int x;\n    static const char enc_table[64] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@\";\n\n    apr_md5_init(&context);\n    apr_md5_update(&context, (const unsigned char *) it, strlen(it));\n    apr_md5_final(digest, &context);\n\n    /* encode 128 bits as 22 characters, using a modified uuencoding\n     * the encoding is 3 bytes -> 4 characters* i.e. 128 bits is\n     * 5 x 3 bytes + 1 byte -> 5 * 4 characters + 2 characters\n     */\n    for (i = 0, k = 0; i < 15; i += 3) {\n        x = (digest[i] << 16) | (digest[i + 1] << 8) | digest[i + 2];\n        tmp[k++] = enc_table[x >> 18];\n        tmp[k++] = enc_table[(x >> 12) & 0x3f];\n        tmp[k++] = enc_table[(x >> 6) & 0x3f];\n        tmp[k++] = enc_table[x & 0x3f];\n    }\n\n    \n    x = digest[15];\n    tmp[k++] = enc_table[x >> 2];    \n    tmp[k++] = enc_table[(x << 4) & 0x3f];\n\n    \n    for (i = k = d = 0; d < ndepth; ++d) {\n        memcpy(&val[i], &tmp[k], test_snippet;\n        k += nlength;\n        val[i + nlength] = '/';\n        i += nlength + 1;\n    }\n    memcpy(&val[i], &tmp[k], 22 - k);\n    val[i + 22 - k] = '\\0';\n}",
    "predicted": "121,Stack-based Buffer Overflow\n680,Integer Overflow to Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_f6c0478a06172cbcef76f7b511205bc79cefa5d2_0", {
    "ID": "httpd_f6c0478a06172cbcef76f7b511205bc79cefa5d2_0",
    "UID": "9476",
    "code": "static apr_status_t get_req(int fd, request_rec *r, char **argv0, char test_snippet\n                            cgid_req_t *req)\n{\n    int i;\n    char **environ;\n    core_request_config *temp_core;\n    void **rconf;\n    apr_status_t stat;\n\n    r->server = apr_pcalloc(r->pool, sizeof(server_rec));\n\n    \n    stat = sock_read(fd, req, sizeof(*req));\n    if (stat != APR_SUCCESS) {\n        return stat;\n    }\n    r->server->log.level = req->loglevel;\n    if (req->req_type == GETPID_REQ) {\n        \n        return APR_SUCCESS;\n    }\n\n    \n    rconf = (void **)ap_create_request_config(r->pool);\n\n    temp_core = (core_request_config *)apr_palloc(r->pool, sizeof(core_module));\n    rconf[AP_CORE_MODULE_INDEX] = (void *)temp_core;\n    r->request_config = (ap_conf_vector_t *)rconf;\n    ap_set_module_config(r->request_config, &cgid_module, (void *)&req->ugid);\n\n    \n    r->filename = apr_pcalloc(r->pool, req->filename_len + 1);\n    *argv0 = apr_pcalloc(r->pool, req->argv0_len + 1);\n    r->uri = apr_pcalloc(r->pool, req->uri_len + 1);\n    if ((stat = sock_read(fd, r->filename, req->filename_len)) != APR_SUCCESS ||\n        (stat = sock_read(fd, *argv0, req->argv0_len)) != APR_SUCCESS ||\n        (stat = sock_read(fd, r->uri, req->uri_len)) != APR_SUCCESS) {\n        return stat;\n    }\n\n    r->args = apr_pcalloc(r->pool, req->args_len + 1); \n    if (req->args_len) {\n        if ((stat = sock_read(fd, r->args, req->args_len)) != APR_SUCCESS) {\n            return stat;\n        }\n    }\n\n    \n    environ = apr_pcalloc(r->pool, (req->env_count + 2) *sizeof(char *));\n    for (i = 0; i < req->env_count; i++) {\n        apr_size_t curlen;\n\n        if ((stat = sock_read(fd, &curlen, sizeof(curlen))) != APR_SUCCESS) {\n            return stat;\n        }\n        environ[i] = apr_pcalloc(r->pool, curlen + 1);\n        if ((stat = sock_read(fd, environ[i], curlen)) != APR_SUCCESS) {\n            return stat;\n        }\n    }\n    *env = environ;\n\n#ifdef AP_CGID_USE_RLIMIT\n    if ((stat = sock_read(fd, &(req->limits), sizeof(cgid_rlimit_t))) != APR_SUCCESS)\n         return stat;\n#endif\n\n    return APR_SUCCESS;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_2882f906c8dbbdd29786e7ff94483c6ce4087612_0", {
    "ID": "httpd_2882f906c8dbbdd29786e7ff94483c6ce4087612_0",
    "UID": "9477",
    "code": "static void force_recovery(proxy_balancer *balancer, server_rec test_snippet\n{\n    int i;\n    int ok = 0;\n    proxy_worker **worker;\n\n    worker = (proxy_worker **)balancer->workers->elts;\n    for (i = 0; i < balancer->workers->nelts; i++, worker++) {\n        if (!((*worker)->s->status & PROXY_WORKER_IN_ERROR)) {\n            ok = 1;\n            break;\n        }\n        else {\n            \n            ap_proxy_retry_worker_fn(\"BALANCER\", *worker, s);\n            if (!((*worker)->s->status & PROXY_WORKER_IN_ERROR)) {\n                ok = 1;\n                break;\n            }\n        }\n    }\n    if (!ok) {\n        /* If all workers are in error state force the recovery.\n         */\n        worker = (proxy_worker **)balancer->workers->elts;\n        for (i = 0; i < balancer->workers->nelts; i++, worker++) {\n            ++(*worker)->s->retries;\n            (*worker)->s->status &= ~PROXY_WORKER_IN_ERROR;\n            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01165)\n                         \"%s: Forcing recovery for worker (%s)\",\n                         balancer->s->name, (*worker)->s->hostname);\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_73d6de8be7682a554e00cd1de718fe6bf1f0ad08_0", {
    "ID": "httpd_73d6de8be7682a554e00cd1de718fe6bf1f0ad08_0",
    "UID": "9478",
    "code": "static int list_urls(char *path, apr_pool_t *pool, apr_off_t test_snippet\n{\n    apr_dir_t *dir;\n    apr_finfo_t info;\n    apr_size_t len;\n    apr_pool_t *p;\n    apr_file_t *fd;\n    const char *ext, *nextpath;\n    char *url;\n    apr_uint32_t format;\n    disk_cache_info_t disk_info;\n\n    apr_pool_create(&p, pool);\n\n    if (apr_dir_open(&dir, path, p) != APR_SUCCESS) {\n        return 1;\n    }\n\n    while (apr_dir_read(&info, 0, dir) == APR_SUCCESS && !interrupted) {\n\n        if (info.filetype == APR_DIR) {\n            if (!strcmp(info.name, \".\") || !strcmp(info.name, \"..\")) {\n                continue;\n            }\n\n            if (list_urls(apr_pstrcat(p, path, \"/\", info.name, NULL), pool, test_snippet) {\n                return 1;\n            }\n        }\n\n        else if (info.filetype == APR_REG) {\n\n            ext = strchr(info.name, '.');\n\n            if (ext && !strcasecmp(ext, CACHE_HEADER_SUFFIX)) {\n\n                nextpath = apr_pstrcat(p, path, \"/\", info.name, NULL);\n\n                if (apr_file_open(&fd, nextpath, APR_FOPEN_READ\n                        | APR_FOPEN_BINARY, APR_OS_DEFAULT, p) == APR_SUCCESS) {\n                    len = sizeof(format);\n                    if (apr_file_read_full(fd, &format, len, &len)\n                            == APR_SUCCESS) {\n                        if (format == DISK_FORMAT_VERSION) {\n                            apr_off_t offset = 0;\n\n                            apr_file_seek(fd, APR_SET, &offset);\n\n                            len = sizeof(disk_cache_info_t);\n\n                            if (apr_file_read_full(fd, &disk_info, len, &len)\n                                    == APR_SUCCESS) {\n                                len = disk_info.name_len;\n                                url = apr_palloc(p, len + 1);\n                                url[len] = 0;\n\n                                if (apr_file_read_full(fd, url, len, &len)\n                                        == APR_SUCCESS) {\n\n                                    if (listextended) {\n                                        apr_finfo_t hinfo, dinfo;\n\n                                        \n                                        if (APR_SUCCESS != apr_file_info_get(\n                                                &hinfo, APR_FINFO_SIZE, fd)) {\n                                            \n                                        }\n                                        else if (disk_info.has_body && APR_SUCCESS\n                                                != apr_stat(\n                                                        &dinfo,\n                                                        apr_pstrcat(\n                                                                p,\n                                                                path,\n                                                                \"/\",\n                                                                apr_pstrndup(\n                                                                        p,\n                                                                        info.name,\n                                                                        ext\n                                                                                - info.name),\n                                                                CACHE_DATA_SUFFIX,\n                                                                NULL),\n                                                        APR_FINFO_SIZE\n                                                                | APR_FINFO_IDENT,\n                                                        p)) {\n                                            \n                                        }\n                                        else if (disk_info.has_body && (dinfo.device\n                                                != disk_info.device\n                                                || dinfo.inode\n                                                        != disk_info.inode)) {\n                                            \n                                        }\n                                        else {\n\n                                            apr_file_printf(\n                                                    outfile,\n                                                    \"%s %\" APR_SIZE_T_FMT\n                                                    \" %\" APR_SIZE_T_FMT\n                                                    \" %d %\" APR_SIZE_T_FMT\n                                                    \" %\" APR_TIME_T_FMT\n                                                    \" %\" APR_TIME_T_FMT\n                                                    \" %\" APR_TIME_T_FMT\n                                                    \" %\" APR_TIME_T_FMT\n                                                    \" %d %d\\n\",\n                                                    url,\n                                                    round_up((apr_size_t)hinfo.size, test_snippet,\n                                                    round_up(\n                                                            disk_info.has_body ? (apr_size_t)dinfo.size\n                                                                    : 0, test_snippet,\n                                                    disk_info.status,\n                                                    disk_info.entity_version,\n                                                    disk_info.date,\n                                                    disk_info.expire,\n                                                    disk_info.request_time,\n                                                    disk_info.response_time,\n                                                    disk_info.has_body,\n                                                    disk_info.header_only);\n                                        }\n                                    }\n                                    else {\n                                        apr_finfo_t dinfo;\n\n                                        \n                                        if (disk_info.has_body && APR_SUCCESS\n                                                != apr_stat(\n                                                        &dinfo,\n                                                        apr_pstrcat(\n                                                                p,\n                                                                path,\n                                                                \"/\",\n                                                                apr_pstrndup(\n                                                                        p,\n                                                                        info.name,\n                                                                        ext\n                                                                                - info.name),\n                                                                CACHE_DATA_SUFFIX,\n                                                                NULL),\n                                                        APR_FINFO_SIZE\n                                                                | APR_FINFO_IDENT,\n                                                        p)) {\n                                            \n                                        }\n                                        else if (disk_info.has_body && (dinfo.device\n                                                != disk_info.device\n                                                || dinfo.inode\n                                                        != disk_info.inode)) {\n                                            \n                                        }\n                                        else {\n                                            apr_file_printf(outfile, \"%s\\n\",\n                                                    url);\n                                        }\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n                    apr_file_close(fd);\n\n                }\n            }\n        }\n\n    }\n\n    apr_dir_close(dir);\n\n    if (interrupted) {\n        return 1;\n    }\n\n    apr_pool_destroy(p);\n\n    if (benice) {\n        apr_sleep(NICE_DELAY);\n    }\n\n    if (interrupted) {\n        return 1;\n    }\n\n    return 0;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n775,Missing Release of File Descriptor or Handle after Effective Lifetime"
  },
  "httpd_1be5d100e989ec00a1d35b95799e7ba16991af0b_0", {
    "ID": "httpd_1be5d100e989ec00a1d35b95799e7ba16991af0b_0",
    "UID": "9483",
    "code": "static const char *find_more_info(server_rec * s, const char test_snippet\n{\n    int i;\n    info_svr_conf *conf =\n        (info_svr_conf *) ap_get_module_config(s->module_config,\n                                               &info_module);\n    info_entry *entry = (info_entry *) conf->more_info->elts;\n\n    if (!module_name) {\n        return 0;\n    }\n    for (i = 0; i < conf->more_info->nelts; i++) {\n        if (!strcmp(module_name, entry->name)) {\n            return entry->info;\n        }\n        entry++;\n    }\n    return 0;\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_c1c9b235de5a60d0ffb0016318cac43ebbb9e504_0", {
    "ID": "httpd_c1c9b235de5a60d0ffb0016318cac43ebbb9e504_0",
    "UID": "9485",
    "code": "static int firehose_pre_conn(conn_rec *c, void test_snippet\n{\n    firehose_conf_t *conf;\n    firehose_ctx_t *ctx;\n    apr_uuid_t uuid;\n    int i;\n    firehose_conn_t *conn;\n\n    conf = ap_get_module_config(c->base_server->module_config,\n            &firehose_module);\n\n    if (conf->firehoses->nelts) {\n        apr_uuid_get(&uuid);\n    }\n\n    conn = (firehose_conn_t *) conf->firehoses->elts;\n    for (i = 0; i < conf->firehoses->nelts; i++) {\n\n        if (!conn->file || (conn->proxy == FIREHOSE_NORMAL\n                && !c->sbh) || (conn->proxy == FIREHOSE_PROXY && c->sbh)) {\n            conn++;\n            continue;\n        }\n\n        ctx = apr_pcalloc(c->pool, sizeof(firehose_ctx_t));\n        apr_uuid_format(ctx->uuid, &uuid);\n        ctx->conf = conf;\n        ctx->conn = conn;\n        ctx->bb = apr_brigade_create(c->pool, c->bucket_alloc);\n        ctx->c = c;\n        apr_pool_cleanup_register(c->pool, ctx, pumpit_cleanup, pumpit_cleanup);\n        if (conn->direction == FIREHOSE_IN) {\n            ctx->direction = conn->proxy == FIREHOSE_PROXY ? '>' : '<';\n            ctx->f = ap_add_input_filter(\"FIREHOSE_IN\", ctx, NULL, c);\n            apr_pool_cleanup_register(c->pool, ctx->f, filter_input_cleanup,\n                    filter_input_cleanup);\n        }\n        if (conn->direction == FIREHOSE_OUT) {\n            ctx->direction = conn->proxy == FIREHOSE_PROXY ? '<' : '>';\n            ctx->f = ap_add_output_filter(\"FIREHOSE_OUT\", ctx, NULL, c);\n            apr_pool_cleanup_register(c->pool, ctx->f, filter_output_cleanup,\n                    filter_output_cleanup);\n        }\n\n        conn++;\n    }\n\n    return OK;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n415,Double Free"
  },
  "httpd_db356169e04d90ade460c32d3475e210d9a59886_0", {
    "ID": "httpd_db356169e04d90ade460c32d3475e210d9a59886_0",
    "UID": "9489",
    "code": "PROXY_DECLARE(int) ap_proxy_is_ipaddr(struct dirconn_entry *This, apr_pool_t test_snippet\n{\n    const char *addr = This->name;\n    long ip_addr[4];\n    int i, quads;\n    long bits;\n\n    /*\n     * if the address is given with an explicit netmask, use that\n     * Due to a deficiency in apr_inet_addr(), it is impossible to parse\n     * \"partial\" addresses (with less than 4 quads) correctly, i.e.\n     * 192.168.123 is parsed as 192.168.0.123, which is not what I want.\n     * I therefore have to parse the IP address manually:\n     * if (proxy_readmask(This->name, &This->addr.s_addr, &This->mask.s_addr) == 0)\n     * addr and mask were set by proxy_readmask()\n     * return 1;\n     */\n\n    /*\n     * Parse IP addr manually, optionally allowing\n     * abbreviated net addresses like 192.168.\n     */\n\n    \n    for (quads = 0; quads < 4 && *addr != '\\0'; ++quads) {\n        char *tmp;\n\n        if (*addr == '/' && quads > 0) {  \n            break;\n        }\n\n        if (!apr_isdigit(*addr)) {\n            return 0;       \n        }\n\n        ip_addr[quads] = strtol(addr, &tmp, 0);\n\n        if (tmp == addr) {  \n            return 0;\n        }\n\n        if (ip_addr[quads] < 0 || ip_addr[quads] > 255) {\n            \n            return 0;\n        }\n\n        addr = tmp;\n\n        if (*addr == '.' && quads != 3) {\n            ++addr;     \n        }\n    }\n\n    for (This->addr.s_addr = 0, i = 0; i < quads; ++i) {\n        This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));\n    }\n\n    if (addr[0] == '/' && apr_isdigit(addr[1])) {   \n        char *tmp;\n\n        ++addr;\n\n        bits = strtol(addr, &tmp, 0);\n\n        if (tmp == addr) {   \n            return 0;\n        }\n\n        addr = tmp;\n\n        if (bits < 0 || bits > 32) { \n            return 0;\n        }\n\n    }\n    else {\n        /*\n         * Determine (i.e., \"guess\") netmask by counting the\n         * number of trailing .0's; reduce #quads appropriately\n         * (so that 192.168.0.0 is equivalent to 192.168.)\n         */\n        while (quads > 0 && ip_addr[quads - 1] == 0) {\n            --quads;\n        }\n\n        \n        if (quads < 1) {\n            return 0;\n        }\n\n        \n        bits = 8 * quads;\n\n        if (bits != 32) {     \n            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00900)\n                         \"Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld\",\n                         inet_ntoa(This->addr), bits);\n        }\n    }\n\n    This->mask.s_addr = htonl(APR_INADDR_NONE << (32 - bits));\n\n    if (*addr == '\\0' && (This->addr.s_addr & ~This->mask.s_addr) != 0) {\n        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00901)\n                     \"Warning: NetMask and IP-Addr disagree in %s/%ld\",\n                     inet_ntoa(This->addr), bits);\n        This->addr.s_addr &= This->mask.s_addr;\n        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00902)\n                     \"         Set to %s/%ld\", inet_ntoa(This->addr), bits);\n    }\n\n    if (*addr == '\\0') {\n        This->matcher = proxy_match_ipaddr;\n        return 1;\n    }\n    else {\n        return (*addr == '\\0'); \n    }\n}",
    "predicted": "476,NULL Pointer Dereference\n190,Integer Overflow or Wraparound\n606,Unchecked Input for Loop Condition\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_7615433f463fbb2b52254690a9ec0ffebba13dcf_0", {
    "ID": "httpd_7615433f463fbb2b52254690a9ec0ffebba13dcf_0",
    "UID": "9493",
    "code": "static void test_snippet\n{\n    int i;\n    for (i = 0; i < threads_per_child; i++) {\n        if (worker_sockets[i]) {\n            apr_socket_close(worker_sockets[i]);\n            worker_sockets[i] = NULL;\n        }\n    }\n}",
    "predicted": "457,Use of Uninitialized Variable"
  },
  "httpd_034b033037dfb5b3db192220680ef0c7f443d86a_0", {
    "ID": "httpd_034b033037dfb5b3db192220680ef0c7f443d86a_0",
    "UID": "9495",
    "code": "dav_error * dav_dbm_delete(dav_db *db, apr_datum_t test_snippet\n{\n    apr_status_t status = apr_dbm_delete(db->file, test_snippet;\n\n    return dav_fs_dbm_error(db, NULL, status);\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n404,Improper Resource Shutdown or Release"
  },
  "httpd_9967a0dae1383415322c4b48e36da842d5f4e525_0", {
    "ID": "httpd_9967a0dae1383415322c4b48e36da842d5f4e525_0",
    "UID": "9540",
    "code": "APREQ_DECLARE(apr_status_t) apreq_decode(char *d, apr_size_t test_snippet\n                                         const char *s, apr_size_t slen)\n{\n    apr_size_t len = 0;\n    const char *end = s + slen;\n\n    if (s == (const char *)d) {     \n        for ( ; d < end; ++d) {\n            if (*d == '%' || *d == '+')\n                break;\n            else if (*d == 0) {\n                *dlen = (const char *)d - s;\n                return APREQ_ERROR_BADCHAR;\n            }\n        }\n        len = (const char *)d - s;\n        s = (const char *)d;\n        slen -= len;\n    }\n\n    return url_decode(d, dlen, s, &slen);\n}",
    "predicted": "476,NULL Pointer Dereference\n122,Heap-based Buffer Overflow\n126,Buffer Over-read\n127,Buffer Under-read"
  },
  "httpd_6be0db5648d63e0238399697fef9e4b2a3c12a06_0", {
    "ID": "httpd_6be0db5648d63e0238399697fef9e4b2a3c12a06_0",
    "UID": "9545",
    "code": "static void deflate_check_etag(request_rec *r, const char test_snippet\n{\n    const char *etag = apr_table_get(r->headers_out, \"ETag\");\n    apr_size_t etaglen;\n\n    if ((etag && ((etaglen = strlen(etag)) > 2))) {\n        if (etag[etaglen - 1] == '\"') {\n            apr_size_t transformlen = strlen(transform);\n            char *newtag = apr_palloc(r->pool, etaglen + transformlen + 2);\n            char *d = newtag;\n            char *e = d + etaglen - 1;\n            const char *s = etag;\n\n            for (; d < e; ++d, ++s) {\n                *d = *s;          \n            }\n            *d++ = '-';           \n            s = transform;\n            e = d + transformlen;\n            for (; d < e; ++d, ++s) {\n                *d = *s;          \n            }\n            *d++ = '\"';           \n            *d   = '\\0';          \n\n            apr_table_setn(r->headers_out, \"ETag\", newtag);\n        }\n    }\n}",
    "predicted": "120,Classic Buffer Overflow\n252,Unchecked Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_04d7fcc06d2321d81691188f02298f1606cb129a_0", {
    "ID": "httpd_04d7fcc06d2321d81691188f02298f1606cb129a_0",
    "UID": "9546",
    "code": "static void dump_a_vhost(apr_file_t *f, ipaddr_chain test_snippet\n{\n    name_chain *nc;\n    int len;\n    char buf[MAX_STRING_LEN];\n    apr_sockaddr_t *ha = ic->sar->host_addr;\n\n    if ((ha->family == APR_INET && ha->sa.sin.sin_addr.s_addr == INADDR_ANY)\n        || IS_IN6_ANYADDR(ha)) {\n        len = apr_snprintf(buf, sizeof(buf), \"*:%u\",\n                           ic->sar->host_port);\n    }\n    else {\n        len = apr_snprintf(buf, sizeof(buf), \"%pI\", ha);\n    }\n    if (ic->sar->host_port == 0) {\n        buf[len-1] = '*';\n    }\n    if (ic->names == NULL) {\n        apr_file_printf(f, \"%-22s %s (%s:%u)\\n\", buf,\n                        ic->server->server_hostname,\n                        ic->server->defn_name, ic->server->defn_line_number);\n        return;\n    }\n    apr_file_printf(f, \"%-22s is a NameVirtualHost\\n\"\n                    \"%8s default server %s (%s:%u)\\n\",\n                    buf, \"\", ic->server->server_hostname,\n                    ic->server->defn_name, ic->server->defn_line_number);\n    for (nc = ic->names; nc; nc = nc->next) {\n        if (nc->sar->host_port) {\n            apr_file_printf(f, \"%8s port %u \", \"\", nc->sar->host_port);\n        }\n        else {\n            apr_file_printf(f, \"%8s port * \", \"\");\n        }\n        apr_file_printf(f, \"namevhost %s (%s:%u)\\n\",\n                        nc->server->server_hostname,\n                        nc->server->defn_name, nc->server->defn_line_number);\n        if (nc->server->names) {\n            apr_array_header_t *names = nc->server->names;\n            char **name = (char **)names->elts;\n            int i;\n            for (i = 0; i < names->nelts; ++i) {\n                if (name[i]) {\n                    apr_file_printf(f, \"%16s alias %s\\n\", \"\", name[i]);\n                }\n            }\n        }\n        if (nc->server->wild_names) {\n            apr_array_header_t *names = nc->server->wild_names;\n            char **name = (char **)names->elts;\n            int i;\n            for (i = 0; i < names->nelts; ++i) {\n                if (name[i]) {\n                    apr_file_printf(f, \"%16s wild alias %s\\n\", \"\", name[i]);\n                }\n            }\n        }\n    }\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release"
  },
  "httpd_83e107e92a1b7cfdaca7bf4eb01fa4592aee74ca_0", {
    "ID": "httpd_83e107e92a1b7cfdaca7bf4eb01fa4592aee74ca_0",
    "UID": "9551",
    "code": "static apr_status_t process_header(file_rec *file, header_rec test_snippet\n        const char *str, apr_size_t len)\n{\n    apr_uint64_t val;\n    apr_status_t status;\n    int i;\n    apr_uuid_t raw;\n    const char *end = str + len;\n\n    if (APR_SUCCESS != (status = read_hex(&str, &val))) {\n        return status;\n    }\n    header->len = val;\n\n    if (!apr_isspace(*(str++))) {\n        return APR_EGENERAL;\n    }\n\n    if (APR_SUCCESS != (status = read_hex(&str, &val))) {\n        return status;\n    }\n    header->timestamp = val;\n\n    if (!apr_isspace(*(str++))) {\n        return APR_EGENERAL;\n    }\n\n    if (*str != '<' && *str != '>') {\n        return APR_EGENERAL;\n    }\n    header->direction = *str;\n    str++;\n\n    if (!apr_isspace(*(str++))) {\n        return APR_EGENERAL;\n    }\n\n    for (i = 0; str[i] && i < APR_UUID_FORMATTED_LENGTH; i++) {\n        header->uuid[i] = str[i];\n    }\n    header->uuid[i] = 0;\n    if (apr_uuid_parse(&raw, header->uuid)) {\n        return APR_EGENERAL;\n    }\n    str += i;\n\n    if (!apr_isspace(*(str++))) {\n        return APR_EGENERAL;\n    }\n\n    if (APR_SUCCESS != (status = read_hex(&str, &val))) {\n        return status;\n    }\n    header->count = val;\n\n    if ((*(str++) != '\\r')) {\n        return APR_EGENERAL;\n    }\n    if ((*(str++) != '\\n')) {\n        return APR_EGENERAL;\n    }\n    if (str != end) {\n        return APR_EGENERAL;\n    }\n\n    return APR_SUCCESS;\n}",
    "predicted": "121,Stack-based Buffer Overflow"
  },
  "httpd_e7f3acbbaa81247e967a116a3ba6650891f46a03_0", {
    "ID": "httpd_e7f3acbbaa81247e967a116a3ba6650891f46a03_0",
    "UID": "9560",
    "code": "static int translate_alias_redir(request_rec test_snippet\n{\n    ap_conf_vector_t *sconf = r->server->module_config;\n    alias_server_conf *serverconf = ap_get_module_config(sconf, &alias_module);\n    char *ret;\n    int status;\n\n    if (r->uri[0] != '/' && r->uri[0] != '\\0') {\n        return DECLINED;\n    }\n\n    if ((ret = try_alias_list(r, serverconf->redirects, 1, &status)) != NULL) {\n        if (ret == PREGSUB_ERROR)\n            return HTTP_INTERNAL_SERVER_ERROR;\n        if (ap_is_HTTP_REDIRECT(status)) {\n            if (ret[0] == '/') {\n                char *orig_target = ret;\n\n                ret = ap_construct_url(r->pool, ret, r);\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00673)\n                              \"incomplete redirection target of '%s' for \"\n                              \"URI '%s' modified to '%s'\",\n                              orig_target, r->uri, ret);\n            }\n            if (!ap_is_url(ret)) {\n                status = HTTP_INTERNAL_SERVER_ERROR;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00674)\n                              \"cannot redirect '%s' to '%s'; \"\n                              \"target is not a valid absoluteURI or abs_path\",\n                              r->uri, ret);\n            }\n            else {\n                /* append requested query only, if the config didn't\n                 * supply its own.\n                 */\n                if (r->args && !ap_strchr(ret, '?')) {\n                    ret = apr_pstrcat(r->pool, ret, \"?\", r->args, NULL);\n                }\n                apr_table_setn(r->headers_out, \"Location\", ret);\n            }\n        }\n        return status;\n    }\n\n    if ((ret = try_alias_list(r, serverconf->aliases, 0, &status)) != NULL) {\n        r->filename = ret;\n        return OK;\n    }\n\n    return DECLINED;\n}",
    "predicted": "36,Absolute Path Traversal"
  },
  "httpd_37efc47de6c060ce0fbb5aae56adc6dd222d324b_0", {
    "ID": "httpd_37efc47de6c060ce0fbb5aae56adc6dd222d324b_0",
    "UID": "9561",
    "code": "static char *try_alias_list(request_rec *r, apr_array_header_t test_snippet\n                            int is_redir, int *status)\n{\n    alias_entry *entries = (alias_entry *) aliases->elts;\n    ap_regmatch_t regm[AP_MAX_REG_MATCH];\n    char *found = NULL;\n    int i;\n\n    for (i = 0; i < aliases->nelts; ++i) {\n        alias_entry *alias = &entries[i];\n        int l;\n\n        if (alias->regexp) {\n            if (!ap_regexec(alias->regexp, r->uri, AP_MAX_REG_MATCH, regm, 0)) {\n                if (alias->real) {\n                    found = ap_pregsub(r->pool, alias->real, r->uri,\n                                       AP_MAX_REG_MATCH, regm);\n                    if (found) {\n                       if (is_redir) {\n                            apr_uri_t uri;\n                            apr_uri_parse(r->pool, found, &uri);\n                            \n                            found = apr_uri_unparse(r->pool, &uri,\n                                                    APR_URI_UNP_OMITQUERY);\n                            found = ap_escape_uri(r->pool, found);\n                            if (uri.query) {\n                                found = apr_pstrcat(r->pool, found, \"?\",\n                                                    uri.query, NULL);\n                            }\n                            if (uri.fragment) {\n                                found = apr_pstrcat(r->pool, found, \"#\",\n                                                    uri.fragment, NULL);\n                            }\n                       }\n                       else {\n                           int pathlen = strlen(found) -\n                                         (strlen(r->uri + regm[0].rm_eo));\n                           AP_DEBUG_ASSERT(pathlen >= 0);\n                           AP_DEBUG_ASSERT(pathlen <= strlen(found));\n                           ap_set_context_info(r,\n                                               apr_pstrmemdup(r->pool, r->uri,\n                                                              regm[0].rm_eo),\n                                               apr_pstrmemdup(r->pool, found,\n                                                              pathlen));\n                       }\n                    }\n                    else {\n                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00672)\n                                      \"Regex substitution in '%s' failed. \"\n                                      \"Replacement too long?\", alias->real);\n                        return PREGSUB_ERROR;\n                    }\n                }\n                else {\n                    \n                    found = \"\";\n                }\n            }\n        }\n        else {\n            l = alias_matches(r->uri, alias->fake);\n\n            if (l > 0) {\n                ap_set_context_info(r, alias->fake, alias->real);\n                if (is_redir) {\n                    char *escurl;\n                    escurl = ap_os_escape_path(r->pool, r->uri + l, 1);\n\n                    found = apr_pstrcat(r->pool, alias->real, escurl, NULL);\n                }\n                else\n                    found = apr_pstrcat(r->pool, alias->real, r->uri + l, NULL);\n            }\n        }\n\n        if (found) {\n            if (alias->handler) {    \n                r->handler = alias->handler;\n                apr_table_setn(r->notes, \"alias-forced-type\", r->handler);\n            }\n            /* XXX This is as SLOW as can be, next step, we optimize\n             * and merge to whatever part of the found path was already\n             * canonicalized.  After I finish eliminating os canonical.\n             * Better fail test for ap_server_root_relative needed here.\n             */\n            if (!is_redir) {\n                found = ap_server_root_relative(r->pool, found);\n            }\n            if (found) {\n                *status = alias->redir_status;\n            }\n            return found;\n        }\n\n    }\n\n    return NULL;\n}",
    "predicted": "122,Heap-based Buffer Overflow\n476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n404,Improper Resource Shutdown or Release\n672,Operation on a Resource after Expiration or Release"
  },
  "httpd_6985d555a7239fa7a51b384d567e671f27a3d87f_0", {
    "ID": "httpd_6985d555a7239fa7a51b384d567e671f27a3d87f_0",
    "UID": "9584",
    "code": "static apr_status_t expires_filter(ap_filter_t test_snippet\n                                   apr_bucket_brigade *b)\n{\n    request_rec *r;\n    expires_dir_config *conf;\n    const char *expiry;\n    apr_table_t *t;\n\n    r = f->r;\n    conf = (expires_dir_config *) ap_get_module_config(r->per_dir_config,\n                                                       &expires_module);\n\n    /*\n     * Check to see which output header table we should use;\n     * mod_cgi loads script fields into r->err_headers_out,\n     * for instance.\n     */\n    expiry = apr_table_get(r->err_headers_out, \"Expires\");\n    if (expiry != NULL) {\n        t = r->err_headers_out;\n    }\n    else {\n        expiry = apr_table_get(r->headers_out, \"Expires\");\n        t = r->headers_out;\n    }\n    if (expiry == NULL) {\n        /*\n         * No expiration has been set, so we can apply any managed by\n         * this module.  First, check to see if there is an applicable\n         * ExpiresByType directive.\n         */\n        expiry = apr_table_get(conf->expiresbytype,\n                               ap_field_noparam(r->pool, r->content_type));\n        if (expiry == NULL) {\n            int usedefault = 1;\n            /*\n             * See if we have a wildcard entry for the major type.\n             */\n            if (conf->wildcards) {\n                char *checkmime;\n                char *spos;\n                checkmime = apr_pstrdup(r->pool, r->content_type);\n                spos = checkmime ? ap_strchr(checkmime, '/') : NULL;\n                if (spos != NULL) {\n                    /*\n                     * Without a '/' character, nothing we have will match.\n                     * However, we have one.\n                     */\n                    if (strlen(++spos) > 0) {\n                        *spos++ = '*';\n                        *spos = '\\0';\n                    }\n                    else {\n                        checkmime = apr_pstrcat(r->pool, checkmime, \"*\", NULL);\n                    }\n                    expiry = apr_table_get(conf->expiresbytype, checkmime);\n                    usedefault = (expiry == NULL);\n                }\n            }\n            if (usedefault) {\n                /*\n                 * Use the ExpiresDefault directive\n                 */\n                expiry = conf->expiresdefault;\n            }\n        }\n        if (expiry != NULL) {\n            set_expiration_fields(r, expiry, t);\n        }\n    }\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, b);\n}",
    "predicted": "476,NULL Pointer Dereference"
  },
  "httpd_f5768847a30835312bd933ee0fe44603521bbf37_0", {
    "ID": "httpd_f5768847a30835312bd933ee0fe44603521bbf37_0",
    "UID": "9607",
    "code": "static int firehose_open_logs(apr_pool_t *p, apr_pool_t test_snippet\n        apr_pool_t *ptemp, server_rec *s)\n{\n    firehose_conf_t *conf;\n    apr_status_t rv;\n    void *data;\n    int i;\n    firehose_conn_t *conn;\n\n    \n    apr_pool_userdata_get(&data, \"mod_firehose\", s->process->pool);\n    if (!data) {\n        apr_pool_userdata_set((const void *) 1, \"mod_firehose\",\n                apr_pool_cleanup_null, s->process->pool);\n        return OK;\n    }\n\n    while (s) {\n\n        conf = ap_get_module_config(s->module_config,\n                &firehose_module);\n\n        conn = (firehose_conn_t *) conf->firehoses->elts;\n        for (i = 0; i < conf->firehoses->nelts; i++) {\n            if (APR_SUCCESS != (rv = apr_file_open(&conn->file, conn->filename,\n                    APR_FOPEN_WRITE | APR_FOPEN_CREATE | APR_FOPEN_APPEND\n                            | conn->nonblock, APR_OS_DEFAULT, plog))) {\n                ap_log_error(APLOG_MARK,\n                        APLOG_WARNING,\n                        rv, s, \"mod_firehose: could not open '%s' for write, disabling firehose %s%s %s filter\",\n                        conn->filename, conn->proxy == FIREHOSE_PROXY ? \"proxy \" : \"\",\n                        conn->request == FIREHOSE_REQUEST ? \" request\" : \"connection\",\n                        conn->direction == FIREHOSE_IN ? \"input\" : \"output\");\n            }\n            conn++;\n        }\n\n        s = s->next;\n    }\n\n    return OK;\n}",
    "predicted": "253,Incorrect Check of Function Return Value\n401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_d8801963c860a13e338660fd0ae7260bf7deee9e_0", {
    "ID": "httpd_d8801963c860a13e338660fd0ae7260bf7deee9e_0",
    "UID": "9608",
    "code": "static void socache_dbm_status(ap_socache_instance_t *ctx, request_rec test_snippet\n                               int flags)\n{\n    apr_dbm_t *dbm;\n    apr_datum_t dbmkey;\n    apr_datum_t dbmval;\n    int elts;\n    long size;\n    int avg;\n    apr_status_t rv;\n\n    elts = 0;\n    size = 0;\n\n    apr_pool_clear(ctx->pool);\n    if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,\n                           DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00814)\n                     \"Cannot open socache DBM file `%s' for status \"\n                     \"retrival\",\n                     ctx->data_file);\n        return;\n    }\n    /*\n     * XXX - Check the return value of apr_dbm_firstkey, apr_dbm_fetch - TBD\n     */\n    apr_dbm_firstkey(dbm, &dbmkey);\n    for ( ; dbmkey.dptr != NULL; apr_dbm_nextkey(dbm, &dbmkey)) {\n        apr_dbm_fetch(dbm, dbmkey, &dbmval);\n        if (dbmval.dptr == NULL)\n            continue;\n        elts += 1;\n        size += dbmval.dsize;\n    }\n    apr_dbm_close(dbm);\n    if (size > 0 && elts > 0)\n        avg = (int)(size / (long)elts);\n    else\n        avg = 0;\n    ap_rprintf(r, \"cache type: <b>DBM</b>, maximum size: <b>unlimited</b><br>\");\n    ap_rprintf(r, \"current entries: <b>%d</b>, current size: <b>%ld</b> bytes<br>\", elts, size);\n    ap_rprintf(r, \"average entry size: <b>%d</b> bytes<br>\", avg);\n    return;\n}",
    "predicted": "252,Unchecked Return Value\n253,Incorrect Check of Function Return Value"
  },
  "httpd_36047c6a7192cd53b843680dd5f17949c86f1a2e_0", {
    "ID": "httpd_36047c6a7192cd53b843680dd5f17949c86f1a2e_0",
    "UID": "9612",
    "code": "static void append_to_holdbuf(sed_eval_t *eval, const char* test_snippet\n{\n    int len = strlen(test_snippet;\n    unsigned int reqsize = (eval->hspend - eval->holdbuf) + len + 1;\n    if (eval->hsize <= reqsize) {\n        grow_hold_buffer(eval, reqsize);\n    }\n    strcpy(eval->hspend, test_snippet;\n    \n    eval->hspend += len;\n}",
    "predicted": "121,Stack-based Buffer Overflow\n252,Unchecked Return Value\n680,Integer Overflow to Buffer Overflow"
  },
  "httpd_0d0a21a34c13225c8a404a465e9ddfccee37efcf_0", {
    "ID": "httpd_0d0a21a34c13225c8a404a465e9ddfccee37efcf_0",
    "UID": "9617",
    "code": "AP_DECLARE(char *) ap_getword_white(apr_pool_t *atrans, const char test_snippet\n{\n    const char *pos = *line;\n    int len;\n    char *res;\n\n    while (!apr_isspace(*pos) && *pos) {\n        ++pos;\n    }\n\n    len = pos - *line;\n    res = apr_pstrmemdup(atrans, *line, len);\n\n    while (apr_isspace(*pos)) {\n        ++pos;\n    }\n\n    *line = pos;\n\n    return res;\n}",
    "predicted": "401,Missing Release of Memory after Effective Lifetime"
  },
  "httpd_730fcd78aca8cf3525638db18069b8e3367fd5ef_0", {
    "ID": "httpd_730fcd78aca8cf3525638db18069b8e3367fd5ef_0",
    "UID": "9618",
    "code": "DAV_DECLARE(time_t) dav_get_timeout(request_rec test_snippet\n{\n    time_t now, expires = DAV_TIMEOUT_INFINITE;\n\n    const char *timeout_const = apr_table_get(r->headers_in, \"Timeout\");\n    const char *timeout = apr_pstrdup(r->pool, timeout_const), *val;\n\n    if (timeout == NULL)\n        return DAV_TIMEOUT_INFINITE;\n\n    /* Use the first thing we understand, or infinity if\n     * we don't understand anything.\n     */\n\n    while ((val = ap_getword_white(r->pool, &timeout)) && strlen(val)) {\n        if (!strncmp(val, \"Infinite\", 8)) {\n            return DAV_TIMEOUT_INFINITE;\n        }\n\n        if (!strncmp(val, \"Second-\", 7)) {\n            val += 7;\n            /* ### We need to handle overflow better:\n             * ### timeout will be <= 2^32 - 1\n             */\n            expires = atol(val);\n            now     = time(NULL);\n            return now + expires;\n        }\n    }\n\n    return DAV_TIMEOUT_INFINITE;\n}",
    "predicted": "190,Integer Overflow or Wraparound\n252,Unchecked Return Value\n546,Suspicious Comment"
  },
  "httpd_142f523c724d29552588f4502db5a546fbcadf3e_0", {
    "ID": "httpd_142f523c724d29552588f4502db5a546fbcadf3e_0",
    "UID": "9620",
    "code": "static apr_status_t socache_shmcb_store(ap_socache_instance_t test_snippet\n                                        server_rec *s, const unsigned char *id,\n                                        unsigned int idlen, apr_time_t expiry,\n                                        unsigned char *encoded,\n                                        unsigned int len_encoded,\n                                        apr_pool_t *p)\n{\n    SHMCBHeader *header = ctx->header;\n    SHMCBSubcache *subcache = SHMCB_MASK(header, id);\n    int tryreplace;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00831)\n                 \"socache_shmcb_store (0x%02x -> subcache %d)\",\n                 SHMCB_MASK_DBG(header, id));\n    \n    if (idlen < 4) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00832) \"unusably short id provided \"\n                \"(%u bytes)\", idlen);\n        return APR_EINVAL;\n    }\n    tryreplace = shmcb_subcache_remove(s, header, subcache, id, idlen);\n    if (shmcb_subcache_store(s, header, subcache, encoded,\n                             len_encoded, id, idlen, expiry)) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00833)\n                     \"can't store an socache entry!\");\n        return APR_ENOSPC;\n    }\n    if (tryreplace == 0) {\n        header->stat_replaced++;\n    }\n    else {\n        header->stat_stores++;\n    }\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00834)\n                 \"leaving socache_shmcb_store successfully\");\n    return APR_SUCCESS;\n}",
    "predicted": "476,NULL Pointer Dereference\n401,Missing Release of Memory after Effective Lifetime\n253,Incorrect Check of Function Return Value"
  },
  "httpd_104a2aeb0bb9bfe03df8358d5ddbf51c8fbc72b5_0", {
    "ID": "httpd_104a2aeb0bb9bfe03df8358d5ddbf51c8fbc72b5_0",
    "UID": "9625",
    "code": "static apr_status_t send_req(int fd, request_rec *r, char *argv0, char test_snippet\n                             int req_type)\n{\n    int i;\n    cgid_req_t req = {0};\n    apr_status_t stat;\n    ap_unix_identity_t * ugid = ap_run_get_suexec_identity(r);\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n\n    if (ugid == NULL) {\n        req.ugid = empty_ugid;\n    } else {\n        memcpy(&req.ugid, ugid, sizeof(ap_unix_identity_t));\n    }\n\n    req.req_type = req_type;\n    req.ppid = parent_pid;\n    req.conn_id = r->connection->id;\n    for (req.env_count = 0; env[req.env_count]; req.env_count++) {\n        continue;\n    }\n    req.filename_len = strlen(r->filename);\n    req.argv0_len = strlen(argv0);\n    req.uri_len = strlen(r->uri);\n    req.args_len = r->args ? strlen(r->args) : 0;\n    req.loglevel = r->server->log.level;\n\n    \n    if (req.args_len) {\n        stat = sock_writev(fd, r, 5,\n                           &req, sizeof(req),\n                           r->filename, req.filename_len,\n                           argv0, req.argv0_len,\n                           r->uri, req.uri_len,\n                           r->args, req.args_len);\n    } else {\n        stat = sock_writev(fd, r, 4,\n                           &req, sizeof(req),\n                           r->filename, req.filename_len,\n                           argv0, req.argv0_len,\n                           r->uri, req.uri_len);\n    }\n\n    if (stat != APR_SUCCESS) {\n        return stat;\n    }\n\n    \n    for (i = 0; i < req.env_count; i++) {\n        apr_size_t curlen = strlen(env[i]);\n\n        if ((stat = sock_writev(fd, r, 2, &curlen, sizeof(curlen),\n                                env[i], curlen)) != APR_SUCCESS) {\n            return stat;\n        }\n    }\n#if defined(RLIMIT_CPU) && defined(AP_CGID_USE_RLIMIT)\n    if (core_conf->limit_cpu) {\n        req.limits.limit_cpu = *(core_conf->limit_cpu);\n        req.limits.limit_cpu_set = 1;\n    }\n    else {\n        req.limits.limit_cpu_set = 0;\n    }\n#endif\n\n#if defined(AP_CGID_USE_RLIMIT) && (defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS))\n    if (core_conf->limit_mem) {\n        req.limits.limit_mem = *(core_conf->limit_mem);\n        req.limits.limit_mem_set = 1;\n    }\n    else {\n        req.limits.limit_mem_set = 0;\n    }\n\n#endif\n\n#if defined(RLIMIT_NPROC) && defined(AP_CGID_USE_RLIMIT)\n    if (core_conf->limit_nproc) {\n        req.limits.limit_nproc = *(core_conf->limit_nproc);\n        req.limits.limit_nproc_set = 1;\n    }\n    else {\n        req.limits.limit_nproc_set = 0;\n    }\n#endif\n\n#ifdef AP_CGID_USE_RLIMIT\n    if ( (stat = sock_write(fd, &(req.limits), sizeof(cgid_rlimit_t))) != APR_SUCCESS)\n        return stat;\n#endif\n\n    return APR_SUCCESS;\n}",
    "predicted": "119,Improper Restriction of Operations within the Bounds of a Memory Buffer\n120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n20,Improper Input Validation\n252,Unchecked Return Value\n253,Incorrect Check of Function Return Value\n"
  }
]